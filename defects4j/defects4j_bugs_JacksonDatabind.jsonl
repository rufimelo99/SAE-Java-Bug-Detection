{"project": "JacksonDatabind", "bug_id": 1, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.BeanPropertyWriter", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.io.SerializedString;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\npublic class BeanPropertyWriter\n    implements BeanProperty\n{\n    /**\n     * Marker object used to indicate \"do not serialize if empty\"\n     */\n    public final static Object MARKER_FOR_EMPTY = new Object();\n    \n    /*\n    /**********************************************************\n    /* Settings for accessing property value to serialize\n    /**********************************************************\n     */\n\n    /**\n     * Member (field, method) that represents property and allows access\n     * to associated annotations.\n     */\n    protected final AnnotatedMember _member;\n\n    /**\n     * Annotations from context (most often, class that declares property,\n     * or in case of sub-class serializer, from that sub-class)\n     */\n    protected final Annotations _contextAnnotations;\n    \n    /**\n     * Type property is declared to have, either in class definition \n     * or associated annotations.\n     */\n    protected final JavaType _declaredType;\n    \n    /**\n     * Accessor method used to get property value, for\n     * method-accessible properties.\n     * Null if and only if {@link #_field} is null.\n     */\n    protected final Method _accessorMethod;\n    \n    /**\n     * Field that contains the property value for field-accessible\n     * properties.\n     * Null if and only if {@link #_accessorMethod} is null.\n     */\n    protected final Field _field;\n    \n    /*\n    /**********************************************************\n    /* Opaque internal data that bean serializer factory and\n    /* bean serializers can add.\n    /**********************************************************\n     */\n\n    protected HashMap<Object,Object> _internalSettings;\n    \n    /*\n    /**********************************************************\n    /* Serialization settings\n    /**********************************************************\n     */\n    \n    /**\n     * Logical name of the property; will be used as the field name\n     * under which value for the property is written.\n     */\n    protected final SerializedString _name;\n\n    /**\n     * Wrapper name to use for this element, if any\n     * \n     * @since 2.2\n     */\n    protected final PropertyName _wrapperName;\n    \n    /**\n     * Type to use for locating serializer; normally same as return\n     * type of the accessor method, but may be overridden by annotations.\n     */\n    protected final JavaType _cfgSerializationType;\n\n    /**\n     * Serializer to use for writing out the value: null if it can not\n     * be known statically; non-null if it can.\n     */\n    protected JsonSerializer<Object> _serializer;\n\n    /**\n     * Serializer used for writing out null values, if any: if null,\n     * null values are to be suppressed.\n     */\n    protected JsonSerializer<Object> _nullSerializer;\n    \n    /**\n     * In case serializer is not known statically (i.e. <code>_serializer</code>\n     * is null), we will use a lookup structure for storing dynamically\n     * resolved mapping from type(s) to serializer(s).\n     */\n    protected PropertySerializerMap _dynamicSerializers;\n\n    /**\n     * Whether null values are to be suppressed (nothing written out if\n     * value is null) or not.\n     */\n    protected final boolean _suppressNulls;\n    \n    /**\n     * Value that is considered default value of the property; used for\n     * default-value-suppression if enabled.\n     */\n    protected final Object _suppressableValue;\n\n    /**\n     * Alternate set of property writers used when view-based filtering\n     * is available for the Bean.\n     */\n    protected final Class<?>[] _includeInViews;\n\n    /**\n     * If property being serialized needs type information to be\n     * included this is the type serializer to use.\n     * Declared type (possibly augmented with annotations) of property\n     * is used for determining exact mechanism to use (compared to\n     * actual runtime type used for serializing actual state).\n     */\n    protected TypeSerializer _typeSerializer;\n    \n    /**\n     * Base type of the property, if the declared type is \"non-trivial\";\n     * meaning it is either a structured type (collection, map, array),\n     * or parameterized. Used to retain type information about contained\n     * type, which is mostly necessary if type meta-data is to be\n     * included.\n     */\n    protected JavaType _nonTrivialBaseType;\n\n    /**\n     * Whether value of this property has been marked as required.\n     * Retained since it will be needed when traversing type hierarchy\n     * for producing schemas (and other similar tasks); currently not\n     * used for serialization.\n     * \n     * @since 2.2\n     */\n    protected final boolean _isRequired;\n    \n    /*\n    /**********************************************************\n    /* Construction, configuration\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    public BeanPropertyWriter(BeanPropertyDefinition propDef,\n            AnnotatedMember member, Annotations contextAnnotations,\n            JavaType declaredType,\n            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n            boolean suppressNulls, Object suppressableValue)\n    {\n        \n        _member = member;\n        _contextAnnotations = contextAnnotations;\n        _name = new SerializedString(propDef.getName());\n        _wrapperName = propDef.getWrapperName();\n        _declaredType = declaredType;\n        _serializer = (JsonSerializer<Object>) ser;\n        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n        _typeSerializer = typeSer;\n        _cfgSerializationType = serType;\n        _isRequired = propDef.isRequired();\n\n        if (member instanceof AnnotatedField) {\n            _accessorMethod = null;\n            _field = (Field) member.getMember();\n        } else if (member instanceof AnnotatedMethod) {\n            _accessorMethod = (Method) member.getMember();\n            _field = null;\n        } else {\n            throw new IllegalArgumentException(\"Can not pass member of type \"+member.getClass().getName());\n        }\n        _suppressNulls = suppressNulls;\n        _suppressableValue = suppressableValue;\n        _includeInViews = propDef.findViews();\n\n        // this will be resolved later on, unless nulls are to be suppressed\n        _nullSerializer = null;\n    }\n\n    /**\n     * \"Copy constructor\" to be used by filtering sub-classes\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base) {\n        this(base, base._name);\n    }\n\n    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name)\n    {\n        _name = name;\n        _wrapperName = base._wrapperName;\n\n        _member = base._member;\n        _contextAnnotations = base._contextAnnotations;\n        _declaredType = base._declaredType;\n        _accessorMethod = base._accessorMethod;\n        _field = base._field;\n        _serializer = base._serializer;\n        _nullSerializer = base._nullSerializer;\n        // one more thing: copy internal settings, if any (since 1.7)\n        if (base._internalSettings != null) {\n            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n        }\n        _cfgSerializationType = base._cfgSerializationType;\n        _dynamicSerializers = base._dynamicSerializers;\n        _suppressNulls = base._suppressNulls;\n        _suppressableValue = base._suppressableValue;\n        _includeInViews = base._includeInViews;\n        _typeSerializer = base._typeSerializer;\n        _nonTrivialBaseType = base._nonTrivialBaseType;\n        _isRequired = base._isRequired;\n    }\n\n    public BeanPropertyWriter rename(NameTransformer transformer) {\n        String newName = transformer.transform(_name.getValue());\n        if (newName.equals(_name.toString())) {\n            return this;\n        }\n        return new BeanPropertyWriter(this, new SerializedString(newName));\n    }\n    \n    /**\n     * Method called to assign value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignSerializer(JsonSerializer<Object> ser)\n    {\n        // may need to disable check in future?\n        if (_serializer != null && _serializer != ser) {\n            throw new IllegalStateException(\"Can not override serializer\");\n        }\n        _serializer = ser;\n    }\n\n    /**\n     * Method called to assign null value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignNullSerializer(JsonSerializer<Object> nullSer)\n    {\n        // may need to disable check in future?\n        if (_nullSerializer != null && _nullSerializer != nullSer) {\n            throw new IllegalStateException(\"Can not override null serializer\");\n        }\n        _nullSerializer = nullSer;\n    }\n    \n    /**\n     * Method called create an instance that handles details of unwrapping\n     * contained value.\n     */\n    public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) {\n        return new UnwrappingBeanPropertyWriter(this, unwrapper);\n    }\n\n    /**\n     * Method called to define type to consider as \"non-trivial\" basetype,\n     * needed for dynamic serialization resolution for complex (usually container)\n     * types\n     */\n    public void setNonTrivialBaseType(JavaType t) {\n        _nonTrivialBaseType = t;\n    }\n\n    /*\n    /**********************************************************\n    /* BeanProperty impl\n    /**********************************************************\n     */\n    \n    @Override\n    public String getName() {\n        return _name.getValue();\n    }\n\n    @Override\n    public JavaType getType() {\n        return _declaredType;\n    }\n\n    @Override\n    public PropertyName getWrapperName() {\n        return _wrapperName;\n    }\n\n    @Override\n    public boolean isRequired() {\n        return _isRequired;\n    }\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return _member.getAnnotation(acls);\n    }\n\n    @Override\n    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return _contextAnnotations.get(acls);\n    }\n\n    @Override\n    public AnnotatedMember getMember() {\n        return _member;\n    }\n\n\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n        throws JsonMappingException\n    {\n        if (objectVisitor != null) {\n            if (isRequired()) {\n                objectVisitor.property(this); \n            } else {\n                objectVisitor.optionalProperty(this);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Managing and accessing of opaque internal settings\n    /* (used by extensions)\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value of specified internal setting.\n     * \n     * @return Value of the setting, if any; null if none.\n     */\n    public Object getInternalSetting(Object key)\n    {\n        if (_internalSettings == null) {\n            return null;\n        }\n        return _internalSettings.get(key);\n    }\n    \n    /**\n     * Method for setting specific internal setting to given value\n     * \n     * @return Old value of the setting, if any (null if none)\n     */\n    public Object setInternalSetting(Object key, Object value)\n    {\n        if (_internalSettings == null) {\n            _internalSettings = new HashMap<Object,Object>();\n        }\n        return _internalSettings.put(key, value);\n    }\n\n    /**\n     * Method for removing entry for specified internal setting.\n     * \n     * @return Existing value of the setting, if any (null if none)\n     */\n    public Object removeInternalSetting(Object key)\n    {\n        Object removed = null;\n        if (_internalSettings != null) {\n            removed = _internalSettings.remove(key);\n            // to reduce memory usage, let's also drop the Map itself, if empty\n            if (_internalSettings.size() == 0) {\n                _internalSettings = null;\n            }\n        }\n        return removed;\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    public SerializedString getSerializedName() { return _name; }\n    \n    public boolean hasSerializer() { return _serializer != null; }\n    public boolean hasNullSerializer() { return _nullSerializer != null; }\n\n    public boolean willSuppressNulls() { return _suppressNulls; }\n    \n    // Needed by BeanSerializer#getSchema\n    public JsonSerializer<Object> getSerializer() {\n        return _serializer;\n    }\n\n    public JavaType getSerializationType() {\n        return _cfgSerializationType;\n    }\n\n    public Class<?> getRawSerializationType() {\n        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n    }\n    \n    public Class<?> getPropertyType() \n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getReturnType();\n        }\n        return _field.getType();\n    }\n\n    /**\n     * Get the generic property type of this property writer.\n     *\n     * @return The property type, or null if not found.\n     */\n    public Type getGenericPropertyType()\n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getGenericReturnType();\n        }\n        return _field.getGenericType();\n    }\n\n    public Class<?>[] getViews() { return _includeInViews; }\n\n    /**\n     *<p>\n     * NOTE: due to introspection, this is a <b>slow</b> method to call\n     * and should never be called during actual serialization or filtering\n     * of the property. Rather it is needed for traversal needed for things\n     * like constructing JSON Schema instances.\n     * \n     * @since 2.1\n     * \n     * @deprecated since 2.2, use {@link #isRequired()} instead.\n     */\n    @Deprecated\n    protected boolean isRequired(AnnotationIntrospector intr) {\n        return _isRequired;\n    }\n\n    /*\n    /**********************************************************\n    /* Legacy support for JsonFormatVisitable\n    /**********************************************************\n     */\n\n    /**\n     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n     * \n     * @param propertiesNode Node which the given property would exist within\n     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n     *  processing\n     *  \n     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n        throws JsonMappingException\n    {\n        JavaType propType = getSerializationType();\n        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n        JsonNode schemaNode;\n        // Maybe it already has annotated/statically configured serializer?\n        JsonSerializer<Object> ser = getSerializer();\n        if (ser == null) { // nope\n            Class<?> serType = getRawSerializationType();\n            if (serType == null) {\n                serType = getPropertyType();\n            }\n            ser = provider.findValueSerializer(serType, this);\n        }\n        boolean isOptional = !isRequired();\n        if (ser instanceof SchemaAware) {\n            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n        } else {  \n            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n        }\n        propertiesNode.put(getName(), schemaNode);\n    }\n    \n    /*\n    /**********************************************************\n    /* Serialization functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method called to access property that this bean stands for, from\n     * within given bean, and to serialize it as a JSON Object field\n     * using appropriate serializer.\n     */\n    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        // Null handling is bit different, check that first\n        if (value == null) {\n            if (_nullSerializer != null) {\n                jgen.writeFieldName(_name);\n                _nullSerializer.serialize(null, jgen, prov);\n            }\n            return;\n        }\n        // then find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) {\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) {\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        jgen.writeFieldName(_name);\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to serialize a placeholder used in tabular output when\n     * real value is not to be included (is filtered out), but when we need\n     * an entry so that field indexes will not be off. Typically this should\n     * output null or empty String, depending on datatype.\n     * \n     * @since 2.1\n     */\n    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, jgen, prov);\n        } else {\n            jgen.writeNull();\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n            Class<?> type, SerializerProvider provider) throws JsonMappingException\n    {\n        PropertySerializerMap.SerializerAndMapResult result;\n        if (_nonTrivialBaseType != null) {\n            JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n            result = map.findAndAddSerializer(t, provider, this);\n        } else {\n            result = map.findAndAddSerializer(type, provider, this);\n        }\n        // did we get a new map of serializers? If so, start using it\n        if (map != result.map) {\n            _dynamicSerializers = result.map;\n        }\n        return result.serializer;\n    }\n    \n    /**\n     * Method that can be used to access value of the property this\n     * Object describes, from given bean instance.\n     *<p>\n     * Note: method is final as it should not need to be overridden -- rather,\n     * calling method(s) ({@link #serializeAsField}) should be overridden\n     * to change the behavior\n     */\n    public final Object get(Object bean) throws Exception\n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.invoke(bean);\n        }\n        return _field.get(bean);\n    }\n\n    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n        throws JsonMappingException\n    {\n        /* 05-Feb-2012, tatu: Usually a problem, but NOT if we are handling\n         *    object id; this may be the case for BeanSerializers at least.\n         */\n        if (ser.usesObjectId()) {\n            return;\n        }\n        throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"property '\").append(getName()).append(\"' (\");\n        if (_accessorMethod != null) {\n            sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n        } else {\n            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n        }\n        if (_serializer == null) {\n            sb.append(\", no static serializer\");\n        } else {\n            sb.append(\", static serializer of type \"+_serializer.getClass().getName());\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.io.SerializedString;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\npublic class BeanPropertyWriter\n    implements BeanProperty\n{\n    /**\n     * Marker object used to indicate \"do not serialize if empty\"\n     */\n    public final static Object MARKER_FOR_EMPTY = new Object();\n    \n    /*\n    /**********************************************************\n    /* Settings for accessing property value to serialize\n    /**********************************************************\n     */\n\n    /**\n     * Member (field, method) that represents property and allows access\n     * to associated annotations.\n     */\n    protected final AnnotatedMember _member;\n\n    /**\n     * Annotations from context (most often, class that declares property,\n     * or in case of sub-class serializer, from that sub-class)\n     */\n    protected final Annotations _contextAnnotations;\n    \n    /**\n     * Type property is declared to have, either in class definition \n     * or associated annotations.\n     */\n    protected final JavaType _declaredType;\n    \n    /**\n     * Accessor method used to get property value, for\n     * method-accessible properties.\n     * Null if and only if {@link #_field} is null.\n     */\n    protected final Method _accessorMethod;\n    \n    /**\n     * Field that contains the property value for field-accessible\n     * properties.\n     * Null if and only if {@link #_accessorMethod} is null.\n     */\n    protected final Field _field;\n    \n    /*\n    /**********************************************************\n    /* Opaque internal data that bean serializer factory and\n    /* bean serializers can add.\n    /**********************************************************\n     */\n\n    protected HashMap<Object,Object> _internalSettings;\n    \n    /*\n    /**********************************************************\n    /* Serialization settings\n    /**********************************************************\n     */\n    \n    /**\n     * Logical name of the property; will be used as the field name\n     * under which value for the property is written.\n     */\n    protected final SerializedString _name;\n\n    /**\n     * Wrapper name to use for this element, if any\n     * \n     * @since 2.2\n     */\n    protected final PropertyName _wrapperName;\n    \n    /**\n     * Type to use for locating serializer; normally same as return\n     * type of the accessor method, but may be overridden by annotations.\n     */\n    protected final JavaType _cfgSerializationType;\n\n    /**\n     * Serializer to use for writing out the value: null if it can not\n     * be known statically; non-null if it can.\n     */\n    protected JsonSerializer<Object> _serializer;\n\n    /**\n     * Serializer used for writing out null values, if any: if null,\n     * null values are to be suppressed.\n     */\n    protected JsonSerializer<Object> _nullSerializer;\n    \n    /**\n     * In case serializer is not known statically (i.e. <code>_serializer</code>\n     * is null), we will use a lookup structure for storing dynamically\n     * resolved mapping from type(s) to serializer(s).\n     */\n    protected PropertySerializerMap _dynamicSerializers;\n\n    /**\n     * Whether null values are to be suppressed (nothing written out if\n     * value is null) or not.\n     */\n    protected final boolean _suppressNulls;\n    \n    /**\n     * Value that is considered default value of the property; used for\n     * default-value-suppression if enabled.\n     */\n    protected final Object _suppressableValue;\n\n    /**\n     * Alternate set of property writers used when view-based filtering\n     * is available for the Bean.\n     */\n    protected final Class<?>[] _includeInViews;\n\n    /**\n     * If property being serialized needs type information to be\n     * included this is the type serializer to use.\n     * Declared type (possibly augmented with annotations) of property\n     * is used for determining exact mechanism to use (compared to\n     * actual runtime type used for serializing actual state).\n     */\n    protected TypeSerializer _typeSerializer;\n    \n    /**\n     * Base type of the property, if the declared type is \"non-trivial\";\n     * meaning it is either a structured type (collection, map, array),\n     * or parameterized. Used to retain type information about contained\n     * type, which is mostly necessary if type meta-data is to be\n     * included.\n     */\n    protected JavaType _nonTrivialBaseType;\n\n    /**\n     * Whether value of this property has been marked as required.\n     * Retained since it will be needed when traversing type hierarchy\n     * for producing schemas (and other similar tasks); currently not\n     * used for serialization.\n     * \n     * @since 2.2\n     */\n    protected final boolean _isRequired;\n    \n    /*\n    /**********************************************************\n    /* Construction, configuration\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    public BeanPropertyWriter(BeanPropertyDefinition propDef,\n            AnnotatedMember member, Annotations contextAnnotations,\n            JavaType declaredType,\n            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n            boolean suppressNulls, Object suppressableValue)\n    {\n        \n        _member = member;\n        _contextAnnotations = contextAnnotations;\n        _name = new SerializedString(propDef.getName());\n        _wrapperName = propDef.getWrapperName();\n        _declaredType = declaredType;\n        _serializer = (JsonSerializer<Object>) ser;\n        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n        _typeSerializer = typeSer;\n        _cfgSerializationType = serType;\n        _isRequired = propDef.isRequired();\n\n        if (member instanceof AnnotatedField) {\n            _accessorMethod = null;\n            _field = (Field) member.getMember();\n        } else if (member instanceof AnnotatedMethod) {\n            _accessorMethod = (Method) member.getMember();\n            _field = null;\n        } else {\n            throw new IllegalArgumentException(\"Can not pass member of type \"+member.getClass().getName());\n        }\n        _suppressNulls = suppressNulls;\n        _suppressableValue = suppressableValue;\n        _includeInViews = propDef.findViews();\n\n        // this will be resolved later on, unless nulls are to be suppressed\n        _nullSerializer = null;\n    }\n\n    /**\n     * \"Copy constructor\" to be used by filtering sub-classes\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base) {\n        this(base, base._name);\n    }\n\n    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name)\n    {\n        _name = name;\n        _wrapperName = base._wrapperName;\n\n        _member = base._member;\n        _contextAnnotations = base._contextAnnotations;\n        _declaredType = base._declaredType;\n        _accessorMethod = base._accessorMethod;\n        _field = base._field;\n        _serializer = base._serializer;\n        _nullSerializer = base._nullSerializer;\n        // one more thing: copy internal settings, if any (since 1.7)\n        if (base._internalSettings != null) {\n            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n        }\n        _cfgSerializationType = base._cfgSerializationType;\n        _dynamicSerializers = base._dynamicSerializers;\n        _suppressNulls = base._suppressNulls;\n        _suppressableValue = base._suppressableValue;\n        _includeInViews = base._includeInViews;\n        _typeSerializer = base._typeSerializer;\n        _nonTrivialBaseType = base._nonTrivialBaseType;\n        _isRequired = base._isRequired;\n    }\n\n    public BeanPropertyWriter rename(NameTransformer transformer) {\n        String newName = transformer.transform(_name.getValue());\n        if (newName.equals(_name.toString())) {\n            return this;\n        }\n        return new BeanPropertyWriter(this, new SerializedString(newName));\n    }\n    \n    /**\n     * Method called to assign value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignSerializer(JsonSerializer<Object> ser)\n    {\n        // may need to disable check in future?\n        if (_serializer != null && _serializer != ser) {\n            throw new IllegalStateException(\"Can not override serializer\");\n        }\n        _serializer = ser;\n    }\n\n    /**\n     * Method called to assign null value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignNullSerializer(JsonSerializer<Object> nullSer)\n    {\n        // may need to disable check in future?\n        if (_nullSerializer != null && _nullSerializer != nullSer) {\n            throw new IllegalStateException(\"Can not override null serializer\");\n        }\n        _nullSerializer = nullSer;\n    }\n    \n    /**\n     * Method called create an instance that handles details of unwrapping\n     * contained value.\n     */\n    public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) {\n        return new UnwrappingBeanPropertyWriter(this, unwrapper);\n    }\n\n    /**\n     * Method called to define type to consider as \"non-trivial\" basetype,\n     * needed for dynamic serialization resolution for complex (usually container)\n     * types\n     */\n    public void setNonTrivialBaseType(JavaType t) {\n        _nonTrivialBaseType = t;\n    }\n\n    /*\n    /**********************************************************\n    /* BeanProperty impl\n    /**********************************************************\n     */\n    \n    @Override\n    public String getName() {\n        return _name.getValue();\n    }\n\n    @Override\n    public JavaType getType() {\n        return _declaredType;\n    }\n\n    @Override\n    public PropertyName getWrapperName() {\n        return _wrapperName;\n    }\n\n    @Override\n    public boolean isRequired() {\n        return _isRequired;\n    }\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return _member.getAnnotation(acls);\n    }\n\n    @Override\n    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return _contextAnnotations.get(acls);\n    }\n\n    @Override\n    public AnnotatedMember getMember() {\n        return _member;\n    }\n\n\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n        throws JsonMappingException\n    {\n        if (objectVisitor != null) {\n            if (isRequired()) {\n                objectVisitor.property(this); \n            } else {\n                objectVisitor.optionalProperty(this);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Managing and accessing of opaque internal settings\n    /* (used by extensions)\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value of specified internal setting.\n     * \n     * @return Value of the setting, if any; null if none.\n     */\n    public Object getInternalSetting(Object key)\n    {\n        if (_internalSettings == null) {\n            return null;\n        }\n        return _internalSettings.get(key);\n    }\n    \n    /**\n     * Method for setting specific internal setting to given value\n     * \n     * @return Old value of the setting, if any (null if none)\n     */\n    public Object setInternalSetting(Object key, Object value)\n    {\n        if (_internalSettings == null) {\n            _internalSettings = new HashMap<Object,Object>();\n        }\n        return _internalSettings.put(key, value);\n    }\n\n    /**\n     * Method for removing entry for specified internal setting.\n     * \n     * @return Existing value of the setting, if any (null if none)\n     */\n    public Object removeInternalSetting(Object key)\n    {\n        Object removed = null;\n        if (_internalSettings != null) {\n            removed = _internalSettings.remove(key);\n            // to reduce memory usage, let's also drop the Map itself, if empty\n            if (_internalSettings.size() == 0) {\n                _internalSettings = null;\n            }\n        }\n        return removed;\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    public SerializedString getSerializedName() { return _name; }\n    \n    public boolean hasSerializer() { return _serializer != null; }\n    public boolean hasNullSerializer() { return _nullSerializer != null; }\n\n    public boolean willSuppressNulls() { return _suppressNulls; }\n    \n    // Needed by BeanSerializer#getSchema\n    public JsonSerializer<Object> getSerializer() {\n        return _serializer;\n    }\n\n    public JavaType getSerializationType() {\n        return _cfgSerializationType;\n    }\n\n    public Class<?> getRawSerializationType() {\n        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n    }\n    \n    public Class<?> getPropertyType() \n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getReturnType();\n        }\n        return _field.getType();\n    }\n\n    /**\n     * Get the generic property type of this property writer.\n     *\n     * @return The property type, or null if not found.\n     */\n    public Type getGenericPropertyType()\n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getGenericReturnType();\n        }\n        return _field.getGenericType();\n    }\n\n    public Class<?>[] getViews() { return _includeInViews; }\n\n    /**\n     *<p>\n     * NOTE: due to introspection, this is a <b>slow</b> method to call\n     * and should never be called during actual serialization or filtering\n     * of the property. Rather it is needed for traversal needed for things\n     * like constructing JSON Schema instances.\n     * \n     * @since 2.1\n     * \n     * @deprecated since 2.2, use {@link #isRequired()} instead.\n     */\n    @Deprecated\n    protected boolean isRequired(AnnotationIntrospector intr) {\n        return _isRequired;\n    }\n\n    /*\n    /**********************************************************\n    /* Legacy support for JsonFormatVisitable\n    /**********************************************************\n     */\n\n    /**\n     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n     * \n     * @param propertiesNode Node which the given property would exist within\n     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n     *  processing\n     *  \n     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n        throws JsonMappingException\n    {\n        JavaType propType = getSerializationType();\n        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n        JsonNode schemaNode;\n        // Maybe it already has annotated/statically configured serializer?\n        JsonSerializer<Object> ser = getSerializer();\n        if (ser == null) { // nope\n            Class<?> serType = getRawSerializationType();\n            if (serType == null) {\n                serType = getPropertyType();\n            }\n            ser = provider.findValueSerializer(serType, this);\n        }\n        boolean isOptional = !isRequired();\n        if (ser instanceof SchemaAware) {\n            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n        } else {  \n            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n        }\n        propertiesNode.put(getName(), schemaNode);\n    }\n    \n    /*\n    /**********************************************************\n    /* Serialization functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method called to access property that this bean stands for, from\n     * within given bean, and to serialize it as a JSON Object field\n     * using appropriate serializer.\n     */\n    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        // Null handling is bit different, check that first\n        if (value == null) {\n            if (_nullSerializer != null) {\n                jgen.writeFieldName(_name);\n                _nullSerializer.serialize(null, jgen, prov);\n            }\n            return;\n        }\n        // then find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) {\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) {\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        jgen.writeFieldName(_name);\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n            return;\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to serialize a placeholder used in tabular output when\n     * real value is not to be included (is filtered out), but when we need\n     * an entry so that field indexes will not be off. Typically this should\n     * output null or empty String, depending on datatype.\n     * \n     * @since 2.1\n     */\n    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, jgen, prov);\n        } else {\n            jgen.writeNull();\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n            Class<?> type, SerializerProvider provider) throws JsonMappingException\n    {\n        PropertySerializerMap.SerializerAndMapResult result;\n        if (_nonTrivialBaseType != null) {\n            JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n            result = map.findAndAddSerializer(t, provider, this);\n        } else {\n            result = map.findAndAddSerializer(type, provider, this);\n        }\n        // did we get a new map of serializers? If so, start using it\n        if (map != result.map) {\n            _dynamicSerializers = result.map;\n        }\n        return result.serializer;\n    }\n    \n    /**\n     * Method that can be used to access value of the property this\n     * Object describes, from given bean instance.\n     *<p>\n     * Note: method is final as it should not need to be overridden -- rather,\n     * calling method(s) ({@link #serializeAsField}) should be overridden\n     * to change the behavior\n     */\n    public final Object get(Object bean) throws Exception\n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.invoke(bean);\n        }\n        return _field.get(bean);\n    }\n\n    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n        throws JsonMappingException\n    {\n        /* 05-Feb-2012, tatu: Usually a problem, but NOT if we are handling\n         *    object id; this may be the case for BeanSerializers at least.\n         */\n        if (ser.usesObjectId()) {\n            return;\n        }\n        throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"property '\").append(getName()).append(\"' (\");\n        if (_accessorMethod != null) {\n            sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n        } else {\n            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n        }\n        if (_serializer == null) {\n            sb.append(\", no static serializer\");\n        } else {\n            sb.append(\", static serializer of type \"+_serializer.getClass().getName());\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 2, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.util.TokenBuffer", "buggy_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser jp)\n    {\n        _objectCodec = jp.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = jp.canReadTypeId();\n        _hasNativeObjectIds = jp.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other)\n        throws IOException, JsonGenerationException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        copyCurrentStructure(jp);\n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        @Deprecated // since 2.3\n        protected Parser(Segment firstSeg, ObjectCodec codec) {\n            this(firstSeg, codec, false, false);\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n        \n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser jp)\n    {\n        _objectCodec = jp.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = jp.canReadTypeId();\n        _hasNativeObjectIds = jp.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other)\n        throws IOException, JsonGenerationException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        copyCurrentStructure(jp);\n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        } else if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        @Deprecated // since 2.3\n        protected Parser(Segment firstSeg, ObjectCodec codec) {\n            this(firstSeg, codec, false, false);\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n        \n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 3, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.StringArrayDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\n@JacksonStdImpl\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    \n    /**\n     * Value serializer to use, if not the standard one (which is inlined)\n     */\n    protected JsonDeserializer<String> _elementDeserializer;\n\n    public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Ok: must point to START_ARRAY (or equivalent)\n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            // Ok: no need to convert Strings, but must recognize nulls\n            String value;\n            if (t == JsonToken.VALUE_STRING) {\n                value = jp.getText();\n            } else if (t == JsonToken.VALUE_NULL) {\n                value = _elementDeserializer.getNullValue();\n            } else {\n                value = _parseString(jp, ctxt);\n            }\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        final JsonDeserializer<String> deser = _elementDeserializer;\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            // Ok: no need to convert Strings, but must recognize nulls\n            String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // [JACKSON-526]: implicit arrays from single values?\n        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            // [JACKSON-620] Empty String can become null...\n            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = jp.getText();\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n    }\n\n    /**\n     * Contextualization is needed to see whether we can \"inline\" deserialization\n     * of String values, or if we have to use separate value deserializer.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n    {\n        JsonDeserializer<?> deser = _elementDeserializer;\n        // #125: May have a content converter\n        deser = findConvertingContentDeserializer(ctxt, property, deser);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            deser = ctxt.handleSecondaryContextualization(deser, property);\n        }\n        // Ok ok: if all we got is the default String deserializer, can just forget about it\n        if (deser != null && this.isDefaultDeserializer(deser)) {\n            deser = null;\n        }\n        if (_elementDeserializer != deser) {\n            return new StringArrayDeserializer(deser);\n        }\n        return this;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\n@JacksonStdImpl\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    \n    /**\n     * Value serializer to use, if not the standard one (which is inlined)\n     */\n    protected JsonDeserializer<String> _elementDeserializer;\n\n    public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Ok: must point to START_ARRAY (or equivalent)\n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            // Ok: no need to convert Strings, but must recognize nulls\n            String value;\n            if (t == JsonToken.VALUE_STRING) {\n                value = jp.getText();\n            } else if (t == JsonToken.VALUE_NULL) {\n                value = null; // since we have established that '_elementDeserializer == null' earlier\n            } else {\n                value = _parseString(jp, ctxt);\n            }\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        final JsonDeserializer<String> deser = _elementDeserializer;\n        \n        int ix = 0;\n        JsonToken t;\n        \n        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n            // Ok: no need to convert Strings, but must recognize nulls\n            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n            if (ix >= chunk.length) {\n                chunk = buffer.appendCompletedChunk(chunk);\n                ix = 0;\n            }\n            chunk[ix++] = value;\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // [JACKSON-526]: implicit arrays from single values?\n        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            // [JACKSON-620] Empty String can become null...\n            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = jp.getText();\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n    }\n\n    /**\n     * Contextualization is needed to see whether we can \"inline\" deserialization\n     * of String values, or if we have to use separate value deserializer.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n    {\n        JsonDeserializer<?> deser = _elementDeserializer;\n        // #125: May have a content converter\n        deser = findConvertingContentDeserializer(ctxt, property, deser);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            deser = ctxt.handleSecondaryContextualization(deser, property);\n        }\n        // Ok ok: if all we got is the default String deserializer, can just forget about it\n        if (deser != null && this.isDefaultDeserializer(deser)) {\n            deser = null;\n        }\n        if (_elementDeserializer != deser) {\n            return new StringArrayDeserializer(deser);\n        }\n        return this;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 4, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.StringArrayDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\n@JacksonStdImpl\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    \n    /**\n     * Value serializer to use, if not the standard one (which is inlined)\n     */\n    protected JsonDeserializer<String> _elementDeserializer;\n\n    public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Ok: must point to START_ARRAY (or equivalent)\n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n\n        int ix = 0;\n        JsonToken t;\n\n            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                // Ok: no need to convert Strings, but must recognize nulls\n                String value;\n                if (t == JsonToken.VALUE_STRING) {\n                    value = jp.getText();\n                } else if (t == JsonToken.VALUE_NULL) {\n                    value = null; // since we have established that '_elementDeserializer == null' earlier\n                } else {\n                    value = _parseString(jp, ctxt);\n                }\n                if (ix >= chunk.length) {\n                    chunk = buffer.appendCompletedChunk(chunk);\n                    ix = 0;\n                }\n                chunk[ix++] = value;\n            }\n            // note: pass String.class, not String[].class, as we need element type for error info\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        final JsonDeserializer<String> deser = _elementDeserializer;\n        \n        int ix = 0;\n        JsonToken t;\n\n            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                // Ok: no need to convert Strings, but must recognize nulls\n                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n                if (ix >= chunk.length) {\n                    chunk = buffer.appendCompletedChunk(chunk);\n                    ix = 0;\n                }\n                chunk[ix++] = value;\n            }\n            // note: pass String.class, not String[].class, as we need element type for error info\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // [JACKSON-526]: implicit arrays from single values?\n        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            // [JACKSON-620] Empty String can become null...\n            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = jp.getText();\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n    }\n\n    /**\n     * Contextualization is needed to see whether we can \"inline\" deserialization\n     * of String values, or if we have to use separate value deserializer.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n    {\n        JsonDeserializer<?> deser = _elementDeserializer;\n        // #125: May have a content converter\n        deser = findConvertingContentDeserializer(ctxt, property, deser);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            deser = ctxt.handleSecondaryContextualization(deser, property);\n        }\n        // Ok ok: if all we got is the default String deserializer, can just forget about it\n        if (deser != null && this.isDefaultDeserializer(deser)) {\n            deser = null;\n        }\n        if (_elementDeserializer != deser) {\n            return new StringArrayDeserializer(deser);\n        }\n        return this;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\n@JacksonStdImpl\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    \n    /**\n     * Value serializer to use, if not the standard one (which is inlined)\n     */\n    protected JsonDeserializer<String> _elementDeserializer;\n\n    public StringArrayDeserializer() {\n        super(String[].class);\n        _elementDeserializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n        super(String[].class);\n        _elementDeserializer = (JsonDeserializer<String>) deser;\n    }\n   \n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Ok: must point to START_ARRAY (or equivalent)\n        if (!jp.isExpectedStartArrayToken()) {\n            return handleNonArray(jp, ctxt);\n        }\n        if (_elementDeserializer != null) {\n            return _deserializeCustom(jp, ctxt);\n        }\n\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n\n        int ix = 0;\n        JsonToken t;\n\n        try {\n            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                // Ok: no need to convert Strings, but must recognize nulls\n                String value;\n                if (t == JsonToken.VALUE_STRING) {\n                    value = jp.getText();\n                } else if (t == JsonToken.VALUE_NULL) {\n                    value = null; // since we have established that '_elementDeserializer == null' earlier\n                } else {\n                    value = _parseString(jp, ctxt);\n                }\n                if (ix >= chunk.length) {\n                    chunk = buffer.appendCompletedChunk(chunk);\n                    ix = 0;\n                }\n                chunk[ix++] = value;\n            }\n        } catch (Exception e) {\n            // note: pass String.class, not String[].class, as we need element type for error info\n            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] chunk = buffer.resetAndStart();\n        final JsonDeserializer<String> deser = _elementDeserializer;\n        \n        int ix = 0;\n        JsonToken t;\n\n        try {\n            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                // Ok: no need to convert Strings, but must recognize nulls\n                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n                if (ix >= chunk.length) {\n                    chunk = buffer.appendCompletedChunk(chunk);\n                    ix = 0;\n                }\n                chunk[ix++] = value;\n            }\n        } catch (Exception e) {\n            // note: pass String.class, not String[].class, as we need element type for error info\n            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n        }\n        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n        ctxt.returnObjectBuffer(buffer);\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // [JACKSON-526]: implicit arrays from single values?\n        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            // [JACKSON-620] Empty String can become null...\n            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = jp.getText();\n                if (str.length() == 0) {\n                    return null;\n                }\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n    }\n\n    /**\n     * Contextualization is needed to see whether we can \"inline\" deserialization\n     * of String values, or if we have to use separate value deserializer.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n    {\n        JsonDeserializer<?> deser = _elementDeserializer;\n        // #125: May have a content converter\n        deser = findConvertingContentDeserializer(ctxt, property, deser);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            deser = ctxt.handleSecondaryContextualization(deser, property);\n        }\n        // Ok ok: if all we got is the default String deserializer, can just forget about it\n        if (deser != null && this.isDefaultDeserializer(deser)) {\n            deser = null;\n        }\n        if (_elementDeserializer != deser) {\n            return new StringArrayDeserializer(deser);\n        }\n        return this;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 5, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.introspect.AnnotatedClass", "buggy_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector.MixInResolver;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\npublic final class AnnotatedClass\n    extends Annotated\n{\n    private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0];\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Class for which annotations apply, and that owns other\n     * components (constructors, methods)\n     */\n    final protected Class<?> _class;\n\n    /**\n     * Ordered set of super classes and interfaces of the\n     * class itself: included in order of precedence\n     */\n    final protected List<Class<?>> _superTypes;\n\n    /**\n     * Filter used to determine which annotations to gather; used\n     * to optimize things so that unnecessary annotations are\n     * ignored.\n     */\n    final protected AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * Object that knows mapping of mix-in classes (ones that contain\n     * annotations to add) with their target classes (ones that\n     * get these additional annotations \"mixed in\").\n     */\n    final protected MixInResolver _mixInResolver;\n\n    /**\n     * Primary mix-in class; one to use for the annotated class\n     * itself. Can be null.\n     */\n    final protected Class<?> _primaryMixIn;\n\n    /*\n    /**********************************************************\n    /* Gathered information\n    /**********************************************************\n     */\n\n    /**\n     * Combined list of Jackson annotations that the class has,\n     * including inheritable ones from super classes and interfaces\n     */\n    protected AnnotationMap _classAnnotations;\n\n    /**\n     * Flag to indicate whether creator information has been resolved\n     * or not.\n     */\n    protected boolean _creatorsResolved = false;\n    \n    /**\n     * Default constructor of the annotated class, if it has one.\n     */\n    protected AnnotatedConstructor _defaultConstructor;\n\n    /**\n     * Single argument constructors the class has, if any.\n     */\n    protected List<AnnotatedConstructor> _constructors;\n\n    /**\n     * Single argument static methods that might be usable\n     * as factory methods\n     */\n    protected List<AnnotatedMethod> _creatorMethods;\n\n    /**\n     * Member methods of interest; for now ones with 0 or 1 arguments\n     * (just optimization, since others won't be used now)\n     */\n    protected AnnotatedMethodMap  _memberMethods;\n\n    /**\n     * Member fields of interest: ones that are either public,\n     * or have at least one annotation.\n     */\n    protected List<AnnotatedField> _fields;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor will not do any initializations, to allow for\n     * configuring instances differently depending on use cases\n     */\n    private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes,\n            AnnotationIntrospector aintr, MixInResolver mir,\n            AnnotationMap classAnnotations)\n    {\n        _class = cls;\n        _superTypes = superTypes;\n        _annotationIntrospector = aintr;\n        _mixInResolver = mir;\n        _primaryMixIn = (_mixInResolver == null) ? null\n            : _mixInResolver.findMixInClassFor(_class);\n        _classAnnotations = classAnnotations;\n    }\n\n    @Override\n    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n        return new AnnotatedClass(_class, _superTypes,\n                _annotationIntrospector, _mixInResolver, ann);\n    }\n    \n    /**\n     * Factory method that instantiates an instance. Returned instance\n     * will only be initialized with class annotations, but not with\n     * any method information.\n     */\n    public static AnnotatedClass construct(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n    }\n\n    /**\n     * Method similar to {@link #construct}, but that will NOT include\n     * information from supertypes; only class itself and any direct\n     * mix-ins it may have.\n     */\n    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                Collections.<Class<?>>emptyList(), aintr, mir, null);\n    }\n    \n    /*\n    /**********************************************************\n    /* Annotated impl \n    /**********************************************************\n     */\n\n    @Override\n    public Class<?> getAnnotated() { return _class; }\n\n    @Override\n    public int getModifiers() { return _class.getModifiers(); }\n\n    @Override\n    public String getName() { return _class.getName(); }\n\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls)\n    {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.get(acls);\n    }\n\n    @Override\n    public Type getGenericType() {\n        return _class;\n    }\n\n    @Override\n    public Class<?> getRawType() {\n        return _class;\n    }\n\n    @Override\n    public Iterable<Annotation> annotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.annotations();\n    }\n    \n    @Override\n    protected AnnotationMap getAllAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, generic accessors\n    /**********************************************************\n     */\n\n    public Annotations getAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    public boolean hasAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.size() > 0;\n    }\n\n    public AnnotatedConstructor getDefaultConstructor()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _defaultConstructor;\n    }\n\n    public List<AnnotatedConstructor> getConstructors()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _constructors;\n    }\n\n    public List<AnnotatedMethod> getStaticMethods()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _creatorMethods;\n    }\n\n    public Iterable<AnnotatedMethod> memberMethods()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods;\n    }\n\n    public int getMemberMethodCount()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.size();\n    }\n\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.find(name, paramTypes);\n    }\n\n    public int getFieldCount() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields.size();\n    }\n\n    public Iterable<AnnotatedField> fields()\n    {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, main-level resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Initialization method that will recursively collect Jackson\n     * annotations for this class and all super classes and\n     * interfaces.\n     */\n    private void resolveClassAnnotations()\n    {\n        _classAnnotations = new AnnotationMap();\n        // [JACKSON-659] Should skip processing if annotation processing disabled\n        if (_annotationIntrospector != null) {\n            // add mix-in annotations first (overrides)\n            if (_primaryMixIn != null) {\n                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n            }\n            // first, annotations from the class itself:\n            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n    \n            // and then from super types\n            for (Class<?> cls : _superTypes) {\n                // and mix mix-in annotations in-between\n                _addClassMixIns(_classAnnotations, cls);\n                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n            }\n            /* and finally... any annotations there might be for plain\n             * old Object.class: separate because for all other purposes\n             * it is just ignored (not included in super types)\n             */\n            /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n             *   For now, yes, seems useful for some cases, and not harmful for any?\n             */\n            _addClassMixIns(_classAnnotations, Object.class);\n        }\n    }\n    \n    /**\n     * Initialization method that will find out all constructors\n     * and potential static factory methods the class has.\n     */\n    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n            if (_primaryMixIn != null) {\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }\n    \n    /**\n     * Method for resolving member method information: aggregating all non-static methods\n     * and combining annotations (to implement method-annotation inheritance)\n     * \n     * @param methodFilter Filter used to determine which methods to include\n     */\n    private void resolveMemberMethods()\n    {\n        _memberMethods = new AnnotatedMethodMap();\n        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n        // first: methods from the class itself\n        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n\n        // and then augment these with annotations from super-types:\n        for (Class<?> cls : _superTypes) {\n            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n        }\n        // Special case: mix-ins for Object.class? (to apply to ALL classes)\n        if (_mixInResolver != null) {\n            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n            if (mixin != null) {\n                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n            }\n        }\n\n        /* Any unmatched mix-ins? Most likely error cases (not matching\n         * any method); but there is one possible real use case:\n         * exposing Object#hashCode (alas, Object#getClass can NOT be\n         * exposed, see [JACKSON-140])\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (!mixins.isEmpty()) {\n                Iterator<AnnotatedMethod> it = mixins.iterator();\n                while (it.hasNext()) {\n                    AnnotatedMethod mixIn = it.next();\n                    try {\n                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes());\n                        if (m != null) {\n                            AnnotatedMethod am = _constructMethod(m);\n                            _addMixOvers(mixIn.getAnnotated(), am, false);\n                            _memberMethods.add(am);\n                        }\n                    } catch (Exception e) { }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Method that will collect all member (non-static) fields\n     * that are either public, or have at least a single annotation\n     * associated with them.\n     */\n    private void resolveFields()\n    {\n        Map<String,AnnotatedField> foundFields = _findFields(_class, null);\n        if (foundFields == null || foundFields.size() == 0) {\n            _fields = Collections.emptyList();\n        } else {\n            _fields = new ArrayList<AnnotatedField>(foundFields.size());\n            _fields.addAll(foundFields.values());\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for resolving class annotations\n    /* (resolution consisting of inheritance, overrides,\n    /* and injection of mix-ins as necessary)\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method for adding any mix-in annotations specified\n     * class might have.\n     */\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)\n    {\n        if (_mixInResolver != null) {\n            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));\n        }\n    }\n\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,\n                                   Class<?> mixin)\n    {\n        if (mixin == null) {\n            return;\n        }\n        // Ok, first: annotations from mix-in class itself:\n        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n\n        /* And then from its supertypes, if any. But note that we will\n         * only consider super-types up until reaching the masked\n         * class (if found); this because often mix-in class\n         * is a sub-class (for convenience reasons). And if so, we\n         * absolutely must NOT include super types of masked class,\n         * as that would inverse precedence of annotations.\n         */\n        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating creator (ctor, factory) information\n    /**********************************************************\n     */\n\n    protected void _addConstructorMixIns(Class<?> mixin)\n    {\n        MemberKey[] ctorKeys = null;\n        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n            if (ctor.getParameterTypes().length == 0) {\n                if (_defaultConstructor != null) {\n                    _addMixOvers(ctor, _defaultConstructor, false);\n                }\n            } else {\n                if (ctorKeys == null) {\n                    ctorKeys = new MemberKey[ctorCount];\n                    for (int i = 0; i < ctorCount; ++i) {\n                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n                    }\n                }\n                MemberKey key = new MemberKey(ctor);\n\n                for (int i = 0; i < ctorCount; ++i) {\n                    if (!key.equals(ctorKeys[i])) {\n                        continue;\n                    }\n                    _addMixOvers(ctor, _constructors.get(i), true);\n                    break;\n                }\n            }\n        }\n    }\n\n    protected void _addFactoryMixIns(Class<?> mixin)\n    {\n        MemberKey[] methodKeys = null;\n        int methodCount = _creatorMethods.size();\n\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            if (m.getParameterTypes().length == 0) {\n                continue;\n            }\n            if (methodKeys == null) {\n                methodKeys = new MemberKey[methodCount];\n                for (int i = 0; i < methodCount; ++i) {\n                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n                }\n            }\n            MemberKey key = new MemberKey(m);\n            for (int i = 0; i < methodCount; ++i) {\n                if (!key.equals(methodKeys[i])) {\n                    continue;\n                }\n                _addMixOvers(m, _creatorMethods.get(i), true);\n                break;\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating method information\n    /**********************************************************\n     */\n\n    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        // first, mixIns, since they have higher priority then class methods\n        if (mixInCls != null) {\n            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n        }        \n        if (cls == null) { // just so caller need not check when passing super-class\n            return;\n        }\n\n        // then methods from the class itself\n        for (Method m : cls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod old = methods.find(m);\n            if (old == null) {\n                AnnotatedMethod newM = _constructMethod(m);\n                methods.add(newM);\n                // Ok, but is there a mix-in to connect now?\n                old = mixIns.remove(m);\n                if (old != null) {\n                    _addMixOvers(old.getAnnotated(), newM, false);\n                }\n            } else {\n                /* If sub-class already has the method, we only want to augment\n                 * annotations with entries that are not masked by sub-class.\n                 */\n                _addMixUnders(m, old);\n\n                /* 06-Jan-2010, tatu: [JACKSON-450] Except that if method we saw first is\n                 *   from an interface, and we now find a non-interface definition, we should\n                 *   use this method, but with combination of annotations.\n                 *   This helps (or rather, is essential) with JAXB annotations and\n                 *   may also result in faster method calls (interface calls are slightly\n                 *   costlier than regular method calls)\n                 */\n                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n                    methods.add(old.withMethod(m));\n                }\n            }\n        }\n    }\n\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating field information\n    /**********************************************************\n     */\n\n    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)\n    {\n        /* First, a quick test: we only care for regular classes (not\n         * interfaces, primitive types etc), except for Object.class.\n         * A simple check to rule out other cases is to see if there\n         * is a super class or not.\n         */\n        Class<?> parent = c.getSuperclass();\n        if (parent != null) {\n            // Let's add super-class' fields first, then ours.\n            /* 21-Feb-2010, tatu: Need to handle masking: as per [JACKSON-226]\n             *    we otherwise get into trouble...\n             */\n            fields = _findFields(parent, fields);\n            for (Field f : c.getDeclaredFields()) {\n                // static fields not included, nor transient\n                if (!_isIncludableField(f)) {\n                    continue;\n                }\n                /* Ok now: we can (and need) not filter out ignorable fields\n                 * at this point; partly because mix-ins haven't been\n                 * added, and partly because logic can be done when\n                 * determining get/settability of the field.\n                 */\n                if (fields == null) {\n                    fields = new LinkedHashMap<String,AnnotatedField>();\n                }\n                fields.put(f.getName(), _constructField(f));\n            }\n            // And then... any mix-in overrides?\n            if (_mixInResolver != null) {\n                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                if (mixin != null) {\n                    _addFieldMixIns(parent, mixin, fields);\n                }\n            }\n        }\n        return fields;\n    }\n\n    /**\n     * Method called to add field mix-ins from given mix-in class (and its fields)\n     * into already collected actual fields (from introspected classes and their\n     * super-classes)\n     */\n    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n            Map<String,AnnotatedField> fields)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Field mixinField : mixin.getDeclaredFields()) {\n                // there are some dummy things (static, synthetic); better ignore\n                if (!_isIncludableField(mixinField)) {\n                    continue;\n                }\n                String name = mixinField.getName();\n                // anything to mask? (if not, quietly ignore)\n                AnnotatedField maskedField = fields.get(name);\n                if (maskedField != null) {\n                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, constructing value types\n    /**********************************************************\n     */\n\n    protected AnnotatedMethod _constructMethod(Method m)\n    {\n        /* note: parameter annotations not used for regular (getter, setter)\n         * methods; only for creator methods (static factory methods)\n         * -- at least not yet!\n         */\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n    }\n\n    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }\n\n    protected AnnotatedMethod _constructCreatorMethod(Method m)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n    }\n\n    protected AnnotatedField _constructField(Field f)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedField(f, _emptyAnnotationMap());\n        }\n        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n    }\n \n    private AnnotationMap _emptyAnnotationMap() {\n        return new AnnotationMap();\n    }\n\n    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n        if (count == 0) {\n            return NO_ANNOTATION_MAPS;\n        }\n        AnnotationMap[] maps = new AnnotationMap[count];\n        for (int i = 0; i < count; ++i) {\n            maps[i] = _emptyAnnotationMap();\n        }\n        return maps;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods, inclusion filtering\n    /**********************************************************\n     */\n\n    protected boolean _isIncludableMemberMethod(Method m)\n    {\n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        /* 07-Apr-2009, tatu: Looks like generics can introduce hidden\n         *   bridge and/or synthetic methods. I don't think we want to\n         *   consider those...\n         */\n        if (m.isSynthetic() || m.isBridge()) {\n            return false;\n        }\n        // also, for now we have no use for methods with 2 or more arguments:\n        int pcount = m.getParameterTypes().length;\n        return (pcount <= 2);\n    }\n\n    private boolean _isIncludableField(Field f)\n    {\n        /* I'm pretty sure synthetic fields are to be skipped...\n         * (methods definitely are)\n         */\n        if (f.isSynthetic()) {\n            return false;\n        }\n        // Static fields are never included, nor transient\n        int mods = f.getModifiers();\n        if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) {\n            return false;\n        }\n        return true;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, attaching annotations\n    /**********************************************************\n     */\n\n    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n    {\n        int len = anns.length;\n        AnnotationMap[] result = new AnnotationMap[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = _collectRelevantAnnotations(anns[i]);\n        }\n        return result;\n    }\n\n    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n    {\n        AnnotationMap annMap = new AnnotationMap();\n        _addAnnotationsIfNotPresent(annMap, anns);\n        return annMap;\n    }\n    \n    /* Helper method used to add all applicable annotations from given set.\n     * Takes into account possible \"annotation bundles\" (meta-annotations to\n     * include instead of main-level annotation)\n     */\n    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: we will NOT filter out non-Jackson anns any more\n                    result.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(result, annotations);\n                }\n            }\n        }\n    }\n\n    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: we will NOT filter out non-Jackson anns any more\n                    target.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(target, annotations);\n                }\n            }\n        }\n    }\n    \n    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: no filtering by jackson-annotations\n                    target.addOrOverride(ann);\n                }\n            }\n            if (bundles != null) { // and then bundles, if any: important for precedence\n                for (Annotation[] annotations : bundles) {\n                    _addOrOverrideAnnotations(target, annotations);\n                }\n            }\n        }\n    }\n    \n    /**\n     * @param addParamAnnotations Whether parameter annotations are to be\n     *   added as well\n     */\n    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target,\n            boolean addParamAnnotations)\n    {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param addParamAnnotations Whether parameter annotations are to be\n     *   added as well\n     */\n    protected void _addMixOvers(Method mixin, AnnotatedMethod target,\n            boolean addParamAnnotations)\n    {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method that will add annotations from specified source method to target method,\n     * but only if target does not yet have them.\n     */\n    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n    }\n\n   private final boolean _isAnnotationBundle(Annotation ann)\n   {\n       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n   }\n   \n    /*\n    /**********************************************************\n    /* Other methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return \"[AnnotedClass \"+_class.getName()+\"]\";\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector.MixInResolver;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\npublic final class AnnotatedClass\n    extends Annotated\n{\n    private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0];\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Class for which annotations apply, and that owns other\n     * components (constructors, methods)\n     */\n    final protected Class<?> _class;\n\n    /**\n     * Ordered set of super classes and interfaces of the\n     * class itself: included in order of precedence\n     */\n    final protected List<Class<?>> _superTypes;\n\n    /**\n     * Filter used to determine which annotations to gather; used\n     * to optimize things so that unnecessary annotations are\n     * ignored.\n     */\n    final protected AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * Object that knows mapping of mix-in classes (ones that contain\n     * annotations to add) with their target classes (ones that\n     * get these additional annotations \"mixed in\").\n     */\n    final protected MixInResolver _mixInResolver;\n\n    /**\n     * Primary mix-in class; one to use for the annotated class\n     * itself. Can be null.\n     */\n    final protected Class<?> _primaryMixIn;\n\n    /*\n    /**********************************************************\n    /* Gathered information\n    /**********************************************************\n     */\n\n    /**\n     * Combined list of Jackson annotations that the class has,\n     * including inheritable ones from super classes and interfaces\n     */\n    protected AnnotationMap _classAnnotations;\n\n    /**\n     * Flag to indicate whether creator information has been resolved\n     * or not.\n     */\n    protected boolean _creatorsResolved = false;\n    \n    /**\n     * Default constructor of the annotated class, if it has one.\n     */\n    protected AnnotatedConstructor _defaultConstructor;\n\n    /**\n     * Single argument constructors the class has, if any.\n     */\n    protected List<AnnotatedConstructor> _constructors;\n\n    /**\n     * Single argument static methods that might be usable\n     * as factory methods\n     */\n    protected List<AnnotatedMethod> _creatorMethods;\n\n    /**\n     * Member methods of interest; for now ones with 0 or 1 arguments\n     * (just optimization, since others won't be used now)\n     */\n    protected AnnotatedMethodMap  _memberMethods;\n\n    /**\n     * Member fields of interest: ones that are either public,\n     * or have at least one annotation.\n     */\n    protected List<AnnotatedField> _fields;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor will not do any initializations, to allow for\n     * configuring instances differently depending on use cases\n     */\n    private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes,\n            AnnotationIntrospector aintr, MixInResolver mir,\n            AnnotationMap classAnnotations)\n    {\n        _class = cls;\n        _superTypes = superTypes;\n        _annotationIntrospector = aintr;\n        _mixInResolver = mir;\n        _primaryMixIn = (_mixInResolver == null) ? null\n            : _mixInResolver.findMixInClassFor(_class);\n        _classAnnotations = classAnnotations;\n    }\n\n    @Override\n    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n        return new AnnotatedClass(_class, _superTypes,\n                _annotationIntrospector, _mixInResolver, ann);\n    }\n    \n    /**\n     * Factory method that instantiates an instance. Returned instance\n     * will only be initialized with class annotations, but not with\n     * any method information.\n     */\n    public static AnnotatedClass construct(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n    }\n\n    /**\n     * Method similar to {@link #construct}, but that will NOT include\n     * information from supertypes; only class itself and any direct\n     * mix-ins it may have.\n     */\n    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                Collections.<Class<?>>emptyList(), aintr, mir, null);\n    }\n    \n    /*\n    /**********************************************************\n    /* Annotated impl \n    /**********************************************************\n     */\n\n    @Override\n    public Class<?> getAnnotated() { return _class; }\n\n    @Override\n    public int getModifiers() { return _class.getModifiers(); }\n\n    @Override\n    public String getName() { return _class.getName(); }\n\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls)\n    {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.get(acls);\n    }\n\n    @Override\n    public Type getGenericType() {\n        return _class;\n    }\n\n    @Override\n    public Class<?> getRawType() {\n        return _class;\n    }\n\n    @Override\n    public Iterable<Annotation> annotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.annotations();\n    }\n    \n    @Override\n    protected AnnotationMap getAllAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, generic accessors\n    /**********************************************************\n     */\n\n    public Annotations getAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }\n    \n    public boolean hasAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.size() > 0;\n    }\n\n    public AnnotatedConstructor getDefaultConstructor()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _defaultConstructor;\n    }\n\n    public List<AnnotatedConstructor> getConstructors()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _constructors;\n    }\n\n    public List<AnnotatedMethod> getStaticMethods()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _creatorMethods;\n    }\n\n    public Iterable<AnnotatedMethod> memberMethods()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods;\n    }\n\n    public int getMemberMethodCount()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.size();\n    }\n\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.find(name, paramTypes);\n    }\n\n    public int getFieldCount() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields.size();\n    }\n\n    public Iterable<AnnotatedField> fields()\n    {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, main-level resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Initialization method that will recursively collect Jackson\n     * annotations for this class and all super classes and\n     * interfaces.\n     */\n    private void resolveClassAnnotations()\n    {\n        _classAnnotations = new AnnotationMap();\n        // [JACKSON-659] Should skip processing if annotation processing disabled\n        if (_annotationIntrospector != null) {\n            // add mix-in annotations first (overrides)\n            if (_primaryMixIn != null) {\n                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n            }\n            // first, annotations from the class itself:\n            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n    \n            // and then from super types\n            for (Class<?> cls : _superTypes) {\n                // and mix mix-in annotations in-between\n                _addClassMixIns(_classAnnotations, cls);\n                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n            }\n            /* and finally... any annotations there might be for plain\n             * old Object.class: separate because for all other purposes\n             * it is just ignored (not included in super types)\n             */\n            /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n             *   For now, yes, seems useful for some cases, and not harmful for any?\n             */\n            _addClassMixIns(_classAnnotations, Object.class);\n        }\n    }\n    \n    /**\n     * Initialization method that will find out all constructors\n     * and potential static factory methods the class has.\n     */\n    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n            if (_primaryMixIn != null) {\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }\n    \n    /**\n     * Method for resolving member method information: aggregating all non-static methods\n     * and combining annotations (to implement method-annotation inheritance)\n     * \n     * @param methodFilter Filter used to determine which methods to include\n     */\n    private void resolveMemberMethods()\n    {\n        _memberMethods = new AnnotatedMethodMap();\n        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n        // first: methods from the class itself\n        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n\n        // and then augment these with annotations from super-types:\n        for (Class<?> cls : _superTypes) {\n            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n        }\n        // Special case: mix-ins for Object.class? (to apply to ALL classes)\n        if (_mixInResolver != null) {\n            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n            if (mixin != null) {\n                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n            }\n        }\n\n        /* Any unmatched mix-ins? Most likely error cases (not matching\n         * any method); but there is one possible real use case:\n         * exposing Object#hashCode (alas, Object#getClass can NOT be\n         * exposed, see [JACKSON-140])\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (!mixins.isEmpty()) {\n                Iterator<AnnotatedMethod> it = mixins.iterator();\n                while (it.hasNext()) {\n                    AnnotatedMethod mixIn = it.next();\n                    try {\n                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes());\n                        if (m != null) {\n                            AnnotatedMethod am = _constructMethod(m);\n                            _addMixOvers(mixIn.getAnnotated(), am, false);\n                            _memberMethods.add(am);\n                        }\n                    } catch (Exception e) { }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Method that will collect all member (non-static) fields\n     * that are either public, or have at least a single annotation\n     * associated with them.\n     */\n    private void resolveFields()\n    {\n        Map<String,AnnotatedField> foundFields = _findFields(_class, null);\n        if (foundFields == null || foundFields.size() == 0) {\n            _fields = Collections.emptyList();\n        } else {\n            _fields = new ArrayList<AnnotatedField>(foundFields.size());\n            _fields.addAll(foundFields.values());\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for resolving class annotations\n    /* (resolution consisting of inheritance, overrides,\n    /* and injection of mix-ins as necessary)\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method for adding any mix-in annotations specified\n     * class might have.\n     */\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)\n    {\n        if (_mixInResolver != null) {\n            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));\n        }\n    }\n\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,\n                                   Class<?> mixin)\n    {\n        if (mixin == null) {\n            return;\n        }\n        // Ok, first: annotations from mix-in class itself:\n        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n\n        /* And then from its supertypes, if any. But note that we will\n         * only consider super-types up until reaching the masked\n         * class (if found); this because often mix-in class\n         * is a sub-class (for convenience reasons). And if so, we\n         * absolutely must NOT include super types of masked class,\n         * as that would inverse precedence of annotations.\n         */\n        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating creator (ctor, factory) information\n    /**********************************************************\n     */\n\n    protected void _addConstructorMixIns(Class<?> mixin)\n    {\n        MemberKey[] ctorKeys = null;\n        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n            if (ctor.getParameterTypes().length == 0) {\n                if (_defaultConstructor != null) {\n                    _addMixOvers(ctor, _defaultConstructor, false);\n                }\n            } else {\n                if (ctorKeys == null) {\n                    ctorKeys = new MemberKey[ctorCount];\n                    for (int i = 0; i < ctorCount; ++i) {\n                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n                    }\n                }\n                MemberKey key = new MemberKey(ctor);\n\n                for (int i = 0; i < ctorCount; ++i) {\n                    if (!key.equals(ctorKeys[i])) {\n                        continue;\n                    }\n                    _addMixOvers(ctor, _constructors.get(i), true);\n                    break;\n                }\n            }\n        }\n    }\n\n    protected void _addFactoryMixIns(Class<?> mixin)\n    {\n        MemberKey[] methodKeys = null;\n        int methodCount = _creatorMethods.size();\n\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            if (m.getParameterTypes().length == 0) {\n                continue;\n            }\n            if (methodKeys == null) {\n                methodKeys = new MemberKey[methodCount];\n                for (int i = 0; i < methodCount; ++i) {\n                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n                }\n            }\n            MemberKey key = new MemberKey(m);\n            for (int i = 0; i < methodCount; ++i) {\n                if (!key.equals(methodKeys[i])) {\n                    continue;\n                }\n                _addMixOvers(m, _creatorMethods.get(i), true);\n                break;\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating method information\n    /**********************************************************\n     */\n\n    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        // first, mixIns, since they have higher priority then class methods\n        if (mixInCls != null) {\n            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n        }        \n        if (cls == null) { // just so caller need not check when passing super-class\n            return;\n        }\n\n        // then methods from the class itself\n        for (Method m : cls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod old = methods.find(m);\n            if (old == null) {\n                AnnotatedMethod newM = _constructMethod(m);\n                methods.add(newM);\n                // Ok, but is there a mix-in to connect now?\n                old = mixIns.remove(m);\n                if (old != null) {\n                    _addMixOvers(old.getAnnotated(), newM, false);\n                }\n            } else {\n                /* If sub-class already has the method, we only want to augment\n                 * annotations with entries that are not masked by sub-class.\n                 */\n                _addMixUnders(m, old);\n\n                /* 06-Jan-2010, tatu: [JACKSON-450] Except that if method we saw first is\n                 *   from an interface, and we now find a non-interface definition, we should\n                 *   use this method, but with combination of annotations.\n                 *   This helps (or rather, is essential) with JAXB annotations and\n                 *   may also result in faster method calls (interface calls are slightly\n                 *   costlier than regular method calls)\n                 */\n                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n                    methods.add(old.withMethod(m));\n                }\n            }\n        }\n    }\n\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                    am = mixIns.find(m);\n                    if (am != null) {\n                        _addMixUnders(m, am);\n                    } else {\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating field information\n    /**********************************************************\n     */\n\n    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)\n    {\n        /* First, a quick test: we only care for regular classes (not\n         * interfaces, primitive types etc), except for Object.class.\n         * A simple check to rule out other cases is to see if there\n         * is a super class or not.\n         */\n        Class<?> parent = c.getSuperclass();\n        if (parent != null) {\n            // Let's add super-class' fields first, then ours.\n            /* 21-Feb-2010, tatu: Need to handle masking: as per [JACKSON-226]\n             *    we otherwise get into trouble...\n             */\n            fields = _findFields(parent, fields);\n            for (Field f : c.getDeclaredFields()) {\n                // static fields not included, nor transient\n                if (!_isIncludableField(f)) {\n                    continue;\n                }\n                /* Ok now: we can (and need) not filter out ignorable fields\n                 * at this point; partly because mix-ins haven't been\n                 * added, and partly because logic can be done when\n                 * determining get/settability of the field.\n                 */\n                if (fields == null) {\n                    fields = new LinkedHashMap<String,AnnotatedField>();\n                }\n                fields.put(f.getName(), _constructField(f));\n            }\n            // And then... any mix-in overrides?\n            if (_mixInResolver != null) {\n                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                if (mixin != null) {\n                    _addFieldMixIns(parent, mixin, fields);\n                }\n            }\n        }\n        return fields;\n    }\n\n    /**\n     * Method called to add field mix-ins from given mix-in class (and its fields)\n     * into already collected actual fields (from introspected classes and their\n     * super-classes)\n     */\n    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n            Map<String,AnnotatedField> fields)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Field mixinField : mixin.getDeclaredFields()) {\n                // there are some dummy things (static, synthetic); better ignore\n                if (!_isIncludableField(mixinField)) {\n                    continue;\n                }\n                String name = mixinField.getName();\n                // anything to mask? (if not, quietly ignore)\n                AnnotatedField maskedField = fields.get(name);\n                if (maskedField != null) {\n                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, constructing value types\n    /**********************************************************\n     */\n\n    protected AnnotatedMethod _constructMethod(Method m)\n    {\n        /* note: parameter annotations not used for regular (getter, setter)\n         * methods; only for creator methods (static factory methods)\n         * -- at least not yet!\n         */\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n    }\n\n    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }\n\n    protected AnnotatedMethod _constructCreatorMethod(Method m)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n    }\n\n    protected AnnotatedField _constructField(Field f)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedField(f, _emptyAnnotationMap());\n        }\n        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n    }\n \n    private AnnotationMap _emptyAnnotationMap() {\n        return new AnnotationMap();\n    }\n\n    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n        if (count == 0) {\n            return NO_ANNOTATION_MAPS;\n        }\n        AnnotationMap[] maps = new AnnotationMap[count];\n        for (int i = 0; i < count; ++i) {\n            maps[i] = _emptyAnnotationMap();\n        }\n        return maps;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods, inclusion filtering\n    /**********************************************************\n     */\n\n    protected boolean _isIncludableMemberMethod(Method m)\n    {\n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        /* 07-Apr-2009, tatu: Looks like generics can introduce hidden\n         *   bridge and/or synthetic methods. I don't think we want to\n         *   consider those...\n         */\n        if (m.isSynthetic() || m.isBridge()) {\n            return false;\n        }\n        // also, for now we have no use for methods with 2 or more arguments:\n        int pcount = m.getParameterTypes().length;\n        return (pcount <= 2);\n    }\n\n    private boolean _isIncludableField(Field f)\n    {\n        /* I'm pretty sure synthetic fields are to be skipped...\n         * (methods definitely are)\n         */\n        if (f.isSynthetic()) {\n            return false;\n        }\n        // Static fields are never included, nor transient\n        int mods = f.getModifiers();\n        if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) {\n            return false;\n        }\n        return true;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, attaching annotations\n    /**********************************************************\n     */\n\n    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n    {\n        int len = anns.length;\n        AnnotationMap[] result = new AnnotationMap[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = _collectRelevantAnnotations(anns[i]);\n        }\n        return result;\n    }\n\n    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n    {\n        AnnotationMap annMap = new AnnotationMap();\n        _addAnnotationsIfNotPresent(annMap, anns);\n        return annMap;\n    }\n    \n    /* Helper method used to add all applicable annotations from given set.\n     * Takes into account possible \"annotation bundles\" (meta-annotations to\n     * include instead of main-level annotation)\n     */\n    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: we will NOT filter out non-Jackson anns any more\n                    result.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(result, annotations);\n                }\n            }\n        }\n    }\n\n    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: we will NOT filter out non-Jackson anns any more\n                    target.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(target, annotations);\n                }\n            }\n        }\n    }\n    \n    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: no filtering by jackson-annotations\n                    target.addOrOverride(ann);\n                }\n            }\n            if (bundles != null) { // and then bundles, if any: important for precedence\n                for (Annotation[] annotations : bundles) {\n                    _addOrOverrideAnnotations(target, annotations);\n                }\n            }\n        }\n    }\n    \n    /**\n     * @param addParamAnnotations Whether parameter annotations are to be\n     *   added as well\n     */\n    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target,\n            boolean addParamAnnotations)\n    {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param addParamAnnotations Whether parameter annotations are to be\n     *   added as well\n     */\n    protected void _addMixOvers(Method mixin, AnnotatedMethod target,\n            boolean addParamAnnotations)\n    {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method that will add annotations from specified source method to target method,\n     * but only if target does not yet have them.\n     */\n    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n    }\n\n   private final boolean _isAnnotationBundle(Annotation ann)\n   {\n       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n   }\n   \n    /*\n    /**********************************************************\n    /* Other methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return \"[AnnotedClass \"+_class.getName()+\"]\";\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 6, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.util.StdDateFormat", "buggy_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat\n    extends DateFormat\n{\n    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n     * permissive. The two don't mix, need to write a better one.\n     */\n    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n    //   not really robust\n\n    /**\n     * Defines a commonly used date format that conforms\n     * to ISO-8601 date formatting standard, when it includes basic undecorated\n     * timezone definition\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    /**\n     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n     * (or \"GMT\")\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    /**\n     * ISO-8601 with just the Date part, no time\n     */\n    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n\n    /**\n     * This constant defines the date format specified by\n     * RFC 1123 / RFC 822.\n     */\n    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n\n    /**\n     * For error messages we'll also need a list of all formats.\n     */\n    protected final static String[] ALL_FORMATS = new String[] {\n        DATE_FORMAT_STR_ISO8601,\n        DATE_FORMAT_STR_ISO8601_Z,\n        DATE_FORMAT_STR_RFC1123,\n        DATE_FORMAT_STR_PLAIN\n    };\n\n    /**\n     * By default we use GMT for everything.\n     */\n    private final static TimeZone DEFAULT_TIMEZONE;\n    static {\n        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n    }\n\n    private final static Locale DEFAULT_LOCALE = Locale.US;\n    \n    protected final static DateFormat DATE_FORMAT_RFC1123;\n\n    protected final static DateFormat DATE_FORMAT_ISO8601;\n    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n\n    protected final static DateFormat DATE_FORMAT_PLAIN;\n\n    /* Let's construct \"blueprint\" date format instances: can not be used\n     * as is, due to thread-safety issues, but can be used for constructing\n     * actual instances more cheaply (avoids re-parsing).\n     */\n    static {\n        /* Another important thing: let's force use of GMT for\n         * baseline DataFormat objects\n         */\n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    /**\n     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n     */\n    public final static StdDateFormat instance = new StdDateFormat();\n    \n    /**\n     * Caller may want to explicitly override timezone to use; if so,\n     * we will have non-null value here.\n     */\n    protected transient TimeZone _timezone;\n\n    protected final Locale _locale;\n    \n    protected transient DateFormat _formatRFC1123;\n    protected transient DateFormat _formatISO8601;\n    protected transient DateFormat _formatISO8601_z;\n    protected transient DateFormat _formatPlain;\n\n    /*\n    /**********************************************************\n    /* Life cycle, accessing singleton \"standard\" formats\n    /**********************************************************\n     */\n\n    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    /**\n     * @deprecated Since 2.4, use variant that also takes Locale\n     */\n    @Deprecated // since 2.4\n    public StdDateFormat(TimeZone tz) {\n        this(tz, DEFAULT_LOCALE);\n    }\n    \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    /**\n     * Method used for creating a new instance with specified timezone;\n     * if no timezone specified, defaults to the default timezone (UTC).\n     */\n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if (tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        /* Although there is that much state to share, we do need to\n         * orchestrate a bit, mostly since timezones may be changed\n         */\n        return new StdDateFormat(_timezone, _locale);\n    }\n\n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintISO8601Format() {\n        return DATE_FORMAT_ISO8601;\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specified timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);\n    }\n    \n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintRFC1123Format() {\n        return DATE_FORMAT_RFC1123;\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specific timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public void setTimeZone(TimeZone tz)\n    {\n        /* DateFormats are timezone-specific (via Calendar contained),\n         * so need to reset instances if timezone changes:\n         */\n        if (!tz.equals(_timezone)) {\n            _formatRFC1123 = null;\n            _formatISO8601 = null;\n            _formatISO8601_z = null;\n            _formatPlain = null;\n            _timezone = tz;\n        }\n    }\n    \n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(dateStr, pos);\n        if (result != null) {\n            return result;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And #267 points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { // all digits\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    /*\n    /**********************************************************\n    /* Std overrides\n    /**********************************************************\n     */\n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used to figure out which of supported\n     * formats is the likeliest match.\n     */\n    protected boolean looksLikeISO8601(String dateStr)\n    {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                c = dateStr.charAt(len-9);\n                if (Character.isDigit(c)) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len-5, \".000\");\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen <= 8) {\n                        sb.append(\".000\");\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str)\n    {\n        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n}\n\n", "fixed_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat\n    extends DateFormat\n{\n    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n     * permissive. The two don't mix, need to write a better one.\n     */\n    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n    //   not really robust\n\n    /**\n     * Defines a commonly used date format that conforms\n     * to ISO-8601 date formatting standard, when it includes basic undecorated\n     * timezone definition\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    /**\n     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n     * (or \"GMT\")\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    /**\n     * ISO-8601 with just the Date part, no time\n     */\n    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n\n    /**\n     * This constant defines the date format specified by\n     * RFC 1123 / RFC 822.\n     */\n    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n\n    /**\n     * For error messages we'll also need a list of all formats.\n     */\n    protected final static String[] ALL_FORMATS = new String[] {\n        DATE_FORMAT_STR_ISO8601,\n        DATE_FORMAT_STR_ISO8601_Z,\n        DATE_FORMAT_STR_RFC1123,\n        DATE_FORMAT_STR_PLAIN\n    };\n\n    /**\n     * By default we use GMT for everything.\n     */\n    private final static TimeZone DEFAULT_TIMEZONE;\n    static {\n        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n    }\n\n    private final static Locale DEFAULT_LOCALE = Locale.US;\n    \n    protected final static DateFormat DATE_FORMAT_RFC1123;\n\n    protected final static DateFormat DATE_FORMAT_ISO8601;\n    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n\n    protected final static DateFormat DATE_FORMAT_PLAIN;\n\n    /* Let's construct \"blueprint\" date format instances: can not be used\n     * as is, due to thread-safety issues, but can be used for constructing\n     * actual instances more cheaply (avoids re-parsing).\n     */\n    static {\n        /* Another important thing: let's force use of GMT for\n         * baseline DataFormat objects\n         */\n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    /**\n     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n     */\n    public final static StdDateFormat instance = new StdDateFormat();\n    \n    /**\n     * Caller may want to explicitly override timezone to use; if so,\n     * we will have non-null value here.\n     */\n    protected transient TimeZone _timezone;\n\n    protected final Locale _locale;\n    \n    protected transient DateFormat _formatRFC1123;\n    protected transient DateFormat _formatISO8601;\n    protected transient DateFormat _formatISO8601_z;\n    protected transient DateFormat _formatPlain;\n\n    /*\n    /**********************************************************\n    /* Life cycle, accessing singleton \"standard\" formats\n    /**********************************************************\n     */\n\n    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    /**\n     * @deprecated Since 2.4, use variant that also takes Locale\n     */\n    @Deprecated // since 2.4\n    public StdDateFormat(TimeZone tz) {\n        this(tz, DEFAULT_LOCALE);\n    }\n    \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    /**\n     * Method used for creating a new instance with specified timezone;\n     * if no timezone specified, defaults to the default timezone (UTC).\n     */\n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if (tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        /* Although there is that much state to share, we do need to\n         * orchestrate a bit, mostly since timezones may be changed\n         */\n        return new StdDateFormat(_timezone, _locale);\n    }\n\n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintISO8601Format() {\n        return DATE_FORMAT_ISO8601;\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specified timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);\n    }\n    \n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintRFC1123Format() {\n        return DATE_FORMAT_RFC1123;\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specific timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public void setTimeZone(TimeZone tz)\n    {\n        /* DateFormats are timezone-specific (via Calendar contained),\n         * so need to reset instances if timezone changes:\n         */\n        if (!tz.equals(_timezone)) {\n            _formatRFC1123 = null;\n            _formatISO8601 = null;\n            _formatISO8601_z = null;\n            _formatPlain = null;\n            _timezone = tz;\n        }\n    }\n    \n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(dateStr, pos);\n        if (result != null) {\n            return result;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And #267 points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { // all digits\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    /*\n    /**********************************************************\n    /* Std overrides\n    /**********************************************************\n     */\n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used to figure out which of supported\n     * formats is the likeliest match.\n     */\n    protected boolean looksLikeISO8601(String dateStr)\n    {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n                    int offset = len - 5; // insertion offset, before tz-offset\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: // is this legal? (just second fraction marker)\n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: // not legal to have single-digit second\n                        break;\n                    case 6: // probably not legal, but let's allow\n                        sb.insert(offset, \"00.000\");\n                    case 5: // is legal to omit seconds\n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { // missing, or partial\n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str)\n    {\n        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n}\n\n"}]}
{"project": "JacksonDatabind", "bug_id": 7, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.util.TokenBuffer", "buggy_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser jp)\n    {\n        _objectCodec = jp.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = jp.canReadTypeId();\n        _hasNativeObjectIds = jp.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other)\n        throws IOException, JsonGenerationException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        } else if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        @Deprecated // since 2.3\n        protected Parser(Segment firstSeg, ObjectCodec codec) {\n            this(firstSeg, codec, false, false);\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n        \n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser jp)\n    {\n        _objectCodec = jp.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = jp.canReadTypeId();\n        _hasNativeObjectIds = jp.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n    \n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other)\n        throws IOException, JsonGenerationException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(jp);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(jp);\n        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        } else if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        @Deprecated // since 2.3\n        protected Parser(Segment firstSeg, ObjectCodec codec) {\n            this(firstSeg, codec, false, false);\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n        \n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 8, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.impl.CreatorCollector", "buggy_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.Member;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.deser.CreatorProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Container class for storing information on creators (based on annotations,\n * visibility), to be able to build actual instantiator later on.\n */\npublic class CreatorCollector\n{\n    // Since 2.5\n    protected final static int C_DEFAULT = 0;\n    protected final static int C_STRING = 1;\n    protected final static int C_INT = 2;\n    protected final static int C_LONG = 3;\n    protected final static int C_DOUBLE = 4;\n    protected final static int C_BOOLEAN = 5;\n    protected final static int C_DELEGATE = 6;\n    protected final static int C_PROPS = 7;\n\n    protected final static String[] TYPE_DESCS = new String[] {\n        \"default\",\n        \"String\", \"int\", \"long\", \"double\", \"boolean\",\n        \"delegate\", \"property-based\"\n    };\n\n    /// Type of bean being created\n    final protected BeanDescription _beanDesc;\n\n    final protected boolean _canFixAccess;\n\n    /**\n     * Set of creators we have collected so far\n     * \n     * @since 2.5\n     */\n    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8];\n\n    /**\n     * Bitmask of creators that were explicitly marked as creators; false for auto-detected\n     * (ones included base on naming and/or visibility, not annotation)\n     * \n     * @since 2.5\n     */\n    protected int _explicitCreators = 0;\n    \n    protected boolean _hasNonDefaultCreator = false;\n    \n    // when there are injectable values along with delegate:\n    protected CreatorProperty[] _delegateArgs;\n    \n    protected CreatorProperty[] _propertyBasedArgs;\n\n    protected AnnotatedParameter _incompleteParameter;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess)\n    {\n        _beanDesc = beanDesc;\n        _canFixAccess = canFixAccess;\n    }\n\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n    {\n        JavaType delegateType;\n        boolean maybeVanilla = !_hasNonDefaultCreator;\n\n        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n            delegateType = null;\n        } else {\n            // need to find type...\n            int ix = 0;\n            if (_delegateArgs != null) {\n                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {\n                    if (_delegateArgs[i] == null) { // marker for delegate itself\n                        ix = i;\n                        break;\n                    }\n                }\n            }\n            TypeBindings bindings = _beanDesc.bindingsForBeanType();\n            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n        }\n\n        final JavaType type = _beanDesc.getType();\n\n        // Any non-standard creator will prevent; with one exception: int-valued constructor\n        // that standard containers have can be ignored\n        maybeVanilla &= !_hasNonDefaultCreator;\n\n        if (maybeVanilla) {\n            /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n             *   of \"well-known\" types, can create a non-reflection-based instantiator.\n             */\n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }\n    \n    /*\n    /**********************************************************\n    /* Setters\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to indicate the default creator: no-arguments\n     * constructor or factory method that is called to instantiate\n     * a value before populating it with data. Default creator is\n     * only used if no other creators are indicated.\n     * \n     * @param creator Creator method; no-arguments constructor or static\n     *   factory method.\n     */\n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }\n    \n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }\n\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n            CreatorProperty[] injectables)\n    {\n        verifyNonDup(creator, C_DELEGATE, explicit);\n        _delegateArgs = injectables;\n    }\n    \n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n            CreatorProperty[] properties)\n    {\n        verifyNonDup(creator, C_PROPS, explicit);\n        // [JACKSON-470] Better ensure we have no duplicate names either...\n        if (properties.length > 1) {\n            HashMap<String,Integer> names = new HashMap<String,Integer>();\n            for (int i = 0, len = properties.length; i < len; ++i) {\n                String name = properties[i].getName();\n                /* [Issue-13]: Need to consider Injectables, which may not have\n                 *   a name at all, and need to be skipped\n                 */\n                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                    continue;\n                }\n                Integer old = names.put(name, Integer.valueOf(i));\n                if (old != null) {\n                    throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                }\n            }\n        }\n        _propertyBasedArgs = properties;\n    }\n\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }\n\n    // Bunch of methods deprecated in 2.5, to be removed from 2.6 or later\n    \n    @Deprecated // since 2.5\n    public void addStringCreator(AnnotatedWithParams creator) {\n        addStringCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addIntCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addLongCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addDoubleCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addBooleanCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n\n    @Deprecated // since 2.5\n    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n        addDelegatingCreator(creator, false, injectables);\n    }\n\n    @Deprecated // since 2.5\n    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n        addPropertyCreator(creator, false, properties);\n    }\n\n    @Deprecated // since 2.5, remove from 2.6\n    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n        verifyNonDup(newOne, typeIndex, false);\n        return _creators[typeIndex];\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.1\n     */\n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    private <T extends AnnotatedMember> T _fixAccess(T member)\n    {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());\n        }\n        return member;\n    }\n\n    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                // otherwise only verify if neither explicitly annotated.\n            }\n\n            // one more thing: ok to override in sub-class\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: avoid one particular class of bogus problems\n\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                // otherwise, which one to choose?\n                    // new type more generic, use old\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper class(es)\n    /**********************************************************\n     */\n\n    protected final static class Vanilla\n        extends ValueInstantiator\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        public final static int TYPE_COLLECTION = 1;\n        public final static int TYPE_MAP = 2;\n        public final static int TYPE_HASH_MAP = 3;\n\n        private final int _type;\n        \n        public Vanilla(int t) {\n            _type = t;\n        }\n        \n        \n        @Override\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }\n\n        @Override\n        public boolean canInstantiate() { return true; }\n\n        @Override\n        public boolean canCreateUsingDefault() {  return true; }\n\n        @Override\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.reflect.Member;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.deser.CreatorProperty;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Container class for storing information on creators (based on annotations,\n * visibility), to be able to build actual instantiator later on.\n */\npublic class CreatorCollector\n{\n    // Since 2.5\n    protected final static int C_DEFAULT = 0;\n    protected final static int C_STRING = 1;\n    protected final static int C_INT = 2;\n    protected final static int C_LONG = 3;\n    protected final static int C_DOUBLE = 4;\n    protected final static int C_BOOLEAN = 5;\n    protected final static int C_DELEGATE = 6;\n    protected final static int C_PROPS = 7;\n\n    protected final static String[] TYPE_DESCS = new String[] {\n        \"default\",\n        \"String\", \"int\", \"long\", \"double\", \"boolean\",\n        \"delegate\", \"property-based\"\n    };\n\n    /// Type of bean being created\n    final protected BeanDescription _beanDesc;\n\n    final protected boolean _canFixAccess;\n\n    /**\n     * Set of creators we have collected so far\n     * \n     * @since 2.5\n     */\n    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8];\n\n    /**\n     * Bitmask of creators that were explicitly marked as creators; false for auto-detected\n     * (ones included base on naming and/or visibility, not annotation)\n     * \n     * @since 2.5\n     */\n    protected int _explicitCreators = 0;\n    \n    protected boolean _hasNonDefaultCreator = false;\n    \n    // when there are injectable values along with delegate:\n    protected CreatorProperty[] _delegateArgs;\n    \n    protected CreatorProperty[] _propertyBasedArgs;\n\n    protected AnnotatedParameter _incompleteParameter;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess)\n    {\n        _beanDesc = beanDesc;\n        _canFixAccess = canFixAccess;\n    }\n\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n    {\n        JavaType delegateType;\n        boolean maybeVanilla = !_hasNonDefaultCreator;\n\n        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n            delegateType = null;\n        } else {\n            // need to find type...\n            int ix = 0;\n            if (_delegateArgs != null) {\n                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {\n                    if (_delegateArgs[i] == null) { // marker for delegate itself\n                        ix = i;\n                        break;\n                    }\n                }\n            }\n            TypeBindings bindings = _beanDesc.bindingsForBeanType();\n            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n        }\n\n        final JavaType type = _beanDesc.getType();\n\n        // Any non-standard creator will prevent; with one exception: int-valued constructor\n        // that standard containers have can be ignored\n        maybeVanilla &= !_hasNonDefaultCreator;\n\n        if (maybeVanilla) {\n            /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n             *   of \"well-known\" types, can create a non-reflection-based instantiator.\n             */\n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }\n    \n    /*\n    /**********************************************************\n    /* Setters\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to indicate the default creator: no-arguments\n     * constructor or factory method that is called to instantiate\n     * a value before populating it with data. Default creator is\n     * only used if no other creators are indicated.\n     * \n     * @param creator Creator method; no-arguments constructor or static\n     *   factory method.\n     */\n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }\n    \n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }\n\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n            CreatorProperty[] injectables)\n    {\n        verifyNonDup(creator, C_DELEGATE, explicit);\n        _delegateArgs = injectables;\n    }\n    \n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n            CreatorProperty[] properties)\n    {\n        verifyNonDup(creator, C_PROPS, explicit);\n        // [JACKSON-470] Better ensure we have no duplicate names either...\n        if (properties.length > 1) {\n            HashMap<String,Integer> names = new HashMap<String,Integer>();\n            for (int i = 0, len = properties.length; i < len; ++i) {\n                String name = properties[i].getName();\n                /* [Issue-13]: Need to consider Injectables, which may not have\n                 *   a name at all, and need to be skipped\n                 */\n                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                    continue;\n                }\n                Integer old = names.put(name, Integer.valueOf(i));\n                if (old != null) {\n                    throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                }\n            }\n        }\n        _propertyBasedArgs = properties;\n    }\n\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }\n\n    // Bunch of methods deprecated in 2.5, to be removed from 2.6 or later\n    \n    @Deprecated // since 2.5\n    public void addStringCreator(AnnotatedWithParams creator) {\n        addStringCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addIntCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addLongCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addDoubleCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n    @Deprecated // since 2.5\n    public void addBooleanCreator(AnnotatedWithParams creator) {\n        addBooleanCreator(creator, false);\n    }\n\n    @Deprecated // since 2.5\n    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n        addDelegatingCreator(creator, false, injectables);\n    }\n\n    @Deprecated // since 2.5\n    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n        addPropertyCreator(creator, false, properties);\n    }\n\n    @Deprecated // since 2.5, remove from 2.6\n    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n        verifyNonDup(newOne, typeIndex, false);\n        return _creators[typeIndex];\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.1\n     */\n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    private <T extends AnnotatedMember> T _fixAccess(T member)\n    {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());\n        }\n        return member;\n    }\n\n    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n            boolean verify;\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                verify = true;\n            } else {\n                // otherwise only verify if neither explicitly annotated.\n                verify = !explicit;\n            }\n\n            // one more thing: ok to override in sub-class\n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                // [databind#667]: avoid one particular class of bogus problems\n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                // otherwise, which one to choose?\n                if (newType.isAssignableFrom(oldType)) {\n                    // new type more generic, use old\n                    return;\n                }\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper class(es)\n    /**********************************************************\n     */\n\n    protected final static class Vanilla\n        extends ValueInstantiator\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        public final static int TYPE_COLLECTION = 1;\n        public final static int TYPE_MAP = 2;\n        public final static int TYPE_HASH_MAP = 3;\n\n        private final int _type;\n        \n        public Vanilla(int t) {\n            _type = t;\n        }\n        \n        \n        @Override\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }\n\n        @Override\n        public boolean canInstantiate() { return true; }\n\n        @Override\n        public boolean canCreateUsingDefault() {  return true; }\n\n        @Override\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 9, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.std.StdKeySerializer", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Date;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n\n/**\n * Specialized serializer that can be used as the generic key\n * serializer, when serializing {@link java.util.Map}s to JSON\n * Objects.\n */\n@SuppressWarnings(\"serial\")\npublic class StdKeySerializer extends StdSerializer<Object>\n{\n    public StdKeySerializer() { super(Object.class); }\n\n    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n        String str;\n        \n        if (value instanceof Date) {\n            provider.defaultSerializeDateKey((Date) value, jgen);\n            return;\n        } else {\n            str = value.toString();\n        }\n        jgen.writeFieldName(str);\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n        return createSchemaNode(\"string\");\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        visitor.expectStringFormat(typeHint);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Date;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n\n/**\n * Specialized serializer that can be used as the generic key\n * serializer, when serializing {@link java.util.Map}s to JSON\n * Objects.\n */\n@SuppressWarnings(\"serial\")\npublic class StdKeySerializer extends StdSerializer<Object>\n{\n    public StdKeySerializer() { super(Object.class); }\n\n    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n        String str;\n        Class<?> cls = value.getClass();\n        \n        if (cls == String.class) {\n            str = (String) value;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            provider.defaultSerializeDateKey((Date) value, jgen);\n            return;\n        } else if (cls == Class.class) {\n            str = ((Class<?>) value).getName();\n        } else {\n            str = value.toString();\n        }\n        jgen.writeFieldName(str);\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n        return createSchemaNode(\"string\");\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        visitor.expectStringFormat(typeHint);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 10, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.AnyGetterWriter", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.Map;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\n\n/**\n * Class similar to {@link BeanPropertyWriter}, but that will be used\n * for serializing {@link com.fasterxml.jackson.annotation.JsonAnyGetter} annotated\n * (Map) properties\n */\npublic class AnyGetterWriter\n{\n    protected final BeanProperty _property;\n\n    /**\n     * Method (or field) that represents the \"any getter\"\n     */\n    protected final AnnotatedMember _accessor;\n\n\n    protected MapSerializer _mapSerializer;\n    \n    @SuppressWarnings(\"unchecked\")\n    public AnyGetterWriter(BeanProperty property,\n            AnnotatedMember accessor, MapSerializer serializer)\n    {\n        _accessor = accessor;\n        _property = property;\n            _mapSerializer = (MapSerializer) serializer;\n    }\n\n    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n        throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n            return;\n        }\n    }\n\n    /**\n     * @since 2.3\n     */\n    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n            PropertyFilter filter)\n                    throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);\n            return;\n        }\n        // ... not sure how custom handler would do it\n    }\n    \n    // Note: NOT part of ResolvableSerializer...\n    @SuppressWarnings(\"unchecked\")\n    public void resolve(SerializerProvider provider) throws JsonMappingException\n    {\n        // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n        _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.Map;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\n\n/**\n * Class similar to {@link BeanPropertyWriter}, but that will be used\n * for serializing {@link com.fasterxml.jackson.annotation.JsonAnyGetter} annotated\n * (Map) properties\n */\npublic class AnyGetterWriter\n{\n    protected final BeanProperty _property;\n\n    /**\n     * Method (or field) that represents the \"any getter\"\n     */\n    protected final AnnotatedMember _accessor;\n\n    protected JsonSerializer<Object> _serializer;\n\n    protected MapSerializer _mapSerializer;\n    \n    @SuppressWarnings(\"unchecked\")\n    public AnyGetterWriter(BeanProperty property,\n            AnnotatedMember accessor, JsonSerializer<?> serializer)\n    {\n        _accessor = accessor;\n        _property = property;\n        _serializer = (JsonSerializer<Object>) serializer;\n        if (serializer instanceof MapSerializer) {\n            _mapSerializer = (MapSerializer) serializer;\n        }\n    }\n\n    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n        throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n            return;\n        }\n        _serializer.serialize(value, gen, provider);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n            PropertyFilter filter)\n                    throws Exception\n    {\n        Object value = _accessor.getValue(bean);\n        if (value == null) {\n            return;\n        }\n        if (!(value instanceof Map<?,?>)) {\n            throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                    +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n        }\n        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n        if (_mapSerializer != null) {\n            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);\n            return;\n        }\n        // ... not sure how custom handler would do it\n        _serializer.serialize(value, gen, provider);\n    }\n    \n    // Note: NOT part of ResolvableSerializer...\n    @SuppressWarnings(\"unchecked\")\n    public void resolve(SerializerProvider provider) throws JsonMappingException\n    {\n        // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n        if (_serializer instanceof ContextualSerializer) {\n            JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property);\n            _serializer = (JsonSerializer<Object>) ser;\n            if (ser instanceof MapSerializer) {\n                _mapSerializer = (MapSerializer) ser;\n            }\n        }\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.ser.BeanSerializerFactory", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n     * thus a single shared global (== singleton) instance can be used\n     * without thread-safety issues.\n     */\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: creation, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for creating instances with specified configuration.\n     */\n    protected BeanSerializerFactory(SerializerFactoryConfig config)\n    {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to attach additional\n     * serializer providers into this serializer factory. This is typically\n     * handled by constructing a new instance with additional serializers,\n     * to ensure thread-safe access.\n     */\n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional serializers, or losing serializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        // Then JsonSerializable, @JsonValue etc:\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        \n        // Otherwise, we will check \"primary types\"; both marker types that\n        // indicate specific handling (JsonSerializable), or main types that have\n        // precedence over container types\n        if (ser == null) {\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [Issue#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public methods that are not part of\n    /* JsonSerializerFactory API\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to construct a {@link BeanSerializer} for\n     * given class. Returns null if no properties are found.\n     */\n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First things first: we know some types are not beans...\n        if (!isPotentialBeanType(type.getRawClass())) {\n            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n            //   as per [Issue#24]\n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * non-container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param baseType Declared type to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property values, if one is needed; null if not.\n     */\n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, baseType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n                accessor, config, ai, baseType);\n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param containerType Declared type of the container to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property value contents, if one is needed; null if not.\n     */    \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, contentType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor,\n                config, ai, contentType);\n        return b.buildTypeSerializer(config, contentType, subtypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        }\n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n            // TODO: can we find full PropertyName?\n            PropertyName name = new PropertyName(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    /**\n     * Method called to construct a filtered writer, for given view\n     * definitions. Default implementation constructs filter that checks\n     * active view type to views property is to be included in.\n     */\n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n            Class<?>[] inViews)\n    {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n            BeanDescription beanDesc)\n    {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public introspection methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    /**\n     * Method used to collect all actual serializable properties.\n     * Can be overridden to implement custom detection schemes.\n     */\n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder)\n        throws JsonMappingException\n    {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        // [JACKSON-429]: ignore specified types\n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        // and possibly remove ones without matching mutator...\n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        // nothing? can't proceed (caller may or may not throw an exception)\n        if (properties.isEmpty()) {\n            return null;\n        }\n        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            // [JACKSON-762]: type id? Requires special handling:\n            if (property.isTypeId()) {\n                if (accessor != null) { // only add if we can access... but otherwise?\n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            // [JACKSON-235]: suppress writing of back references\n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public methods for manipulating bean properties\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable method that can filter out properties. Default implementation\n     * checks annotations class may have.\n     */\n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Method called to handle view information for constructed serializer,\n     * based on bean property writers.\n     *<p>\n     * Note that this method is designed to be overridden by sub-classes\n     * if they want to provide custom view handling. As such it is not\n     * considered an internal implementation detail, and will be supported\n     * as part of API going forward.\n     */\n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n    {\n        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        // Simple: view information is stored within individual writers, need to combine:\n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { // no view info? include or exclude by default?\n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    /**\n     * Method that will apply by-type limitations (as per [JACKSON-429]);\n     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n     * annotation but can be supplied by module-provided introspectors too.\n     */\n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                // default to false, non-ignorable\n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            // lotsa work, and yes, it is ignorable type, so:\n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method that will remove all properties that do not have a mutator.\n     */\n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            // one caveat: as per [JACKSON-806], only remove implicit properties;\n            // explicitly annotated ones should remain\n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */\n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, TypeBindings typeContext,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n         *  here will NOT be resolved or contextualized, unless done here, so:\n         */\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n     * thus a single shared global (== singleton) instance can be used\n     * without thread-safety issues.\n     */\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: creation, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for creating instances with specified configuration.\n     */\n    protected BeanSerializerFactory(SerializerFactoryConfig config)\n    {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to attach additional\n     * serializer providers into this serializer factory. This is typically\n     * handled by constructing a new instance with additional serializers,\n     * to ensure thread-safe access.\n     */\n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional serializers, or losing serializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        // Then JsonSerializable, @JsonValue etc:\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        \n        // Otherwise, we will check \"primary types\"; both marker types that\n        // indicate specific handling (JsonSerializable), or main types that have\n        // precedence over container types\n        if (ser == null) {\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [Issue#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public methods that are not part of\n    /* JsonSerializerFactory API\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to construct a {@link BeanSerializer} for\n     * given class. Returns null if no properties are found.\n     */\n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First things first: we know some types are not beans...\n        if (!isPotentialBeanType(type.getRawClass())) {\n            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n            //   as per [Issue#24]\n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * non-container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param baseType Declared type to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property values, if one is needed; null if not.\n     */\n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, baseType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n                accessor, config, ai, baseType);\n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param containerType Declared type of the container to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property value contents, if one is needed; null if not.\n     */    \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, contentType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor,\n                config, ai, contentType);\n        return b.buildTypeSerializer(config, contentType, subtypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        }\n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                        typeSer, null, null, /*filterId*/ null);\n            }\n            // TODO: can we find full PropertyName?\n            PropertyName name = new PropertyName(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    /**\n     * Method called to construct a filtered writer, for given view\n     * definitions. Default implementation constructs filter that checks\n     * active view type to views property is to be included in.\n     */\n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n            Class<?>[] inViews)\n    {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n            BeanDescription beanDesc)\n    {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public introspection methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    /**\n     * Method used to collect all actual serializable properties.\n     * Can be overridden to implement custom detection schemes.\n     */\n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder)\n        throws JsonMappingException\n    {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        // [JACKSON-429]: ignore specified types\n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        // and possibly remove ones without matching mutator...\n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        // nothing? can't proceed (caller may or may not throw an exception)\n        if (properties.isEmpty()) {\n            return null;\n        }\n        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            // [JACKSON-762]: type id? Requires special handling:\n            if (property.isTypeId()) {\n                if (accessor != null) { // only add if we can access... but otherwise?\n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            // [JACKSON-235]: suppress writing of back references\n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public methods for manipulating bean properties\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable method that can filter out properties. Default implementation\n     * checks annotations class may have.\n     */\n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Method called to handle view information for constructed serializer,\n     * based on bean property writers.\n     *<p>\n     * Note that this method is designed to be overridden by sub-classes\n     * if they want to provide custom view handling. As such it is not\n     * considered an internal implementation detail, and will be supported\n     * as part of API going forward.\n     */\n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n    {\n        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        // Simple: view information is stored within individual writers, need to combine:\n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { // no view info? include or exclude by default?\n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    /**\n     * Method that will apply by-type limitations (as per [JACKSON-429]);\n     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n     * annotation but can be supplied by module-provided introspectors too.\n     */\n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                // default to false, non-ignorable\n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            // lotsa work, and yes, it is ignorable type, so:\n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method that will remove all properties that do not have a mutator.\n     */\n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            // one caveat: as per [JACKSON-806], only remove implicit properties;\n            // explicitly annotated ones should remain\n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */\n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, TypeBindings typeContext,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n         *  here will NOT be resolved or contextualized, unless done here, so:\n         */\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 11, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.TypeFactory", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n    \n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n\n    /*\n     * Looks like construction of {@link JavaType} instances can be\n     * a bottleneck, esp. for root-level Maps, so we better do bit\n     * of low-level component caching here...\n     */\n    \n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedHashMapType;\n\n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedArrayListType;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n    \n    protected final TypeParser _parser;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        _parser = p;\n        _modifiers = mods;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Shouldbe able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer>\"\n     * from \"Map&ltString,Integer>\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n    \n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        /* Tricky part here is that some JavaType instances have been constructed\n         * from generic type (usually via TypeReference); and in those case\n         * types have been resolved. Alternative is that the leaf type is type-erased\n         * class, in which case this has not been done.\n         * For now simplest way to handle this is to split processing in two: latter\n         * case actually fully works; and former mostly works. In future may need to\n         * rewrite former part, which requires changes to JavaType as well.\n         */\n        if (expType == type.getParameterSource()) {\n            // Direct type info; good since we can return it as is\n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        /* Otherwise need to go through type-erased class. This may miss cases where\n         * we get generic type; ideally JavaType/SimpleType would retain information\n         * about generic declaration at main level... but let's worry about that\n         * if/when there are problems; current handling is an improvement over earlier\n         * code.\n         */\n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n        // First: find full inheritance chain\n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        // Caller is supposed to ensure this never happens, so:\n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        // Ok and then go to the ultimate super-type:\n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { // got bindings, need to resolve\n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        // which ought to be generic (if not, it's raw type)\n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        return _constructType(typeRef.getType(), null);\n    }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n\n    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n    \n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n    \n    /**\n     * Method for constructing a type instance with specified parameterization.\n     * \n     * @deprecated Since 2.5, use variant that takes one more argument\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }\n    \n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        // Quick sanity check: must match numbers of types with expected...\n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } \n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }\n    \n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  TypeFactory.parametricType(List.class, Integer.class);\n     *</pre>\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     * \n     * @param parametrized Type-erased type of instance being constructed\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterClasses Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.parametricType(Set.class, Integer.class);\n     *  TypeFactory.parametricType(List.class, inner);\n     *</pre>\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     * \n     * \n     * @param parametrized Actual full type\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        JavaType resultType;\n        \n        // Need to check kind of class we are dealing with...\n        if (parametrized.isArray()) {\n            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Actual factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @param context Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n        // Very first thing: small set of core types we know well:\n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        // Barring that, we may have recently constructed an instance:\n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // If context was needed, weed do:\n        /*\n        if (context == null) {\n            context = new TypeBindings(this, cls);\n        }\n        */\n\n        // First: do we have an array type?\n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            /* Also: although enums can also be fully resolved, there's little\n             * point in doing so (T extends Enum<T>) etc.\n             */\n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            /* Maps and Collections aren't quite as hot; problem is, due\n             * to type erasure we often do not know typing and can only assume\n             * base Object.\n             */\n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n            if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); // cache object syncs\n        return result;\n    }\n    \n    /**\n     * Method used by {@link TypeParser} when generics-aware version\n     * is constructed.\n     */\n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n        if (clz.isArray()) { // ignore generics (should never have any)\n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { // ditto for enums\n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            // First: if we do have param types, use them\n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        // Hmmh. Does this actually occur?\n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }\n    \n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n        /* First: what is the actual base type? One odd thing\n         * is that 'getRawType' returns Type, not Class<?> as\n         * one might expect. But let's assume it is always of\n         * type Class: if not, need to add more code to resolve\n         * it to Class.\n         */\n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        // Ok: Map or Collection?\n        if (Map.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        if (paramCount == 0) { // no generics\n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }\n\n    \n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n    {\n        /* Similar to challenges with TypeVariable, we may have\n         * multiple upper bounds. But it is also possible that if\n         * upper bound defaults to Object, we might want to consider\n         * lower bounds instead.\n         *\n         * For now, we won't try anything more advanced; above is\n         * just for future reference.\n         */\n        return _constructType(type.getUpperBounds()[0], context);\n    }\n\n    private JavaType _mapType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    // further resolution needed?\n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    // no we're good for the variable (but it may have parameterization of its own)\n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }\n    \n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to find inheritance (implements, extends) path\n     * between given types, if one exists (caller generally checks before\n     * calling this method). Returned type represents given <b>subtype</b>,\n     * with supertype linkage extending to <b>supertype</b>.\n     */\n    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n        // If super-type is a class (not interface), bit simpler\n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        // Otherwise, keep on going down the rat hole...\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        // Otherwise, keep on going down the rat hole; first implemented interfaces\n        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's\n         *   try caching certain commonly needed cases\n         */\n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n    {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        // as long as there are superclasses\n        // and unless we have already seen the type (<T extends X<T>>)\n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        // and then super-class if any\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n    \n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n\n    /*\n     * Looks like construction of {@link JavaType} instances can be\n     * a bottleneck, esp. for root-level Maps, so we better do bit\n     * of low-level component caching here...\n     */\n    \n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedHashMapType;\n\n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedArrayListType;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n    \n    protected final TypeParser _parser;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        _parser = p;\n        _modifiers = mods;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Shouldbe able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer>\"\n     * from \"Map&ltString,Integer>\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n    \n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        /* Tricky part here is that some JavaType instances have been constructed\n         * from generic type (usually via TypeReference); and in those case\n         * types have been resolved. Alternative is that the leaf type is type-erased\n         * class, in which case this has not been done.\n         * For now simplest way to handle this is to split processing in two: latter\n         * case actually fully works; and former mostly works. In future may need to\n         * rewrite former part, which requires changes to JavaType as well.\n         */\n        if (expType == type.getParameterSource()) {\n            // Direct type info; good since we can return it as is\n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        /* Otherwise need to go through type-erased class. This may miss cases where\n         * we get generic type; ideally JavaType/SimpleType would retain information\n         * about generic declaration at main level... but let's worry about that\n         * if/when there are problems; current handling is an improvement over earlier\n         * code.\n         */\n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n        // First: find full inheritance chain\n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        // Caller is supposed to ensure this never happens, so:\n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        // Ok and then go to the ultimate super-type:\n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { // got bindings, need to resolve\n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        // which ought to be generic (if not, it's raw type)\n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        return _constructType(typeRef.getType(), null);\n    }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n\n    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n    \n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n    \n    /**\n     * Method for constructing a type instance with specified parameterization.\n     * \n     * @deprecated Since 2.5, use variant that takes one more argument\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }\n    \n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        // Quick sanity check: must match numbers of types with expected...\n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } \n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }\n    \n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  TypeFactory.parametricType(List.class, Integer.class);\n     *</pre>\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     * \n     * @param parametrized Type-erased type of instance being constructed\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterClasses Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.parametricType(Set.class, Integer.class);\n     *  TypeFactory.parametricType(List.class, inner);\n     *</pre>\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     * \n     * \n     * @param parametrized Actual full type\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        JavaType resultType;\n        \n        // Need to check kind of class we are dealing with...\n        if (parametrized.isArray()) {\n            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Actual factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @param context Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n        // Very first thing: small set of core types we know well:\n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        // Barring that, we may have recently constructed an instance:\n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // If context was needed, weed do:\n        /*\n        if (context == null) {\n            context = new TypeBindings(this, cls);\n        }\n        */\n\n        // First: do we have an array type?\n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            /* Also: although enums can also be fully resolved, there's little\n             * point in doing so (T extends Enum<T>) etc.\n             */\n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            /* Maps and Collections aren't quite as hot; problem is, due\n             * to type erasure we often do not know typing and can only assume\n             * base Object.\n             */\n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n            if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); // cache object syncs\n        return result;\n    }\n    \n    /**\n     * Method used by {@link TypeParser} when generics-aware version\n     * is constructed.\n     */\n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n        if (clz.isArray()) { // ignore generics (should never have any)\n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { // ditto for enums\n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            // First: if we do have param types, use them\n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        // Hmmh. Does this actually occur?\n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }\n    \n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n        /* First: what is the actual base type? One odd thing\n         * is that 'getRawType' returns Type, not Class<?> as\n         * one might expect. But let's assume it is always of\n         * type Class: if not, need to add more code to resolve\n         * it to Class.\n         */\n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        // Ok: Map or Collection?\n        if (Map.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        if (paramCount == 0) { // no generics\n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }\n\n    \n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n    {\n        /* Similar to challenges with TypeVariable, we may have\n         * multiple upper bounds. But it is also possible that if\n         * upper bound defaults to Object, we might want to consider\n         * lower bounds instead.\n         *\n         * For now, we won't try anything more advanced; above is\n         * just for future reference.\n         */\n        return _constructType(type.getUpperBounds()[0], context);\n    }\n\n    private JavaType _mapType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    // further resolution needed?\n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    // no we're good for the variable (but it may have parameterization of its own)\n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }\n    \n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to find inheritance (implements, extends) path\n     * between given types, if one exists (caller generally checks before\n     * calling this method). Returned type represents given <b>subtype</b>,\n     * with supertype linkage extending to <b>supertype</b>.\n     */\n    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n        // If super-type is a class (not interface), bit simpler\n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        // Otherwise, keep on going down the rat hole...\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        // Otherwise, keep on going down the rat hole; first implemented interfaces\n        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's\n         *   try caching certain commonly needed cases\n         */\n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n    {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        // as long as there are superclasses\n        // and unless we have already seen the type (<T extends X<T>>)\n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        // and then super-class if any\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 12, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\n\n/**\n * Basic serializer that can take JSON \"Object\" structure and\n * construct a {@link java.util.Map} instance, with typed contents.\n *<p>\n * Note: for untyped content (one indicated by passing Object.class\n * as the type), {@link UntypedObjectDeserializer} is used instead.\n * It can also construct {@link java.util.Map}s, but not with specific\n * POJO types, only other containers and primitives/wrappers.\n */\n@JacksonStdImpl\npublic class MapDeserializer\n    extends ContainerDeserializerBase<Map<Object,Object>>\n    implements ContextualDeserializer, ResolvableDeserializer\n{\n    private static final long serialVersionUID = -3378654289961736240L;\n\n    // // Configuration: typing, deserializers\n\n    protected final JavaType _mapType;\n\n    /**\n     * Key deserializer to use; either passed via constructor\n     * (when indicated by annotations), or resolved when\n     * {@link #resolve} is called;\n     */\n    protected final KeyDeserializer _keyDeserializer;\n\n    /**\n     * Flag set to indicate that the key type is\n     * {@link java.lang.String} (or {@link java.lang.Object}, for\n     * which String is acceptable), <b>and</b> that the\n     * default Jackson key deserializer would be used.\n     * If both are true, can optimize handling.\n     */\n    protected boolean _standardStringKey;\n\n    /**\n     * Value deserializer.\n     */\n    protected final JsonDeserializer<Object> _valueDeserializer;\n\n    /**\n     * If value instances have polymorphic type information, this\n     * is the type deserializer that can handle it\n     */\n    protected final TypeDeserializer _valueTypeDeserializer;\n    \n    // // Instance construction settings:\n\n    protected final ValueInstantiator _valueInstantiator;\n\n    protected final boolean _hasDefaultCreator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _delegateDeserializer;\n\n    /**\n     * If the Map is to be instantiated using non-default constructor\n     * or factory method\n     * that takes one or more named properties as argument(s),\n     * this creator is used for instantiation.\n     */\n    protected PropertyBasedCreator _propertyBasedCreator;    \n\n    // // Any properties to ignore if seen?\n    \n    protected HashSet<String> _ignorableProperties;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator,\n            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser)\n    {\n        super(mapType);\n        _mapType = mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = valueInstantiator;\n        _hasDefaultCreator = valueInstantiator.canCreateUsingDefault();\n        _delegateDeserializer = null;\n        _propertyBasedCreator = null;\n        _standardStringKey = _isStdKeyDeser(mapType, keyDeser);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write styling copying of settings of an existing instance.\n     */\n    protected MapDeserializer(MapDeserializer src)\n    {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = src._keyDeserializer;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        // should we make a copy here?\n        _ignorableProperties = src._ignorableProperties;\n\n        _standardStringKey = src._standardStringKey;\n    }\n\n    protected MapDeserializer(MapDeserializer src,\n            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser,\n            HashSet<String> ignorable)\n    {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        _ignorableProperties = ignorable;\n\n        _standardStringKey = _isStdKeyDeser(_mapType, keyDeser);\n    }\n\n    /**\n     * Fluent factory method used to create a copy with slightly\n     * different settings. When sub-classing, MUST be overridden.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected MapDeserializer withResolved(KeyDeserializer keyDeser,\n            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser,\n            HashSet<String> ignorable)\n    {\n        \n        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n            return this;\n        }\n        return new MapDeserializer(this,\n                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable);\n    }\n\n    /**\n     * Helper method used to check whether we can just use the default key\n     * deserialization, where JSON String becomes Java String.\n     */\n    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)\n    {\n        if (keyDeser == null) {\n            return true;\n        }\n        JavaType keyType = mapType.getKeyType();\n        if (keyType == null) { // assumed to be Object\n            return true;\n        }\n        Class<?> rawKeyType = keyType.getRawClass();\n        return ((rawKeyType == String.class || rawKeyType == Object.class)\n                && isDefaultKeyDeserializer(keyDeser));\n    }\n\n    public void setIgnorableProperties(String[] ignorable) {\n        _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n            null : ArrayBuilders.arrayToSet(ignorable);\n    }\n\n    /*\n    /**********************************************************\n    /* Validation, post-processing (ResolvableDeserializer)\n    /**********************************************************\n     */\n\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n    {\n        // May need to resolve types for delegate- and/or property-based creators:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            /* Theoretically should be able to get CreatorProperty for delegate\n             * parameter to pass; but things get tricky because DelegateCreator\n             * may contain injectable values. So, for now, let's pass nothing.\n             */\n            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n        }\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n    }\n\n    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed for.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        } else {\n            if (kd instanceof ContextualKeyDeserializer) {\n                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n            }\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        // #125: May have a content converter\n        vd = findConvertingContentDeserializer(ctxt, property, vd);\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            vd = ctxt.handleSecondaryContextualization(vd, property);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        HashSet<String> ignored = _ignorableProperties;\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null && property != null) {\n            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n            if (moreToIgnore != null) {\n                ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                for (String str : moreToIgnore) {\n                    ignored.add(str);\n                }\n            }\n        }\n        return withResolved(kd, vtd, vd, ignored);\n    }\n    \n    /*\n    /**********************************************************\n    /* ContainerDeserializerBase API\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n        return _mapType.getContentType();\n    }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializer API\n    /**********************************************************\n     */\n\n    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingCreator(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return (Map<Object,Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (!_hasDefaultCreator) {\n            throw ctxt.instantiationException(getMapClass(), \"No default constructor found\");\n        }\n        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            // [JACKSON-620] (empty) String may be ok however:\n            if (t == JsonToken.VALUE_STRING) {\n                return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n            }\n            throw ctxt.mappingException(getMapClass());\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        // Ok: must point to START_OBJECT or FIELD_NAME\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            throw ctxt.mappingException(getMapClass());\n        }\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException, JsonProcessingException\n    {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public accessors\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public final Class<?> getMapClass() { return (Class<Map<Object,Object>>) _mapType.getRawClass(); }\n\n    @Override public JavaType getValueType() { return _mapType; }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            Object key = keyDes.deserializeKey(fieldName, ctxt);\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try{\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                /* !!! 23-Dec-2008, tatu: should there be an option to verify\n                 *   that there are no duplicate field names? (and/or what\n                 *   to do, keep-first or keep-last)\n                 */\n                if (useObjectId) {\n                    referringAccumulator.put(key, value);\n                } else {\n                    result.put(key, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n\n    /**\n     * Optimized method used when keys can be deserialized as plain old\n     * {@link java.lang.String}s, and there is no custom deserialized\n     * specified.\n     */\n    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try {\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                if (useObjectId) {\n                    referringAccumulator.put(fieldName, value);\n                } else {\n                    result.put(fieldName, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n    \n    @SuppressWarnings(\"unchecked\") \n    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        // null -> no ObjectIdReader for Maps (yet?)\n        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null);\n\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            t = jp.nextToken(); // to get to value\n            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n                jp.skipChildren(); // and skip it (in case of array/object)\n                continue;\n            }\n            // creator property?\n            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n            if (prop != null) {\n                // Last property to set?\n                Object value = prop.deserialize(jp, ctxt);\n                if (buffer.assignParameter(prop.getCreatorIndex(), value)) {\n                    jp.nextToken();\n                    Map<Object,Object> result;\n                    try {\n                        result = (Map<Object,Object>)creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _mapType.getRawClass(), propName);\n                        return null;\n                    }\n                    _readAndBind(jp, ctxt, result);\n                    return result;\n                }\n                continue;\n            }\n            // other property? needs buffering\n            String fieldName = jp.getCurrentName();\n            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n            Object value; \n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, _mapType.getRawClass(), propName);\n                return null;\n            }\n            buffer.bufferMapProperty(key, value);\n        }\n        // end of JSON object?\n        // if so, can just construct and leave...\n        try {\n            return (Map<Object,Object>)creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapAndThrow(e, _mapType.getRawClass(), null);\n            return null;\n        }\n    }\n\n    @Deprecated // since 2.5\n    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n        wrapAndThrow(t, ref, null);\n    }\n    \n    // note: copied from BeanDeserializer; should try to share somehow...\n    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n    {\n        // to handle StackOverflow:\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // ... except for mapping exceptions\n        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n            throw (IOException) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, ref, key);\n    }\n\n    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n            Object key, UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        if (accumulator == null) {\n            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n        }\n        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n        reference.getRoid().appendReferring(referring);\n    }\n\n    private final static class MapReferringAccumulator {\n        private final Class<?> _valueType;\n        private Map<Object,Object> _result;\n        /**\n         * A list of {@link MapReferring} to maintain ordering.\n         */\n        private List<MapReferring> _accumulator = new ArrayList<MapReferring>();\n\n        public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n            _valueType = valueType;\n            _result = result;\n        }\n\n        public void put(Object key, Object value)\n        {\n            if (_accumulator.isEmpty()) {\n                _result.put(key, value);\n            } else {\n                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.put(key, value);\n            }\n        }\n\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n        {\n            MapReferring id = new MapReferring(this, reference, _valueType, key);\n            _accumulator.add(id);\n            return id;\n        }\n\n        public void resolveForwardReference(Object id, Object value) throws IOException\n        {\n            Iterator<MapReferring> iterator = _accumulator.iterator();\n            // Resolve ordering after resolution of an id. This means either:\n            // 1- adding to the result map in case of the first unresolved id.\n            // 2- merge the content of the resolved id with its previous unresolved id.\n            Map<Object,Object> previous = _result;\n            while (iterator.hasNext()) {\n                MapReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.put(ref.key, value);\n                    previous.putAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }\n    }\n\n    /**\n     * Helper class to maintain processing order of value. The resolved\n     * object associated with {@link #_id} comes before the values in\n     * {@link _next}.\n     */\n    private final static class MapReferring extends Referring {\n        private final MapReferringAccumulator _parent;\n\n        public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n        public final Object key;\n        \n        protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                Class<?> valueType, Object key)\n        {\n            super(ref, valueType);\n            _parent = parent;\n            this.key = key;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\n\n/**\n * Basic serializer that can take JSON \"Object\" structure and\n * construct a {@link java.util.Map} instance, with typed contents.\n *<p>\n * Note: for untyped content (one indicated by passing Object.class\n * as the type), {@link UntypedObjectDeserializer} is used instead.\n * It can also construct {@link java.util.Map}s, but not with specific\n * POJO types, only other containers and primitives/wrappers.\n */\n@JacksonStdImpl\npublic class MapDeserializer\n    extends ContainerDeserializerBase<Map<Object,Object>>\n    implements ContextualDeserializer, ResolvableDeserializer\n{\n    private static final long serialVersionUID = -3378654289961736240L;\n\n    // // Configuration: typing, deserializers\n\n    protected final JavaType _mapType;\n\n    /**\n     * Key deserializer to use; either passed via constructor\n     * (when indicated by annotations), or resolved when\n     * {@link #resolve} is called;\n     */\n    protected final KeyDeserializer _keyDeserializer;\n\n    /**\n     * Flag set to indicate that the key type is\n     * {@link java.lang.String} (or {@link java.lang.Object}, for\n     * which String is acceptable), <b>and</b> that the\n     * default Jackson key deserializer would be used.\n     * If both are true, can optimize handling.\n     */\n    protected boolean _standardStringKey;\n\n    /**\n     * Value deserializer.\n     */\n    protected final JsonDeserializer<Object> _valueDeserializer;\n\n    /**\n     * If value instances have polymorphic type information, this\n     * is the type deserializer that can handle it\n     */\n    protected final TypeDeserializer _valueTypeDeserializer;\n    \n    // // Instance construction settings:\n\n    protected final ValueInstantiator _valueInstantiator;\n\n    protected final boolean _hasDefaultCreator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _delegateDeserializer;\n\n    /**\n     * If the Map is to be instantiated using non-default constructor\n     * or factory method\n     * that takes one or more named properties as argument(s),\n     * this creator is used for instantiation.\n     */\n    protected PropertyBasedCreator _propertyBasedCreator;    \n\n    // // Any properties to ignore if seen?\n    \n    protected HashSet<String> _ignorableProperties;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator,\n            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser)\n    {\n        super(mapType);\n        _mapType = mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = valueInstantiator;\n        _hasDefaultCreator = valueInstantiator.canCreateUsingDefault();\n        _delegateDeserializer = null;\n        _propertyBasedCreator = null;\n        _standardStringKey = _isStdKeyDeser(mapType, keyDeser);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write styling copying of settings of an existing instance.\n     */\n    protected MapDeserializer(MapDeserializer src)\n    {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = src._keyDeserializer;\n        _valueDeserializer = src._valueDeserializer;\n        _valueTypeDeserializer = src._valueTypeDeserializer;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        // should we make a copy here?\n        _ignorableProperties = src._ignorableProperties;\n\n        _standardStringKey = src._standardStringKey;\n    }\n\n    protected MapDeserializer(MapDeserializer src,\n            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser,\n            HashSet<String> ignorable)\n    {\n        super(src._mapType);\n        _mapType = src._mapType;\n        _keyDeserializer = keyDeser;\n        _valueDeserializer = valueDeser;\n        _valueTypeDeserializer = valueTypeDeser;\n        _valueInstantiator = src._valueInstantiator;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _hasDefaultCreator = src._hasDefaultCreator;\n        _ignorableProperties = ignorable;\n\n        _standardStringKey = _isStdKeyDeser(_mapType, keyDeser);\n    }\n\n    /**\n     * Fluent factory method used to create a copy with slightly\n     * different settings. When sub-classing, MUST be overridden.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected MapDeserializer withResolved(KeyDeserializer keyDeser,\n            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser,\n            HashSet<String> ignorable)\n    {\n        \n        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n            return this;\n        }\n        return new MapDeserializer(this,\n                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable);\n    }\n\n    /**\n     * Helper method used to check whether we can just use the default key\n     * deserialization, where JSON String becomes Java String.\n     */\n    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)\n    {\n        if (keyDeser == null) {\n            return true;\n        }\n        JavaType keyType = mapType.getKeyType();\n        if (keyType == null) { // assumed to be Object\n            return true;\n        }\n        Class<?> rawKeyType = keyType.getRawClass();\n        return ((rawKeyType == String.class || rawKeyType == Object.class)\n                && isDefaultKeyDeserializer(keyDeser));\n    }\n\n    public void setIgnorableProperties(String[] ignorable) {\n        _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n            null : ArrayBuilders.arrayToSet(ignorable);\n    }\n\n    /*\n    /**********************************************************\n    /* Validation, post-processing (ResolvableDeserializer)\n    /**********************************************************\n     */\n\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n    {\n        // May need to resolve types for delegate- and/or property-based creators:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            /* Theoretically should be able to get CreatorProperty for delegate\n             * parameter to pass; but things get tricky because DelegateCreator\n             * may contain injectable values. So, for now, let's pass nothing.\n             */\n            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n        }\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n    }\n\n    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed for.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        } else {\n            if (kd instanceof ContextualKeyDeserializer) {\n                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n            }\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        // #125: May have a content converter\n        vd = findConvertingContentDeserializer(ctxt, property, vd);\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            vd = ctxt.handleSecondaryContextualization(vd, property);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        HashSet<String> ignored = _ignorableProperties;\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null && property != null) {\n            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n            if (moreToIgnore != null) {\n                ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                for (String str : moreToIgnore) {\n                    ignored.add(str);\n                }\n            }\n        }\n        return withResolved(kd, vtd, vd, ignored);\n    }\n    \n    /*\n    /**********************************************************\n    /* ContainerDeserializerBase API\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n        return _mapType.getContentType();\n    }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializer API\n    /**********************************************************\n     */\n\n    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueDeserializer == null)\n                && (_keyDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingCreator(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return (Map<Object,Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (!_hasDefaultCreator) {\n            throw ctxt.instantiationException(getMapClass(), \"No default constructor found\");\n        }\n        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            // [JACKSON-620] (empty) String may be ok however:\n            if (t == JsonToken.VALUE_STRING) {\n                return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n            }\n            throw ctxt.mappingException(getMapClass());\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        // Ok: must point to START_OBJECT or FIELD_NAME\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            throw ctxt.mappingException(getMapClass());\n        }\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException, JsonProcessingException\n    {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public accessors\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public final Class<?> getMapClass() { return (Class<Map<Object,Object>>) _mapType.getRawClass(); }\n\n    @Override public JavaType getValueType() { return _mapType; }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            Object key = keyDes.deserializeKey(fieldName, ctxt);\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try{\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                /* !!! 23-Dec-2008, tatu: should there be an option to verify\n                 *   that there are no duplicate field names? (and/or what\n                 *   to do, keep-first or keep-last)\n                 */\n                if (useObjectId) {\n                    referringAccumulator.put(key, value);\n                } else {\n                    result.put(key, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n\n    /**\n     * Optimized method used when keys can be deserialized as plain old\n     * {@link java.lang.String}s, and there is no custom deserialized\n     * specified.\n     */\n    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try {\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                if (useObjectId) {\n                    referringAccumulator.put(fieldName, value);\n                } else {\n                    result.put(fieldName, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }\n    \n    @SuppressWarnings(\"unchecked\") \n    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        // null -> no ObjectIdReader for Maps (yet?)\n        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null);\n\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            t = jp.nextToken(); // to get to value\n            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n                jp.skipChildren(); // and skip it (in case of array/object)\n                continue;\n            }\n            // creator property?\n            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n            if (prop != null) {\n                // Last property to set?\n                Object value = prop.deserialize(jp, ctxt);\n                if (buffer.assignParameter(prop.getCreatorIndex(), value)) {\n                    jp.nextToken();\n                    Map<Object,Object> result;\n                    try {\n                        result = (Map<Object,Object>)creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _mapType.getRawClass(), propName);\n                        return null;\n                    }\n                    _readAndBind(jp, ctxt, result);\n                    return result;\n                }\n                continue;\n            }\n            // other property? needs buffering\n            String fieldName = jp.getCurrentName();\n            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n            Object value; \n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, _mapType.getRawClass(), propName);\n                return null;\n            }\n            buffer.bufferMapProperty(key, value);\n        }\n        // end of JSON object?\n        // if so, can just construct and leave...\n        try {\n            return (Map<Object,Object>)creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapAndThrow(e, _mapType.getRawClass(), null);\n            return null;\n        }\n    }\n\n    @Deprecated // since 2.5\n    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n        wrapAndThrow(t, ref, null);\n    }\n    \n    // note: copied from BeanDeserializer; should try to share somehow...\n    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n    {\n        // to handle StackOverflow:\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // ... except for mapping exceptions\n        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n            throw (IOException) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, ref, key);\n    }\n\n    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n            Object key, UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        if (accumulator == null) {\n            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n        }\n        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n        reference.getRoid().appendReferring(referring);\n    }\n\n    private final static class MapReferringAccumulator {\n        private final Class<?> _valueType;\n        private Map<Object,Object> _result;\n        /**\n         * A list of {@link MapReferring} to maintain ordering.\n         */\n        private List<MapReferring> _accumulator = new ArrayList<MapReferring>();\n\n        public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n            _valueType = valueType;\n            _result = result;\n        }\n\n        public void put(Object key, Object value)\n        {\n            if (_accumulator.isEmpty()) {\n                _result.put(key, value);\n            } else {\n                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.put(key, value);\n            }\n        }\n\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n        {\n            MapReferring id = new MapReferring(this, reference, _valueType, key);\n            _accumulator.add(id);\n            return id;\n        }\n\n        public void resolveForwardReference(Object id, Object value) throws IOException\n        {\n            Iterator<MapReferring> iterator = _accumulator.iterator();\n            // Resolve ordering after resolution of an id. This means either:\n            // 1- adding to the result map in case of the first unresolved id.\n            // 2- merge the content of the resolved id with its previous unresolved id.\n            Map<Object,Object> previous = _result;\n            while (iterator.hasNext()) {\n                MapReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.put(ref.key, value);\n                    previous.putAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }\n    }\n\n    /**\n     * Helper class to maintain processing order of value. The resolved\n     * object associated with {@link #_id} comes before the values in\n     * {@link _next}.\n     */\n    private final static class MapReferring extends Referring {\n        private final MapReferringAccumulator _parent;\n\n        public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n        public final Object key;\n        \n        protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                Class<?> valueType, Object key)\n        {\n            super(ref, valueType);\n            _parent = parent;\n            this.key = key;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 13, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.DefaultDeserializationContext", "buggy_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\nimport com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Complete {@link DeserializationContext} implementation that adds\n * extended API for {@link ObjectMapper} (and {@link ObjectReader})\n * to call, as well as implements certain parts that base class\n * has left abstract.\n * The remaining abstract methods ({@link #createInstance}, {@link #with})\n * are left so that custom implementations will properly implement them\n * to return intended subtype.\n */\npublic abstract class DefaultDeserializationContext\n    extends DeserializationContext\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    protected transient LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds;\n\n    private List<ObjectIdResolver> _objectIdResolvers;\n\n    /**\n     * Constructor that will pass specified deserializer factory and\n     * cache: cache may be null (in which case default implementation\n     * will be used), factory can not be null\n     */\n    protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache) {\n        super(df, cache);\n    }\n    \n    protected DefaultDeserializationContext(DefaultDeserializationContext src,\n            DeserializationConfig config, JsonParser jp, InjectableValues values) {\n        super(src, config, jp, values);\n    }\n\n    protected DefaultDeserializationContext(DefaultDeserializationContext src,\n            DeserializerFactory factory) {\n        super(src, factory);\n    }\n\n    /**\n     * @since 2.4.4\n     */\n    protected DefaultDeserializationContext(DefaultDeserializationContext src) {\n        super(src);\n    }\n    \n    /**\n     * Method needed to ensure that {@link ObjectMapper#copy} will work\n     * properly; specifically, that caches are cleared, but settings\n     * will otherwise remain identical; and that no sharing of state\n     * occurs.\n     * \n     * @since 2.4.4\n     */\n    public DefaultDeserializationContext copy() {\n        throw new IllegalStateException(\"DefaultDeserializationContext sub-class not overriding copy()\");\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract methods impls, Object Id\n    /**********************************************************\n     */\n\n    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n    {\n        /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how\n         *   missing id already works.\n         */\n\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n\n        if (_objectIds == null) {\n            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n        } else {\n            ReadableObjectId entry = _objectIds.get(key);\n            if (entry != null) {\n                return entry;\n            }\n        }\n\n        // Not seen yet, must create entry and configure resolver.\n        ObjectIdResolver resolver = null;\n\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        } else {\n            for (ObjectIdResolver res : _objectIdResolvers) {\n                if (res.canUseFor(resolverType)) {\n                    resolver = res;\n                    break;\n                }\n            }\n        }\n\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n            //   needed to clear state between calls.\n            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            /*\n            if (resolverType.getClass() == SimpleObjectIdResolver.class) {\n                resolver = new SimpleObjectIdResolver();\n            }\n            */\n            _objectIdResolvers.add(resolver);\n        }\n\n        ReadableObjectId entry = new ReadableObjectId(key);\n        entry.setResolver(resolver);\n        _objectIds.put(key, entry);\n        return entry;\n    }\n    \n    @Deprecated // since 2.4\n    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen) {\n        return findObjectId(id, gen, new SimpleObjectIdResolver());\n    }\n\n    @Override\n    public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n    {\n        if (_objectIds == null) {\n            return;\n        }\n        // 29-Dec-2014, tatu: As per [databind#299], may also just let unresolved refs be...\n        if (!isEnabled(DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS)) {\n            return;\n        }\n        UnresolvedForwardReference exception = null;\n        for (Entry<IdKey,ReadableObjectId> entry : _objectIds.entrySet()) {\n            ReadableObjectId roid = entry.getValue();\n            if (roid.hasReferringProperties()) {\n                if (exception == null) {\n                    exception = new UnresolvedForwardReference(\"Unresolved forward references for: \");\n                }\n                for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext(); ) {\n                    Referring referring = iterator.next();\n                    exception.addUnresolvedId(roid.getKey().key, referring.getBeanType(), referring.getLocation());\n                }\n            }\n        }\n        if (exception != null) {\n            throw exception;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract methods impls, other factory methods\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public JsonDeserializer<Object> deserializerInstance(Annotated ann, Object deserDef)\n        throws JsonMappingException\n    {\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<?> deser;\n        \n        if (deserDef instanceof JsonDeserializer) {\n            deser = (JsonDeserializer<?>) deserDef;\n        } else {\n            /* Alas, there's no way to force return type of \"either class\n             * X or Y\" -- need to throw an exception after the fact\n             */\n            if (!(deserDef instanceof Class)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n            }\n            Class<?> deserClass = (Class<?>)deserDef;\n            // there are some known \"no class\" markers to consider too:\n            if (deserClass == JsonDeserializer.None.class || ClassUtil.isBogusClass(deserClass)) {\n                return null;\n            }\n            if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n            }\n            HandlerInstantiator hi = _config.getHandlerInstantiator();\n            deser = (hi == null) ? null : hi.deserializerInstance(_config, ann, deserClass);\n            if (deser == null) {\n                deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n                        _config.canOverrideAccessModifiers());\n            }\n        }\n        // First: need to resolve\n        if (deser instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) deser).resolve(this);\n        }\n        return (JsonDeserializer<Object>) deser;\n    }\n\n    @Override\n    public final KeyDeserializer keyDeserializerInstance(Annotated ann, Object deserDef)\n        throws JsonMappingException\n    {\n        if (deserDef == null) {\n            return null;\n        }\n\n        KeyDeserializer deser;\n        \n        if (deserDef instanceof KeyDeserializer) {\n            deser = (KeyDeserializer) deserDef;\n        } else {\n            if (!(deserDef instanceof Class)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                        +deserDef.getClass().getName()\n                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n            }\n            Class<?> deserClass = (Class<?>)deserDef;\n            // there are some known \"no class\" markers to consider too:\n            if (deserClass == KeyDeserializer.None.class || ClassUtil.isBogusClass(deserClass)) {\n                return null;\n            }\n            if (!KeyDeserializer.class.isAssignableFrom(deserClass)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()\n                        +\"; expected Class<KeyDeserializer>\");\n            }\n            HandlerInstantiator hi = _config.getHandlerInstantiator();\n            deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, ann, deserClass);\n            if (deser == null) {\n                deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n                        _config.canOverrideAccessModifiers());\n            }\n        }\n        // First: need to resolve\n        if (deser instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) deser).resolve(this);\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method used for constructing a blueprint instance\n     * with different factory\n     */\n    public abstract DefaultDeserializationContext with(DeserializerFactory factory);\n    \n    /**\n     * Method called to create actual usable per-deserialization\n     * context instance.\n     */\n    public abstract DefaultDeserializationContext createInstance(\n            DeserializationConfig config, JsonParser jp, InjectableValues values);\n    \n    /*\n    /**********************************************************\n    /* And then the concrete implementation class\n    /**********************************************************\n     */\n\n    /**\n     * Actual full concrete implementation\n     */\n    public final static class Impl extends DefaultDeserializationContext\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Default constructor for a blueprint object, which will use the standard\n         * {@link DeserializerCache}, given factory.\n         */\n        public Impl(DeserializerFactory df) {\n            super(df, null);\n        }\n\n        protected Impl(Impl src,\n                DeserializationConfig config, JsonParser jp, InjectableValues values) {\n            super(src, config, jp, values);\n        }\n\n        protected Impl(Impl src) { super(src); }\n        \n        protected Impl(Impl src, DeserializerFactory factory) {\n            super(src, factory);\n        }\n\n        @Override\n        public DefaultDeserializationContext copy() {\n            if (getClass() != Impl.class) {\n                return super.copy();\n            }\n           return new Impl(this);\n        }\n        \n        @Override\n        public DefaultDeserializationContext createInstance(DeserializationConfig config,\n                JsonParser jp, InjectableValues values) {\n            return new Impl(this, config, jp, values);\n        }\n\n        @Override\n        public DefaultDeserializationContext with(DeserializerFactory factory) {\n            return new Impl(this, factory);\n        }        \n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\nimport com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Complete {@link DeserializationContext} implementation that adds\n * extended API for {@link ObjectMapper} (and {@link ObjectReader})\n * to call, as well as implements certain parts that base class\n * has left abstract.\n * The remaining abstract methods ({@link #createInstance}, {@link #with})\n * are left so that custom implementations will properly implement them\n * to return intended subtype.\n */\npublic abstract class DefaultDeserializationContext\n    extends DeserializationContext\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    protected transient LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds;\n\n    private List<ObjectIdResolver> _objectIdResolvers;\n\n    /**\n     * Constructor that will pass specified deserializer factory and\n     * cache: cache may be null (in which case default implementation\n     * will be used), factory can not be null\n     */\n    protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache) {\n        super(df, cache);\n    }\n    \n    protected DefaultDeserializationContext(DefaultDeserializationContext src,\n            DeserializationConfig config, JsonParser jp, InjectableValues values) {\n        super(src, config, jp, values);\n    }\n\n    protected DefaultDeserializationContext(DefaultDeserializationContext src,\n            DeserializerFactory factory) {\n        super(src, factory);\n    }\n\n    /**\n     * @since 2.4.4\n     */\n    protected DefaultDeserializationContext(DefaultDeserializationContext src) {\n        super(src);\n    }\n    \n    /**\n     * Method needed to ensure that {@link ObjectMapper#copy} will work\n     * properly; specifically, that caches are cleared, but settings\n     * will otherwise remain identical; and that no sharing of state\n     * occurs.\n     * \n     * @since 2.4.4\n     */\n    public DefaultDeserializationContext copy() {\n        throw new IllegalStateException(\"DefaultDeserializationContext sub-class not overriding copy()\");\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract methods impls, Object Id\n    /**********************************************************\n     */\n\n    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n    {\n        /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how\n         *   missing id already works.\n         */\n        if (id == null) {\n            return null;\n        }\n\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n\n        if (_objectIds == null) {\n            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n        } else {\n            ReadableObjectId entry = _objectIds.get(key);\n            if (entry != null) {\n                return entry;\n            }\n        }\n\n        // Not seen yet, must create entry and configure resolver.\n        ObjectIdResolver resolver = null;\n\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        } else {\n            for (ObjectIdResolver res : _objectIdResolvers) {\n                if (res.canUseFor(resolverType)) {\n                    resolver = res;\n                    break;\n                }\n            }\n        }\n\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n            //   needed to clear state between calls.\n            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            /*\n            if (resolverType.getClass() == SimpleObjectIdResolver.class) {\n                resolver = new SimpleObjectIdResolver();\n            }\n            */\n            _objectIdResolvers.add(resolver);\n        }\n\n        ReadableObjectId entry = new ReadableObjectId(key);\n        entry.setResolver(resolver);\n        _objectIds.put(key, entry);\n        return entry;\n    }\n    \n    @Deprecated // since 2.4\n    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen) {\n        return findObjectId(id, gen, new SimpleObjectIdResolver());\n    }\n\n    @Override\n    public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n    {\n        if (_objectIds == null) {\n            return;\n        }\n        // 29-Dec-2014, tatu: As per [databind#299], may also just let unresolved refs be...\n        if (!isEnabled(DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS)) {\n            return;\n        }\n        UnresolvedForwardReference exception = null;\n        for (Entry<IdKey,ReadableObjectId> entry : _objectIds.entrySet()) {\n            ReadableObjectId roid = entry.getValue();\n            if (roid.hasReferringProperties()) {\n                if (exception == null) {\n                    exception = new UnresolvedForwardReference(\"Unresolved forward references for: \");\n                }\n                for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext(); ) {\n                    Referring referring = iterator.next();\n                    exception.addUnresolvedId(roid.getKey().key, referring.getBeanType(), referring.getLocation());\n                }\n            }\n        }\n        if (exception != null) {\n            throw exception;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract methods impls, other factory methods\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public JsonDeserializer<Object> deserializerInstance(Annotated ann, Object deserDef)\n        throws JsonMappingException\n    {\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<?> deser;\n        \n        if (deserDef instanceof JsonDeserializer) {\n            deser = (JsonDeserializer<?>) deserDef;\n        } else {\n            /* Alas, there's no way to force return type of \"either class\n             * X or Y\" -- need to throw an exception after the fact\n             */\n            if (!(deserDef instanceof Class)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n            }\n            Class<?> deserClass = (Class<?>)deserDef;\n            // there are some known \"no class\" markers to consider too:\n            if (deserClass == JsonDeserializer.None.class || ClassUtil.isBogusClass(deserClass)) {\n                return null;\n            }\n            if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n            }\n            HandlerInstantiator hi = _config.getHandlerInstantiator();\n            deser = (hi == null) ? null : hi.deserializerInstance(_config, ann, deserClass);\n            if (deser == null) {\n                deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n                        _config.canOverrideAccessModifiers());\n            }\n        }\n        // First: need to resolve\n        if (deser instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) deser).resolve(this);\n        }\n        return (JsonDeserializer<Object>) deser;\n    }\n\n    @Override\n    public final KeyDeserializer keyDeserializerInstance(Annotated ann, Object deserDef)\n        throws JsonMappingException\n    {\n        if (deserDef == null) {\n            return null;\n        }\n\n        KeyDeserializer deser;\n        \n        if (deserDef instanceof KeyDeserializer) {\n            deser = (KeyDeserializer) deserDef;\n        } else {\n            if (!(deserDef instanceof Class)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                        +deserDef.getClass().getName()\n                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n            }\n            Class<?> deserClass = (Class<?>)deserDef;\n            // there are some known \"no class\" markers to consider too:\n            if (deserClass == KeyDeserializer.None.class || ClassUtil.isBogusClass(deserClass)) {\n                return null;\n            }\n            if (!KeyDeserializer.class.isAssignableFrom(deserClass)) {\n                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()\n                        +\"; expected Class<KeyDeserializer>\");\n            }\n            HandlerInstantiator hi = _config.getHandlerInstantiator();\n            deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, ann, deserClass);\n            if (deser == null) {\n                deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n                        _config.canOverrideAccessModifiers());\n            }\n        }\n        // First: need to resolve\n        if (deser instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) deser).resolve(this);\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method used for constructing a blueprint instance\n     * with different factory\n     */\n    public abstract DefaultDeserializationContext with(DeserializerFactory factory);\n    \n    /**\n     * Method called to create actual usable per-deserialization\n     * context instance.\n     */\n    public abstract DefaultDeserializationContext createInstance(\n            DeserializationConfig config, JsonParser jp, InjectableValues values);\n    \n    /*\n    /**********************************************************\n    /* And then the concrete implementation class\n    /**********************************************************\n     */\n\n    /**\n     * Actual full concrete implementation\n     */\n    public final static class Impl extends DefaultDeserializationContext\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Default constructor for a blueprint object, which will use the standard\n         * {@link DeserializerCache}, given factory.\n         */\n        public Impl(DeserializerFactory df) {\n            super(df, null);\n        }\n\n        protected Impl(Impl src,\n                DeserializationConfig config, JsonParser jp, InjectableValues values) {\n            super(src, config, jp, values);\n        }\n\n        protected Impl(Impl src) { super(src); }\n        \n        protected Impl(Impl src, DeserializerFactory factory) {\n            super(src, factory);\n        }\n\n        @Override\n        public DefaultDeserializationContext copy() {\n            if (getClass() != Impl.class) {\n                return super.copy();\n            }\n           return new Impl(this);\n        }\n        \n        @Override\n        public DefaultDeserializationContext createInstance(DeserializationConfig config,\n                JsonParser jp, InjectableValues values) {\n            return new Impl(this, config, jp, values);\n        }\n\n        @Override\n        public DefaultDeserializationContext with(DeserializerFactory factory) {\n            return new Impl(this, factory);\n        }        \n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty", "buggy_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n\n/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final ObjectIdReader _objectIdReader;\n\n    public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n            PropertyMetadata metadata)\n    {\n        super(objectIdReader.propertyName, objectIdReader.getIdType(), metadata,\n                objectIdReader.getDeserializer());\n        _objectIdReader = objectIdReader;\n    }\n\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, JsonDeserializer<?> deser)\n    {\n        super(src, deser);\n        _objectIdReader = src._objectIdReader;\n    }\n\n    @Deprecated // since 2.3\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, PropertyName newName) {\n        super(src, newName);\n        _objectIdReader = src._objectIdReader;\n    }\n    \n    @Deprecated // since 2.3\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, String newName) {\n        this(src, new PropertyName(newName));\n    }\n\n    @Override\n    public ObjectIdValueProperty withName(PropertyName newName) {\n        return new ObjectIdValueProperty(this, newName);\n    }\n\n    @Override\n    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        return new ObjectIdValueProperty(this, deser);\n    }\n    \n    // // // BeanProperty impl\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return null;\n    }\n\n    @Override public AnnotatedMember getMember() {  return null; }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods\n    /**********************************************************\n     */\n\n    @Override\n    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n            Object instance) throws IOException\n    {\n        deserializeSetAndReturn(jp, ctxt, instance);\n    }\n\n    @Override\n    public Object deserializeSetAndReturn(JsonParser jp,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        Object id = _valueDeserializer.deserialize(jp, ctxt);\n\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        \n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }\n\n    @Override\n    public void set(Object instance, Object value) throws IOException {\n        setAndReturn(instance, value);\n    }\n\n    @Override\n    public Object setAndReturn(Object instance, Object value) throws IOException\n    {\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp == null) {\n            throw new UnsupportedOperationException(\n                    \"Should not call set() on ObjectIdProperty that has no SettableBeanProperty\");\n        }\n        return idProp.setAndReturn(instance, value);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n\n/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final ObjectIdReader _objectIdReader;\n\n    public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n            PropertyMetadata metadata)\n    {\n        super(objectIdReader.propertyName, objectIdReader.getIdType(), metadata,\n                objectIdReader.getDeserializer());\n        _objectIdReader = objectIdReader;\n    }\n\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, JsonDeserializer<?> deser)\n    {\n        super(src, deser);\n        _objectIdReader = src._objectIdReader;\n    }\n\n    @Deprecated // since 2.3\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, PropertyName newName) {\n        super(src, newName);\n        _objectIdReader = src._objectIdReader;\n    }\n    \n    @Deprecated // since 2.3\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, String newName) {\n        this(src, new PropertyName(newName));\n    }\n\n    @Override\n    public ObjectIdValueProperty withName(PropertyName newName) {\n        return new ObjectIdValueProperty(this, newName);\n    }\n\n    @Override\n    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        return new ObjectIdValueProperty(this, deser);\n    }\n    \n    // // // BeanProperty impl\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return null;\n    }\n\n    @Override public AnnotatedMember getMember() {  return null; }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods\n    /**********************************************************\n     */\n\n    @Override\n    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n            Object instance) throws IOException\n    {\n        deserializeSetAndReturn(jp, ctxt, instance);\n    }\n\n    @Override\n    public Object deserializeSetAndReturn(JsonParser jp,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        Object id = _valueDeserializer.deserialize(jp, ctxt);\n\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        if (id == null) {\n            return null;\n        }\n        \n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }\n\n    @Override\n    public void set(Object instance, Object value) throws IOException {\n        setAndReturn(instance, value);\n    }\n\n    @Override\n    public Object setAndReturn(Object instance, Object value) throws IOException\n    {\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp == null) {\n            throw new UnsupportedOperationException(\n                    \"Should not call set() on ObjectIdProperty that has no SettableBeanProperty\");\n        }\n        return idProp.setAndReturn(instance, value);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 14, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ObjectReader", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.DataFormatReaders;\nimport com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.NullNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.type.SimpleType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"fluent\" (or, kind of, builder) pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    /*\n    /**********************************************************\n    /* Immutable configuration from ObjectMapper\n    /**********************************************************\n     */\n\n    /**\n     * General serialization configuration settings; while immutable,\n     * can use copy-constructor to create modified instances as necessary.\n     */\n    protected final DeserializationConfig _config;\n\n    /**\n     * Blueprint instance of deserialization context; used for creating\n     * actual instance when needed.\n     */\n    protected final DefaultDeserializationContext _context;\n\n    /**\n     * Factory used for constructing {@link JsonGenerator}s\n     */\n    protected final JsonFactory _parserFactory;\n\n    /**\n     * Flag that indicates whether root values are expected to be unwrapped or not\n     */\n    protected final boolean _unwrapRoot;\n\n    /*\n    /**********************************************************\n    /* Configuration that can be changed during building\n    /**********************************************************\n     */\n\n    /**\n     * Declared type of value to instantiate during deserialization.\n     * Defines which deserializer to use; as well as base type of instance\n     * to construct if an updatable value is not configured to be used\n     * (subject to changes by embedded type information, for polymorphic\n     * types). If {@link #_valueToUpdate} is non-null, only used for\n     * locating deserializer.\n     */\n    protected final JavaType _valueType;\n\n    /**\n     * We may pre-fetch deserializer as soon as {@link #_valueType}\n     * is known, and if so, reuse it afterwards.\n     * This allows avoiding further deserializer lookups and increases\n     * performance a bit on cases where readers are reused.\n     * \n     * @since 2.1\n     */\n    protected final JsonDeserializer<Object> _rootDeserializer;\n    \n    /**\n     * Instance to update with data binding; if any. If null,\n     * a new instance is created, if non-null, properties of\n     * this value object will be updated instead.\n     * Note that value can be of almost any type, except not\n     * {@link com.fasterxml.jackson.databind.type.ArrayType}; array\n     * types can not be modified because array size is immutable.\n     */\n    protected final Object _valueToUpdate;\n\n    /**\n     * When using data format that uses a schema, schema is passed\n     * to parser.\n     */\n    protected final FormatSchema _schema;\n\n    /**\n     * Values that can be injected during deserialization, if any.\n     */\n    protected final InjectableValues _injectableValues;\n\n    /**\n     * Optional detector used for auto-detecting data format that byte-based\n     * input uses.\n     *<p>\n     * NOTE: If defined non-null, <code>readValue()</code> methods that take\n     * {@link Reader} or {@link String} input <b>will fail with exception</b>,\n     * because format-detection only works on byte-sources. Also, if format\n     * can not be detect reliably (as per detector settings),\n     * a {@link JsonParseException} will be thrown).\n     * \n     * @since 2.1\n     */\n    protected final DataFormatReaders _dataFormatReaders;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * Root-level cached deserializers.\n     * Passed by {@link ObjectMapper}, shared with it.\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n\n    /**\n     * Cache for root names used when root-wrapping is enabled.\n     * Passed by {@link ObjectMapper}, shared with it.\n     */\n    protected final RootNameLookup _rootNames;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle, construction\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link ObjectMapper} for initial instantiation\n     */\n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }\n\n    /**\n     * Constructor called when a root deserializer should be fetched based\n     * on other configuration.\n     */\n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,\n            JavaType valueType, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues)\n    {\n        _config = config;\n        _context = mapper._deserializationContext;\n        _rootDeserializers = mapper._rootDeserializers;\n        _parserFactory = mapper._jsonFactory;\n        _rootNames = mapper._rootNames;\n        _valueType = valueType;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n\n        _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n        _dataFormatReaders = null;        \n    }\n    \n    /**\n     * Copy constructor used for building variations.\n     */\n    protected ObjectReader(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders)\n    {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = valueType;\n        _rootDeserializer = rootDeser;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = dataFormatReaders;\n    }\n\n    /**\n     * Copy constructor used when modifying simple feature flags\n     */\n    protected ObjectReader(ObjectReader base, DeserializationConfig config)\n    {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f)\n    {\n        // may need to override ordering, based on data format capabilities\n        _config = base._config\n            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = f;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override, used for constructing\n    /* reader instances, (re)configuring parser instances\n    /* Added in 2.5\n    /**********************************************************\n     */\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n        return new ObjectReader(base, config);\n    }\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }\n\n    /**\n     * Factory method used to create {@link MappingIterator} instances;\n     * either default, or custom subtype.\n     * \n     * @since 2.5\n     */\n    protected <T> MappingIterator<T> _newIterator(JavaType valueType,\n            JsonParser parser, DeserializationContext ctxt,\n            JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)\n    {\n            return new MappingIterator<T>(valueType, parser, ctxt,\n                    deser, parserManaged, valueToUpdate);\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes may choose to override, if customized\n    /* initialization is needed.\n    /**********************************************************\n     */\n\n    /**\n     * NOTE: changed from static to non-static in 2.5; unfortunate but\n     * necessary change to support overridability\n     */\n    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) { // and then we must get something...\n            t = p.nextToken();\n            if (t == null) {\n                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    /**\n     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n     * of multiple values means that we may or may not want to advance the stream,\n     * but need to do other initialization.\n     *<p>\n     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n     * \n     * @since 2.5\n     */\n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for DeserializationFeatures\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     */\n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader with(DeserializationFeature first,\n            DeserializationFeature... other)\n    {\n        return _with(_config.with(first, other));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     */\n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader without(DeserializationFeature first,\n            DeserializationFeature... other) {\n        return _with(_config.without(first, other));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    \n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for JsonParser.Features\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     */\n    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     */\n    public ObjectReader without(JsonParser.Feature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods, other\n    /**********************************************************\n     */\n\n    public ObjectReader with(DeserializationConfig config) {\n        return _with(config);\n    }    \n\n    /**\n     * Method for constructing a new instance with configuration that uses\n     * passed {@link InjectableValues} to provide injectable values.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(InjectableValues injectableValues)\n    {\n        if (_injectableValues == injectableValues) {\n            return this;\n        }\n        return _new(this, _config,\n                _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, injectableValues, _dataFormatReaders);\n    }\n\n    /**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonNodeFactory} for constructing {@link JsonNode}\n     * instances.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(JsonNodeFactory f) {\n        return _with(_config.with(f));\n    }\n\n    /**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonFactory} for constructing underlying Readers.\n     *<p>\n     * NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>\n     * (that is, ones that return <code>false</code> for\n     * {@link JsonFactory#requiresCustomCodec()}) can be used: trying\n     * to use one that requires custom codec will throw exception\n     * \n     * @since 2.1\n     */\n    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        // Also, try re-linking, if possible...\n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }\n    \n    /**\n     * Method for constructing a new instance with configuration that\n     * specifies what root name to expect for \"root name unwrapping\".\n     * See {@link DeserializationConfig#withRootName(String)} for\n     * details.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n\n    /**\n     * Method for constructing a new instance with configuration that\n     * passes specified {@link FormatSchema} to {@link JsonParser} that\n     * is constructed for parsing content.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(FormatSchema schema)\n    {\n        if (_schema == schema) {\n            return this;\n        }\n        _verifySchemaType(schema);\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                schema, _injectableValues, _dataFormatReaders);\n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     * \n     * @since 2.5\n     */\n    public ObjectReader forType(JavaType valueType)\n    {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n        // type is stored here, no need to make a copy of config\n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     *\n     * @since 2.5\n     */\n    public ObjectReader forType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     *\n     * @since 2.5\n     */\n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }\n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n        return forType(_config.getTypeFactory().constructType(valueType));\n    }\n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    /**\n     * Method for constructing a new instance with configuration that\n     * updates passed Object (as root value), instead of constructing \n     * a new value.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withValueToUpdate(Object value)\n    {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        /* no real benefit from pre-fetching, as updating readers are much\n         * less likely to be reused, and value type may also be forced\n         * with a later chained call...\n         */\n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }\n\n    /**\n     * Method for constructing a new instance with configuration that\n     * uses specified View for filtering.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }\n\n    public ObjectReader with(Locale l) {\n        return _with(_config.with(l));\n    }\n\n    public ObjectReader with(TimeZone tz) {\n        return _with(_config.with(tz));\n    }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n        return _with(_config.with(defaultBase64));\n    }\n\n    /**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified list of\n     * {@link JsonFactory} instances, and default {@link DataFormatReaders} settings\n     * (for customized {@link DataFormatReaders}, you can construct instance yourself).\n     * to construct appropriate {@link JsonParser} for actual parsing.\n     *<p>\n     * Note: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     *<p>\n     * Note: not all {@link JsonFactory} types can be passed: specifically, ones that\n     * require \"custom codec\" (like XML factory) will not work. Instead, use\n     * method that takes {@link ObjectReader} instances instead of factories.\n     * \n     * @param readers Data formats accepted, in decreasing order of priority (that is,\n     *   matches checked in listed order, first match wins)\n     * \n     * @return Newly configured writer instance\n     * \n     * @since 2.1\n     */\n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }\n\n    /**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified\n     * {@link DataFormatReaders}.\n     *<p>\n     * NOTE: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     * \n     * @param readers DataFormatReaders to use for detecting underlying format.\n     * \n     * @return Newly configured writer instance\n     * \n     * @since 2.1\n     */\n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withAttributes(Map<Object,Object> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable factory methods may override\n    /**********************************************************\n     */\n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }\n    \n    /*\n    /**********************************************************\n    /* Simple accessors\n    /**********************************************************\n     */\n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(MapperFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _parserFactory.isEnabled(f);\n    }\n\n    /**\n     * @since 2.2\n     */\n    public DeserializationConfig getConfig() {\n        return _config;\n    }\n    \n    /**\n     * @since 2.1\n     */\n    @Override\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() {\n        return _parserFactory;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization methods; basic ones to support ObjectCodec first\n    /* (ones that take JsonParser)\n    /**********************************************************\n     */\n\n    /**\n     * Method that binds content read using given parser, using\n     * configuration of this reader, including expected result type.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        return (T) _bind(jp, _valueToUpdate);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return (T) withType(valueTypeRef).readValue(jp);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) withType((JavaType)valueType).readValue(jp);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueTypeRef).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException {\n        return withType(valueTypeRef).readValues(jp);\n    }\n    \n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)\n        throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    /*\n    /**********************************************************\n    /* TreeCodec impl\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n            throws IOException, JsonProcessingException\n    {\n        return (T) _bindAsTree(jp);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization methods; others similar to what ObjectMapper has\n    /**********************************************************\n     */\n    \n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    /**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src, offset, length), _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(in));\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(r));\n    }\n\n    /**\n     * Method that reads content from given JSON input String,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(json));\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods; reading sequence of values\n    /**********************************************************\n     */\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n        // false -> do not close as caller gave parser instance\n        return _newIterator(_valueType, jp, ctxt,\n                _findRootDeserializer(ctxt, _valueType),\n                false, _valueToUpdate);\n    }\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either wrapped or unwrapped root-level sequence:\n     * wrapped means that the elements are enclosed in JSON Array;\n     * and unwrapped that elements are directly accessed at main level.\n     * Assumption is that iff the first token of the document is\n     * <code>START_ARRAY</code>, we have a wrapped sequence; otherwise\n     * unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>\n     * is skipped, so that for both cases, underlying {@link JsonParser}\n     * will point to what is expected to be the first token of the first\n     * element.\n     *<p>\n     * Note that the wrapped vs unwrapped logic means that it is NOT\n     * possible to use this method for reading an unwrapped sequence\n     * of elements written as JSON Arrays: to read such sequences, one\n     * has to use {@link #readValues(JsonParser)}, making sure parser\n     * points to the first token of the first element (i.e. the second\n     * <code>START_ARRAY</code> which is part of the first element).\n     */\n    public <T> MappingIterator<T> readValues(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _parserFactory.createParser(src);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _parserFactory.createParser(json);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param src URL to read to access JSON content to parse.\n     */\n    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /*\n    /**********************************************************\n    /* Implementation of rest of ObjectCodec methods\n    /**********************************************************\n     */\n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n    {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, data-binding\n    /**********************************************************\n     */\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n    {\n        /* First: may need to read the next token, to initialize state (either\n         * before first read from parser, or after previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(jp, ctxt);\n                } else {\n                    deser.deserialize(jp, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                if (valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                } else {\n                    result = valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                } else {\n                    if (valueToUpdate == null) {\n                        result = deser.deserialize(jp, ctxt);\n                    } else {\n                        deser.deserialize(jp, ctxt, valueToUpdate);\n                        result = valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n        try {\n            return _bindAsTree(jp);\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    /**\n     * @since 2.1\n     */\n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException\n    {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt, \n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n    {\n        String expName = _config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, _config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        jp.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(jp, ctxt);\n        } else {\n            deser.deserialize(jp, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        // and last, verify that we now get matching END_OBJECT\n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, locating deserializers etc\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        // Sanity check: must have actual type...\n        if (valueType == null) {\n            throw new JsonMappingException(\"No value type configured for ObjectReader\");\n        }\n        \n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.6\n     */\n            // Nope: need to ask provider to resolve it\n\n    /**\n     * Method called to locate deserializer ahead of time, if permitted\n     * by configuration. Method also is NOT to throw an exception if\n     * access fails.\n     */\n    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)\n    {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        // already cached?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                // If not, need to resolve; for which we need a temporary context as well:\n                DeserializationContext ctxt = createDeserializationContext(null, _config);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n                \n            } catch (JsonProcessingException e) {\n                // need to swallow?\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, format auto-detection (since 2.1)\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser jp = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(jp, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndClose(p, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException, JsonProcessingException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndReadValues(p, _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    /**\n     * Method called to indicate that format detection failed to detect format\n     * of given input\n     */\n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException\n    {\n        throw new JsonParseException(\"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString(),\n                JsonLocation.NA);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg) {\n        // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n        return _context.createInstance(cfg, jp, _injectableValues);\n    }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n    {\n        throw new JsonParseException(\"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\",\n                JsonLocation.NA);\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.deser.DataFormatReaders;\nimport com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.NullNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.type.SimpleType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"fluent\" (or, kind of, builder) pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    /*\n    /**********************************************************\n    /* Immutable configuration from ObjectMapper\n    /**********************************************************\n     */\n\n    /**\n     * General serialization configuration settings; while immutable,\n     * can use copy-constructor to create modified instances as necessary.\n     */\n    protected final DeserializationConfig _config;\n\n    /**\n     * Blueprint instance of deserialization context; used for creating\n     * actual instance when needed.\n     */\n    protected final DefaultDeserializationContext _context;\n\n    /**\n     * Factory used for constructing {@link JsonGenerator}s\n     */\n    protected final JsonFactory _parserFactory;\n\n    /**\n     * Flag that indicates whether root values are expected to be unwrapped or not\n     */\n    protected final boolean _unwrapRoot;\n\n    /*\n    /**********************************************************\n    /* Configuration that can be changed during building\n    /**********************************************************\n     */\n\n    /**\n     * Declared type of value to instantiate during deserialization.\n     * Defines which deserializer to use; as well as base type of instance\n     * to construct if an updatable value is not configured to be used\n     * (subject to changes by embedded type information, for polymorphic\n     * types). If {@link #_valueToUpdate} is non-null, only used for\n     * locating deserializer.\n     */\n    protected final JavaType _valueType;\n\n    /**\n     * We may pre-fetch deserializer as soon as {@link #_valueType}\n     * is known, and if so, reuse it afterwards.\n     * This allows avoiding further deserializer lookups and increases\n     * performance a bit on cases where readers are reused.\n     * \n     * @since 2.1\n     */\n    protected final JsonDeserializer<Object> _rootDeserializer;\n    \n    /**\n     * Instance to update with data binding; if any. If null,\n     * a new instance is created, if non-null, properties of\n     * this value object will be updated instead.\n     * Note that value can be of almost any type, except not\n     * {@link com.fasterxml.jackson.databind.type.ArrayType}; array\n     * types can not be modified because array size is immutable.\n     */\n    protected final Object _valueToUpdate;\n\n    /**\n     * When using data format that uses a schema, schema is passed\n     * to parser.\n     */\n    protected final FormatSchema _schema;\n\n    /**\n     * Values that can be injected during deserialization, if any.\n     */\n    protected final InjectableValues _injectableValues;\n\n    /**\n     * Optional detector used for auto-detecting data format that byte-based\n     * input uses.\n     *<p>\n     * NOTE: If defined non-null, <code>readValue()</code> methods that take\n     * {@link Reader} or {@link String} input <b>will fail with exception</b>,\n     * because format-detection only works on byte-sources. Also, if format\n     * can not be detect reliably (as per detector settings),\n     * a {@link JsonParseException} will be thrown).\n     * \n     * @since 2.1\n     */\n    protected final DataFormatReaders _dataFormatReaders;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * Root-level cached deserializers.\n     * Passed by {@link ObjectMapper}, shared with it.\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n\n    /**\n     * Cache for root names used when root-wrapping is enabled.\n     * Passed by {@link ObjectMapper}, shared with it.\n     */\n    protected final RootNameLookup _rootNames;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle, construction\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link ObjectMapper} for initial instantiation\n     */\n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n        this(mapper, config, null, null, null, null);\n    }\n\n    /**\n     * Constructor called when a root deserializer should be fetched based\n     * on other configuration.\n     */\n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,\n            JavaType valueType, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues)\n    {\n        _config = config;\n        _context = mapper._deserializationContext;\n        _rootDeserializers = mapper._rootDeserializers;\n        _parserFactory = mapper._jsonFactory;\n        _rootNames = mapper._rootNames;\n        _valueType = valueType;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n\n        _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n        _dataFormatReaders = null;        \n    }\n    \n    /**\n     * Copy constructor used for building variations.\n     */\n    protected ObjectReader(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders)\n    {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = valueType;\n        _rootDeserializer = rootDeser;\n        _valueToUpdate = valueToUpdate;\n        if (valueToUpdate != null && valueType.isArrayType()) {\n            throw new IllegalArgumentException(\"Can not update an array value\");\n        }\n        _schema = schema;\n        _injectableValues = injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = dataFormatReaders;\n    }\n\n    /**\n     * Copy constructor used when modifying simple feature flags\n     */\n    protected ObjectReader(ObjectReader base, DeserializationConfig config)\n    {\n        _config = config;\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = base._parserFactory;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = config.useRootWrapping();\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f)\n    {\n        // may need to override ordering, based on data format capabilities\n        _config = base._config\n            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n        _context = base._context;\n\n        _rootDeserializers = base._rootDeserializers;\n        _parserFactory = f;\n        _rootNames = base._rootNames;\n\n        _valueType = base._valueType;\n        _rootDeserializer = base._rootDeserializer;\n        _valueToUpdate = base._valueToUpdate;\n        _schema = base._schema;\n        _injectableValues = base._injectableValues;\n        _unwrapRoot = base._unwrapRoot;\n        _dataFormatReaders = base._dataFormatReaders;\n    }\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override, used for constructing\n    /* reader instances, (re)configuring parser instances\n    /* Added in 2.5\n    /**********************************************************\n     */\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n        return new ObjectReader(base, config);\n    }\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }\n\n    /**\n     * Factory method used to create {@link MappingIterator} instances;\n     * either default, or custom subtype.\n     * \n     * @since 2.5\n     */\n    protected <T> MappingIterator<T> _newIterator(JavaType valueType,\n            JsonParser parser, DeserializationContext ctxt,\n            JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)\n    {\n            return new MappingIterator<T>(valueType, parser, ctxt,\n                    deser, parserManaged, valueToUpdate);\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes may choose to override, if customized\n    /* initialization is needed.\n    /**********************************************************\n     */\n\n    /**\n     * NOTE: changed from static to non-static in 2.5; unfortunate but\n     * necessary change to support overridability\n     */\n    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) { // and then we must get something...\n            t = p.nextToken();\n            if (t == null) {\n                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    /**\n     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n     * of multiple values means that we may or may not want to advance the stream,\n     * but need to do other initialization.\n     *<p>\n     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n     * \n     * @since 2.5\n     */\n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for DeserializationFeatures\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     */\n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader with(DeserializationFeature first,\n            DeserializationFeature... other)\n    {\n        return _with(_config.with(first, other));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     */\n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader without(DeserializationFeature first,\n            DeserializationFeature... other) {\n        return _with(_config.without(first, other));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    \n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for JsonParser.Features\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     */\n    public ObjectReader with(JsonParser.Feature feature) {\n        return _with(_config.with(feature));\n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n        return _with(_config.withFeatures(features));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     */\n    public ObjectReader without(JsonParser.Feature feature) {\n        return _with(_config.without(feature)); \n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n        return _with(_config.withoutFeatures(features));\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods, other\n    /**********************************************************\n     */\n\n    public ObjectReader with(DeserializationConfig config) {\n        return _with(config);\n    }    \n\n    /**\n     * Method for constructing a new instance with configuration that uses\n     * passed {@link InjectableValues} to provide injectable values.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(InjectableValues injectableValues)\n    {\n        if (_injectableValues == injectableValues) {\n            return this;\n        }\n        return _new(this, _config,\n                _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, injectableValues, _dataFormatReaders);\n    }\n\n    /**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonNodeFactory} for constructing {@link JsonNode}\n     * instances.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(JsonNodeFactory f) {\n        return _with(_config.with(f));\n    }\n\n    /**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonFactory} for constructing underlying Readers.\n     *<p>\n     * NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>\n     * (that is, ones that return <code>false</code> for\n     * {@link JsonFactory#requiresCustomCodec()}) can be used: trying\n     * to use one that requires custom codec will throw exception\n     * \n     * @since 2.1\n     */\n    public ObjectReader with(JsonFactory f) {\n        if (f == _parserFactory) {\n            return this;\n        }\n        ObjectReader r = _new(this, f);\n        // Also, try re-linking, if possible...\n        if (f.getCodec() == null) {\n            f.setCodec(r);\n        }\n        return r;\n    }\n    \n    /**\n     * Method for constructing a new instance with configuration that\n     * specifies what root name to expect for \"root name unwrapping\".\n     * See {@link DeserializationConfig#withRootName(String)} for\n     * details.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }\n\n    /**\n     * Method for constructing a new instance with configuration that\n     * passes specified {@link FormatSchema} to {@link JsonParser} that\n     * is constructed for parsing content.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(FormatSchema schema)\n    {\n        if (_schema == schema) {\n            return this;\n        }\n        _verifySchemaType(schema);\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                schema, _injectableValues, _dataFormatReaders);\n    }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     * \n     * @since 2.5\n     */\n    public ObjectReader forType(JavaType valueType)\n    {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n        // type is stored here, no need to make a copy of config\n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     *\n     * @since 2.5\n     */\n    public ObjectReader forType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     *\n     * @since 2.5\n     */\n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }\n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n        return forType(_config.constructType(valueType));\n    }    \n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n        return forType(_config.getTypeFactory().constructType(valueType));\n    }\n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    \n\n    /**\n     * Method for constructing a new instance with configuration that\n     * updates passed Object (as root value), instead of constructing \n     * a new value.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withValueToUpdate(Object value)\n    {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        /* no real benefit from pre-fetching, as updating readers are much\n         * less likely to be reused, and value type may also be forced\n         * with a later chained call...\n         */\n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }\n\n    /**\n     * Method for constructing a new instance with configuration that\n     * uses specified View for filtering.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }\n\n    public ObjectReader with(Locale l) {\n        return _with(_config.with(l));\n    }\n\n    public ObjectReader with(TimeZone tz) {\n        return _with(_config.with(tz));\n    }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n        return _with(_config.with(defaultBase64));\n    }\n\n    /**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified list of\n     * {@link JsonFactory} instances, and default {@link DataFormatReaders} settings\n     * (for customized {@link DataFormatReaders}, you can construct instance yourself).\n     * to construct appropriate {@link JsonParser} for actual parsing.\n     *<p>\n     * Note: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     *<p>\n     * Note: not all {@link JsonFactory} types can be passed: specifically, ones that\n     * require \"custom codec\" (like XML factory) will not work. Instead, use\n     * method that takes {@link ObjectReader} instances instead of factories.\n     * \n     * @param readers Data formats accepted, in decreasing order of priority (that is,\n     *   matches checked in listed order, first match wins)\n     * \n     * @return Newly configured writer instance\n     * \n     * @since 2.1\n     */\n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }\n\n    /**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified\n     * {@link DataFormatReaders}.\n     *<p>\n     * NOTE: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     * \n     * @param readers DataFormatReaders to use for detecting underlying format.\n     * \n     * @return Newly configured writer instance\n     * \n     * @since 2.1\n     */\n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withAttributes(Map<Object,Object> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable factory methods may override\n    /**********************************************************\n     */\n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }\n    \n    /*\n    /**********************************************************\n    /* Simple accessors\n    /**********************************************************\n     */\n    \n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(MapperFeature f) {\n        return _config.isEnabled(f);\n    }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _parserFactory.isEnabled(f);\n    }\n\n    /**\n     * @since 2.2\n     */\n    public DeserializationConfig getConfig() {\n        return _config;\n    }\n    \n    /**\n     * @since 2.1\n     */\n    @Override\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() {\n        return _parserFactory;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }\n\n    /**\n     * @since 2.3\n     */\n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization methods; basic ones to support ObjectCodec first\n    /* (ones that take JsonParser)\n    /**********************************************************\n     */\n\n    /**\n     * Method that binds content read using given parser, using\n     * configuration of this reader, including expected result type.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        return (T) _bind(jp, _valueToUpdate);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return (T) withType(valueTypeRef).readValue(jp);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) withType((JavaType)valueType).readValue(jp);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n        return (T) withType(valueType).readValue(jp);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueTypeRef).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException {\n        return withType(valueTypeRef).readValues(jp);\n    }\n    \n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(jp);\n     *</pre>\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)\n        throws IOException, JsonProcessingException {\n        return withType(valueType).readValues(jp);\n    }\n\n    /*\n    /**********************************************************\n    /* TreeCodec impl\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }\n\n    @Override\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n            throws IOException, JsonProcessingException\n    {\n        return (T) _bindAsTree(jp);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization methods; others similar to what ObjectMapper has\n    /**********************************************************\n     */\n    \n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    /**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, 0, src.length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(src, offset, length);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src, offset, length), _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(in));\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(r);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(r));\n    }\n\n    /**\n     * Method that reads content from given JSON input String,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        return _bindAndCloseAsTree(_parserFactory.createParser(json));\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods; reading sequence of values\n    /**********************************************************\n     */\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n        // false -> do not close as caller gave parser instance\n        return _newIterator(_valueType, jp, ctxt,\n                _findRootDeserializer(ctxt, _valueType),\n                false, _valueToUpdate);\n    }\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either wrapped or unwrapped root-level sequence:\n     * wrapped means that the elements are enclosed in JSON Array;\n     * and unwrapped that elements are directly accessed at main level.\n     * Assumption is that iff the first token of the document is\n     * <code>START_ARRAY</code>, we have a wrapped sequence; otherwise\n     * unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>\n     * is skipped, so that for both cases, underlying {@link JsonParser}\n     * will point to what is expected to be the first token of the first\n     * element.\n     *<p>\n     * Note that the wrapped vs unwrapped logic means that it is NOT\n     * possible to use this method for reading an unwrapped sequence\n     * of elements written as JSON Arrays: to read such sequences, one\n     * has to use {@link #readValues(JsonParser)}, making sure parser\n     * points to the first token of the first element (i.e. the second\n     * <code>START_ARRAY</code> which is part of the first element).\n     */\n    public <T> MappingIterator<T> readValues(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(src);\n        }\n        JsonParser p = _parserFactory.createParser(src);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _parserFactory.createParser(json);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt,\n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param src URL to read to access JSON content to parse.\n     */\n    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);\n    }\n\n    /*\n    /**********************************************************\n    /* Implementation of rest of ObjectCodec methods\n    /**********************************************************\n     */\n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n    {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    \n    \n    @Override\n    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, data-binding\n    /**********************************************************\n     */\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n    {\n        /* First: may need to read the next token, to initialize state (either\n         * before first read from parser, or after previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(jp, ctxt);\n                } else {\n                    deser.deserialize(jp, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                if (valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                } else {\n                    result = valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(jp, _config);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                } else {\n                    if (valueToUpdate == null) {\n                        result = deser.deserialize(jp, ctxt);\n                    } else {\n                        deser.deserialize(jp, ctxt, valueToUpdate);\n                        result = valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n        try {\n            return _bindAsTree(jp);\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(jp, _config);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    /**\n     * @since 2.1\n     */\n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException\n    {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p, _config);\n        return _newIterator(_valueType, p, ctxt, \n                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n    {\n        String expName = _config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, _config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        jp.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(jp, ctxt);\n        } else {\n            deser.deserialize(jp, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        // and last, verify that we now get matching END_OBJECT\n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, locating deserializers etc\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        // Sanity check: must have actual type...\n        if (valueType == null) {\n            throw new JsonMappingException(\"No value type configured for ObjectReader\");\n        }\n        \n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n            // Nope: need to ask provider to resolve it\n            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n            if (deser == null) { // can this happen?\n                throw new JsonMappingException(\"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n            }\n            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n        }\n        return deser;\n    }\n\n    /**\n     * Method called to locate deserializer ahead of time, if permitted\n     * by configuration. Method also is NOT to throw an exception if\n     * access fails.\n     */\n    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)\n    {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        // already cached?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                // If not, need to resolve; for which we need a temporary context as well:\n                DeserializationContext ctxt = createDeserializationContext(null, _config);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n                \n            } catch (JsonProcessingException e) {\n                // need to swallow?\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, format auto-detection (since 2.1)\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser jp = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(jp, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndClose(p, _valueToUpdate);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException, JsonProcessingException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndReadValues(p, _valueToUpdate);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    /**\n     * Method called to indicate that format detection failed to detect format\n     * of given input\n     */\n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException\n    {\n        throw new JsonParseException(\"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString(),\n                JsonLocation.NA);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg) {\n        // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n        return _context.createInstance(cfg, jp, _injectableValues);\n    }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n    {\n        throw new JsonParseException(\"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\",\n                JsonLocation.NA);\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 15, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.JavaType", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.lang.reflect.Modifier;\n\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\n/**\n * Base class for type token classes used both to contain information\n * and as keys for deserializers.\n *<p>\n * Instances can (only) be constructed by\n * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n *<p>\n * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n * it to be pushed through interfaces that only expose that type.\n */\npublic abstract class JavaType\n    extends ResolvedType\n    implements java.io.Serializable, // 2.1\n        java.lang.reflect.Type // 2.2\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * This is the nominal type-erased Class that would be close to the\n     * type represented (but not exactly type, due to type erasure: type\n     * instance may have more information on this).\n     * May be an interface or abstract class, so instantiation\n     * may not be possible.\n     */\n    protected final Class<?> _class;\n\n    protected final int _hash;\n\n    /**\n     * Optional handler (codec) that can be attached to indicate \n     * what to use for handling (serializing, deserializing) values of\n     * this specific type.\n     *<p>\n     * Note: untyped (i.e. caller has to cast) because it is used for\n     * different kinds of handlers, with unrelated types.\n     */\n    protected final Object _valueHandler;\n\n    /**\n     * Optional handler that can be attached to indicate how to handle\n     * additional type metadata associated with this type.\n     *<p>\n     * Note: untyped (i.e. caller has to cast) because it is used for\n     * different kinds of handlers, with unrelated types.\n     */\n    protected final Object _typeHandler;\n\n    /**\n     * Whether entities defined with this type should be handled using\n     * static typing (as opposed to dynamic runtime type) or not.\n     * \n     * @since 2.2\n     */\n    protected final boolean _asStatic;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param raw \"Raw\" (type-erased) class for this type\n     * @param additionalHash Additional hash code to use, in addition\n     *   to hash code of the class name \n     */\n    protected JavaType(Class<?> raw, int additionalHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        _class = raw;\n        _hash = raw.getName().hashCode() + additionalHash;\n        _valueHandler = valueHandler;\n        _typeHandler = typeHandler;\n        _asStatic = asStatic;\n    }\n    \n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that it will have specified type handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withTypeHandler(Object h);\n\n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that its content type will have specified\n     * type handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withContentTypeHandler(Object h);\n\n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that it will have specified value handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withValueHandler(Object h);\n\n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that it will have specified content value handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withContentValueHandler(Object h);\n\n    /**\n     * Method that can be called to get a type instance that indicates\n     * that values of the type should be handled using \"static typing\" for purposes\n     * of serialization (as opposed to \"dynamic\" aka runtime typing):\n     * meaning that no runtime information is needed for determining serializers to use.\n     * The main use case is to allow forcing of specific root value serialization type,\n     * and specifically in resolving serializers for contained types (element types\n     * for arrays, Collections and Maps).\n     * \n     * @since 2.2\n     */\n    public abstract JavaType withStaticTyping();\n    \n    /*\n    /**********************************************************\n    /* Type coercion fluent factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to do a \"narrowing\" conversions; that is,\n     * to return a type with a raw class that is assignable to the raw\n     * class of this type. If this is not possible, an\n     * {@link IllegalArgumentException} is thrown.\n     * If class is same as the current raw class, instance itself is\n     * returned.\n     */\n    public JavaType narrowBy(Class<?> subclass)\n    {\n        // First: if same raw class, just return this instance\n        if (subclass == _class) { return this; }\n        // Otherwise, ensure compatibility\n        _assertSubclass(subclass, _class);\n        JavaType result = _narrow(subclass);\n\n        // TODO: these checks should NOT actually be needed; above should suffice:\n        if (_valueHandler != result.<Object>getValueHandler()) {\n            result = result.withValueHandler(_valueHandler);\n        }\n        if (_typeHandler != result.<Object>getTypeHandler()) {\n            result = result.withTypeHandler(_typeHandler);\n        }\n        return result;\n    }\n\n    /**\n     * More efficient version of {@link #narrowBy}, called by\n     * internal framework in cases where compatibility checks\n     * are to be skipped.\n     */\n    public JavaType forcedNarrowBy(Class<?> subclass)\n    {\n        if (subclass == _class) { // can still optimize for simple case\n            return this;\n        }\n        JavaType result = _narrow(subclass);\n        // TODO: these checks should NOT actually be needed; above should suffice:\n        if (_valueHandler != result.<Object>getValueHandler()) {\n            result = result.withValueHandler(_valueHandler);\n        }\n        if (_typeHandler != result.<Object>getTypeHandler()) {\n            result = result.withTypeHandler(_typeHandler);\n        }\n        return result;\n    }\n\n    /**\n     * Method that can be called to do a \"widening\" conversions; that is,\n     * to return a type with a raw class that could be assigned from this\n     * type.\n     * If such conversion is not possible, an\n     * {@link IllegalArgumentException} is thrown.\n     * If class is same as the current raw class, instance itself is\n     * returned.\n     */\n    public JavaType widenBy(Class<?> superclass) {\n        // First: if same raw class, just return this instance\n        if (superclass == _class) { return this; }\n        // Otherwise, ensure compatibility\n        _assertSubclass(_class, superclass);\n        return _widen(superclass);\n    }\n\n    protected abstract JavaType _narrow(Class<?> subclass);\n\n    /**\n     *<p>\n     * Default implementation is just to call {@link #_narrow}, since\n     * underlying type construction is usually identical\n     */\n    protected JavaType _widen(Class<?> superclass) { return _narrow(superclass); }\n\n    public abstract JavaType narrowContentsBy(Class<?> contentClass);\n\n    public abstract JavaType widenContentsBy(Class<?> contentClass);\n    \n    /*\n    /**********************************************************\n    /* Implementation of ResolvedType API\n    /**********************************************************\n     */\n\n    @Override\n    public final Class<?> getRawClass() { return _class; }\n\n    /**\n     * Method that can be used to check whether this type has\n     * specified Class as its type erasure. Put another way, returns\n     * true if instantiation of this Type is given (type-erased) Class.\n     */\n    @Override\n    public final boolean hasRawClass(Class<?> clz) { return _class == clz; }\n\n    @Override\n    public boolean isAbstract() {\n        return Modifier.isAbstract(_class.getModifiers());\n    }\n\n    /**\n     * Convenience method for checking whether underlying Java type\n     * is a concrete class or not: abstract classes and interfaces\n     * are not.\n     */\n    @Override\n    public boolean isConcrete() {\n        int mod = _class.getModifiers();\n        if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {\n            return true;\n        }\n        /* 19-Feb-2010, tatus: Holy mackarel; primitive types\n         *    have 'abstract' flag set...\n         */\n        return _class.isPrimitive();\n    }\n\n    @Override\n    public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); }\n\n    @Override\n    public boolean isArrayType() { return false; }\n\n    @Override\n    public final boolean isEnumType() { return _class.isEnum(); }\n\n    @Override\n    public final boolean isInterface() { return _class.isInterface(); }\n\n    @Override\n    public final boolean isPrimitive() { return _class.isPrimitive(); }\n\n    @Override\n    public final boolean isFinal() { return Modifier.isFinal(_class.getModifiers()); }\n\n    /**\n     * @return True if type represented is a container type; this includes\n     *    array, Map and Collection types.\n     */\n    @Override\n    public abstract boolean isContainerType();\n\n    /**\n     * @return True if type is either true {@link java.util.Collection} type,\n     *    or something similar (meaning it has at least one type parameter,\n     *    which describes type of contents)\n     */\n    @Override\n    public boolean isCollectionLikeType() { return false; }\n\n    /**\n     * @return True if type is either true {@link java.util.Map} type,\n     *    or something similar (meaning it has at least two type parameter;\n     *    first one describing key type, second value type)\n     */\n    @Override\n    public boolean isMapLikeType() { return false; }\n\n    /**\n     * Convenience method, short-hand for\n     *<code>\n     *   getRawClass() == Object.class\n     *</code>\n     * and used to figure if we basically have \"untyped\" type object.\n     *\n     * @since 2.5\n     */\n\n    /**\n     * Accessor for checking whether handlers for dealing with values of\n     * this type should use static typing (as opposed to dynamic typing).\n     * Note that while value of 'true' does mean that static typing is to\n     * be used, value of 'false' may still be overridden by other settings.\n     * \n     * @since 2.2\n     */\n    public final boolean useStaticType() { return _asStatic; }\n\n    /*\n    /**********************************************************\n    /* Public API, type parameter access; pass-through\n    /**********************************************************\n     */\n\n    @Override\n    public boolean hasGenericTypes() { return containedTypeCount() > 0; }\n\n    @Override\n    public JavaType getKeyType() { return null; }\n\n    @Override\n    public JavaType getContentType() { return null; }\n\n    @Override\n    public int containedTypeCount() { return 0; }\n\n    @Override\n    public JavaType containedType(int index) { return null; }\n       \n    @Override\n    public String containedTypeName(int index) { return null; }\n\n    @Override\n    public abstract Class<?> getParameterSource();\n    \n    /*\n    /**********************************************************\n    /* Extended API beyond ResolvedType\n    /**********************************************************\n     */\n    \n    // NOTE: not defined in Resolved type\n    /**\n     * Convenience method that is functionally same as:\n     *<code>\n     * JavaType t = containedType(index);\n     * if (t == null) {\n     *    t = TypeFactory.unknownType();\n     * }\n     *</code>\n     * and typically used to eliminate need for null checks for common case\n     * where we just want to check if containedType is available first; and\n     * if not, use \"unknown type\" (which translates to <code>java.lang.Object</code>\n     * basically).\n     *\n     * @since 2.5\n     */\n    public JavaType containedTypeOrUnknown(int index) {\n        JavaType t = containedType(index);\n        return (t == null)  ? TypeFactory.unknownType() : t;\n    }\n\n    /*\n    /**********************************************************\n    /* Semi-public API, accessing handlers\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value handler associated with this type, if any\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getValueHandler() { return (T) _valueHandler; }\n\n    /**\n     * Method for accessing type handler associated with this type, if any\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getTypeHandler() { return (T) _typeHandler; }\n\n    /*\n    /**********************************************************\n    /* Support for producing signatures\n    /**********************************************************\n     */\n    \n    //public abstract String toCanonical();\n\n    /**\n     * Method for accessing signature that contains generic\n     * type information, in form compatible with JVM 1.5\n     * as per JLS. It is a superset of {@link #getErasedSignature},\n     * in that generic information can be automatically removed\n     * if necessary (just remove outermost\n     * angle brackets along with content inside)\n     */\n    public String getGenericSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getGenericSignature(sb);\n        return sb.toString();        \n    }\n\n    /**\n     * \n     * @param sb StringBuilder to append signature to\n     * \n     * @return StringBuilder that was passed in; returned to allow\n     * call chaining\n     */\n    public abstract StringBuilder getGenericSignature(StringBuilder sb);\n    \n    /**\n     * Method for accessing signature without generic\n     * type information, in form compatible with all versions\n     * of JVM, and specifically used for type descriptions\n     * when generating byte code.\n     */\n    public String getErasedSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getErasedSignature(sb);\n        return sb.toString();\n    }\n\n    /**\n     * Method for accessing signature without generic\n     * type information, in form compatible with all versions\n     * of JVM, and specifically used for type descriptions\n     * when generating byte code.\n     * \n     * @param sb StringBuilder to append signature to\n     * \n     * @return StringBuilder that was passed in; returned to allow\n     * call chaining\n     */\n    public abstract StringBuilder getErasedSignature(StringBuilder sb);\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected void _assertSubclass(Class<?> subclass, Class<?> superClass) {\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" is not assignable to \"+_class.getName());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods; let's make them abstract to force override\n    /**********************************************************\n     */\n\n    @Override\n    public abstract String toString();\n\n    @Override\n    public abstract boolean equals(Object o);\n\n    @Override\n    public final int hashCode() { return _hash; }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.lang.reflect.Modifier;\n\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\n/**\n * Base class for type token classes used both to contain information\n * and as keys for deserializers.\n *<p>\n * Instances can (only) be constructed by\n * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n *<p>\n * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n * it to be pushed through interfaces that only expose that type.\n */\npublic abstract class JavaType\n    extends ResolvedType\n    implements java.io.Serializable, // 2.1\n        java.lang.reflect.Type // 2.2\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * This is the nominal type-erased Class that would be close to the\n     * type represented (but not exactly type, due to type erasure: type\n     * instance may have more information on this).\n     * May be an interface or abstract class, so instantiation\n     * may not be possible.\n     */\n    protected final Class<?> _class;\n\n    protected final int _hash;\n\n    /**\n     * Optional handler (codec) that can be attached to indicate \n     * what to use for handling (serializing, deserializing) values of\n     * this specific type.\n     *<p>\n     * Note: untyped (i.e. caller has to cast) because it is used for\n     * different kinds of handlers, with unrelated types.\n     */\n    protected final Object _valueHandler;\n\n    /**\n     * Optional handler that can be attached to indicate how to handle\n     * additional type metadata associated with this type.\n     *<p>\n     * Note: untyped (i.e. caller has to cast) because it is used for\n     * different kinds of handlers, with unrelated types.\n     */\n    protected final Object _typeHandler;\n\n    /**\n     * Whether entities defined with this type should be handled using\n     * static typing (as opposed to dynamic runtime type) or not.\n     * \n     * @since 2.2\n     */\n    protected final boolean _asStatic;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param raw \"Raw\" (type-erased) class for this type\n     * @param additionalHash Additional hash code to use, in addition\n     *   to hash code of the class name \n     */\n    protected JavaType(Class<?> raw, int additionalHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        _class = raw;\n        _hash = raw.getName().hashCode() + additionalHash;\n        _valueHandler = valueHandler;\n        _typeHandler = typeHandler;\n        _asStatic = asStatic;\n    }\n    \n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that it will have specified type handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withTypeHandler(Object h);\n\n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that its content type will have specified\n     * type handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withContentTypeHandler(Object h);\n\n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that it will have specified value handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withValueHandler(Object h);\n\n    /**\n     * \"Copy method\" that will construct a new instance that is identical to\n     * this instance, except that it will have specified content value handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withContentValueHandler(Object h);\n\n    /**\n     * Method that can be called to get a type instance that indicates\n     * that values of the type should be handled using \"static typing\" for purposes\n     * of serialization (as opposed to \"dynamic\" aka runtime typing):\n     * meaning that no runtime information is needed for determining serializers to use.\n     * The main use case is to allow forcing of specific root value serialization type,\n     * and specifically in resolving serializers for contained types (element types\n     * for arrays, Collections and Maps).\n     * \n     * @since 2.2\n     */\n    public abstract JavaType withStaticTyping();\n    \n    /*\n    /**********************************************************\n    /* Type coercion fluent factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to do a \"narrowing\" conversions; that is,\n     * to return a type with a raw class that is assignable to the raw\n     * class of this type. If this is not possible, an\n     * {@link IllegalArgumentException} is thrown.\n     * If class is same as the current raw class, instance itself is\n     * returned.\n     */\n    public JavaType narrowBy(Class<?> subclass)\n    {\n        // First: if same raw class, just return this instance\n        if (subclass == _class) { return this; }\n        // Otherwise, ensure compatibility\n        _assertSubclass(subclass, _class);\n        JavaType result = _narrow(subclass);\n\n        // TODO: these checks should NOT actually be needed; above should suffice:\n        if (_valueHandler != result.<Object>getValueHandler()) {\n            result = result.withValueHandler(_valueHandler);\n        }\n        if (_typeHandler != result.<Object>getTypeHandler()) {\n            result = result.withTypeHandler(_typeHandler);\n        }\n        return result;\n    }\n\n    /**\n     * More efficient version of {@link #narrowBy}, called by\n     * internal framework in cases where compatibility checks\n     * are to be skipped.\n     */\n    public JavaType forcedNarrowBy(Class<?> subclass)\n    {\n        if (subclass == _class) { // can still optimize for simple case\n            return this;\n        }\n        JavaType result = _narrow(subclass);\n        // TODO: these checks should NOT actually be needed; above should suffice:\n        if (_valueHandler != result.<Object>getValueHandler()) {\n            result = result.withValueHandler(_valueHandler);\n        }\n        if (_typeHandler != result.<Object>getTypeHandler()) {\n            result = result.withTypeHandler(_typeHandler);\n        }\n        return result;\n    }\n\n    /**\n     * Method that can be called to do a \"widening\" conversions; that is,\n     * to return a type with a raw class that could be assigned from this\n     * type.\n     * If such conversion is not possible, an\n     * {@link IllegalArgumentException} is thrown.\n     * If class is same as the current raw class, instance itself is\n     * returned.\n     */\n    public JavaType widenBy(Class<?> superclass) {\n        // First: if same raw class, just return this instance\n        if (superclass == _class) { return this; }\n        // Otherwise, ensure compatibility\n        _assertSubclass(_class, superclass);\n        return _widen(superclass);\n    }\n\n    protected abstract JavaType _narrow(Class<?> subclass);\n\n    /**\n     *<p>\n     * Default implementation is just to call {@link #_narrow}, since\n     * underlying type construction is usually identical\n     */\n    protected JavaType _widen(Class<?> superclass) { return _narrow(superclass); }\n\n    public abstract JavaType narrowContentsBy(Class<?> contentClass);\n\n    public abstract JavaType widenContentsBy(Class<?> contentClass);\n    \n    /*\n    /**********************************************************\n    /* Implementation of ResolvedType API\n    /**********************************************************\n     */\n\n    @Override\n    public final Class<?> getRawClass() { return _class; }\n\n    /**\n     * Method that can be used to check whether this type has\n     * specified Class as its type erasure. Put another way, returns\n     * true if instantiation of this Type is given (type-erased) Class.\n     */\n    @Override\n    public final boolean hasRawClass(Class<?> clz) { return _class == clz; }\n\n    @Override\n    public boolean isAbstract() {\n        return Modifier.isAbstract(_class.getModifiers());\n    }\n\n    /**\n     * Convenience method for checking whether underlying Java type\n     * is a concrete class or not: abstract classes and interfaces\n     * are not.\n     */\n    @Override\n    public boolean isConcrete() {\n        int mod = _class.getModifiers();\n        if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {\n            return true;\n        }\n        /* 19-Feb-2010, tatus: Holy mackarel; primitive types\n         *    have 'abstract' flag set...\n         */\n        return _class.isPrimitive();\n    }\n\n    @Override\n    public boolean isThrowable() { return Throwable.class.isAssignableFrom(_class); }\n\n    @Override\n    public boolean isArrayType() { return false; }\n\n    @Override\n    public final boolean isEnumType() { return _class.isEnum(); }\n\n    @Override\n    public final boolean isInterface() { return _class.isInterface(); }\n\n    @Override\n    public final boolean isPrimitive() { return _class.isPrimitive(); }\n\n    @Override\n    public final boolean isFinal() { return Modifier.isFinal(_class.getModifiers()); }\n\n    /**\n     * @return True if type represented is a container type; this includes\n     *    array, Map and Collection types.\n     */\n    @Override\n    public abstract boolean isContainerType();\n\n    /**\n     * @return True if type is either true {@link java.util.Collection} type,\n     *    or something similar (meaning it has at least one type parameter,\n     *    which describes type of contents)\n     */\n    @Override\n    public boolean isCollectionLikeType() { return false; }\n\n    /**\n     * @return True if type is either true {@link java.util.Map} type,\n     *    or something similar (meaning it has at least two type parameter;\n     *    first one describing key type, second value type)\n     */\n    @Override\n    public boolean isMapLikeType() { return false; }\n\n    /**\n     * Convenience method, short-hand for\n     *<code>\n     *   getRawClass() == Object.class\n     *</code>\n     * and used to figure if we basically have \"untyped\" type object.\n     *\n     * @since 2.5\n     */\n    public final boolean isJavaLangObject() { return _class == Object.class; }\n\n    /**\n     * Accessor for checking whether handlers for dealing with values of\n     * this type should use static typing (as opposed to dynamic typing).\n     * Note that while value of 'true' does mean that static typing is to\n     * be used, value of 'false' may still be overridden by other settings.\n     * \n     * @since 2.2\n     */\n    public final boolean useStaticType() { return _asStatic; }\n\n    /*\n    /**********************************************************\n    /* Public API, type parameter access; pass-through\n    /**********************************************************\n     */\n\n    @Override\n    public boolean hasGenericTypes() { return containedTypeCount() > 0; }\n\n    @Override\n    public JavaType getKeyType() { return null; }\n\n    @Override\n    public JavaType getContentType() { return null; }\n\n    @Override\n    public int containedTypeCount() { return 0; }\n\n    @Override\n    public JavaType containedType(int index) { return null; }\n       \n    @Override\n    public String containedTypeName(int index) { return null; }\n\n    @Override\n    public abstract Class<?> getParameterSource();\n    \n    /*\n    /**********************************************************\n    /* Extended API beyond ResolvedType\n    /**********************************************************\n     */\n    \n    // NOTE: not defined in Resolved type\n    /**\n     * Convenience method that is functionally same as:\n     *<code>\n     * JavaType t = containedType(index);\n     * if (t == null) {\n     *    t = TypeFactory.unknownType();\n     * }\n     *</code>\n     * and typically used to eliminate need for null checks for common case\n     * where we just want to check if containedType is available first; and\n     * if not, use \"unknown type\" (which translates to <code>java.lang.Object</code>\n     * basically).\n     *\n     * @since 2.5\n     */\n    public JavaType containedTypeOrUnknown(int index) {\n        JavaType t = containedType(index);\n        return (t == null)  ? TypeFactory.unknownType() : t;\n    }\n\n    /*\n    /**********************************************************\n    /* Semi-public API, accessing handlers\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value handler associated with this type, if any\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getValueHandler() { return (T) _valueHandler; }\n\n    /**\n     * Method for accessing type handler associated with this type, if any\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getTypeHandler() { return (T) _typeHandler; }\n\n    /*\n    /**********************************************************\n    /* Support for producing signatures\n    /**********************************************************\n     */\n    \n    //public abstract String toCanonical();\n\n    /**\n     * Method for accessing signature that contains generic\n     * type information, in form compatible with JVM 1.5\n     * as per JLS. It is a superset of {@link #getErasedSignature},\n     * in that generic information can be automatically removed\n     * if necessary (just remove outermost\n     * angle brackets along with content inside)\n     */\n    public String getGenericSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getGenericSignature(sb);\n        return sb.toString();        \n    }\n\n    /**\n     * \n     * @param sb StringBuilder to append signature to\n     * \n     * @return StringBuilder that was passed in; returned to allow\n     * call chaining\n     */\n    public abstract StringBuilder getGenericSignature(StringBuilder sb);\n    \n    /**\n     * Method for accessing signature without generic\n     * type information, in form compatible with all versions\n     * of JVM, and specifically used for type descriptions\n     * when generating byte code.\n     */\n    public String getErasedSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getErasedSignature(sb);\n        return sb.toString();\n    }\n\n    /**\n     * Method for accessing signature without generic\n     * type information, in form compatible with all versions\n     * of JVM, and specifically used for type descriptions\n     * when generating byte code.\n     * \n     * @param sb StringBuilder to append signature to\n     * \n     * @return StringBuilder that was passed in; returned to allow\n     * call chaining\n     */\n    public abstract StringBuilder getErasedSignature(StringBuilder sb);\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected void _assertSubclass(Class<?> subclass, Class<?> superClass) {\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" is not assignable to \"+_class.getName());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods; let's make them abstract to force override\n    /**********************************************************\n     */\n\n    @Override\n    public abstract String toString();\n\n    @Override\n    public abstract boolean equals(Object o);\n\n    @Override\n    public final int hashCode() { return _hash; }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.ser.BeanSerializerFactory", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n     * thus a single shared global (== singleton) instance can be used\n     * without thread-safety issues.\n     */\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: creation, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for creating instances with specified configuration.\n     */\n    protected BeanSerializerFactory(SerializerFactoryConfig config)\n    {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to attach additional\n     * serializer providers into this serializer factory. This is typically\n     * handled by constructing a new instance with additional serializers,\n     * to ensure thread-safe access.\n     */\n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional serializers, or losing serializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        // [databind#731]: Should skip if nominally java.lang.Object\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        // Then JsonSerializable, @JsonValue etc:\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        \n        // Otherwise, we will check \"primary types\"; both marker types that\n        // indicate specific handling (JsonSerializable), or main types that have\n        // precedence over container types\n        if (ser == null) {\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [Issue#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public methods that are not part of\n    /* JsonSerializerFactory API\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to construct a {@link BeanSerializer} for\n     * given class. Returns null if no properties are found.\n     */\n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First things first: we know some types are not beans...\n        if (!isPotentialBeanType(type.getRawClass())) {\n            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n            //   as per [Issue#24]\n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * non-container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param baseType Declared type to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property values, if one is needed; null if not.\n     */\n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, baseType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n                accessor, config, ai, baseType);\n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param containerType Declared type of the container to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property value contents, if one is needed; null if not.\n     */    \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, contentType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor,\n                config, ai, contentType);\n        return b.buildTypeSerializer(config, contentType, subtypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        }\n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                        typeSer, null, null, /*filterId*/ null);\n            }\n            // TODO: can we find full PropertyName?\n            PropertyName name = new PropertyName(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    /**\n     * Method called to construct a filtered writer, for given view\n     * definitions. Default implementation constructs filter that checks\n     * active view type to views property is to be included in.\n     */\n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n            Class<?>[] inViews)\n    {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n            BeanDescription beanDesc)\n    {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public introspection methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    /**\n     * Method used to collect all actual serializable properties.\n     * Can be overridden to implement custom detection schemes.\n     */\n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder)\n        throws JsonMappingException\n    {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        // [JACKSON-429]: ignore specified types\n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        // and possibly remove ones without matching mutator...\n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        // nothing? can't proceed (caller may or may not throw an exception)\n        if (properties.isEmpty()) {\n            return null;\n        }\n        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            // [JACKSON-762]: type id? Requires special handling:\n            if (property.isTypeId()) {\n                if (accessor != null) { // only add if we can access... but otherwise?\n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            // [JACKSON-235]: suppress writing of back references\n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public methods for manipulating bean properties\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable method that can filter out properties. Default implementation\n     * checks annotations class may have.\n     */\n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Method called to handle view information for constructed serializer,\n     * based on bean property writers.\n     *<p>\n     * Note that this method is designed to be overridden by sub-classes\n     * if they want to provide custom view handling. As such it is not\n     * considered an internal implementation detail, and will be supported\n     * as part of API going forward.\n     */\n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n    {\n        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        // Simple: view information is stored within individual writers, need to combine:\n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { // no view info? include or exclude by default?\n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    /**\n     * Method that will apply by-type limitations (as per [JACKSON-429]);\n     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n     * annotation but can be supplied by module-provided introspectors too.\n     */\n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                // default to false, non-ignorable\n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            // lotsa work, and yes, it is ignorable type, so:\n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method that will remove all properties that do not have a mutator.\n     */\n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            // one caveat: as per [JACKSON-806], only remove implicit properties;\n            // explicitly annotated ones should remain\n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */\n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, TypeBindings typeContext,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n         *  here will NOT be resolved or contextualized, unless done here, so:\n         */\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n     * thus a single shared global (== singleton) instance can be used\n     * without thread-safety issues.\n     */\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: creation, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for creating instances with specified configuration.\n     */\n    protected BeanSerializerFactory(SerializerFactoryConfig config)\n    {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to attach additional\n     * serializer providers into this serializer factory. This is typically\n     * handled by constructing a new instance with additional serializers,\n     * to ensure thread-safe access.\n     */\n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional serializers, or losing serializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        // [databind#731]: Should skip if nominally java.lang.Object\n        if (ser == null && !delegateType.isJavaLangObject()) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        // Then JsonSerializable, @JsonValue etc:\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        \n        // Otherwise, we will check \"primary types\"; both marker types that\n        // indicate specific handling (JsonSerializable), or main types that have\n        // precedence over container types\n        if (ser == null) {\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [Issue#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public methods that are not part of\n    /* JsonSerializerFactory API\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to construct a {@link BeanSerializer} for\n     * given class. Returns null if no properties are found.\n     */\n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First things first: we know some types are not beans...\n        if (!isPotentialBeanType(type.getRawClass())) {\n            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n            //   as per [Issue#24]\n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * non-container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param baseType Declared type to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property values, if one is needed; null if not.\n     */\n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, baseType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n                accessor, config, ai, baseType);\n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param containerType Declared type of the container to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property value contents, if one is needed; null if not.\n     */    \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return createTypeSerializer(config, contentType);\n        }\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor,\n                config, ai, contentType);\n        return b.buildTypeSerializer(config, contentType, subtypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        }\n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                        typeSer, null, null, /*filterId*/ null);\n            }\n            // TODO: can we find full PropertyName?\n            PropertyName name = new PropertyName(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    /**\n     * Method called to construct a filtered writer, for given view\n     * definitions. Default implementation constructs filter that checks\n     * active view type to views property is to be included in.\n     */\n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n            Class<?>[] inViews)\n    {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n            BeanDescription beanDesc)\n    {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public introspection methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    /**\n     * Method used to collect all actual serializable properties.\n     * Can be overridden to implement custom detection schemes.\n     */\n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder)\n        throws JsonMappingException\n    {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        // [JACKSON-429]: ignore specified types\n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        // and possibly remove ones without matching mutator...\n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        // nothing? can't proceed (caller may or may not throw an exception)\n        if (properties.isEmpty()) {\n            return null;\n        }\n        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            // [JACKSON-762]: type id? Requires special handling:\n            if (property.isTypeId()) {\n                if (accessor != null) { // only add if we can access... but otherwise?\n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            // [JACKSON-235]: suppress writing of back references\n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public methods for manipulating bean properties\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable method that can filter out properties. Default implementation\n     * checks annotations class may have.\n     */\n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Method called to handle view information for constructed serializer,\n     * based on bean property writers.\n     *<p>\n     * Note that this method is designed to be overridden by sub-classes\n     * if they want to provide custom view handling. As such it is not\n     * considered an internal implementation detail, and will be supported\n     * as part of API going forward.\n     */\n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n    {\n        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        // Simple: view information is stored within individual writers, need to combine:\n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { // no view info? include or exclude by default?\n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    /**\n     * Method that will apply by-type limitations (as per [JACKSON-429]);\n     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n     * annotation but can be supplied by module-provided introspectors too.\n     */\n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                // default to false, non-ignorable\n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            // lotsa work, and yes, it is ignorable type, so:\n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method that will remove all properties that do not have a mutator.\n     */\n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            // one caveat: as per [JACKSON-806], only remove implicit properties;\n            // explicitly annotated ones should remain\n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */\n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, TypeBindings typeContext,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n         *  here will NOT be resolved or contextualized, unless done here, so:\n         */\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass()) || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.ser.std.BeanSerializerBase", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.Converter;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base class both for the standard bean serializer, and couple\n * of variants that only differ in small details.\n * Can be used for custom bean serializers as well, although that\n * is not the primary design goal.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class BeanSerializerBase\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    protected final static PropertyName NAME_FOR_OBJECT_REF = new PropertyName(\"#object-ref\");\n    \n    final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Writers used for outputting actual property values\n     */\n    final protected BeanPropertyWriter[] _props;\n\n    /**\n     * Optional filters used to suppress output of properties that\n     * are only to be included in certain views\n     */\n    final protected BeanPropertyWriter[] _filteredProps;\n\n    /**\n     * Handler for {@link com.fasterxml.jackson.annotation.JsonAnyGetter}\n     * annotated properties\n     */\n    final protected AnyGetterWriter _anyGetterWriter;\n\n    /**\n     * Id of the bean property filter to use, if any; null if none.\n     */\n    final protected Object _propertyFilterId;\n\n    /**\n     * If using custom type ids (usually via getter, or field), this is the\n     * reference to that member.\n     */\n    final protected AnnotatedMember _typeId;\n\n    /**\n     * If this POJO can be alternatively serialized using just an object id\n     * to denote a reference to previously serialized object,\n     * this Object will handle details.\n     */\n    final protected ObjectIdWriter _objectIdWriter;\n\n    /**\n     * Requested shape from bean class annotations.\n     */\n    final protected JsonFormat.Shape _serializationShape;\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanSerializerBuilder} to create an\n     * instance\n     * \n     * @param type Nominal type of values handled by this serializer\n     * @param builder Builder for accessing other collected information\n     */\n    protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder,\n            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties)\n    {\n        super(type);\n        _props = properties;\n        _filteredProps = filteredProperties;\n        if (builder == null) { // mostly for testing\n            _typeId = null;\n            _anyGetterWriter = null;\n            _propertyFilterId = null;\n            _objectIdWriter = null;\n            _serializationShape = null;\n        } else {\n            _typeId = builder.getTypeId();\n            _anyGetterWriter = builder.getAnyGetter();\n            _propertyFilterId = builder.getFilterId();\n            _objectIdWriter = builder.getObjectIdWriter();\n            JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null);\n            _serializationShape = (format == null) ? null : format.getShape();\n        }\n    }\n\n    public BeanSerializerBase(BeanSerializerBase src,\n            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties)\n    {\n        super(src._handledType);\n        _props = properties;\n        _filteredProps = filteredProperties;\n\n        _typeId = src._typeId;\n        _anyGetterWriter = src._anyGetterWriter;\n        _objectIdWriter = src._objectIdWriter;\n        _propertyFilterId = src._propertyFilterId;\n        _serializationShape = src._serializationShape;\n    }\n\n    protected BeanSerializerBase(BeanSerializerBase src,\n            ObjectIdWriter objectIdWriter)\n    {\n        this(src, objectIdWriter, src._propertyFilterId);\n    }\n    \n    /**\n     * @since 2.3\n     */\n    protected BeanSerializerBase(BeanSerializerBase src,\n            ObjectIdWriter objectIdWriter, Object filterId)\n    {\n        super(src._handledType);\n        _props = src._props;\n        _filteredProps = src._filteredProps;\n        \n        _typeId = src._typeId;\n        _anyGetterWriter = src._anyGetterWriter;\n        _objectIdWriter = objectIdWriter;\n        _propertyFilterId = filterId;\n        _serializationShape = src._serializationShape;\n    }\n\n    protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore)\n    {\n        super(src._handledType);\n\n        // Bit clumsy, but has to do:\n        HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore);\n        final BeanPropertyWriter[] propsIn = src._props;\n        final BeanPropertyWriter[] fpropsIn = src._filteredProps;\n        final int len = propsIn.length;\n\n        ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len);\n        ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len);\n\n        for (int i = 0; i < len; ++i) {\n            BeanPropertyWriter bpw = propsIn[i];\n            // should be ignored?\n            if (ignoredSet.contains(bpw.getName())) {\n                continue;\n            }\n            propsOut.add(bpw);\n            if (fpropsIn != null) {\n                fpropsOut.add(fpropsIn[i]);\n            }\n        }\n        _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]);\n        _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]);\n        \n        _typeId = src._typeId;\n        _anyGetterWriter = src._anyGetterWriter;\n        _objectIdWriter = src._objectIdWriter;\n        _propertyFilterId = src._propertyFilterId;\n        _serializationShape = src._serializationShape;\n    }\n    \n    /**\n     * Mutant factory used for creating a new instance with different\n     * {@link ObjectIdWriter}.\n     * \n     * @since 2.0\n     */\n    public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n\n    /**\n     * Mutant factory used for creating a new instance with additional\n     * set of properties to ignore (from properties this instance otherwise has)\n     * \n     * @since 2.0\n     */\n    protected abstract BeanSerializerBase withIgnorals(String[] toIgnore);\n\n    /**\n     * Mutant factory for creating a variant that output POJO as a\n     * JSON Array. Implementations may ignore this request if output\n     * as array is not possible (either at all, or reliably).\n     * \n     * @since 2.1\n     */\n    protected abstract BeanSerializerBase asArraySerializer();\n\n    /**\n     * Mutant factory used for creating a new instance with different\n     * filter id (used with <code>JsonFilter</code> annotation)\n     * \n     * @since 2.3\n     */\n    protected abstract BeanSerializerBase withFilterId(Object filterId);\n    \n    /**\n     * Copy-constructor that is useful for sub-classes that just want to\n     * copy all super-class properties without modifications.\n     */\n    protected BeanSerializerBase(BeanSerializerBase src) {\n        this(src, src._props, src._filteredProps);\n    }\n\n    /**\n     * Copy-constructor that will also rename properties with given prefix\n     * (if it's non-empty)\n     */\n    protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper) {\n        this(src, rename(src._props, unwrapper), rename(src._filteredProps, unwrapper));\n    }\n    \n    private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props,\n            NameTransformer transformer)\n    {\n        if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) {\n            return props;\n        }\n        final int len = props.length;\n        BeanPropertyWriter[] result = new BeanPropertyWriter[len];\n        for (int i = 0; i < len; ++i) {\n            BeanPropertyWriter bpw = props[i];\n            if (bpw != null) {\n                result[i] = bpw.rename(transformer);\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Post-constriction processing: resolvable, contextual\n    /**********************************************************\n     */\n\n    /**\n     * We need to implement {@link ResolvableSerializer} to be able to\n     * properly handle cyclic type references.\n     */\n    @Override\n    public void resolve(SerializerProvider provider)\n        throws JsonMappingException\n    {\n        int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter prop = _props[i];\n            // let's start with null serializer resolution actually\n            if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) {\n                JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop);\n                if (nullSer != null) {\n                    prop.assignNullSerializer(nullSer);\n                    // also: remember to replace filtered property too? (see [JACKSON-364])\n                    if (i < filteredCount) {\n                        BeanPropertyWriter w2 = _filteredProps[i];\n                        if (w2 != null) {\n                            w2.assignNullSerializer(nullSer);\n                        }\n                    }\n                }\n            }\n            \n            if (prop.hasSerializer()) {\n                continue;\n            }\n            // [Issue#124]: allow use of converters\n            JsonSerializer<Object> ser = findConvertingSerializer(provider, prop);\n            if (ser == null) {\n                // Was the serialization type hard-coded? If so, use it\n                JavaType type = prop.getSerializationType();\n                \n                // It not, we can use declared return type if and only if declared type is final:\n                // if not, we don't really know the actual type until we get the instance.\n                if (type == null) {\n                    type = provider.constructType(prop.getGenericPropertyType());\n                    if (!type.isFinal()) {\n                        if (type.isContainerType() || type.containedTypeCount() > 0) {\n                            prop.setNonTrivialBaseType(type);\n                        }\n                        continue;\n                    }\n                }\n                ser = provider.findValueSerializer(type, prop);\n                /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n                 *   too, earlier; if so, it's time to connect the dots here:\n                 */\n                if (type.isContainerType()) {\n                    TypeSerializer typeSer = type.getContentType().getTypeHandler();\n                    if (typeSer != null) {\n                        // for now, can do this only for standard containers...\n                        if (ser instanceof ContainerSerializer<?>) {\n                            // ugly casts... but necessary\n                            @SuppressWarnings(\"unchecked\")\n                            JsonSerializer<Object> ser2 = (JsonSerializer<Object>)((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer);\n                            ser = ser2;\n                        }\n                    }\n                }\n            }\n            prop.assignSerializer(ser);\n            // and maybe replace filtered property too? (see [JACKSON-364])\n            if (i < filteredCount) {\n                BeanPropertyWriter w2 = _filteredProps[i];\n                if (w2 != null) {\n                    w2.assignSerializer(ser);\n                }\n            }\n        }\n\n        // also, any-getter may need to be resolved\n        if (_anyGetterWriter != null) {\n            // 23-Feb-2015, tatu: Misleading, as this actually triggers call to contextualization...\n            _anyGetterWriter.resolve(provider);\n        }\n    }\n\n    /**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n            BeanPropertyWriter prop)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                    return new StdDelegatingSerializer(conv, delegateType, ser);\n                }\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"incomplete-switch\")\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        final SerializationConfig config = provider.getConfig();\n        \n        // Let's start with one big transmutation: Enums that are annotated\n        // to serialize as Objects may want to revert\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n                // or, alternatively, asked to revert \"back to\" other representations...\n                if (shape != _serializationShape) {\n                    if (_handledType.isEnum()) {\n                        switch (shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n                                    provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        }\n                    }\n                }\n            }\n        }\n\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        Object newFilterId = null;\n        \n        // Then we may have an override for Object Id\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo == null) {\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor,\n                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName().getSimpleName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n            \n            // Or change Filter Id in use?\n            Object filterId = intr.findFilterId(accessor);\n            if (filterId != null) {\n                // but only consider case of adding a new filter id (no removal via annotation)\n                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                    newFilterId = filterId;\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        if (newFilterId != null) {\n            contextual = contextual.withFilterId(newFilterId);\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            return contextual.asArraySerializer();\n        }\n        return contextual;\n    }\n    \n    /*\n    /**********************************************************\n    /* Partial JsonSerializer implementation\n    /**********************************************************\n     */\n\n    @Override\n    public boolean usesObjectId() {\n        return (_objectIdWriter != null);\n    }\n    \n    // Main serialization method left unimplemented\n    @Override\n    public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n        throws IOException;\n\n    // Type-info-augmented case implemented as it does not usually differ between impls\n    @Override\n    public void serializeWithType(Object bean, JsonGenerator gen,\n            SerializerProvider provider, TypeSerializer typeSer)\n        throws IOException\n    {\n        if (_objectIdWriter != null) {\n            _serializeWithObjectId(bean, gen, provider, typeSer);\n            return;\n        }\n\n        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n        if (typeStr == null) {\n            typeSer.writeTypePrefixForObject(bean, gen);\n        } else {\n            typeSer.writeCustomTypePrefixForObject(bean, gen, typeStr);\n        }\n        if (_propertyFilterId != null) {\n            serializeFieldsFiltered(bean, gen, provider);\n        } else {\n            serializeFields(bean, gen, provider);\n        }\n        if (typeStr == null) {\n            typeSer.writeTypeSuffixForObject(bean, gen);\n        } else {\n            typeSer.writeCustomTypeSuffixForObject(bean, gen, typeStr);\n        }\n    }\n\n    protected final void _serializeWithObjectId(Object bean,\n            JsonGenerator jgen, SerializerProvider provider,\n            boolean startEndObject)\n        throws IOException, JsonGenerationException\n    {\n        final ObjectIdWriter w = _objectIdWriter;\n        WritableObjectId objectId = provider.findObjectId(bean, w.generator);\n        // If possible, write as id already\n        if (objectId.writeAsId(jgen, provider, w)) {\n            return;\n        }\n        // If not, need to inject the id:\n        Object id = objectId.generateId(bean);\n        if (w.alwaysAsId) {\n            w.serializer.serialize(id, jgen, provider);\n            return;\n        }\n        if (startEndObject) {\n            jgen.writeStartObject();\n        }\n        objectId.writeAsField(jgen, provider, w);\n        if (_propertyFilterId != null) {\n            serializeFieldsFiltered(bean, jgen, provider);\n        } else {\n            serializeFields(bean, jgen, provider);\n        }\n        if (startEndObject) {\n            jgen.writeEndObject();\n        }\n    }\n    \n    protected final void _serializeWithObjectId(Object bean,\n            JsonGenerator jgen, SerializerProvider provider,\n            TypeSerializer typeSer)\n        throws IOException, JsonGenerationException\n    {\n        final ObjectIdWriter w = _objectIdWriter;\n        WritableObjectId objectId = provider.findObjectId(bean, w.generator);\n        // If possible, write as id already\n        if (objectId.writeAsId(jgen, provider, w)) {\n            return;\n        }\n        // If not, need to inject the id:\n        Object id = objectId.generateId(bean);\n        if (w.alwaysAsId) {\n            w.serializer.serialize(id, jgen, provider);\n            return;\n        }\n\n        _serializeObjectId(bean, jgen, provider, typeSer, objectId);\n    }\n\n    protected  void _serializeObjectId(Object bean,\n            JsonGenerator jgen,SerializerProvider provider,\n            TypeSerializer typeSer, WritableObjectId objectId)\n        throws IOException, JsonProcessingException, JsonGenerationException {\n        final ObjectIdWriter w = _objectIdWriter;\n        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n        if (typeStr == null) {\n            typeSer.writeTypePrefixForObject(bean, jgen);\n        } else {\n            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n        }\n        objectId.writeAsField(jgen, provider, w);\n        if (_propertyFilterId != null) {\n            serializeFieldsFiltered(bean, jgen, provider);\n        } else {\n            serializeFields(bean, jgen, provider);\n        }\n        if (typeStr == null) {\n            typeSer.writeTypeSuffixForObject(bean, jgen);\n        } else {\n            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n        }\n    }\n    \n    protected final String _customTypeId(Object bean)\n    {\n        final Object typeId = _typeId.getValue(bean);\n        if (typeId == null) {\n            return \"\";\n        }\n        return (typeId instanceof String) ? (String) typeId : typeId.toString();\n    }\n    \n    /*\n    /**********************************************************\n    /* Field serialization methods\n    /**********************************************************\n     */\n\n    protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n        throws IOException, JsonGenerationException\n    {\n        final BeanPropertyWriter[] props;\n        if (_filteredProps != null && provider.getActiveView() != null) {\n            props = _filteredProps;\n        } else {\n            props = _props;\n        }\n        int i = 0;\n        try {\n            for (final int len = props.length; i < len; ++i) {\n                BeanPropertyWriter prop = props[i];\n                if (prop != null) { // can have nulls in filtered list\n                    prop.serializeAsField(bean, jgen, provider);\n                }\n            }\n            if (_anyGetterWriter != null) {\n                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n            }\n        } catch (Exception e) {\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            wrapAndThrow(provider, e, bean, name);\n        } catch (StackOverflowError e) {\n            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n             *   have many stack frames to spare... just one or two; can't\n             *   make many calls.\n             */\n            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n            throw mapE;\n        }\n    }\n\n    /**\n     * Alternative serialization method that gets called when there is a\n     * {@link PropertyFilter} that needs to be called to determine\n     * which properties are to be serialized (and possibly how)\n     */\n    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen,\n            SerializerProvider provider)\n        throws IOException, JsonGenerationException\n    {\n        /* note: almost verbatim copy of \"serializeFields\"; copied (instead of merged)\n         * so that old method need not add check for existence of filter.\n         */\n        final BeanPropertyWriter[] props;\n        if (_filteredProps != null && provider.getActiveView() != null) {\n            props = _filteredProps;\n        } else {\n            props = _props;\n        }\n        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n        // better also allow missing filter actually..\n        if (filter == null) {\n            serializeFields(bean, jgen, provider);\n            return;\n        }\n        int i = 0;\n        try {\n            for (final int len = props.length; i < len; ++i) {\n                BeanPropertyWriter prop = props[i];\n                if (prop != null) { // can have nulls in filtered list\n                    filter.serializeAsField(bean, jgen, provider, prop);\n                }\n            }\n            if (_anyGetterWriter != null) {\n                _anyGetterWriter.getAndFilter(bean, jgen, provider, filter);\n            }\n        } catch (Exception e) {\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            wrapAndThrow(provider, e, bean, name);\n        } catch (StackOverflowError e) {\n            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n            throw mapE;\n        }\n    }\n\n    @Deprecated\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException\n    {\n        ObjectNode o = createSchemaNode(\"object\", true);\n        // [JACKSON-813]: Add optional JSON Schema id attribute, if found\n        // NOTE: not optimal, does NOT go through AnnotationIntrospector etc:\n        JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class);\n        if (ann != null) {\n            String id = ann.id();\n            if (id != null && id.length() > 0) {\n                o.put(\"id\", id);\n            }\n        }\n \n        //todo: should the classname go in the title?\n        //o.put(\"title\", _className);\n        ObjectNode propertiesNode = o.objectNode();\n        final PropertyFilter filter;\n        if (_propertyFilterId != null) {\n            filter = findPropertyFilter(provider, _propertyFilterId, null);\n        } else {\n            filter = null;\n        }\n        \t\t\n        for (int i = 0; i < _props.length; i++) {\n            BeanPropertyWriter prop = _props[i];\n            if (filter == null) {\n                prop.depositSchemaProperty(propertiesNode, provider);\n            } else {\n                filter.depositSchemaProperty(prop, propertiesNode, provider);\n            }\n\n        }\n        o.put(\"properties\", propertiesNode);\n        return o;\n    }\n    \n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        //deposit your output format \n        if (visitor == null) {\n            return;\n        }\n        JsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n        if (objectVisitor == null) {\n            return;\n        }\n        if (_propertyFilterId != null) {\n            PropertyFilter filter = findPropertyFilter(visitor.getProvider(),\n                    _propertyFilterId, null);\n            for (int i = 0; i < _props.length; i++) {\n                filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());\n            }\n        } else {\n            for (int i = 0; i < _props.length; i++) {\n                _props[i].depositSchemaProperty(objectVisitor);\n            }\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.Converter;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base class both for the standard bean serializer, and couple\n * of variants that only differ in small details.\n * Can be used for custom bean serializers as well, although that\n * is not the primary design goal.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class BeanSerializerBase\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    protected final static PropertyName NAME_FOR_OBJECT_REF = new PropertyName(\"#object-ref\");\n    \n    final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Writers used for outputting actual property values\n     */\n    final protected BeanPropertyWriter[] _props;\n\n    /**\n     * Optional filters used to suppress output of properties that\n     * are only to be included in certain views\n     */\n    final protected BeanPropertyWriter[] _filteredProps;\n\n    /**\n     * Handler for {@link com.fasterxml.jackson.annotation.JsonAnyGetter}\n     * annotated properties\n     */\n    final protected AnyGetterWriter _anyGetterWriter;\n\n    /**\n     * Id of the bean property filter to use, if any; null if none.\n     */\n    final protected Object _propertyFilterId;\n\n    /**\n     * If using custom type ids (usually via getter, or field), this is the\n     * reference to that member.\n     */\n    final protected AnnotatedMember _typeId;\n\n    /**\n     * If this POJO can be alternatively serialized using just an object id\n     * to denote a reference to previously serialized object,\n     * this Object will handle details.\n     */\n    final protected ObjectIdWriter _objectIdWriter;\n\n    /**\n     * Requested shape from bean class annotations.\n     */\n    final protected JsonFormat.Shape _serializationShape;\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanSerializerBuilder} to create an\n     * instance\n     * \n     * @param type Nominal type of values handled by this serializer\n     * @param builder Builder for accessing other collected information\n     */\n    protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder,\n            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties)\n    {\n        super(type);\n        _props = properties;\n        _filteredProps = filteredProperties;\n        if (builder == null) { // mostly for testing\n            _typeId = null;\n            _anyGetterWriter = null;\n            _propertyFilterId = null;\n            _objectIdWriter = null;\n            _serializationShape = null;\n        } else {\n            _typeId = builder.getTypeId();\n            _anyGetterWriter = builder.getAnyGetter();\n            _propertyFilterId = builder.getFilterId();\n            _objectIdWriter = builder.getObjectIdWriter();\n            JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null);\n            _serializationShape = (format == null) ? null : format.getShape();\n        }\n    }\n\n    public BeanSerializerBase(BeanSerializerBase src,\n            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties)\n    {\n        super(src._handledType);\n        _props = properties;\n        _filteredProps = filteredProperties;\n\n        _typeId = src._typeId;\n        _anyGetterWriter = src._anyGetterWriter;\n        _objectIdWriter = src._objectIdWriter;\n        _propertyFilterId = src._propertyFilterId;\n        _serializationShape = src._serializationShape;\n    }\n\n    protected BeanSerializerBase(BeanSerializerBase src,\n            ObjectIdWriter objectIdWriter)\n    {\n        this(src, objectIdWriter, src._propertyFilterId);\n    }\n    \n    /**\n     * @since 2.3\n     */\n    protected BeanSerializerBase(BeanSerializerBase src,\n            ObjectIdWriter objectIdWriter, Object filterId)\n    {\n        super(src._handledType);\n        _props = src._props;\n        _filteredProps = src._filteredProps;\n        \n        _typeId = src._typeId;\n        _anyGetterWriter = src._anyGetterWriter;\n        _objectIdWriter = objectIdWriter;\n        _propertyFilterId = filterId;\n        _serializationShape = src._serializationShape;\n    }\n\n    protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore)\n    {\n        super(src._handledType);\n\n        // Bit clumsy, but has to do:\n        HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore);\n        final BeanPropertyWriter[] propsIn = src._props;\n        final BeanPropertyWriter[] fpropsIn = src._filteredProps;\n        final int len = propsIn.length;\n\n        ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len);\n        ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len);\n\n        for (int i = 0; i < len; ++i) {\n            BeanPropertyWriter bpw = propsIn[i];\n            // should be ignored?\n            if (ignoredSet.contains(bpw.getName())) {\n                continue;\n            }\n            propsOut.add(bpw);\n            if (fpropsIn != null) {\n                fpropsOut.add(fpropsIn[i]);\n            }\n        }\n        _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]);\n        _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]);\n        \n        _typeId = src._typeId;\n        _anyGetterWriter = src._anyGetterWriter;\n        _objectIdWriter = src._objectIdWriter;\n        _propertyFilterId = src._propertyFilterId;\n        _serializationShape = src._serializationShape;\n    }\n    \n    /**\n     * Mutant factory used for creating a new instance with different\n     * {@link ObjectIdWriter}.\n     * \n     * @since 2.0\n     */\n    public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n\n    /**\n     * Mutant factory used for creating a new instance with additional\n     * set of properties to ignore (from properties this instance otherwise has)\n     * \n     * @since 2.0\n     */\n    protected abstract BeanSerializerBase withIgnorals(String[] toIgnore);\n\n    /**\n     * Mutant factory for creating a variant that output POJO as a\n     * JSON Array. Implementations may ignore this request if output\n     * as array is not possible (either at all, or reliably).\n     * \n     * @since 2.1\n     */\n    protected abstract BeanSerializerBase asArraySerializer();\n\n    /**\n     * Mutant factory used for creating a new instance with different\n     * filter id (used with <code>JsonFilter</code> annotation)\n     * \n     * @since 2.3\n     */\n    protected abstract BeanSerializerBase withFilterId(Object filterId);\n    \n    /**\n     * Copy-constructor that is useful for sub-classes that just want to\n     * copy all super-class properties without modifications.\n     */\n    protected BeanSerializerBase(BeanSerializerBase src) {\n        this(src, src._props, src._filteredProps);\n    }\n\n    /**\n     * Copy-constructor that will also rename properties with given prefix\n     * (if it's non-empty)\n     */\n    protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper) {\n        this(src, rename(src._props, unwrapper), rename(src._filteredProps, unwrapper));\n    }\n    \n    private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props,\n            NameTransformer transformer)\n    {\n        if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) {\n            return props;\n        }\n        final int len = props.length;\n        BeanPropertyWriter[] result = new BeanPropertyWriter[len];\n        for (int i = 0; i < len; ++i) {\n            BeanPropertyWriter bpw = props[i];\n            if (bpw != null) {\n                result[i] = bpw.rename(transformer);\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Post-constriction processing: resolvable, contextual\n    /**********************************************************\n     */\n\n    /**\n     * We need to implement {@link ResolvableSerializer} to be able to\n     * properly handle cyclic type references.\n     */\n    @Override\n    public void resolve(SerializerProvider provider)\n        throws JsonMappingException\n    {\n        int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter prop = _props[i];\n            // let's start with null serializer resolution actually\n            if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) {\n                JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop);\n                if (nullSer != null) {\n                    prop.assignNullSerializer(nullSer);\n                    // also: remember to replace filtered property too? (see [JACKSON-364])\n                    if (i < filteredCount) {\n                        BeanPropertyWriter w2 = _filteredProps[i];\n                        if (w2 != null) {\n                            w2.assignNullSerializer(nullSer);\n                        }\n                    }\n                }\n            }\n            \n            if (prop.hasSerializer()) {\n                continue;\n            }\n            // [Issue#124]: allow use of converters\n            JsonSerializer<Object> ser = findConvertingSerializer(provider, prop);\n            if (ser == null) {\n                // Was the serialization type hard-coded? If so, use it\n                JavaType type = prop.getSerializationType();\n                \n                // It not, we can use declared return type if and only if declared type is final:\n                // if not, we don't really know the actual type until we get the instance.\n                if (type == null) {\n                    type = provider.constructType(prop.getGenericPropertyType());\n                    if (!type.isFinal()) {\n                        if (type.isContainerType() || type.containedTypeCount() > 0) {\n                            prop.setNonTrivialBaseType(type);\n                        }\n                        continue;\n                    }\n                }\n                ser = provider.findValueSerializer(type, prop);\n                /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n                 *   too, earlier; if so, it's time to connect the dots here:\n                 */\n                if (type.isContainerType()) {\n                    TypeSerializer typeSer = type.getContentType().getTypeHandler();\n                    if (typeSer != null) {\n                        // for now, can do this only for standard containers...\n                        if (ser instanceof ContainerSerializer<?>) {\n                            // ugly casts... but necessary\n                            @SuppressWarnings(\"unchecked\")\n                            JsonSerializer<Object> ser2 = (JsonSerializer<Object>)((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer);\n                            ser = ser2;\n                        }\n                    }\n                }\n            }\n            prop.assignSerializer(ser);\n            // and maybe replace filtered property too? (see [JACKSON-364])\n            if (i < filteredCount) {\n                BeanPropertyWriter w2 = _filteredProps[i];\n                if (w2 != null) {\n                    w2.assignSerializer(ser);\n                }\n            }\n        }\n\n        // also, any-getter may need to be resolved\n        if (_anyGetterWriter != null) {\n            // 23-Feb-2015, tatu: Misleading, as this actually triggers call to contextualization...\n            _anyGetterWriter.resolve(provider);\n        }\n    }\n\n    /**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n            BeanPropertyWriter prop)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null\n                            : provider.findValueSerializer(delegateType, prop);\n                    return new StdDelegatingSerializer(conv, delegateType, ser);\n                }\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"incomplete-switch\")\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        final SerializationConfig config = provider.getConfig();\n        \n        // Let's start with one big transmutation: Enums that are annotated\n        // to serialize as Objects may want to revert\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n                // or, alternatively, asked to revert \"back to\" other representations...\n                if (shape != _serializationShape) {\n                    if (_handledType.isEnum()) {\n                        switch (shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n                                    provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        }\n                    }\n                }\n            }\n        }\n\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        Object newFilterId = null;\n        \n        // Then we may have an override for Object Id\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo == null) {\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor,\n                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName().getSimpleName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n            \n            // Or change Filter Id in use?\n            Object filterId = intr.findFilterId(accessor);\n            if (filterId != null) {\n                // but only consider case of adding a new filter id (no removal via annotation)\n                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                    newFilterId = filterId;\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        if (newFilterId != null) {\n            contextual = contextual.withFilterId(newFilterId);\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            return contextual.asArraySerializer();\n        }\n        return contextual;\n    }\n    \n    /*\n    /**********************************************************\n    /* Partial JsonSerializer implementation\n    /**********************************************************\n     */\n\n    @Override\n    public boolean usesObjectId() {\n        return (_objectIdWriter != null);\n    }\n    \n    // Main serialization method left unimplemented\n    @Override\n    public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n        throws IOException;\n\n    // Type-info-augmented case implemented as it does not usually differ between impls\n    @Override\n    public void serializeWithType(Object bean, JsonGenerator gen,\n            SerializerProvider provider, TypeSerializer typeSer)\n        throws IOException\n    {\n        if (_objectIdWriter != null) {\n            _serializeWithObjectId(bean, gen, provider, typeSer);\n            return;\n        }\n\n        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n        if (typeStr == null) {\n            typeSer.writeTypePrefixForObject(bean, gen);\n        } else {\n            typeSer.writeCustomTypePrefixForObject(bean, gen, typeStr);\n        }\n        if (_propertyFilterId != null) {\n            serializeFieldsFiltered(bean, gen, provider);\n        } else {\n            serializeFields(bean, gen, provider);\n        }\n        if (typeStr == null) {\n            typeSer.writeTypeSuffixForObject(bean, gen);\n        } else {\n            typeSer.writeCustomTypeSuffixForObject(bean, gen, typeStr);\n        }\n    }\n\n    protected final void _serializeWithObjectId(Object bean,\n            JsonGenerator jgen, SerializerProvider provider,\n            boolean startEndObject)\n        throws IOException, JsonGenerationException\n    {\n        final ObjectIdWriter w = _objectIdWriter;\n        WritableObjectId objectId = provider.findObjectId(bean, w.generator);\n        // If possible, write as id already\n        if (objectId.writeAsId(jgen, provider, w)) {\n            return;\n        }\n        // If not, need to inject the id:\n        Object id = objectId.generateId(bean);\n        if (w.alwaysAsId) {\n            w.serializer.serialize(id, jgen, provider);\n            return;\n        }\n        if (startEndObject) {\n            jgen.writeStartObject();\n        }\n        objectId.writeAsField(jgen, provider, w);\n        if (_propertyFilterId != null) {\n            serializeFieldsFiltered(bean, jgen, provider);\n        } else {\n            serializeFields(bean, jgen, provider);\n        }\n        if (startEndObject) {\n            jgen.writeEndObject();\n        }\n    }\n    \n    protected final void _serializeWithObjectId(Object bean,\n            JsonGenerator jgen, SerializerProvider provider,\n            TypeSerializer typeSer)\n        throws IOException, JsonGenerationException\n    {\n        final ObjectIdWriter w = _objectIdWriter;\n        WritableObjectId objectId = provider.findObjectId(bean, w.generator);\n        // If possible, write as id already\n        if (objectId.writeAsId(jgen, provider, w)) {\n            return;\n        }\n        // If not, need to inject the id:\n        Object id = objectId.generateId(bean);\n        if (w.alwaysAsId) {\n            w.serializer.serialize(id, jgen, provider);\n            return;\n        }\n\n        _serializeObjectId(bean, jgen, provider, typeSer, objectId);\n    }\n\n    protected  void _serializeObjectId(Object bean,\n            JsonGenerator jgen,SerializerProvider provider,\n            TypeSerializer typeSer, WritableObjectId objectId)\n        throws IOException, JsonProcessingException, JsonGenerationException {\n        final ObjectIdWriter w = _objectIdWriter;\n        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n        if (typeStr == null) {\n            typeSer.writeTypePrefixForObject(bean, jgen);\n        } else {\n            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n        }\n        objectId.writeAsField(jgen, provider, w);\n        if (_propertyFilterId != null) {\n            serializeFieldsFiltered(bean, jgen, provider);\n        } else {\n            serializeFields(bean, jgen, provider);\n        }\n        if (typeStr == null) {\n            typeSer.writeTypeSuffixForObject(bean, jgen);\n        } else {\n            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n        }\n    }\n    \n    protected final String _customTypeId(Object bean)\n    {\n        final Object typeId = _typeId.getValue(bean);\n        if (typeId == null) {\n            return \"\";\n        }\n        return (typeId instanceof String) ? (String) typeId : typeId.toString();\n    }\n    \n    /*\n    /**********************************************************\n    /* Field serialization methods\n    /**********************************************************\n     */\n\n    protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n        throws IOException, JsonGenerationException\n    {\n        final BeanPropertyWriter[] props;\n        if (_filteredProps != null && provider.getActiveView() != null) {\n            props = _filteredProps;\n        } else {\n            props = _props;\n        }\n        int i = 0;\n        try {\n            for (final int len = props.length; i < len; ++i) {\n                BeanPropertyWriter prop = props[i];\n                if (prop != null) { // can have nulls in filtered list\n                    prop.serializeAsField(bean, jgen, provider);\n                }\n            }\n            if (_anyGetterWriter != null) {\n                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n            }\n        } catch (Exception e) {\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            wrapAndThrow(provider, e, bean, name);\n        } catch (StackOverflowError e) {\n            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n             *   have many stack frames to spare... just one or two; can't\n             *   make many calls.\n             */\n            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n            throw mapE;\n        }\n    }\n\n    /**\n     * Alternative serialization method that gets called when there is a\n     * {@link PropertyFilter} that needs to be called to determine\n     * which properties are to be serialized (and possibly how)\n     */\n    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen,\n            SerializerProvider provider)\n        throws IOException, JsonGenerationException\n    {\n        /* note: almost verbatim copy of \"serializeFields\"; copied (instead of merged)\n         * so that old method need not add check for existence of filter.\n         */\n        final BeanPropertyWriter[] props;\n        if (_filteredProps != null && provider.getActiveView() != null) {\n            props = _filteredProps;\n        } else {\n            props = _props;\n        }\n        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n        // better also allow missing filter actually..\n        if (filter == null) {\n            serializeFields(bean, jgen, provider);\n            return;\n        }\n        int i = 0;\n        try {\n            for (final int len = props.length; i < len; ++i) {\n                BeanPropertyWriter prop = props[i];\n                if (prop != null) { // can have nulls in filtered list\n                    filter.serializeAsField(bean, jgen, provider, prop);\n                }\n            }\n            if (_anyGetterWriter != null) {\n                _anyGetterWriter.getAndFilter(bean, jgen, provider, filter);\n            }\n        } catch (Exception e) {\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            wrapAndThrow(provider, e, bean, name);\n        } catch (StackOverflowError e) {\n            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n            throw mapE;\n        }\n    }\n\n    @Deprecated\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException\n    {\n        ObjectNode o = createSchemaNode(\"object\", true);\n        // [JACKSON-813]: Add optional JSON Schema id attribute, if found\n        // NOTE: not optimal, does NOT go through AnnotationIntrospector etc:\n        JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class);\n        if (ann != null) {\n            String id = ann.id();\n            if (id != null && id.length() > 0) {\n                o.put(\"id\", id);\n            }\n        }\n \n        //todo: should the classname go in the title?\n        //o.put(\"title\", _className);\n        ObjectNode propertiesNode = o.objectNode();\n        final PropertyFilter filter;\n        if (_propertyFilterId != null) {\n            filter = findPropertyFilter(provider, _propertyFilterId, null);\n        } else {\n            filter = null;\n        }\n        \t\t\n        for (int i = 0; i < _props.length; i++) {\n            BeanPropertyWriter prop = _props[i];\n            if (filter == null) {\n                prop.depositSchemaProperty(propertiesNode, provider);\n            } else {\n                filter.depositSchemaProperty(prop, propertiesNode, provider);\n            }\n\n        }\n        o.put(\"properties\", propertiesNode);\n        return o;\n    }\n    \n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        //deposit your output format \n        if (visitor == null) {\n            return;\n        }\n        JsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n        if (objectVisitor == null) {\n            return;\n        }\n        if (_propertyFilterId != null) {\n            PropertyFilter filter = findPropertyFilter(visitor.getProvider(),\n                    _propertyFilterId, null);\n            for (int i = 0; i < _props.length; i++) {\n                filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());\n            }\n        } else {\n            for (int i = 0; i < _props.length; i++) {\n                _props[i].depositSchemaProperty(objectVisitor);\n            }\n        }\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\nimport com.fasterxml.jackson.databind.ser.ResolvableSerializer;\nimport com.fasterxml.jackson.databind.util.Converter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\n\n/**\n * Serializer implementation where given Java type is first converted\n * to an intermediate \"delegate type\" (using a configured\n * {@link Converter}, and then this delegate value is serialized by Jackson.\n *<p>\n * Note that although types may be related, they must not be same; trying\n * to do this will result in an exception.\n *\n * @since 2.1\n */\n@SuppressWarnings(\"serial\")\npublic class StdDelegatingSerializer\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    protected final Converter<Object,?> _converter;\n\n    /**\n     * Fully resolved delegate type, with generic information if any available.\n     */\n    protected final JavaType _delegateType;\n    \n    /**\n     * Underlying serializer for type <code>T<.code>.\n     */\n    protected final JsonSerializer<Object> _delegateSerializer;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public StdDelegatingSerializer(Converter<?,?> converter)\n    {\n        super(Object.class);\n        _converter = (Converter<Object,?>)converter;\n        _delegateType = null;\n        _delegateSerializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter)\n    {\n        super(cls, false);\n        _converter = (Converter<Object,?>)converter;\n        _delegateType = null;\n        _delegateSerializer = null;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public StdDelegatingSerializer(Converter<Object,?> converter,\n            JavaType delegateType, JsonSerializer<?> delegateSerializer)\n    {\n        super(delegateType);\n        _converter = converter;\n        _delegateType = delegateType;\n        _delegateSerializer = (JsonSerializer<Object>) delegateSerializer;\n    }\n\n    /**\n     * Method used for creating resolved contextual instances. Must be\n     * overridden when sub-classing.\n     */\n    protected StdDelegatingSerializer withDelegate(Converter<Object,?> converter,\n            JavaType delegateType, JsonSerializer<?> delegateSerializer)\n    {\n        if (getClass() != StdDelegatingSerializer.class) {\n            throw new IllegalStateException(\"Sub-class \"+getClass().getName()+\" must override 'withDelegate'\");\n        }\n        return new StdDelegatingSerializer(converter, delegateType, delegateSerializer);\n    }\n    \n    /*\n    /**********************************************************\n    /* Contextualization\n    /**********************************************************\n     */\n\n    @Override\n    public void resolve(SerializerProvider provider) throws JsonMappingException\n    {\n        if ((_delegateSerializer != null)\n                && (_delegateSerializer instanceof ResolvableSerializer)) {\n            ((ResolvableSerializer) _delegateSerializer).resolve(provider);\n        }\n    }\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> delSer = _delegateSerializer;\n        JavaType delegateType = _delegateType;\n\n        if (delSer == null) {\n            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n            if (delegateType == null) {\n                delegateType = _converter.getOutputType(provider.getTypeFactory());\n            }\n            /* 02-Apr-2015, tatu: For \"dynamic case\", where type is only specified as\n             *    java.lang.Object (or missing generic), [databind#731]\n             */\n                delSer = provider.findValueSerializer(delegateType);\n        }\n        if (delSer instanceof ContextualSerializer) {\n            delSer = provider.handleSecondaryContextualization(delSer, property);\n        }\n        return (delSer == _delegateSerializer) ? this\n                : withDelegate(_converter, delegateType, delSer);\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    protected Converter<Object, ?> getConverter() {\n        return _converter;\n    }\n\n    @Override\n    public JsonSerializer<?> getDelegatee() {\n        return _delegateSerializer;\n    }\n    \n    /*\n    /**********************************************************\n    /* Serialization\n    /**********************************************************\n     */\n\n    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n    {\n        Object delegateValue = convertValue(value);\n        // should we accept nulls?\n        if (delegateValue == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n        _delegateSerializer.serialize(delegateValue, gen, provider);\n    }\n\n    @Override\n    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer) throws IOException\n    {\n        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,\n         *    let's give it a chance?\n         */\n        Object delegateValue = convertValue(value);\n        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n    }\n\n    @Override\n    @Deprecated // since 2.5\n    public boolean isEmpty(Object value)\n    {\n        Object delegateValue = convertValue(value);\n        return _delegateSerializer.isEmpty(delegateValue);\n    }\n\n    @Override\n    public boolean isEmpty(SerializerProvider prov, Object value)\n    {\n        Object delegateValue = convertValue(value);\n        return _delegateSerializer.isEmpty(prov, delegateValue);\n    }\n\n    /*\n    /**********************************************************\n    /* Schema functionality\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException\n    {\n        if (_delegateSerializer instanceof SchemaAware) {\n            return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint);\n        }\n        return super.getSchema(provider, typeHint);\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint,\n        boolean isOptional) throws JsonMappingException\n    {\n        if (_delegateSerializer instanceof SchemaAware) {\n            return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint, isOptional);\n        }\n        return super.getSchema(provider, typeHint);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n         *    properly... but for now, try this:\n         */\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to convert from source Java value into delegate\n     * value (which will be serialized using standard Jackson serializer for delegate type)\n     *<P>\n     * The default implementation uses configured {@link Converter} to do\n     * conversion.\n     * \n     * @param value Value to convert\n     * \n     * @return Result of conversion\n     */\n    protected Object convertValue(Object value) {\n        return _converter.convert(value);\n    }\n\n    /**\n     * Helper method used for locating serializer to use in dynamic use case, where\n     * actual type value gets converted to is not specified beyond basic\n     * {@link java.lang.Object}, and where serializer needs to be located dynamically\n     * based on actual value type.\n     *\n     * @since 2.6\n     */\n        // NOTE: will NOT call contextualization\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\nimport com.fasterxml.jackson.databind.ser.ResolvableSerializer;\nimport com.fasterxml.jackson.databind.util.Converter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\n\n/**\n * Serializer implementation where given Java type is first converted\n * to an intermediate \"delegate type\" (using a configured\n * {@link Converter}, and then this delegate value is serialized by Jackson.\n *<p>\n * Note that although types may be related, they must not be same; trying\n * to do this will result in an exception.\n *\n * @since 2.1\n */\n@SuppressWarnings(\"serial\")\npublic class StdDelegatingSerializer\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    protected final Converter<Object,?> _converter;\n\n    /**\n     * Fully resolved delegate type, with generic information if any available.\n     */\n    protected final JavaType _delegateType;\n    \n    /**\n     * Underlying serializer for type <code>T<.code>.\n     */\n    protected final JsonSerializer<Object> _delegateSerializer;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public StdDelegatingSerializer(Converter<?,?> converter)\n    {\n        super(Object.class);\n        _converter = (Converter<Object,?>)converter;\n        _delegateType = null;\n        _delegateSerializer = null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter)\n    {\n        super(cls, false);\n        _converter = (Converter<Object,?>)converter;\n        _delegateType = null;\n        _delegateSerializer = null;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public StdDelegatingSerializer(Converter<Object,?> converter,\n            JavaType delegateType, JsonSerializer<?> delegateSerializer)\n    {\n        super(delegateType);\n        _converter = converter;\n        _delegateType = delegateType;\n        _delegateSerializer = (JsonSerializer<Object>) delegateSerializer;\n    }\n\n    /**\n     * Method used for creating resolved contextual instances. Must be\n     * overridden when sub-classing.\n     */\n    protected StdDelegatingSerializer withDelegate(Converter<Object,?> converter,\n            JavaType delegateType, JsonSerializer<?> delegateSerializer)\n    {\n        if (getClass() != StdDelegatingSerializer.class) {\n            throw new IllegalStateException(\"Sub-class \"+getClass().getName()+\" must override 'withDelegate'\");\n        }\n        return new StdDelegatingSerializer(converter, delegateType, delegateSerializer);\n    }\n    \n    /*\n    /**********************************************************\n    /* Contextualization\n    /**********************************************************\n     */\n\n    @Override\n    public void resolve(SerializerProvider provider) throws JsonMappingException\n    {\n        if ((_delegateSerializer != null)\n                && (_delegateSerializer instanceof ResolvableSerializer)) {\n            ((ResolvableSerializer) _delegateSerializer).resolve(provider);\n        }\n    }\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> delSer = _delegateSerializer;\n        JavaType delegateType = _delegateType;\n\n        if (delSer == null) {\n            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n            if (delegateType == null) {\n                delegateType = _converter.getOutputType(provider.getTypeFactory());\n            }\n            /* 02-Apr-2015, tatu: For \"dynamic case\", where type is only specified as\n             *    java.lang.Object (or missing generic), [databind#731]\n             */\n            if (!delegateType.isJavaLangObject()) {\n                delSer = provider.findValueSerializer(delegateType);\n            }\n        }\n        if (delSer instanceof ContextualSerializer) {\n            delSer = provider.handleSecondaryContextualization(delSer, property);\n        }\n        if (delSer == _delegateSerializer && delegateType == _delegateType) {\n            return this;\n        }\n        return withDelegate(_converter, delegateType, delSer);\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    protected Converter<Object, ?> getConverter() {\n        return _converter;\n    }\n\n    @Override\n    public JsonSerializer<?> getDelegatee() {\n        return _delegateSerializer;\n    }\n    \n    /*\n    /**********************************************************\n    /* Serialization\n    /**********************************************************\n     */\n\n    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n    {\n        Object delegateValue = convertValue(value);\n        // should we accept nulls?\n        if (delegateValue == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n        JsonSerializer<Object> ser = _delegateSerializer;\n        if (ser == null) {\n            ser = _findSerializer(delegateValue, provider);\n        }\n        ser.serialize(delegateValue, gen, provider);\n    }\n\n    @Override\n    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer) throws IOException\n    {\n        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,\n         *    let's give it a chance?\n         */\n        Object delegateValue = convertValue(value);\n        JsonSerializer<Object> ser = _delegateSerializer;\n        if (ser == null) {\n            ser = _findSerializer(value, provider);\n        }\n        ser.serializeWithType(delegateValue, gen, provider, typeSer);\n    }\n\n    @Override\n    @Deprecated // since 2.5\n    public boolean isEmpty(Object value)\n    {\n        Object delegateValue = convertValue(value);\n        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n            return (value == null);\n        }\n        return _delegateSerializer.isEmpty(delegateValue);\n    }\n\n    @Override\n    public boolean isEmpty(SerializerProvider prov, Object value)\n    {\n        Object delegateValue = convertValue(value);\n        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n            return (value == null);\n        }\n        return _delegateSerializer.isEmpty(prov, delegateValue);\n    }\n\n    /*\n    /**********************************************************\n    /* Schema functionality\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException\n    {\n        if (_delegateSerializer instanceof SchemaAware) {\n            return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint);\n        }\n        return super.getSchema(provider, typeHint);\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint,\n        boolean isOptional) throws JsonMappingException\n    {\n        if (_delegateSerializer instanceof SchemaAware) {\n            return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint, isOptional);\n        }\n        return super.getSchema(provider, typeHint);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n         *    properly... but for now, try this:\n         */\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n        if (_delegateSerializer != null) {\n            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to convert from source Java value into delegate\n     * value (which will be serialized using standard Jackson serializer for delegate type)\n     *<P>\n     * The default implementation uses configured {@link Converter} to do\n     * conversion.\n     * \n     * @param value Value to convert\n     * \n     * @return Result of conversion\n     */\n    protected Object convertValue(Object value) {\n        return _converter.convert(value);\n    }\n\n    /**\n     * Helper method used for locating serializer to use in dynamic use case, where\n     * actual type value gets converted to is not specified beyond basic\n     * {@link java.lang.Object}, and where serializer needs to be located dynamically\n     * based on actual value type.\n     *\n     * @since 2.6\n     */\n    protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers)\n        throws JsonMappingException\n    {\n        // NOTE: will NOT call contextualization\n        return serializers.findValueSerializer(value.getClass());\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.ser.std.StdSerializer", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.FilterProvider;\nimport com.fasterxml.jackson.databind.ser.PropertyFilter;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Base class used by all standard serializers, and can also\n * be used for custom serializers (in fact, this is the recommended\n * base class to use).\n * Provides convenience methods for implementing {@link SchemaAware}\n */\npublic abstract class StdSerializer<T>\n    extends JsonSerializer<T>\n    implements JsonFormatVisitable, SchemaAware, java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Nominal type supported, usually declared type of\n     * property for which serializer is used.\n     */\n    protected final Class<T> _handledType;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    protected StdSerializer(Class<T> t) {\n        _handledType = t;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StdSerializer(JavaType type) {\n        _handledType = (Class<T>) type.getRawClass();\n    }\n    \n    /**\n     * Alternate constructor that is (alas!) needed to work\n     * around kinks of generic type handling\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected StdSerializer(Class<?> t, boolean dummy) {\n        _handledType = (Class<T>) t;\n    }\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n    \n    @Override\n    public Class<T> handledType() { return _handledType; }\n\n    /*\n    /**********************************************************\n    /* Serialization\n    /**********************************************************\n     */\n    \n    @Override\n    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n        throws IOException, JsonGenerationException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for JSON Schema generation\n    /**********************************************************\n     */\n    \n    /**\n     * Default implementation simply claims type is \"string\"; usually\n     * overriden by custom serializers.\n     */\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException\n    {\n        return createSchemaNode(\"string\");\n    }\n    \n    /**\n     * Default implementation simply claims type is \"string\"; usually\n     * overriden by custom serializers.\n     */\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n        throws JsonMappingException\n    {\n    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n    \tif (!isOptional) {\n    \t\tschema.put(\"required\", !isOptional);\n    \t}\n        return schema;\n    }\n    \n    protected ObjectNode createObjectNode() {\n        return JsonNodeFactory.instance.objectNode();\n    }\n    \n    protected ObjectNode createSchemaNode(String type)\n    {\n        ObjectNode schema = createObjectNode();\n        schema.put(\"type\", type);\n        return schema;\n    }\n    \n    protected ObjectNode createSchemaNode(String type, boolean isOptional)\n    {\n        ObjectNode schema = createSchemaNode(type);\n        // as per [JACKSON-563]. Note that 'required' defaults to false\n        if (!isOptional) {\n            schema.put(\"required\", !isOptional);\n        }\n        return schema;\n    }\n    \n    /**\n     * Default implementation specifies no format. This behavior is usually\n     * overriden by custom serializers.\n     */\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        visitor.expectAnyFormat(typeHint);\n    }\n            \n    /*\n    /**********************************************************\n    /* Helper methods for exception handling\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will modify caught exception (passed in as argument)\n     * as necessary to include reference information, and to ensure it\n     * is a subtype of {@link IOException}, or an unchecked exception.\n     *<p>\n     * Rules for wrapping and unwrapping are bit complicated; essentially:\n     *<ul>\n     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n     * <li>\"Plain\" IOExceptions (ones that are not of type\n     *   {@link JsonMappingException} are to be passed as is\n     *</ul>\n     */\n    public void wrapAndThrow(SerializerProvider provider,\n            Throwable t, Object bean, String fieldName)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // Ditto for IOExceptions... except for mapping exceptions!\n        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonMappingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }\n\n    public void wrapAndThrow(SerializerProvider provider,\n            Throwable t, Object bean, int index)\n        throws IOException\n    {\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors are to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // Ditto for IOExceptions... except for mapping exceptions!\n        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonMappingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, index);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, other\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to determine if given serializer is the default\n     * serializer Jackson uses; as opposed to a custom serializer installed by\n     * a module or calling application. Determination is done using\n     * {@link JacksonStdImpl} annotation on serializer class.\n     */\n    protected boolean isDefaultSerializer(JsonSerializer<?> serializer) {\n        return ClassUtil.isJacksonStdImpl(serializer);\n    }\n\n    /**\n     * Helper method that can be used to see if specified property has annotation\n     * indicating that a converter is to be used for contained values (contents\n     * of structured types; array/List/Map values)\n     * \n     * @param existingSerializer (optional) configured content\n     *    serializer if one already exists.\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n            BeanProperty prop, JsonSerializer<?> existingSerializer)\n        throws JsonMappingException\n    {\n        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n         *   when applying contextual content converter; this is not ideal way,\n         *   but should work for most cases.\n         */\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null && prop != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationContentConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    if (existingSerializer == null) {\n                        existingSerializer = provider.findValueSerializer(delegateType);\n                    }\n                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                }\n            }\n        }\n        return existingSerializer;\n    }\n\n    /**\n     * Helper method used to locate filter that is needed, based on filter id\n     * this serializer was constructed with.\n     * \n     * @since 2.3\n     */\n    protected PropertyFilter findPropertyFilter(SerializerProvider provider,\n            Object filterId, Object valueToFilter)\n        throws JsonMappingException\n    {\n        FilterProvider filters = provider.getFilterProvider();\n        // Not ok to miss the provider, if a filter is declared to be needed.\n        if (filters == null) {\n            throw new JsonMappingException(\"Can not resolve PropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n        }\n        PropertyFilter filter = filters.findPropertyFilter(filterId, valueToFilter);\n        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n        return filter;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.FilterProvider;\nimport com.fasterxml.jackson.databind.ser.PropertyFilter;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Base class used by all standard serializers, and can also\n * be used for custom serializers (in fact, this is the recommended\n * base class to use).\n * Provides convenience methods for implementing {@link SchemaAware}\n */\npublic abstract class StdSerializer<T>\n    extends JsonSerializer<T>\n    implements JsonFormatVisitable, SchemaAware, java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Nominal type supported, usually declared type of\n     * property for which serializer is used.\n     */\n    protected final Class<T> _handledType;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    protected StdSerializer(Class<T> t) {\n        _handledType = t;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StdSerializer(JavaType type) {\n        _handledType = (Class<T>) type.getRawClass();\n    }\n    \n    /**\n     * Alternate constructor that is (alas!) needed to work\n     * around kinks of generic type handling\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected StdSerializer(Class<?> t, boolean dummy) {\n        _handledType = (Class<T>) t;\n    }\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n    \n    @Override\n    public Class<T> handledType() { return _handledType; }\n\n    /*\n    /**********************************************************\n    /* Serialization\n    /**********************************************************\n     */\n    \n    @Override\n    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n        throws IOException, JsonGenerationException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for JSON Schema generation\n    /**********************************************************\n     */\n    \n    /**\n     * Default implementation simply claims type is \"string\"; usually\n     * overriden by custom serializers.\n     */\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException\n    {\n        return createSchemaNode(\"string\");\n    }\n    \n    /**\n     * Default implementation simply claims type is \"string\"; usually\n     * overriden by custom serializers.\n     */\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n        throws JsonMappingException\n    {\n    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n    \tif (!isOptional) {\n    \t\tschema.put(\"required\", !isOptional);\n    \t}\n        return schema;\n    }\n    \n    protected ObjectNode createObjectNode() {\n        return JsonNodeFactory.instance.objectNode();\n    }\n    \n    protected ObjectNode createSchemaNode(String type)\n    {\n        ObjectNode schema = createObjectNode();\n        schema.put(\"type\", type);\n        return schema;\n    }\n    \n    protected ObjectNode createSchemaNode(String type, boolean isOptional)\n    {\n        ObjectNode schema = createSchemaNode(type);\n        // as per [JACKSON-563]. Note that 'required' defaults to false\n        if (!isOptional) {\n            schema.put(\"required\", !isOptional);\n        }\n        return schema;\n    }\n    \n    /**\n     * Default implementation specifies no format. This behavior is usually\n     * overriden by custom serializers.\n     */\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException\n    {\n        visitor.expectAnyFormat(typeHint);\n    }\n            \n    /*\n    /**********************************************************\n    /* Helper methods for exception handling\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will modify caught exception (passed in as argument)\n     * as necessary to include reference information, and to ensure it\n     * is a subtype of {@link IOException}, or an unchecked exception.\n     *<p>\n     * Rules for wrapping and unwrapping are bit complicated; essentially:\n     *<ul>\n     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n     * <li>\"Plain\" IOExceptions (ones that are not of type\n     *   {@link JsonMappingException} are to be passed as is\n     *</ul>\n     */\n    public void wrapAndThrow(SerializerProvider provider,\n            Throwable t, Object bean, String fieldName)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // Ditto for IOExceptions... except for mapping exceptions!\n        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonMappingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }\n\n    public void wrapAndThrow(SerializerProvider provider,\n            Throwable t, Object bean, int index)\n        throws IOException\n    {\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors are to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // Ditto for IOExceptions... except for mapping exceptions!\n        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonMappingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, index);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, other\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to determine if given serializer is the default\n     * serializer Jackson uses; as opposed to a custom serializer installed by\n     * a module or calling application. Determination is done using\n     * {@link JacksonStdImpl} annotation on serializer class.\n     */\n    protected boolean isDefaultSerializer(JsonSerializer<?> serializer) {\n        return ClassUtil.isJacksonStdImpl(serializer);\n    }\n\n    /**\n     * Helper method that can be used to see if specified property has annotation\n     * indicating that a converter is to be used for contained values (contents\n     * of structured types; array/List/Map values)\n     * \n     * @param existingSerializer (optional) configured content\n     *    serializer if one already exists.\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n            BeanProperty prop, JsonSerializer<?> existingSerializer)\n        throws JsonMappingException\n    {\n        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n         *   when applying contextual content converter; this is not ideal way,\n         *   but should work for most cases.\n         */\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        if (intr != null && prop != null) {\n            AnnotatedMember m = prop.getMember();\n            if (m != null) {\n                Object convDef = intr.findSerializationContentConverter(m);\n                if (convDef != null) {\n                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                    // [databind#731]: Should skip if nominally java.lang.Object\n                    if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {\n                        existingSerializer = provider.findValueSerializer(delegateType);\n                    }\n                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                }\n            }\n        }\n        return existingSerializer;\n    }\n\n    /**\n     * Helper method used to locate filter that is needed, based on filter id\n     * this serializer was constructed with.\n     * \n     * @since 2.3\n     */\n    protected PropertyFilter findPropertyFilter(SerializerProvider provider,\n            Object filterId, Object valueToFilter)\n        throws JsonMappingException\n    {\n        FilterProvider filters = provider.getFilterProvider();\n        // Not ok to miss the provider, if a filter is declared to be needed.\n        if (filters == null) {\n            throw new JsonMappingException(\"Can not resolve PropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n        }\n        PropertyFilter filter = filters.findPropertyFilter(filterId, valueToFilter);\n        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n        return filter;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 16, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.introspect.AnnotationMap", "buggy_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.util.Annotations;\n\n/**\n * Simple helper class used to keep track of collection of\n * Jackson Annotations associated with annotatable things\n * (methods, constructors, classes).\n * Note that only Jackson-owned annotations are tracked (for now?).\n */\npublic final class AnnotationMap implements Annotations\n{\n    protected HashMap<Class<? extends Annotation>,Annotation> _annotations;\n\n    public AnnotationMap() { }\n    \n    private AnnotationMap(HashMap<Class<? extends Annotation>,Annotation> a) {\n        _annotations = a;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A get(Class<A> cls)\n    {\n        if (_annotations == null) {\n            return null;\n        }\n        return (A) _annotations.get(cls);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public Iterable<Annotation> annotations() {\n        if (_annotations == null || _annotations.size() == 0) {\n            return Collections.emptyList();\n        }\n        return _annotations.values();\n    }\n    \n    public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary)\n    {\n        if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) {\n            return secondary;\n        }\n        if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) {\n            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous != null) && previous.equals(ann);\n    }\n}\n\n\n", "fixed_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.util.Annotations;\n\n/**\n * Simple helper class used to keep track of collection of\n * Jackson Annotations associated with annotatable things\n * (methods, constructors, classes).\n * Note that only Jackson-owned annotations are tracked (for now?).\n */\npublic final class AnnotationMap implements Annotations\n{\n    protected HashMap<Class<? extends Annotation>,Annotation> _annotations;\n\n    public AnnotationMap() { }\n    \n    private AnnotationMap(HashMap<Class<? extends Annotation>,Annotation> a) {\n        _annotations = a;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A get(Class<A> cls)\n    {\n        if (_annotations == null) {\n            return null;\n        }\n        return (A) _annotations.get(cls);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public Iterable<Annotation> annotations() {\n        if (_annotations == null || _annotations.size() == 0) {\n            return Collections.emptyList();\n        }\n        return _annotations.values();\n    }\n    \n    public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary)\n    {\n        if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) {\n            return secondary;\n        }\n        if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) {\n            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous == null) || !previous.equals(ann);\n    }\n}\n\n\n"}]}
{"project": "JacksonDatabind", "bug_id": 17, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ObjectMapper", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * This mapper (or, data binder, or codec) provides functionality for\n * converting between Java objects (instances of JDK provided core classes,\n * beans), and matching JSON constructs.\n * It will use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes.\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Helper classes, enums\n    /**********************************************************\n     */\n\n    /**\n     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n     * to specify what kind of types (classes) default typing should\n     * be used for. It will only be used if no explicit type information\n     * is found, but this enumeration further limits subset of those types.\n     *<p>\n     * Since 2.4 there are special exceptions for JSON Tree model\n     * types (sub-types of {@link TreeNode}: default typing is never\n     * applied to them\n     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n     */\n    public enum DefaultTyping {\n        /**\n         * This value means that only properties that have\n         * {@link java.lang.Object} as declared type (including\n         * generic types without explicit type) will use default\n         * typing.\n         */\n        JAVA_LANG_OBJECT,\n        \n        /**\n         * Value that means that default typing will be used for\n         * properties with declared type of {@link java.lang.Object}\n         * or an abstract type (abstract class or interface).\n         * Note that this does <b>not</b> include array types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        OBJECT_AND_NON_CONCRETE,\n\n        /**\n         * Value that means that default typing will be used for\n         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n         * plus all array types for them.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_CONCRETE_AND_ARRAYS,\n        \n        /**\n         * Value that means that default typing will be used for\n         * all non-final types, with exception of small number of\n         * \"natural\" types (String, Boolean, Integer, Double), which\n         * can be correctly inferred from JSON; as well as for\n         * all arrays of non-final types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_FINAL\n    }\n\n    /**\n     * Customized {@link TypeResolverBuilder} that provides type resolver builders\n     * used with so-called \"default typing\"\n     * (see {@link ObjectMapper#enableDefaultTyping()} for details).\n     *<p>\n     * Type resolver construction is based on configuration: implementation takes care\n     * of only providing builders in cases where type information should be applied.\n     * This is important since build calls may be sent for any and all types, and\n     * type information should NOT be applied to all of them.\n     */\n    public static class DefaultTypeResolverBuilder\n        extends StdTypeResolverBuilder\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Definition of what types is this default typer valid for.\n         */\n        protected final DefaultTyping _appliesFor;\n\n        public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n     *   sure what'd be simple and elegant way. So until then:\n     */\n    protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n\n    // 16-May-2009, tatu: Ditto ^^^\n    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n\n    protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n\n    protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter();\n    \n    /**\n     * Base settings contain defaults used for all {@link ObjectMapper}\n     * instances.\n     */\n    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n            DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n            null, StdDateFormat.instance, null,\n            Locale.getDefault(),\n//            TimeZone.getDefault()\n            TimeZone.getTimeZone(\"GMT\"),\n            Base64Variants.getDefaultVariant() // 2.1\n    );\n\n    /*\n    /**********************************************************\n    /* Configuration settings, shared\n    /**********************************************************\n     */\n\n    /**\n     * Factory used to create {@link JsonParser} and {@link JsonGenerator}\n     * instances as necessary.\n     */\n    protected final JsonFactory _jsonFactory;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected TypeFactory _typeFactory;\n\n    /**\n     * Provider for values to inject in deserialized POJOs.\n     */\n    protected InjectableValues _injectableValues;\n\n    /**\n     * Thing used for registering sub-types, resolving them to\n     * super/sub-types as needed.\n     */\n    protected SubtypeResolver _subtypeResolver;\n\n    /**\n     * Cache for root names used when root-wrapping is enabled.\n     */\n    protected final RootNameLookup _rootNames;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Mapping that defines how to apply mix-in annotations: key is\n     * the type to received additional annotations, and value is the\n     * type that has annotations to \"mix in\".\n     *<p>\n     * Annotations associated with the value classes will be used to\n     * override annotations of the key class, associated with the\n     * same field or method. They can be further masked by sub-classes:\n     * you can think of it as injecting annotations between the target\n     * class and its sub-classes (or interfaces)\n     */\n    protected final HashMap<ClassKey,Class<?>> _mixInAnnotations;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected SerializationConfig _serializationConfig;\n\n    /**\n     * Object that manages access to serializers used for serialization,\n     * including caching.\n     * It is configured with {@link #_serializerFactory} to allow\n     * for constructing custom serializers.\n     *<p>\n     * Note: while serializers are only exposed {@link SerializerProvider},\n     * mappers and readers need to access additional API defined by\n     * {@link DefaultSerializerProvider}\n     */\n    protected DefaultSerializerProvider _serializerProvider;\n\n    /**\n     * Serializer factory used for constructing serializers.\n     */\n    protected SerializerFactory _serializerFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected DeserializationConfig _deserializationConfig;\n\n    /**\n     * Blueprint context object; stored here to allow custom\n     * sub-classes. Contains references to objects needed for\n     * deserialization construction (cache, factory).\n     */\n    protected DefaultDeserializationContext _deserializationContext;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /* Note: handling of serializers and deserializers is not symmetric;\n     * and as a result, only root-level deserializers can be cached here.\n     * This is mostly because typing and resolution for deserializers is\n     * fully static; whereas it is quite dynamic for serialization.\n     */\n\n    /**\n     * We will use a separate main-level Map for keeping track\n     * of root-level deserializers. This is where most succesful\n     * cache lookups get resolved.\n     * Map will contain resolvers for all kinds of types, including\n     * container types: this is different from the component cache\n     * which will only cache bean deserializers.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * explicitly define a low concurrency setting.\n     *<p>\n     * Since version 1.5, these may are either \"raw\" deserializers (when\n     * no type information is needed for base type), or type-wrapped\n     * deserializers (if it is needed)\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructing instance\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor, which will construct the default\n     * {@link JsonFactory} as necessary, use\n     * {@link SerializerProvider} as its\n     * {@link SerializerProvider}, and\n     * {@link BeanSerializerFactory} as its\n     * {@link SerializerFactory}.\n     * This means that it\n     * can serialize all standard JDK types, as well as regular\n     * Java Beans (based on method names and Jackson-specific annotations),\n     * but does not support JAXB annotations.\n     */\n    public ObjectMapper()\n    {\n        this(null, null, null);\n    }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s.\n     */\n    public ObjectMapper(JsonFactory jf)\n    {\n        this(jf, null, null);\n    }\n\n    /**\n     * Copy-constructor, mostly used to support {@link #copy}.\n     * \n     * @since 2.1\n     */\n    protected ObjectMapper(ObjectMapper src)\n    {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _rootNames = new RootNameLookup();\n        _typeFactory = src._typeFactory;\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>(src._mixInAnnotations);\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = src._serializerFactory;\n    }\n    \n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s, and uses given providers for accessing\n     * serializers and deserializers.\n     * \n     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n     * @param dc Blueprint deserialization context instance to use for creating\n     *    actual context objects; if null, will construct standard\n     *    {@link DeserializationContext}\n     */\n    public ObjectMapper(JsonFactory jf,\n            DefaultSerializerProvider sp, DefaultDeserializationContext dc)\n    {\n        /* 02-Mar-2009, tatu: Important: we MUST default to using\n         *   the mapping factory, otherwise tree serialization will\n         *   have problems with POJONodes.\n         * 03-Jan-2010, tatu: and obviously we also must pass 'this',\n         *    to create actual linking.\n         */\n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { // as per [JACKSON-741]\n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        _rootNames = new RootNameLookup();\n        // and default type factory is shared one\n        _typeFactory = TypeFactory.defaultInstance();\n\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n\n        // Some overrides we may need\n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy()\n    {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    /**\n     * @since 2.1\n     * @param exp\n     */\n    protected void _checkInvalidCopy(Class<?> exp)\n    {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Versioned impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    /*\n    /**********************************************************\n    /* com.fasterxml.jackson.databind.Module registration, discovery\n    /**********************************************************\n     */\n\n    /**\n     * Method for registering a module that can extend functionality\n     * provided by this mapper; for example, by adding providers for\n     * custom serializers and deserializers.\n     * \n     * @param module com.fasterxml.jackson.databind.Module to register\n     */\n    public ObjectMapper registerModule(Module module)\n    {\n        /* Let's ensure we have access to name and version information, \n         * even if we do not have immediate use for either. This way we know\n         * that they will be available from beginning\n         */\n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        // And then call registration\n        module.setupModule(new Module.SetupContext()\n        {\n            // // // Accessors\n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                // why do we need the cast here?!?\n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            // // // Methods for registering handlers: deserializers\n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            // // // Methods for registering handlers: serializers\n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            // // // Methods for registering handlers: other\n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixInAnnotations(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Module... modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)\n    {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    /**\n     * Convenience method that is functionally equivalent to:\n     *<code>\n     *   mapper.registerModules(mapper.findModules());\n     *<code>\n     *<p>\n     * As with {@link #findModules()}, no caching is done for modules, so care\n     * needs to be taken to either create and share a single mapper instance;\n     * or to cache introspected set of modules.\n     *\n     * @since 2.2\n     */\n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: main config object access\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns the shared default {@link SerializationConfig}\n     * object that defines configuration settings for serialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    /**\n     * Method that returns\n     * the shared default {@link DeserializationConfig} object\n     * that defines configuration settings for deserialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    /**\n     * Method for getting current {@link DeserializationContext}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of context object.\n    */\n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: ser/deser factory, provider access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for setting specific {@link SerializerFactory} to use\n     * for constructing (bean) serializers.\n     */\n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    /**\n     * Method for getting current {@link SerializerFactory}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of factory object.\n     */\n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    /**\n     * Method for setting specific {@link SerializerProvider} to use\n     * for handling caching of {@link JsonSerializer} instances.\n     */\n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Method to use for defining mix-in annotations to use for augmenting\n     * annotations that processable (serializable / deserializable)\n     * classes have.\n     * Mixing in is done when introspecting class annotations and properties.\n     * Map passed contains keys that are target classes (ones to augment\n     * with new annotation overrides), and values that are source classes\n     * (have annotations to use for augmentation).\n     * Annotations from source classes (and their supertypes)\n     * will <b>override</b>\n     * annotations that target classes (and their super-types) have.\n     */\n    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n    {\n        _mixInAnnotations.clear();\n        if (sourceMixins != null && sourceMixins.size() > 0) {\n            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n            }\n        }\n    }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     */\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n    }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     */\n    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n        return this;\n    }\n\n    public final Class<?> findMixInClassFor(Class<?> cls) {\n        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n    }\n\n    public final int mixInCount() {\n        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     */\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    /**\n     * Method for setting currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     * This default checker is used if no per-class overrides\n     * are defined.\n     */    \n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n    }\n\n    /**\n     * Convenience method that allows changing configuration for\n     * underlying {@link VisibilityChecker}s, to change details of what kinds of\n     * properties are auto-detected.\n     * Basically short cut for doing:\n     *<pre>\n     *  mapper.setVisibilityChecker(\n     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)\n     *  );\n     *</pre>\n     * one common use case would be to do:\n     *<pre>\n     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);\n     *</pre>\n     * which would make all member fields serializable without further annotations,\n     * instead of just public fields (default setting).\n     * \n     * @param forMethod Type of property descriptor affected (field, getter/isGetter,\n     *     setter, creator)\n     * @param visibility Minimum visibility to require for the property descriptors of type\n     * \n     * @return Modified mapper instance (that is, \"this\"), to allow chaining\n     *    of configuration calls\n     */\n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    /**\n     * Method for accessing subtype resolver in use.\n     */\n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    /**\n     * Method for setting custom subtype resolver to use.\n     */\n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} used by this\n     * mapper instance for both serialization and deserialization\n     */\n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} instances used\n     * by this mapper instance for serialization and deserialization,\n     * specifying them separately so that different introspection can be\n     * used for different aspects\n     * \n     * @since 2.1\n     * \n     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n     *    serialization\n     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n     *    deserialization\n     */\n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    /**\n     * Method for setting custom property naming strategy to use.\n     */\n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    /**\n     * Method for setting defalt POJO property inclusion strategy for serialization.\n     */\n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Type information configuration (1.5+)\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information -- needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --\n     * using \"As.PROPERTY\" inclusion mechanism and specified property name\n     * to use for inclusion (default being \"@class\" since default type information\n     * always uses class name as type identifier)\n     */\n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    /**\n     * Method for disabling automatic inclusion of type information; if so, only\n     * explicitly annotated types (ones with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have\n     * additional embedded type information.\n     */\n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Type for given class is determined from appropriate annotation;\n     * or if missing, default name (unqualified class name)\n     */\n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Name may be provided as part of argument, but if not will\n     * be based on annotations or use default name (unqualified\n     * class name).\n     */\n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration, basic type handling\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting currently configured {@link TypeFactory} instance.\n     */\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    /**\n     * Method that can be used to override {@link TypeFactory} instance\n     * used by this mapper.\n     *<p>\n     * Note: will also set {@link TypeFactory} that deserialization and\n     * serialization config objects use.\n     */\n    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    /**\n     * Convenience method for constructing {@link JavaType} out of given\n     * type (typically <code>java.lang.Class</code>), but without explicit\n     * context.\n     */\n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, deserialization\n    /**********************************************************\n     */\n    \n    /**\n     * Method for specifying {@link JsonNodeFactory} to use for\n     * constructing root level tree nodes (via method\n     * {@link #createObjectNode}\n     */\n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for adding specified {@link DeserializationProblemHandler}\n     * to be used for handling specific problems during deserialization.\n     */\n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    /**\n     * Method for removing all registered {@link DeserializationProblemHandler}s\n     * instances from this mapper.\n     */\n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link DeserializationConfig}\n     * object.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any deserialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *  mapper.setFilters(mapper.getSerializationConfig().withFilters(filterProvider));\n     *</pre>\n     *<p>\n     * Note that usually it is better to use method {@link #writer(FilterProvider)};\n     * however, sometimes\n     * this method is more convenient. For example, some frameworks only allow configuring\n     * of ObjectMapper instances and not ObjectWriters.\n     */\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    /**\n     * Method that will configure default {@link Base64Variant} that\n     * <code>byte[]</code> serializers and deserializers will use.\n     * \n     * @param v Base64 variant to use\n     * \n     * @return This mapper, for convenience to allow chaining\n     * \n     * @since 2.1\n     */\n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link SerializationConfig}\n     * object, which contains serialization-specific configuration settings.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any serialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(SerializationConfig config) {\n    \t_serializationConfig = config;\n    \treturn this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonFactory} that this\n     * mapper uses if it needs to construct {@link JsonParser}s\n     * and/or {@link JsonGenerator}s.\n     *\n     * @return {@link JsonFactory} that this mapper uses when it needs to\n     *   construct Json parser and generators\n     */\n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    /**\n     * Method for configuring the default {@link DateFormat} to use when serializing time\n     * values as Strings, and deserializing from JSON Strings.\n     * This is preferably to directly modifying {@link SerializationConfig} and\n     * {@link DeserializationConfig} instances.\n     * If you need per-request configuration, use {@link #writer(DateFormat)} to\n     * create properly configured {@link ObjectWriter} and use that; this because\n     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n     * thread-safe when configuring methods (such as this one) are NOT called.\n     */\n    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    /**\n     * Method for configuring {@link HandlerInstantiator} to use for creating\n     * instances of handlers (such as serializers, deserializers, type and type\n     * id resolvers), given a class.\n     *\n     * @param hi Instantiator to use; if null, use the default implementation\n     */\n    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    /**\n     * Method for configuring {@link InjectableValues} which used to find\n     * values to inject.\n     */\n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n    \n    /**\n     * Method for overriding default locale to use for formatting.\n     * Default value used is {@link Locale#getDefault()}.\n     */\n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    /**\n     * Method for overriding default TimeZone to use for formatting.\n     * Default value used is UTC (NOT local timezone).\n     */\n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features\n    /**********************************************************\n     */\n\n    /**\n     * Method for changing state of an on/off mapper feature for\n     * this mapper instance.\n     */\n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n    \n    /**\n     * Method for changing state of an on/off serialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for changing state of an on/off deserialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for changing state of an on/off {@link JsonParser} feature for\n     * {@link JsonFactory} instance this object mapper uses.\n     *<p>\n     * This is method is basically a shortcut method for calling\n     * {@link JsonFactory#enable} on the shared\n     * {@link JsonFactory} this mapper uses (which is accessible\n     * using {@link #getJsonFactory}).\n     */\n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    /**\n     * Method for changing state of an on/off {@link JsonGenerator} feature for\n     * {@link JsonFactory} instance this object mapper uses.\n     *<p>\n     * This is method is basically a shortcut method for calling\n     * {@link JsonFactory#enable} on the shared\n     * {@link JsonFactory} this mapper uses (which is accessible\n     * using {@link #getJsonFactory}).\n     */\n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n\n    /**\n     * Method for checking whether given Mapper\n     * feature is enabled.\n     */\n    public boolean isEnabled(MapperFeature f) {\n        // ok to use either one, should be kept in sync\n        return _serializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Method for checking whether given serialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n    \n    /**\n     * Method for checking whether given deserialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    /**\n     * Method that can be used to get hold of {@link JsonNodeFactory}\n     * that this mapper will use when directly constructing\n     * root {@link JsonNode} instances for Trees.\n     *<p>\n     * Note: this is just a shortcut for calling\n     *<pre>\n     *   getDeserializationConfig().getNodeFactory()\n     *</pre>\n     */\n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): deserialization\n    /* (mapping from JSON to Java types);\n    /* main methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        /* 02-Mar-2009, tatu: One twist; deserialization provider\n         *   will map JSON null straight into Java null. But what\n         *   we want to return is the \"null node\" instead.\n         */\n        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n         *   calling readValue(), since that'll choke on it otherwise\n         */\n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     *<p>\n     * Note that {@link ObjectReader} has more complete set of variants.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n            throws IOException, JsonProcessingException\n    {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        // false -> do NOT close JsonParser (since caller passed it)\n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API not included in ObjectCodec: deserialization\n    /* (mapping from JSON to Java types)\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): serialization\n    /* (mapping from Java types to Json)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using provided {@link JsonGenerator}.\n     */\n    @Override\n    public void writeValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(jgen, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(jgen, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from TreeCodec via ObjectCodec): Tree Model support\n    /**********************************************************\n     */\n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     * Method to serialize given JSON Tree, using generator\n     * provided.\n     */\n    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    /**\n     * Method for constructing a {@link JsonParser} out of JSON tree\n     * representation.\n     * \n     * @param n Root node of the tree that resulting parser will read from\n     */\n    @Override\n    public JsonParser treeAsTokens(TreeNode n)\n    {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    /**\n     * Convenience conversion method that will bind data given JSON tree\n     * contains into specific value (usually bean) type.\n     *<p>\n     * Functionally equivalent to:\n     *<pre>\n     *   objectMapper.convertValue(n, valueClass);\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: one known difference from actual serialization is that so-called\n     * \"raw values\" are not supported -- since they are opaque sequence of\n     * bytes to include (which may or may not be supported by the backend)\n     * they can not be converted using this method. It may be possible to\n     * support conversions using full serialization, if raw values must be\n     * preserved.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could serialize an instance of given Class.\n     * Check is done\n     * by checking whether a serializer can be found for the type.\n     *<p>\n     * NOTE: since this method does NOT throw exceptions, but internal\n     * processing may, caller usually has little information as to why\n     * serialization would fail.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canSerialize(Class)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could deserialize an Object of given type.\n     * Check is done\n     * by checking whether a deserializer can be found for the type.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canDeserialize(JavaType type)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canDeserialize(JavaType)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API, deserialization,\n    /* convenience methods\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//      _setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API: serialization\n    /* (mapping from Java types to JSON)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, written to File provided.\n     */\n    public void writeValue(File resultFile, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using output stream provided (using encoding\n     * {@link JsonEncoding#UTF8}).\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(OutputStream out, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using Writer provided.\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(Writer w, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    /**\n     * Method that can be used to serialize any Java value as\n     * a byte array. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n     * and getting bytes, but more efficient.\n     * Encoding used will be UTF-8.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectWriters\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for constructing {@link ObjectWriter}\n     * with default settings.\n     */\n    public ObjectWriter writer() {\n        return new ObjectWriter(this, getSerializationConfig());\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature feature) {\n        return new ObjectWriter(this, getSerializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature first,\n            SerializationFeature... other) {\n        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified {@link DateFormat}; or, if\n     * null passed, using timestamp (64-bit number.\n     */\n    public ObjectWriter writer(DateFormat df) {\n        return new ObjectWriter(this, getSerializationConfig().with(df));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified JSON View (filter).\n     */\n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime\n     * type.\n     */\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     */\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     */\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified pretty printer for indentation\n     * (or if null, no pretty printer)\n     */\n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using the default pretty printer for indentation\n     */\n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        return new ObjectWriter(this, getSerializationConfig(),\n                /*root type*/ null, _defaultPrettyPrinter());\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified filter provider.\n     */\n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return new ObjectWriter(this,\n                getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * pass specific schema object to {@link JsonGenerator} used for\n     * writing content.\n     * \n     * @param schema Schema to pass to generator\n     */\n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectWriter(this, getSerializationConfig(), schema);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified character escaping details for output.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return writer().with(escapes);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(ContextAttributes attrs) {\n        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectReaders\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * default settings. Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader() {\n        return new ObjectReader(this, getDeserializationConfig())\n            .with(_injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature feature) {\n        return new ObjectReader(this, getDeserializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature first,\n            DeserializationFeature... other) {\n        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * update given Object (usually Bean, but can be a Collection or Map\n     * as well, but NOT an array) with JSON data. Deserialization occurs\n     * normally except that the root-level value in JSON is not used for\n     * instantiating a new object; instead give updateable object is used\n     * as root.\n     * Runtime type of value object is used for locating deserializer,\n     * unless overridden by other factory methods of {@link ObjectReader}\n     */\n    public ObjectReader readerForUpdating(Object valueToUpdate)\n    {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(JavaType type)\n    {\n        return new ObjectReader(this, getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(Class<?> type)\n    {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(TypeReference<?> type)\n    {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified {@link JsonNodeFactory} for constructing JSON trees.\n     */\n    public ObjectReader reader(JsonNodeFactory f)\n    {\n        return new ObjectReader(this, getDeserializationConfig()).with(f);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * pass specific schema object to {@link JsonParser} used for\n     * reading content.\n     * \n     * @param schema Schema to pass to parser\n     */\n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified injectable values.\n     * \n     * @param injectableValues Injectable values to use\n     */\n    public ObjectReader reader(InjectableValues injectableValues) {\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * deserialize objects using specified JSON View (filter).\n     */\n    public ObjectReader readerWithView(Class<?> view) {\n        return new ObjectReader(this, getDeserializationConfig().withView(view));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectReader reader(ContextAttributes attrs) {\n        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: convenience type conversion\n    /**********************************************************\n     */\n   \n    /**\n     * Convenience method for doing two-step conversion from given value, into\n     * instance of given value type. This is functionality equivalent to first\n     * serializing given value into JSON, then binding JSON data into value\n     * of given type, but may be executed without fully serializing into\n     * JSON. Same converters (serializers, deserializers) will be used as for\n     * data binding, meaning same object mapper configuration works.\n     *      \n     * @throws IllegalArgumentException If conversion fails due to incompatible type;\n     *    if so, root cause will contain underlying checked exception data binding\n     *    functionality threw\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n        throws IllegalArgumentException\n    {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        /* Then use TokenBuffer, which is a JsonGenerator:\n         * (see [JACKSON-175])\n         */\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: JSON Schema generation\n    /**********************************************************\n     */\n\n    /**\n     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n     * instance for specified class.\n     *\n     * @param t The class to generate schema for\n     * @return Constructed JSON schema.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     * Visitation uses <code>Serializer</code> hierarchy and related properties\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for serialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used for constructing\n     * {@link SerializerProvider} to use for serialization.\n     */\n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    /**\n     * Helper method that should return default pretty-printer to\n     * use for generators constructed by this mapper, when instructed\n     * to use default pretty printer.\n     */\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }\n    \n    /**\n     * Method called to configure the generator as necessary and then\n     * call write functionality\n     */\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig();\n        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            /* won't try to close twice; also, must catch exception (so it \n             * will not mask exception that is pending)\n             */\n            if (!closed) {\n                /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                 *    structures, which typically causes more damage.\n                 */\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            if (!closed) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (jgen != null) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for deserialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg)\n    {\n        return _deserializationContext.createInstance(cfg,\n                jp, _injectableValues);\n    }\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: may need to read the next token, to initialize\n         * state (either before first read from parser, or after\n         * previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue();\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            // ok, let's get the value\n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            // Need to consume the token too\n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    /**\n     * Method called to ensure that given parser is ready for reading\n     * content for data binding.\n     *\n     * @return First token to be used for data binding after this call:\n     *  can never be null as exception will be thrown if parser can not\n     *  provide more tokens.\n     *\n     * @throws IOException if the underlying input source has problems during\n     *   parsing\n     * @throws JsonParseException if parser has problems parsing content\n     * @throws JsonMappingException if the parser does not have any more\n     *   content to map (note: Json \"null\" value is considered content;\n     *   enf-of-stream not)\n     */\n    protected JsonToken _initForReading(JsonParser jp)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            // and then we must get something...\n            t = jp.nextToken();\n            if (t == null) {\n                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                 *   not an actual parsing problem\n                 */\n                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n            DeserializationConfig config,\n            JavaType rootType, JsonDeserializer<Object> deser)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        String expName = config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        jp.nextToken();\n        Object result = deser.deserialize(jp, ctxt);\n        // and last, verify that we now get matching END_OBJECT\n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * This mapper (or, data binder, or codec) provides functionality for\n * converting between Java objects (instances of JDK provided core classes,\n * beans), and matching JSON constructs.\n * It will use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes.\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Helper classes, enums\n    /**********************************************************\n     */\n\n    /**\n     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n     * to specify what kind of types (classes) default typing should\n     * be used for. It will only be used if no explicit type information\n     * is found, but this enumeration further limits subset of those types.\n     *<p>\n     * Since 2.4 there are special exceptions for JSON Tree model\n     * types (sub-types of {@link TreeNode}: default typing is never\n     * applied to them\n     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n     */\n    public enum DefaultTyping {\n        /**\n         * This value means that only properties that have\n         * {@link java.lang.Object} as declared type (including\n         * generic types without explicit type) will use default\n         * typing.\n         */\n        JAVA_LANG_OBJECT,\n        \n        /**\n         * Value that means that default typing will be used for\n         * properties with declared type of {@link java.lang.Object}\n         * or an abstract type (abstract class or interface).\n         * Note that this does <b>not</b> include array types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        OBJECT_AND_NON_CONCRETE,\n\n        /**\n         * Value that means that default typing will be used for\n         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n         * plus all array types for them.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_CONCRETE_AND_ARRAYS,\n        \n        /**\n         * Value that means that default typing will be used for\n         * all non-final types, with exception of small number of\n         * \"natural\" types (String, Boolean, Integer, Double), which\n         * can be correctly inferred from JSON; as well as for\n         * all arrays of non-final types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_FINAL\n    }\n\n    /**\n     * Customized {@link TypeResolverBuilder} that provides type resolver builders\n     * used with so-called \"default typing\"\n     * (see {@link ObjectMapper#enableDefaultTyping()} for details).\n     *<p>\n     * Type resolver construction is based on configuration: implementation takes care\n     * of only providing builders in cases where type information should be applied.\n     * This is important since build calls may be sent for any and all types, and\n     * type information should NOT be applied to all of them.\n     */\n    public static class DefaultTypeResolverBuilder\n        extends StdTypeResolverBuilder\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Definition of what types is this default typer valid for.\n         */\n        protected final DefaultTyping _appliesFor;\n\n        public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n     *   sure what'd be simple and elegant way. So until then:\n     */\n    protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n\n    // 16-May-2009, tatu: Ditto ^^^\n    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n\n    protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n\n    protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter();\n    \n    /**\n     * Base settings contain defaults used for all {@link ObjectMapper}\n     * instances.\n     */\n    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n            DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n            null, StdDateFormat.instance, null,\n            Locale.getDefault(),\n//            TimeZone.getDefault()\n            TimeZone.getTimeZone(\"GMT\"),\n            Base64Variants.getDefaultVariant() // 2.1\n    );\n\n    /*\n    /**********************************************************\n    /* Configuration settings, shared\n    /**********************************************************\n     */\n\n    /**\n     * Factory used to create {@link JsonParser} and {@link JsonGenerator}\n     * instances as necessary.\n     */\n    protected final JsonFactory _jsonFactory;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected TypeFactory _typeFactory;\n\n    /**\n     * Provider for values to inject in deserialized POJOs.\n     */\n    protected InjectableValues _injectableValues;\n\n    /**\n     * Thing used for registering sub-types, resolving them to\n     * super/sub-types as needed.\n     */\n    protected SubtypeResolver _subtypeResolver;\n\n    /**\n     * Cache for root names used when root-wrapping is enabled.\n     */\n    protected final RootNameLookup _rootNames;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Mapping that defines how to apply mix-in annotations: key is\n     * the type to received additional annotations, and value is the\n     * type that has annotations to \"mix in\".\n     *<p>\n     * Annotations associated with the value classes will be used to\n     * override annotations of the key class, associated with the\n     * same field or method. They can be further masked by sub-classes:\n     * you can think of it as injecting annotations between the target\n     * class and its sub-classes (or interfaces)\n     */\n    protected final HashMap<ClassKey,Class<?>> _mixInAnnotations;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected SerializationConfig _serializationConfig;\n\n    /**\n     * Object that manages access to serializers used for serialization,\n     * including caching.\n     * It is configured with {@link #_serializerFactory} to allow\n     * for constructing custom serializers.\n     *<p>\n     * Note: while serializers are only exposed {@link SerializerProvider},\n     * mappers and readers need to access additional API defined by\n     * {@link DefaultSerializerProvider}\n     */\n    protected DefaultSerializerProvider _serializerProvider;\n\n    /**\n     * Serializer factory used for constructing serializers.\n     */\n    protected SerializerFactory _serializerFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected DeserializationConfig _deserializationConfig;\n\n    /**\n     * Blueprint context object; stored here to allow custom\n     * sub-classes. Contains references to objects needed for\n     * deserialization construction (cache, factory).\n     */\n    protected DefaultDeserializationContext _deserializationContext;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /* Note: handling of serializers and deserializers is not symmetric;\n     * and as a result, only root-level deserializers can be cached here.\n     * This is mostly because typing and resolution for deserializers is\n     * fully static; whereas it is quite dynamic for serialization.\n     */\n\n    /**\n     * We will use a separate main-level Map for keeping track\n     * of root-level deserializers. This is where most succesful\n     * cache lookups get resolved.\n     * Map will contain resolvers for all kinds of types, including\n     * container types: this is different from the component cache\n     * which will only cache bean deserializers.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * explicitly define a low concurrency setting.\n     *<p>\n     * Since version 1.5, these may are either \"raw\" deserializers (when\n     * no type information is needed for base type), or type-wrapped\n     * deserializers (if it is needed)\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructing instance\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor, which will construct the default\n     * {@link JsonFactory} as necessary, use\n     * {@link SerializerProvider} as its\n     * {@link SerializerProvider}, and\n     * {@link BeanSerializerFactory} as its\n     * {@link SerializerFactory}.\n     * This means that it\n     * can serialize all standard JDK types, as well as regular\n     * Java Beans (based on method names and Jackson-specific annotations),\n     * but does not support JAXB annotations.\n     */\n    public ObjectMapper()\n    {\n        this(null, null, null);\n    }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s.\n     */\n    public ObjectMapper(JsonFactory jf)\n    {\n        this(jf, null, null);\n    }\n\n    /**\n     * Copy-constructor, mostly used to support {@link #copy}.\n     * \n     * @since 2.1\n     */\n    protected ObjectMapper(ObjectMapper src)\n    {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _rootNames = new RootNameLookup();\n        _typeFactory = src._typeFactory;\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>(src._mixInAnnotations);\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = src._serializerFactory;\n    }\n    \n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s, and uses given providers for accessing\n     * serializers and deserializers.\n     * \n     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n     * @param dc Blueprint deserialization context instance to use for creating\n     *    actual context objects; if null, will construct standard\n     *    {@link DeserializationContext}\n     */\n    public ObjectMapper(JsonFactory jf,\n            DefaultSerializerProvider sp, DefaultDeserializationContext dc)\n    {\n        /* 02-Mar-2009, tatu: Important: we MUST default to using\n         *   the mapping factory, otherwise tree serialization will\n         *   have problems with POJONodes.\n         * 03-Jan-2010, tatu: and obviously we also must pass 'this',\n         *    to create actual linking.\n         */\n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { // as per [JACKSON-741]\n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        _rootNames = new RootNameLookup();\n        // and default type factory is shared one\n        _typeFactory = TypeFactory.defaultInstance();\n\n        HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n        _mixInAnnotations = mixins;\n        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                    _subtypeResolver, mixins);\n\n        // Some overrides we may need\n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy()\n    {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    /**\n     * @since 2.1\n     * @param exp\n     */\n    protected void _checkInvalidCopy(Class<?> exp)\n    {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Versioned impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n    \n    /*\n    /**********************************************************\n    /* com.fasterxml.jackson.databind.Module registration, discovery\n    /**********************************************************\n     */\n\n    /**\n     * Method for registering a module that can extend functionality\n     * provided by this mapper; for example, by adding providers for\n     * custom serializers and deserializers.\n     * \n     * @param module com.fasterxml.jackson.databind.Module to register\n     */\n    public ObjectMapper registerModule(Module module)\n    {\n        /* Let's ensure we have access to name and version information, \n         * even if we do not have immediate use for either. This way we know\n         * that they will be available from beginning\n         */\n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        // And then call registration\n        module.setupModule(new Module.SetupContext()\n        {\n            // // // Accessors\n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                // why do we need the cast here?!?\n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            // // // Methods for registering handlers: deserializers\n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            // // // Methods for registering handlers: serializers\n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            // // // Methods for registering handlers: other\n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixInAnnotations(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Module... modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)\n    {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    /**\n     * Convenience method that is functionally equivalent to:\n     *<code>\n     *   mapper.registerModules(mapper.findModules());\n     *<code>\n     *<p>\n     * As with {@link #findModules()}, no caching is done for modules, so care\n     * needs to be taken to either create and share a single mapper instance;\n     * or to cache introspected set of modules.\n     *\n     * @since 2.2\n     */\n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: main config object access\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns the shared default {@link SerializationConfig}\n     * object that defines configuration settings for serialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    /**\n     * Method that returns\n     * the shared default {@link DeserializationConfig} object\n     * that defines configuration settings for deserialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    /**\n     * Method for getting current {@link DeserializationContext}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of context object.\n    */\n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: ser/deser factory, provider access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for setting specific {@link SerializerFactory} to use\n     * for constructing (bean) serializers.\n     */\n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    /**\n     * Method for getting current {@link SerializerFactory}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of factory object.\n     */\n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    /**\n     * Method for setting specific {@link SerializerProvider} to use\n     * for handling caching of {@link JsonSerializer} instances.\n     */\n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Method to use for defining mix-in annotations to use for augmenting\n     * annotations that processable (serializable / deserializable)\n     * classes have.\n     * Mixing in is done when introspecting class annotations and properties.\n     * Map passed contains keys that are target classes (ones to augment\n     * with new annotation overrides), and values that are source classes\n     * (have annotations to use for augmentation).\n     * Annotations from source classes (and their supertypes)\n     * will <b>override</b>\n     * annotations that target classes (and their super-types) have.\n     */\n    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n    {\n        _mixInAnnotations.clear();\n        if (sourceMixins != null && sourceMixins.size() > 0) {\n            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n            }\n        }\n    }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     */\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n    }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     */\n    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n        return this;\n    }\n\n    public final Class<?> findMixInClassFor(Class<?> cls) {\n        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n    }\n\n    public final int mixInCount() {\n        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     */\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    /**\n     * Method for setting currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     * This default checker is used if no per-class overrides\n     * are defined.\n     */    \n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n    }\n\n    /**\n     * Convenience method that allows changing configuration for\n     * underlying {@link VisibilityChecker}s, to change details of what kinds of\n     * properties are auto-detected.\n     * Basically short cut for doing:\n     *<pre>\n     *  mapper.setVisibilityChecker(\n     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)\n     *  );\n     *</pre>\n     * one common use case would be to do:\n     *<pre>\n     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);\n     *</pre>\n     * which would make all member fields serializable without further annotations,\n     * instead of just public fields (default setting).\n     * \n     * @param forMethod Type of property descriptor affected (field, getter/isGetter,\n     *     setter, creator)\n     * @param visibility Minimum visibility to require for the property descriptors of type\n     * \n     * @return Modified mapper instance (that is, \"this\"), to allow chaining\n     *    of configuration calls\n     */\n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    /**\n     * Method for accessing subtype resolver in use.\n     */\n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    /**\n     * Method for setting custom subtype resolver to use.\n     */\n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} used by this\n     * mapper instance for both serialization and deserialization\n     */\n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} instances used\n     * by this mapper instance for serialization and deserialization,\n     * specifying them separately so that different introspection can be\n     * used for different aspects\n     * \n     * @since 2.1\n     * \n     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n     *    serialization\n     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n     *    deserialization\n     */\n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    /**\n     * Method for setting custom property naming strategy to use.\n     */\n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    /**\n     * Method for setting defalt POJO property inclusion strategy for serialization.\n     */\n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Type information configuration (1.5+)\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information -- needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --\n     * using \"As.PROPERTY\" inclusion mechanism and specified property name\n     * to use for inclusion (default being \"@class\" since default type information\n     * always uses class name as type identifier)\n     */\n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    /**\n     * Method for disabling automatic inclusion of type information; if so, only\n     * explicitly annotated types (ones with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have\n     * additional embedded type information.\n     */\n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Type for given class is determined from appropriate annotation;\n     * or if missing, default name (unqualified class name)\n     */\n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Name may be provided as part of argument, but if not will\n     * be based on annotations or use default name (unqualified\n     * class name).\n     */\n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration, basic type handling\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting currently configured {@link TypeFactory} instance.\n     */\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    /**\n     * Method that can be used to override {@link TypeFactory} instance\n     * used by this mapper.\n     *<p>\n     * Note: will also set {@link TypeFactory} that deserialization and\n     * serialization config objects use.\n     */\n    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    /**\n     * Convenience method for constructing {@link JavaType} out of given\n     * type (typically <code>java.lang.Class</code>), but without explicit\n     * context.\n     */\n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, deserialization\n    /**********************************************************\n     */\n    \n    /**\n     * Method for specifying {@link JsonNodeFactory} to use for\n     * constructing root level tree nodes (via method\n     * {@link #createObjectNode}\n     */\n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for adding specified {@link DeserializationProblemHandler}\n     * to be used for handling specific problems during deserialization.\n     */\n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    /**\n     * Method for removing all registered {@link DeserializationProblemHandler}s\n     * instances from this mapper.\n     */\n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link DeserializationConfig}\n     * object.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any deserialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *  mapper.setFilters(mapper.getSerializationConfig().withFilters(filterProvider));\n     *</pre>\n     *<p>\n     * Note that usually it is better to use method {@link #writer(FilterProvider)};\n     * however, sometimes\n     * this method is more convenient. For example, some frameworks only allow configuring\n     * of ObjectMapper instances and not ObjectWriters.\n     */\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    /**\n     * Method that will configure default {@link Base64Variant} that\n     * <code>byte[]</code> serializers and deserializers will use.\n     * \n     * @param v Base64 variant to use\n     * \n     * @return This mapper, for convenience to allow chaining\n     * \n     * @since 2.1\n     */\n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link SerializationConfig}\n     * object, which contains serialization-specific configuration settings.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any serialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(SerializationConfig config) {\n    \t_serializationConfig = config;\n    \treturn this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonFactory} that this\n     * mapper uses if it needs to construct {@link JsonParser}s\n     * and/or {@link JsonGenerator}s.\n     *\n     * @return {@link JsonFactory} that this mapper uses when it needs to\n     *   construct Json parser and generators\n     */\n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    /**\n     * Method for configuring the default {@link DateFormat} to use when serializing time\n     * values as Strings, and deserializing from JSON Strings.\n     * This is preferably to directly modifying {@link SerializationConfig} and\n     * {@link DeserializationConfig} instances.\n     * If you need per-request configuration, use {@link #writer(DateFormat)} to\n     * create properly configured {@link ObjectWriter} and use that; this because\n     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n     * thread-safe when configuring methods (such as this one) are NOT called.\n     */\n    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    /**\n     * Method for configuring {@link HandlerInstantiator} to use for creating\n     * instances of handlers (such as serializers, deserializers, type and type\n     * id resolvers), given a class.\n     *\n     * @param hi Instantiator to use; if null, use the default implementation\n     */\n    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    /**\n     * Method for configuring {@link InjectableValues} which used to find\n     * values to inject.\n     */\n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n    \n    /**\n     * Method for overriding default locale to use for formatting.\n     * Default value used is {@link Locale#getDefault()}.\n     */\n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    /**\n     * Method for overriding default TimeZone to use for formatting.\n     * Default value used is UTC (NOT local timezone).\n     */\n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features\n    /**********************************************************\n     */\n\n    /**\n     * Method for changing state of an on/off mapper feature for\n     * this mapper instance.\n     */\n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n    \n    /**\n     * Method for changing state of an on/off serialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for changing state of an on/off deserialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for changing state of an on/off {@link JsonParser} feature for\n     * {@link JsonFactory} instance this object mapper uses.\n     *<p>\n     * This is method is basically a shortcut method for calling\n     * {@link JsonFactory#enable} on the shared\n     * {@link JsonFactory} this mapper uses (which is accessible\n     * using {@link #getJsonFactory}).\n     */\n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    /**\n     * Method for changing state of an on/off {@link JsonGenerator} feature for\n     * {@link JsonFactory} instance this object mapper uses.\n     *<p>\n     * This is method is basically a shortcut method for calling\n     * {@link JsonFactory#enable} on the shared\n     * {@link JsonFactory} this mapper uses (which is accessible\n     * using {@link #getJsonFactory}).\n     */\n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n\n    /**\n     * Method for checking whether given Mapper\n     * feature is enabled.\n     */\n    public boolean isEnabled(MapperFeature f) {\n        // ok to use either one, should be kept in sync\n        return _serializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Method for checking whether given serialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n    \n    /**\n     * Method for checking whether given deserialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n    \n    /**\n     * Method that can be used to get hold of {@link JsonNodeFactory}\n     * that this mapper will use when directly constructing\n     * root {@link JsonNode} instances for Trees.\n     *<p>\n     * Note: this is just a shortcut for calling\n     *<pre>\n     *   getDeserializationConfig().getNodeFactory()\n     *</pre>\n     */\n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): deserialization\n    /* (mapping from JSON to Java types);\n    /* main methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        /* 02-Mar-2009, tatu: One twist; deserialization provider\n         *   will map JSON null straight into Java null. But what\n         *   we want to return is the \"null node\" instead.\n         */\n        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n         *   calling readValue(), since that'll choke on it otherwise\n         */\n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     *<p>\n     * Note that {@link ObjectReader} has more complete set of variants.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n            throws IOException, JsonProcessingException\n    {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        // false -> do NOT close JsonParser (since caller passed it)\n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API not included in ObjectCodec: deserialization\n    /* (mapping from JSON to Java types)\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): serialization\n    /* (mapping from Java types to Json)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using provided {@link JsonGenerator}.\n     */\n    @Override\n    public void writeValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(jgen, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(jgen, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from TreeCodec via ObjectCodec): Tree Model support\n    /**********************************************************\n     */\n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     * Method to serialize given JSON Tree, using generator\n     * provided.\n     */\n    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    /**\n     * Method for constructing a {@link JsonParser} out of JSON tree\n     * representation.\n     * \n     * @param n Root node of the tree that resulting parser will read from\n     */\n    @Override\n    public JsonParser treeAsTokens(TreeNode n)\n    {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    /**\n     * Convenience conversion method that will bind data given JSON tree\n     * contains into specific value (usually bean) type.\n     *<p>\n     * Functionally equivalent to:\n     *<pre>\n     *   objectMapper.convertValue(n, valueClass);\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: one known difference from actual serialization is that so-called\n     * \"raw values\" are not supported -- since they are opaque sequence of\n     * bytes to include (which may or may not be supported by the backend)\n     * they can not be converted using this method. It may be possible to\n     * support conversions using full serialization, if raw values must be\n     * preserved.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could serialize an instance of given Class.\n     * Check is done\n     * by checking whether a serializer can be found for the type.\n     *<p>\n     * NOTE: since this method does NOT throw exceptions, but internal\n     * processing may, caller usually has little information as to why\n     * serialization would fail.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canSerialize(Class)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could deserialize an Object of given type.\n     * Check is done\n     * by checking whether a deserializer can be found for the type.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canDeserialize(JavaType type)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canDeserialize(JavaType)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API, deserialization,\n    /* convenience methods\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//      _setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API: serialization\n    /* (mapping from Java types to JSON)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, written to File provided.\n     */\n    public void writeValue(File resultFile, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using output stream provided (using encoding\n     * {@link JsonEncoding#UTF8}).\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(OutputStream out, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using Writer provided.\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(Writer w, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    /**\n     * Method that can be used to serialize any Java value as\n     * a byte array. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n     * and getting bytes, but more efficient.\n     * Encoding used will be UTF-8.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectWriters\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for constructing {@link ObjectWriter}\n     * with default settings.\n     */\n    public ObjectWriter writer() {\n        return new ObjectWriter(this, getSerializationConfig());\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature feature) {\n        return new ObjectWriter(this, getSerializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature first,\n            SerializationFeature... other) {\n        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified {@link DateFormat}; or, if\n     * null passed, using timestamp (64-bit number.\n     */\n    public ObjectWriter writer(DateFormat df) {\n        return new ObjectWriter(this, getSerializationConfig().with(df));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified JSON View (filter).\n     */\n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime\n     * type.\n     */\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     */\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     */\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified pretty printer for indentation\n     * (or if null, no pretty printer)\n     */\n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using the default pretty printer for indentation\n     */\n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        return new ObjectWriter(this, getSerializationConfig(),\n                /*root type*/ null, _defaultPrettyPrinter());\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified filter provider.\n     */\n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return new ObjectWriter(this,\n                getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * pass specific schema object to {@link JsonGenerator} used for\n     * writing content.\n     * \n     * @param schema Schema to pass to generator\n     */\n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectWriter(this, getSerializationConfig(), schema);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified character escaping details for output.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return writer().with(escapes);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(ContextAttributes attrs) {\n        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectReaders\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * default settings. Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader() {\n        return new ObjectReader(this, getDeserializationConfig())\n            .with(_injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature feature) {\n        return new ObjectReader(this, getDeserializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature first,\n            DeserializationFeature... other) {\n        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * update given Object (usually Bean, but can be a Collection or Map\n     * as well, but NOT an array) with JSON data. Deserialization occurs\n     * normally except that the root-level value in JSON is not used for\n     * instantiating a new object; instead give updateable object is used\n     * as root.\n     * Runtime type of value object is used for locating deserializer,\n     * unless overridden by other factory methods of {@link ObjectReader}\n     */\n    public ObjectReader readerForUpdating(Object valueToUpdate)\n    {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(JavaType type)\n    {\n        return new ObjectReader(this, getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(Class<?> type)\n    {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(TypeReference<?> type)\n    {\n        return reader(_typeFactory.constructType(type));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified {@link JsonNodeFactory} for constructing JSON trees.\n     */\n    public ObjectReader reader(JsonNodeFactory f)\n    {\n        return new ObjectReader(this, getDeserializationConfig()).with(f);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * pass specific schema object to {@link JsonParser} used for\n     * reading content.\n     * \n     * @param schema Schema to pass to parser\n     */\n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified injectable values.\n     * \n     * @param injectableValues Injectable values to use\n     */\n    public ObjectReader reader(InjectableValues injectableValues) {\n        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * deserialize objects using specified JSON View (filter).\n     */\n    public ObjectReader readerWithView(Class<?> view) {\n        return new ObjectReader(this, getDeserializationConfig().withView(view));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectReader reader(ContextAttributes attrs) {\n        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: convenience type conversion\n    /**********************************************************\n     */\n   \n    /**\n     * Convenience method for doing two-step conversion from given value, into\n     * instance of given value type. This is functionality equivalent to first\n     * serializing given value into JSON, then binding JSON data into value\n     * of given type, but may be executed without fully serializing into\n     * JSON. Same converters (serializers, deserializers) will be used as for\n     * data binding, meaning same object mapper configuration works.\n     *      \n     * @throws IllegalArgumentException If conversion fails due to incompatible type;\n     *    if so, root cause will contain underlying checked exception data binding\n     *    functionality threw\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n        throws IllegalArgumentException\n    {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        /* Then use TokenBuffer, which is a JsonGenerator:\n         * (see [JACKSON-175])\n         */\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: JSON Schema generation\n    /**********************************************************\n     */\n\n    /**\n     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n     * instance for specified class.\n     *\n     * @param t The class to generate schema for\n     * @return Constructed JSON schema.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     * Visitation uses <code>Serializer</code> hierarchy and related properties\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for serialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used for constructing\n     * {@link SerializerProvider} to use for serialization.\n     */\n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    /**\n     * Helper method that should return default pretty-printer to\n     * use for generators constructed by this mapper, when instructed\n     * to use default pretty printer.\n     */\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }\n    \n    /**\n     * Method called to configure the generator as necessary and then\n     * call write functionality\n     */\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig();\n        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            /* won't try to close twice; also, must catch exception (so it \n             * will not mask exception that is pending)\n             */\n            if (!closed) {\n                /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                 *    structures, which typically causes more damage.\n                 */\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            if (!closed) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (jgen != null) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for deserialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg)\n    {\n        return _deserializationContext.createInstance(cfg,\n                jp, _injectableValues);\n    }\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: may need to read the next token, to initialize\n         * state (either before first read from parser, or after\n         * previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue();\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            // ok, let's get the value\n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            // Need to consume the token too\n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    /**\n     * Method called to ensure that given parser is ready for reading\n     * content for data binding.\n     *\n     * @return First token to be used for data binding after this call:\n     *  can never be null as exception will be thrown if parser can not\n     *  provide more tokens.\n     *\n     * @throws IOException if the underlying input source has problems during\n     *   parsing\n     * @throws JsonParseException if parser has problems parsing content\n     * @throws JsonMappingException if the parser does not have any more\n     *   content to map (note: Json \"null\" value is considered content;\n     *   enf-of-stream not)\n     */\n    protected JsonToken _initForReading(JsonParser jp)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            // and then we must get something...\n            t = jp.nextToken();\n            if (t == null) {\n                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                 *   not an actual parsing problem\n                 */\n                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n            DeserializationConfig config,\n            JavaType rootType, JsonDeserializer<Object> deser)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        String expName = config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        jp.nextToken();\n        Object result = deser.deserialize(jp, ctxt);\n        // and last, verify that we now get matching END_OBJECT\n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 18, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.MappingIterator", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Iterator exposed by {@link ObjectMapper} when binding sequence of\n * objects. Extension is done to allow more convenient exposing of\n * {@link IOException} (which basic {@link Iterator} does not expose)\n */\npublic class MappingIterator<T> implements Iterator<T>, Closeable\n{\n    protected final static MappingIterator<?> EMPTY_ITERATOR =\n        new MappingIterator<Object>(null, null, null, null, false, null);\n\n    /*\n    /**********************************************************\n    /* State constants\n    /**********************************************************\n     */\n\n    /**\n     * State in which iterator is closed\n     */\n    \n    /**\n     * State in which value read failed\n     */\n    \n    /**\n     * State in which no recovery is needed, but \"hasNextValue()\" needs\n     * to be called first\n     */\n\n    /**\n     * State in which \"hasNextValue()\" has been succesfully called\n     * and deserializer can be called to fetch value\n     */\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Type to bind individual elements to.\n     */\n    protected final JavaType _type;\n\n    /**\n     * Context for deserialization, needed to pass through to deserializer\n     */\n    protected final DeserializationContext _context;\n\n    /**\n     * Deserializer for individual element values.\n     */\n    protected final JsonDeserializer<T> _deserializer;\n\n    /**\n     * Underlying parser used for reading content to bind. Initialized\n     * as not <code>null</code> but set as <code>null</null> when\n     * iterator is closed, to denote closing.\n     */\n    protected JsonParser _parser;\n\n    /**\n     * Context to resynchronize to, in case an exception is encountered\n     * but caller wants to try to read more elements.\n     */\n    \n    /**\n     * If not null, \"value to update\" instead of creating a new instance\n     * for each call.\n     */\n    protected final T _updatedValue;\n    \n    /**\n     * Flag that indicates whether input {@link JsonParser} should be closed\n     * when we are done or not; generally only called when caller did not\n     * pass JsonParser.\n     */\n    protected final boolean _closeParser;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * State of the iterator\n     */\n    protected boolean _hasNextChecked;\n\n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n    \n    /**\n     * @param managedParser Whether we \"own\" the {@link JsonParser} passed or not:\n     *   if true, it was created by {@link ObjectReader} and code here needs to\n     *   close it; if false, it was passed by calling code and should not be\n     *   closed by iterator.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt,\n            JsonDeserializer<?> deser,\n            boolean managedParser, Object valueToUpdate)\n    {\n        _type = type;\n        _parser = p;\n        _context = ctxt;\n        _deserializer = (JsonDeserializer<T>) deser;\n        _closeParser = managedParser;\n        if (valueToUpdate == null) {\n            _updatedValue = null;\n        } else {\n            _updatedValue = (T) valueToUpdate;\n        }\n\n        /* Ok: one more thing; we may have to skip START_ARRAY, assuming\n         * \"wrapped\" sequence; but this is ONLY done for 'managed' parsers\n         * and never if JsonParser was directly passed by caller (if it\n         * was, caller must have either positioned it over first token of\n         * the first element, or cleared the START_ARRAY token explicitly).\n         * Note, however, that we do not try to guess whether this could be\n         * an unwrapped sequence of arrays/Lists: we just assume it is wrapped;\n         * and if not, caller needs to hand us JsonParser instead, pointing to\n         * the first token of the first element.\n         */\n        if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {\n                // If pointing to START_ARRAY, context should be that ARRAY\n                p.clearCurrentToken();\n                // regardless, recovery context should be whatever context we have now,\n                // with sole exception of pointing to a start marker, in which case it's\n                // the parent\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T> MappingIterator<T> emptyIterator() {\n        return (MappingIterator<T>) EMPTY_ITERATOR;\n    }\n    \n    /*\n    /**********************************************************\n    /* Basic iterator impl\n    /**********************************************************\n     */\n\n    @Override\n    public boolean hasNext()\n    {\n        try {\n            return hasNextValue();\n        } catch (JsonMappingException e) {\n            return (Boolean) _handleMappingException(e);\n        } catch (IOException e) {\n            return (Boolean) _handleIOException(e);\n        }\n    }\n    \n    @Override\n    public T next()\n    {\n        try {\n            return nextValue();\n        } catch (JsonMappingException e) {\n            throw new RuntimeJsonMappingException(e.getMessage(), e);\n        } catch (IOException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void close() throws IOException {\n            if (_parser != null) {\n                _parser.close();\n            }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, iteration\n    /**********************************************************\n     */\n\n\n    /*\n     */\n    \n    /**\n     * Equivalent of {@link #next} but one that may throw checked\n     * exceptions from Jackson due to invalid input.\n     */\n    public boolean hasNextValue() throws IOException\n    {\n        if (_parser == null) {\n            return false;\n            // fall-through\n        }\n        if (!_hasNextChecked) {\n            JsonToken t = _parser.getCurrentToken();\n            _hasNextChecked = true;\n            if (t == null) { // un-initialized or cleared; find next\n                t = _parser.nextToken();\n                // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).\n                if (t == null || t == JsonToken.END_ARRAY) {\n                    JsonParser jp = _parser;\n                    _parser = null;\n                    if (_closeParser) {\n                        jp.close();\n                    }\n                    return false;\n                }\n            }\n            // fall through\n        }\n        return true;\n    }\n\n    public T nextValue() throws IOException\n    {\n        if (!_hasNextChecked) {\n            if (!hasNextValue()) {\n                return _throwNoSuchElement();\n            }\n        }\n        if (_parser == null) {\n            return _throwNoSuchElement();\n        }\n        _hasNextChecked = false;\n\n        try {\n            T value;\n            if (_updatedValue == null) {\n                value = _deserializer.deserialize(_parser, _context);\n            } else{\n                _deserializer.deserialize(_parser, _context, _updatedValue);\n                value = _updatedValue;\n            }\n            return value;\n        } finally {\n            /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no\n             *   matter what, to avoid infinite loop for certain failure cases.\n             *   For 2.6 need to improve further.\n             */\n            _parser.clearCurrentToken();\n        }\n    }\n\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n     * \n     * @return List of entries read\n     * \n     * @since 2.2\n     */\n    public List<T> readAll() throws IOException {\n        return readAll(new ArrayList<T>());\n    }\n\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator\n     * \n     * @return List of entries read (same as passed-in argument)\n     * \n     * @since 2.2\n     */\n    public <L extends List<? super T>> L readAll(L resultList) throws IOException\n    {\n        while (hasNextValue()) {\n            resultList.add(nextValue());\n        }\n        return resultList;\n    }\n\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator\n     * \n     * @since 2.5\n     */\n    public <C extends Collection<? super T>> C readAll(C results) throws IOException\n    {\n        while (hasNextValue()) {\n            results.add(nextValue());\n        }\n        return results;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting underlying parser this iterator uses.\n     * \n     * @since 2.2\n     */\n    public JsonParser getParser() {\n        return _parser;\n    }\n\n    /**\n     * Accessor for accessing {@link FormatSchema} that the underlying parser\n     * (as per {@link #getParser}) is using, if any; only parser of schema-aware\n     * formats use schemas.\n     * \n     * @since 2.2\n     */\n    public FormatSchema getParserSchema() {\n    \treturn _parser.getSchema();\n    }\n\n    /**\n     * Convenience method, functionally equivalent to:\n     *<code>\n     *   iterator.getParser().getCurrentLocation()\n     *</code>\n     * \n     * @return Location of the input stream of the underlying parser\n     * \n     * @since 2.2.1\n     */\n    public JsonLocation getCurrentLocation() {\n        return _parser.getCurrentLocation();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n        // First, a quick check to see if we might have been lucky and no re-sync needed\n\n\n    protected <R> R _throwNoSuchElement() {\n        throw new NoSuchElementException();\n    }\n    \n    protected <R> R _handleMappingException(JsonMappingException e) {\n        throw new RuntimeJsonMappingException(e.getMessage(), e);\n    }\n\n    protected <R> R _handleIOException(IOException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Iterator exposed by {@link ObjectMapper} when binding sequence of\n * objects. Extension is done to allow more convenient exposing of\n * {@link IOException} (which basic {@link Iterator} does not expose)\n */\npublic class MappingIterator<T> implements Iterator<T>, Closeable\n{\n    protected final static MappingIterator<?> EMPTY_ITERATOR =\n        new MappingIterator<Object>(null, null, null, null, false, null);\n\n    /*\n    /**********************************************************\n    /* State constants\n    /**********************************************************\n     */\n\n    /**\n     * State in which iterator is closed\n     */\n    protected final static int STATE_CLOSED = 0;\n    \n    /**\n     * State in which value read failed\n     */\n    protected final static int STATE_NEED_RESYNC = 1;\n    \n    /**\n     * State in which no recovery is needed, but \"hasNextValue()\" needs\n     * to be called first\n     */\n    protected final static int STATE_MAY_HAVE_VALUE = 2;\n\n    /**\n     * State in which \"hasNextValue()\" has been succesfully called\n     * and deserializer can be called to fetch value\n     */\n    protected final static int STATE_HAS_VALUE = 3;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Type to bind individual elements to.\n     */\n    protected final JavaType _type;\n\n    /**\n     * Context for deserialization, needed to pass through to deserializer\n     */\n    protected final DeserializationContext _context;\n\n    /**\n     * Deserializer for individual element values.\n     */\n    protected final JsonDeserializer<T> _deserializer;\n\n    /**\n     * Underlying parser used for reading content to bind. Initialized\n     * as not <code>null</code> but set as <code>null</null> when\n     * iterator is closed, to denote closing.\n     */\n    protected final JsonParser _parser;\n\n    /**\n     * Context to resynchronize to, in case an exception is encountered\n     * but caller wants to try to read more elements.\n     */\n    protected final JsonStreamContext _seqContext;\n    \n    /**\n     * If not null, \"value to update\" instead of creating a new instance\n     * for each call.\n     */\n    protected final T _updatedValue;\n    \n    /**\n     * Flag that indicates whether input {@link JsonParser} should be closed\n     * when we are done or not; generally only called when caller did not\n     * pass JsonParser.\n     */\n    protected final boolean _closeParser;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * State of the iterator\n     */\n    protected int _state;\n\n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n    \n    /**\n     * @param managedParser Whether we \"own\" the {@link JsonParser} passed or not:\n     *   if true, it was created by {@link ObjectReader} and code here needs to\n     *   close it; if false, it was passed by calling code and should not be\n     *   closed by iterator.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt,\n            JsonDeserializer<?> deser,\n            boolean managedParser, Object valueToUpdate)\n    {\n        _type = type;\n        _parser = p;\n        _context = ctxt;\n        _deserializer = (JsonDeserializer<T>) deser;\n        _closeParser = managedParser;\n        if (valueToUpdate == null) {\n            _updatedValue = null;\n        } else {\n            _updatedValue = (T) valueToUpdate;\n        }\n\n        /* Ok: one more thing; we may have to skip START_ARRAY, assuming\n         * \"wrapped\" sequence; but this is ONLY done for 'managed' parsers\n         * and never if JsonParser was directly passed by caller (if it\n         * was, caller must have either positioned it over first token of\n         * the first element, or cleared the START_ARRAY token explicitly).\n         * Note, however, that we do not try to guess whether this could be\n         * an unwrapped sequence of arrays/Lists: we just assume it is wrapped;\n         * and if not, caller needs to hand us JsonParser instead, pointing to\n         * the first token of the first element.\n         */\n        if (p == null) { // can this occur?\n            _seqContext = null;\n            _state = STATE_CLOSED;\n        } else {\n            JsonStreamContext sctxt = p.getParsingContext();\n            if (managedParser && p.isExpectedStartArrayToken()) {\n                // If pointing to START_ARRAY, context should be that ARRAY\n                p.clearCurrentToken();\n            } else {\n                // regardless, recovery context should be whatever context we have now,\n                // with sole exception of pointing to a start marker, in which case it's\n                // the parent\n                JsonToken t = p.getCurrentToken();\n                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {\n                    sctxt = sctxt.getParent();\n                }\n            }\n            _seqContext = sctxt;\n            _state = STATE_MAY_HAVE_VALUE;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T> MappingIterator<T> emptyIterator() {\n        return (MappingIterator<T>) EMPTY_ITERATOR;\n    }\n    \n    /*\n    /**********************************************************\n    /* Basic iterator impl\n    /**********************************************************\n     */\n\n    @Override\n    public boolean hasNext()\n    {\n        try {\n            return hasNextValue();\n        } catch (JsonMappingException e) {\n            return (Boolean) _handleMappingException(e);\n        } catch (IOException e) {\n            return (Boolean) _handleIOException(e);\n        }\n    }\n    \n    @Override\n    public T next()\n    {\n        try {\n            return nextValue();\n        } catch (JsonMappingException e) {\n            throw new RuntimeJsonMappingException(e.getMessage(), e);\n        } catch (IOException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void close() throws IOException {\n        if (_state != STATE_CLOSED) {\n            _state = STATE_CLOSED;\n            if (_parser != null) {\n                _parser.close();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, iteration\n    /**********************************************************\n     */\n\n\n    /*\n     */\n    \n    /**\n     * Equivalent of {@link #next} but one that may throw checked\n     * exceptions from Jackson due to invalid input.\n     */\n    public boolean hasNextValue() throws IOException\n    {\n        switch (_state) {\n        case STATE_CLOSED:\n            return false;\n        case STATE_NEED_RESYNC:\n            _resync();\n            // fall-through\n        case STATE_MAY_HAVE_VALUE:\n            JsonToken t = _parser.getCurrentToken();\n            if (t == null) { // un-initialized or cleared; find next\n                t = _parser.nextToken();\n                // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).\n                if (t == null || t == JsonToken.END_ARRAY) {\n                    _state = STATE_CLOSED;\n                    if (_closeParser && (_parser != null)) {\n                        _parser.close();\n                    }\n                    return false;\n                }\n            }\n            _state = STATE_HAS_VALUE;\n            return true;\n        case STATE_HAS_VALUE:\n            // fall through\n        }\n        return true;\n    }\n\n    public T nextValue() throws IOException\n    {\n        switch (_state) {\n        case STATE_CLOSED:\n            return _throwNoSuchElement();\n        case STATE_NEED_RESYNC: // fall-through, will do re-sync\n        case STATE_MAY_HAVE_VALUE:\n            if (!hasNextValue()) {\n                return _throwNoSuchElement();\n            }\n            break;\n        case STATE_HAS_VALUE:\n            break;\n        }\n\n        int nextState = STATE_NEED_RESYNC;\n        try {\n            T value;\n            if (_updatedValue == null) {\n                value = _deserializer.deserialize(_parser, _context);\n            } else{\n                _deserializer.deserialize(_parser, _context, _updatedValue);\n                value = _updatedValue;\n            }\n            nextState = STATE_MAY_HAVE_VALUE;\n            return value;\n        } finally {\n            _state = nextState;\n            /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no\n             *   matter what, to avoid infinite loop for certain failure cases.\n             *   For 2.6 need to improve further.\n             */\n            _parser.clearCurrentToken();\n        }\n    }\n\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n     * \n     * @return List of entries read\n     * \n     * @since 2.2\n     */\n    public List<T> readAll() throws IOException {\n        return readAll(new ArrayList<T>());\n    }\n\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator\n     * \n     * @return List of entries read (same as passed-in argument)\n     * \n     * @since 2.2\n     */\n    public <L extends List<? super T>> L readAll(L resultList) throws IOException\n    {\n        while (hasNextValue()) {\n            resultList.add(nextValue());\n        }\n        return resultList;\n    }\n\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator\n     * \n     * @since 2.5\n     */\n    public <C extends Collection<? super T>> C readAll(C results) throws IOException\n    {\n        while (hasNextValue()) {\n            results.add(nextValue());\n        }\n        return results;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting underlying parser this iterator uses.\n     * \n     * @since 2.2\n     */\n    public JsonParser getParser() {\n        return _parser;\n    }\n\n    /**\n     * Accessor for accessing {@link FormatSchema} that the underlying parser\n     * (as per {@link #getParser}) is using, if any; only parser of schema-aware\n     * formats use schemas.\n     * \n     * @since 2.2\n     */\n    public FormatSchema getParserSchema() {\n    \treturn _parser.getSchema();\n    }\n\n    /**\n     * Convenience method, functionally equivalent to:\n     *<code>\n     *   iterator.getParser().getCurrentLocation()\n     *</code>\n     * \n     * @return Location of the input stream of the underlying parser\n     * \n     * @since 2.2.1\n     */\n    public JsonLocation getCurrentLocation() {\n        return _parser.getCurrentLocation();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected void _resync() throws IOException\n    {\n        final JsonParser p = _parser;\n        // First, a quick check to see if we might have been lucky and no re-sync needed\n        if (p.getParsingContext() == _seqContext) {\n            return;\n        }\n\n        while (true) {\n            JsonToken t = p.nextToken();\n            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {\n                if (p.getParsingContext() == _seqContext) {\n                    p.clearCurrentToken();\n                    return;\n                }\n            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {\n                p.skipChildren();\n            } else if (t == null) {\n                return;\n            }\n        }\n    }\n\n    protected <R> R _throwNoSuchElement() {\n        throw new NoSuchElementException();\n    }\n    \n    protected <R> R _handleMappingException(JsonMappingException e) {\n        throw new RuntimeJsonMappingException(e.getMessage(), e);\n    }\n\n    protected <R> R _handleIOException(IOException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 19, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.TypeFactory", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n    \n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n\n    /*\n     * Looks like construction of {@link JavaType} instances can be\n     * a bottleneck, esp. for root-level Maps, so we better do bit\n     * of low-level component caching here...\n     */\n    \n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedHashMapType;\n\n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedArrayListType;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n    \n    protected final TypeParser _parser;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        _parser = p;\n        _modifiers = mods;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Shouldbe able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer>\"\n     * from \"Map&ltString,Integer>\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n    \n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        /* Tricky part here is that some JavaType instances have been constructed\n         * from generic type (usually via TypeReference); and in those case\n         * types have been resolved. Alternative is that the leaf type is type-erased\n         * class, in which case this has not been done.\n         * For now simplest way to handle this is to split processing in two: latter\n         * case actually fully works; and former mostly works. In future may need to\n         * rewrite former part, which requires changes to JavaType as well.\n         */\n        if (expType == type.getParameterSource()) {\n            // Direct type info; good since we can return it as is\n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        /* Otherwise need to go through type-erased class. This may miss cases where\n         * we get generic type; ideally JavaType/SimpleType would retain information\n         * about generic declaration at main level... but let's worry about that\n         * if/when there are problems; current handling is an improvement over earlier\n         * code.\n         */\n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n        // First: find full inheritance chain\n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        // Caller is supposed to ensure this never happens, so:\n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        // Ok and then go to the ultimate super-type:\n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { // got bindings, need to resolve\n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        // which ought to be generic (if not, it's raw type)\n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        return _constructType(typeRef.getType(), null);\n    }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n\n    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n    \n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n    \n    /**\n     * Method for constructing a type instance with specified parameterization.\n     * \n     * @deprecated Since 2.5, use variant that takes one more argument\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     */\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        // Quick sanity check: must match numbers of types with expected...\n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } \n\n    /**\n     * @since 2.6\n     */\n    public JavaType constructReferenceType(Class<?> rawType, JavaType refType)\n    {\n        return new ReferenceType(rawType, refType, null, null, false);\n    }\n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }\n    \n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&ltInteger></code>, you could\n     * call\n     *<pre>\n     *  TypeFactory.constructParametrizedType(List.class, List.class, Integer.class);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList<Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * when resolving <code>parameterClasses</code> into {@link JavaType}.\n     *\n     * @param parametrized Type-erased type of instance being constructed\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterClasses Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList<Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        JavaType resultType;\n        \n        // Need to check kind of class we are dealing with...\n        if (parametrized.isArray()) {\n            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Actual factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @param context Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n        // Very first thing: small set of core types we know well:\n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        // Barring that, we may have recently constructed an instance:\n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // If context was needed, weed do:\n        /*\n        if (context == null) {\n            context = new TypeBindings(this, cls);\n        }\n        */\n\n        // First: do we have an array type?\n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            /* Also: although enums can also be fully resolved, there's little\n             * point in doing so (T extends Enum<T>) etc.\n             */\n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            /* Maps and Collections aren't quite as hot; problem is, due\n             * to type erasure we often do not know typing and can only assume\n             * base Object.\n             */\n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            // 28-Apr-2015, tatu: New class of types, referential...\n            if (AtomicReference.class.isAssignableFrom(clz)) {\n                \n                JavaType[] pts = findTypeParameters(clz, AtomicReference.class);\n                JavaType rt = (pts == null || pts.length != 1) ? unknownType() : pts[0];\n                result = constructReferenceType(clz, rt);\n            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n            } else if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); // cache object syncs\n        return result;\n    }\n    \n    /**\n     * Method used by {@link TypeParser} when generics-aware version\n     * is constructed.\n     */\n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n        if (clz.isArray()) { // ignore generics (should never have any)\n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { // ditto for enums\n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            // First: if we do have param types, use them\n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        // Hmmh. Does this actually occur?\n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }\n    \n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n        /* First: what is the actual base type? One odd thing\n         * is that 'getRawType' returns Type, not Class<?> as\n         * one might expect. But let's assume it is always of\n         * type Class: if not, need to add more code to resolve\n         * it to Class.\n         */\n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        // Ok: Map or Collection?\n        if (Map.class.isAssignableFrom(rawType)) {\n            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        // 28-Apr-2015, tatu: New class of types, referential...\n        if (AtomicReference.class.isAssignableFrom(rawType)) {\n            JavaType rt = null;\n\n            if (rawType == AtomicReference.class) {\n                if (paramCount == 1) {\n                    rt = pt[0];\n                }\n            } else {\n                JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n                if (pts != null && pts.length != 1) {\n                    rt = pts[0];\n                }\n            }\n            return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n        }\n        if (Map.Entry.class.isAssignableFrom(rawType)) {\n            JavaType kt = null, vt = null;\n\n            if (rawType == Map.Entry.class) {\n                if (paramCount == 2) {\n                    kt = pt[0];\n                    vt = pt[1];\n                }\n            } else {\n                JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n                if (pts != null && pts.length != 2) {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n            }\n            return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n        }\n        \n        if (paramCount == 0) { // no generics\n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }\n\n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n    {\n        /* Similar to challenges with TypeVariable, we may have\n         * multiple upper bounds. But it is also possible that if\n         * upper bound defaults to Object, we might want to consider\n         * lower bounds instead.\n         *\n         * For now, we won't try anything more advanced; above is\n         * just for future reference.\n         */\n        return _constructType(type.getUpperBounds()[0], context);\n    }\n\n    private JavaType _mapType(Class<?> rawClass)\n    {\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    // further resolution needed?\n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    // no we're good for the variable (but it may have parameterization of its own)\n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }\n    \n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to find inheritance (implements, extends) path\n     * between given types, if one exists (caller generally checks before\n     * calling this method). Returned type represents given <b>subtype</b>,\n     * with supertype linkage extending to <b>supertype</b>.\n     */\n    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n        // If super-type is a class (not interface), bit simpler\n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        // Otherwise, keep on going down the rat hole...\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        // Otherwise, keep on going down the rat hole; first implemented interfaces\n        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's\n         *   try caching certain commonly needed cases\n         */\n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n    {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        // as long as there are superclasses\n        // and unless we have already seen the type (<T extends X<T>>)\n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        // and then super-class if any\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n    \n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n\n    /*\n     * Looks like construction of {@link JavaType} instances can be\n     * a bottleneck, esp. for root-level Maps, so we better do bit\n     * of low-level component caching here...\n     */\n    \n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedHashMapType;\n\n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedArrayListType;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n    \n    protected final TypeParser _parser;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        _parser = p;\n        _modifiers = mods;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Shouldbe able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer>\"\n     * from \"Map&ltString,Integer>\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n    \n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        /* Tricky part here is that some JavaType instances have been constructed\n         * from generic type (usually via TypeReference); and in those case\n         * types have been resolved. Alternative is that the leaf type is type-erased\n         * class, in which case this has not been done.\n         * For now simplest way to handle this is to split processing in two: latter\n         * case actually fully works; and former mostly works. In future may need to\n         * rewrite former part, which requires changes to JavaType as well.\n         */\n        if (expType == type.getParameterSource()) {\n            // Direct type info; good since we can return it as is\n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        /* Otherwise need to go through type-erased class. This may miss cases where\n         * we get generic type; ideally JavaType/SimpleType would retain information\n         * about generic declaration at main level... but let's worry about that\n         * if/when there are problems; current handling is an improvement over earlier\n         * code.\n         */\n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n    }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n        // First: find full inheritance chain\n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        // Caller is supposed to ensure this never happens, so:\n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        // Ok and then go to the ultimate super-type:\n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { // got bindings, need to resolve\n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        // which ought to be generic (if not, it's raw type)\n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n        return _constructType(typeRef.getType(), null);\n    }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n\n    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }\n    \n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }\n    \n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }\n    \n    /**\n     * Method for constructing a type instance with specified parameterization.\n     * \n     * @deprecated Since 2.5, use variant that takes one more argument\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     */\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        // Quick sanity check: must match numbers of types with expected...\n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } \n\n    /**\n     * @since 2.6\n     */\n    public JavaType constructReferenceType(Class<?> rawType, JavaType refType)\n    {\n        return new ReferenceType(rawType, refType, null, null, false);\n    }\n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }\n    \n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&ltInteger></code>, you could\n     * call\n     *<pre>\n     *  TypeFactory.constructParametrizedType(List.class, List.class, Integer.class);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList<Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * when resolving <code>parameterClasses</code> into {@link JavaType}.\n     *\n     * @param parametrized Type-erased type of instance being constructed\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterClasses Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList<Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        JavaType resultType;\n        \n        // Need to check kind of class we are dealing with...\n        if (parametrized.isArray()) {\n            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }\n    \n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Actual factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @param context Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n        // Very first thing: small set of core types we know well:\n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        // Barring that, we may have recently constructed an instance:\n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // If context was needed, weed do:\n        /*\n        if (context == null) {\n            context = new TypeBindings(this, cls);\n        }\n        */\n\n        // First: do we have an array type?\n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            /* Also: although enums can also be fully resolved, there's little\n             * point in doing so (T extends Enum<T>) etc.\n             */\n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            /* Maps and Collections aren't quite as hot; problem is, due\n             * to type erasure we often do not know typing and can only assume\n             * base Object.\n             */\n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            // 28-Apr-2015, tatu: New class of types, referential...\n            if (AtomicReference.class.isAssignableFrom(clz)) {\n                \n                JavaType[] pts = findTypeParameters(clz, AtomicReference.class);\n                JavaType rt = (pts == null || pts.length != 1) ? unknownType() : pts[0];\n                result = constructReferenceType(clz, rt);\n            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n            } else if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); // cache object syncs\n        return result;\n    }\n    \n    /**\n     * Method used by {@link TypeParser} when generics-aware version\n     * is constructed.\n     */\n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n        if (clz.isArray()) { // ignore generics (should never have any)\n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { // ditto for enums\n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            // First: if we do have param types, use them\n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        // Hmmh. Does this actually occur?\n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }\n    \n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n        /* First: what is the actual base type? One odd thing\n         * is that 'getRawType' returns Type, not Class<?> as\n         * one might expect. But let's assume it is always of\n         * type Class: if not, need to add more code to resolve\n         * it to Class.\n         */\n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        // Ok: Map or Collection?\n        if (Map.class.isAssignableFrom(rawType)) {\n            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        // 28-Apr-2015, tatu: New class of types, referential...\n        if (AtomicReference.class.isAssignableFrom(rawType)) {\n            JavaType rt = null;\n\n            if (rawType == AtomicReference.class) {\n                if (paramCount == 1) {\n                    rt = pt[0];\n                }\n            } else {\n                JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n                if (pts != null && pts.length != 1) {\n                    rt = pts[0];\n                }\n            }\n            return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n        }\n        if (Map.Entry.class.isAssignableFrom(rawType)) {\n            JavaType kt = null, vt = null;\n\n            if (rawType == Map.Entry.class) {\n                if (paramCount == 2) {\n                    kt = pt[0];\n                    vt = pt[1];\n                }\n            } else {\n                JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n                if (pts != null && pts.length != 2) {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n            }\n            return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n        }\n        \n        if (paramCount == 0) { // no generics\n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }\n\n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n    {\n        /* Similar to challenges with TypeVariable, we may have\n         * multiple upper bounds. But it is also possible that if\n         * upper bound defaults to Object, we might want to consider\n         * lower bounds instead.\n         *\n         * For now, we won't try anything more advanced; above is\n         * just for future reference.\n         */\n        return _constructType(type.getUpperBounds()[0], context);\n    }\n\n    private JavaType _mapType(Class<?> rawClass)\n    {\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]\n        if (rawClass == Properties.class) {\n            return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);\n        }\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    // further resolution needed?\n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    // no we're good for the variable (but it may have parameterization of its own)\n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }\n    \n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to find inheritance (implements, extends) path\n     * between given types, if one exists (caller generally checks before\n     * calling this method). Returned type represents given <b>subtype</b>,\n     * with supertype linkage extending to <b>supertype</b>.\n     */\n    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n        // If super-type is a class (not interface), bit simpler\n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        // Otherwise, keep on going down the rat hole...\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        // Otherwise, keep on going down the rat hole; first implemented interfaces\n        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's\n         *   try caching certain commonly needed cases\n         */\n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n    {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        // as long as there are superclasses\n        // and unless we have already seen the type (<T extends X<T>>)\n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        // and then super-class if any\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 20, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.node.ObjectNode", "buggy_version": "package com.fasterxml.jackson.databind.node;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Node that maps to JSON Object structures in JSON content.\n *<p>\n * Note: class was <code>final</code> temporarily for Jackson 2.2.\n */\npublic class ObjectNode\n    extends ContainerNode<ObjectNode>\n{\n    // Note: LinkedHashMap for backwards compatibility\n    protected final Map<String, JsonNode> _children;\n\n    public ObjectNode(JsonNodeFactory nc) {\n        super(nc);\n        _children = new LinkedHashMap<String, JsonNode>();\n    }\n\n    /**\n     * @since 2.4\n     */\n    public ObjectNode(JsonNodeFactory nc, Map<String, JsonNode> kids) {\n        super(nc);\n        _children = kids;\n    }\n    \n    @Override\n    protected JsonNode _at(JsonPointer ptr) {\n        return get(ptr.getMatchingProperty());\n    }\n\n    /* Question: should this delegate to `JsonNodeFactory`? It does not absolutely\n     * have to, as long as sub-types override the method but...\n     */\n    // note: co-variant for type safety\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public ObjectNode deepCopy()\n    {\n        ObjectNode ret = new ObjectNode(_nodeFactory);\n\n        for (Map.Entry<String, JsonNode> entry: _children.entrySet())\n            ret._children.put(entry.getKey(), entry.getValue().deepCopy());\n\n        return ret;\n    }\n\n    /*\n    /**********************************************************\n    /* Implementation of core JsonNode API\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNodeType getNodeType() {\n        return JsonNodeType.OBJECT;\n    }\n\n    @Override public JsonToken asToken() { return JsonToken.START_OBJECT; }\n\n    @Override\n    public int size() {\n        return _children.size();\n    }\n\n    @Override\n    public Iterator<JsonNode> elements() {\n        return _children.values().iterator();\n    }\n\n    @Override\n    public JsonNode get(int index) { return null; }\n\n    @Override\n    public JsonNode get(String fieldName) {\n        return _children.get(fieldName);\n    }\n\n    @Override\n    public Iterator<String> fieldNames() {\n        return _children.keySet().iterator();\n    }\n\n    @Override\n    public JsonNode path(int index) {\n        return MissingNode.getInstance();\n    }\n\n    @Override\n    public JsonNode path(String fieldName)\n    {\n        JsonNode n = _children.get(fieldName);\n        if (n != null) {\n            return n;\n        }\n        return MissingNode.getInstance();\n    }\n\n    /**\n     * Method to use for accessing all fields (with both names\n     * and values) of this JSON Object.\n     */\n    @Override\n    public Iterator<Map.Entry<String, JsonNode>> fields() {\n        return _children.entrySet().iterator();\n    }\n\n    @Override\n    public ObjectNode with(String propertyName) {\n        JsonNode n = _children.get(propertyName);\n        if (n != null) {\n            if (n instanceof ObjectNode) {\n                return (ObjectNode) n;\n            }\n            throw new UnsupportedOperationException(\"Property '\" + propertyName\n                + \"' has value that is not of type ObjectNode (but \" + n\n                .getClass().getName() + \")\");\n        }\n        ObjectNode result = objectNode();\n        _children.put(propertyName, result);\n        return result;\n    }\n\n    @Override\n    public ArrayNode withArray(String propertyName)\n    {\n        JsonNode n = _children.get(propertyName);\n        if (n != null) {\n            if (n instanceof ArrayNode) {\n                return (ArrayNode) n;\n            }\n            throw new UnsupportedOperationException(\"Property '\" + propertyName\n                + \"' has value that is not of type ArrayNode (but \" + n\n                .getClass().getName() + \")\");\n        }\n        ArrayNode result = arrayNode();\n        _children.put(propertyName, result);\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, finding value nodes\n    /**********************************************************\n     */\n    \n    @Override\n    public JsonNode findValue(String fieldName)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                return entry.getValue();\n            }\n            JsonNode value = entry.getValue().findValue(fieldName);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                if (foundSoFar == null) {\n                    foundSoFar = new ArrayList<JsonNode>();\n                }\n                foundSoFar.add(entry.getValue());\n            } else { // only add children if parent not added\n                foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n            }\n        }\n        return foundSoFar;\n    }\n\n    @Override\n    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                if (foundSoFar == null) {\n                    foundSoFar = new ArrayList<String>();\n                }\n                foundSoFar.add(entry.getValue().asText());\n            } else { // only add children if parent not added\n                foundSoFar = entry.getValue().findValuesAsText(fieldName,\n                    foundSoFar);\n            }\n        }\n        return foundSoFar;\n    }\n    \n    @Override\n    public ObjectNode findParent(String fieldName)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                return this;\n            }\n            JsonNode value = entry.getValue().findParent(fieldName);\n            if (value != null) {\n                return (ObjectNode) value;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                if (foundSoFar == null) {\n                    foundSoFar = new ArrayList<JsonNode>();\n                }\n                foundSoFar.add(this);\n            } else { // only add children if parent not added\n                foundSoFar = entry.getValue()\n                    .findParents(fieldName, foundSoFar);\n            }\n        }\n        return foundSoFar;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to serialize this node and\n     * all of its descendants using specified JSON generator.\n     */\n    @Override\n    public void serialize(JsonGenerator jg, SerializerProvider provider)\n        throws IOException, JsonProcessingException\n    {\n        jg.writeStartObject();\n        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n            jg.writeFieldName(en.getKey());\n                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n                 *   extend BaseJsonNode? Or if not, at least implement\n                 *   JsonSerializable? Let's start with former, change if\n                 *   we must.\n                 */\n            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n        }\n        jg.writeEndObject();\n    }\n\n    @Override\n    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n            TypeSerializer typeSer)\n        throws IOException, JsonProcessingException\n    {\n        typeSer.writeTypePrefixForObject(this, jg);\n        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n            jg.writeFieldName(en.getKey());\n            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n        }\n        typeSer.writeTypeSuffixForObject(this, jg);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended ObjectNode API, mutators, since 2.1\n    /**********************************************************\n     */\n\n    /**\n     * Method that will set specified field, replacing old value, if any.\n     * Note that this is identical to {@link #replace(String, JsonNode)},\n     * except for return value.\n     *<p>\n     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}\n     * where chaining with 'this' is desired.\n     *\n     * @param value to set field to; if null, will be converted\n     *   to a {@link NullNode} first  (to remove field entry, call\n     *   {@link #remove} instead)\n     *\n     * @return This node after adding/replacing property value (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode set(String fieldName, JsonNode value)\n    {\n        if (value == null) {\n            value = nullNode();\n        }\n        _children.put(fieldName, value);\n        return this;\n    }\n\n    /**\n     * Method for adding given properties to this object node, overriding\n     * any existing values for those properties.\n     * \n     * @param properties Properties to add\n     * \n     * @return This node after adding/replacing property values (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode setAll(Map<String,? extends JsonNode> properties)\n    {\n        for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {\n            JsonNode n = en.getValue();\n            if (n == null) {\n                n = nullNode();\n            }\n            _children.put(en.getKey(), n);\n        }\n        return this;\n    }\n\n    /**\n     * Method for adding all properties of the given Object, overriding\n     * any existing values for those properties.\n     * \n     * @param other Object of which properties to add to this object\n     *\n     * @return This node after addition (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode setAll(ObjectNode other)\n    {\n        _children.putAll(other._children);\n        return this;\n    }\n    \n    /**\n     * Method for replacing value of specific property with passed\n     * value, and returning value (or null if none).\n     *\n     * @param fieldName Property of which value to replace\n     * @param value Value to set property to, replacing old value if any\n     * \n     * @return Old value of the property; null if there was no such property\n     *   with value\n     * \n     * @since 2.1\n     */\n    public JsonNode replace(String fieldName, JsonNode value)\n    {\n        if (value == null) { // let's not store 'raw' nulls but nodes\n            value = nullNode();\n        }\n        return _children.put(fieldName, value);\n    }\n\n    /**\n     * Method for removing field entry from this ObjectNode, and\n     * returning instance after removal.\n     * \n     * @return This node after removing entry (if any)\n     * \n     * @since 2.1\n     */\n    public JsonNode without(String fieldName)\n    {\n        _children.remove(fieldName);\n        return this;\n    }\n\n    /**\n     * Method for removing specified field properties out of\n     * this ObjectNode.\n     * \n     * @param fieldNames Names of fields to remove\n     * \n     * @return This node after removing entries\n     * \n     * @since 2.1\n     */\n    public ObjectNode without(Collection<String> fieldNames)\n    {\n        _children.keySet().removeAll(fieldNames);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended ObjectNode API, mutators, generic\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will set specified field, replacing old value, if any.\n     *\n     * @param value to set field to; if null, will be converted\n     *   to a {@link NullNode} first  (to remove field entry, call\n     *   {@link #remove} instead)\n     *   \n     * @return Old value of the field, if any; null if there was no\n     *   old value.\n     *   \n     * @deprecated Since 2.4 use either {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},\n     */\n    @Deprecated\n    public JsonNode put(String fieldName, JsonNode value)\n    {\n        if (value == null) { // let's not store 'raw' nulls but nodes\n            value = nullNode();\n        }\n        return _children.put(fieldName, value);\n    }\n    \n    /**\n     * Method for removing field entry from this ObjectNode.\n     * Will return value of the field, if such field existed;\n     * null if not.\n     * \n     * @return Value of specified field, if it existed; null if not\n     */\n    public JsonNode remove(String fieldName) {\n        return _children.remove(fieldName);\n    }\n\n    /**\n     * Method for removing specified field properties out of\n     * this ObjectNode.\n     * \n     * @param fieldNames Names of fields to remove\n     * \n     * @return This node after removing entries\n     */\n    public ObjectNode remove(Collection<String> fieldNames)\n    {\n        _children.keySet().removeAll(fieldNames);\n        return this;\n    }\n    \n    /**\n     * Method for removing all field properties, such that this\n     * ObjectNode will contain no properties after call.\n     * \n     * @return This node after removing all entries\n     */\n    @Override\n    public ObjectNode removeAll()\n    {\n        _children.clear();\n        return this;\n    }\n\n    /**\n     * Method for adding given properties to this object node, overriding\n     * any existing values for those properties.\n     * \n     * @param properties Properties to add\n     * \n     * @return This node after adding/replacing property values (to allow chaining)\n     * \n     * @deprecated Since 2.4 use {@link #setAll(Map)},\n     */\n    @Deprecated\n    public JsonNode putAll(Map<String,? extends JsonNode> properties) {\n        return setAll(properties);\n    }\n\n    /**\n     * Method for adding all properties of the given Object, overriding\n     * any existing values for those properties.\n     * \n     * @param other Object of which properties to add to this object\n     * \n     * @return This node (to allow chaining)\n     * \n     * @deprecated Since 2.4 use {@link #setAll(ObjectNode)},\n     */\n    @Deprecated\n    public JsonNode putAll(ObjectNode other) {\n        return setAll(other);\n    }\n\n    /**\n     * Method for removing all field properties out of this ObjectNode\n     * <b>except</b> for ones specified in argument.\n     * \n     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n     * \n     * @return This node (to allow call chaining)\n     */\n    public ObjectNode retain(Collection<String> fieldNames)\n    {\n        _children.keySet().retainAll(fieldNames);\n        return this;\n    }\n\n    /**\n     * Method for removing all field properties out of this ObjectNode\n     * <b>except</b> for ones specified in argument.\n     * \n     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n     * \n     * @return This node (to allow call chaining)\n     */\n    public ObjectNode retain(String... fieldNames) {\n        return retain(Arrays.asList(fieldNames));\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended ObjectNode API, mutators, typed\n    /**********************************************************\n     */\n\n    /**\n     * Method that will construct an ArrayNode and add it as a\n     * field of this ObjectNode, replacing old value, if any.\n     *<p>\n     * <b>NOTE</b>: Unlike all <b>put(...)</b> methods, return value\n     * is <b>NOT</b> this <code>ObjectNode</code>, but the\n     * <b>newly created</b> <code>ArrayNode</code> instance.\n     *\n     * @return Newly constructed ArrayNode (NOT the old value,\n     *   which could be of any type)\n     */\n    public ArrayNode putArray(String fieldName)\n    {\n        ArrayNode n  = arrayNode();\n        _put(fieldName, n);\n        return n;\n    }\n\n    /**\n     * Method that will construct an ObjectNode and add it as a\n     * field of this ObjectNode, replacing old value, if any.\n     *<p>\n     * <b>NOTE</b>: Unlike all <b>put(...)</b> methods, return value\n     * is <b>NOT</b> this <code>ObjectNode</code>, but the\n     * <b>newly created</b> <code>ObjectNode</code> instance.\n     *\n     * @return Newly constructed ObjectNode (NOT the old value,\n     *   which could be of any type)\n     */\n    public ObjectNode putObject(String fieldName)\n    {\n        ObjectNode n = objectNode();\n        _put(fieldName, n);\n        return n;\n    }\n\n    /**\n     * @return This node (to allow chaining)\n     */\n    public ObjectNode putPOJO(String fieldName, Object pojo) {\n        return _put(fieldName, pojoNode(pojo));\n    }\n\n    /**\n     * @return This node (to allow chaining)\n     */\n    public ObjectNode putNull(String fieldName)\n    {\n        _children.put(fieldName, nullNode());\n        return this;\n    }\n\n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, short v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Short v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.shortValue()));\n    }\n\n    /**\n     * Method for setting value of a field to specified numeric value.\n     * The underlying {@link JsonNode} that will be added is constructed\n     * using {@link JsonNodeFactory#numberNode(int)}, and may be\n     *  \"smaller\" (like {@link ShortNode}) in cases where value fits within\n     *  range of a smaller integral numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, int v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Integer v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.intValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * The underlying {@link JsonNode} that will be added is constructed\n     * using {@link JsonNodeFactory#numberNode(long)}, and may be\n     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n     *  range of a smaller integral numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, long v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Method for setting value of a field to specified numeric value.\n     * The underlying {@link JsonNode} that will be added is constructed\n     * using {@link JsonNodeFactory#numberNode(Long)}, and may be\n     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n     *  range of a smaller integral numeric value.\n     * <p>\n     * Note that this is alternative to {@link #put(String, long)} needed to avoid\n     * bumping into NPE issues with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Long v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.longValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, float v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Float v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.floatValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, double v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Double v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.doubleValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, BigDecimal v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v));\n    }\n\n    /**\n     * Method for setting value of a field to specified String value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, String v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : textNode(v));\n    }\n\n    /**\n     * Method for setting value of a field to specified String value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, boolean v) {\n        return _put(fieldName, booleanNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Boolean v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : booleanNode(v.booleanValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified binary value\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, byte[] v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : binaryNode(v));\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof ObjectNode) {\n            return _childrenEqual((ObjectNode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _childrenEqual(ObjectNode other)\n    {\n        return _children.equals(other._children);\n    }\n    \n    @Override\n    public int hashCode()\n    {\n        return _children.hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(32 + (size() << 4));\n        sb.append(\"{\");\n        int count = 0;\n        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n            if (count > 0) {\n                sb.append(\",\");\n            }\n            ++count;\n            TextNode.appendQuoted(sb, en.getKey());\n            sb.append(':');\n            sb.append(en.getValue().toString());\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods (overridable)\n    /**********************************************************\n     */\n\n    protected ObjectNode _put(String fieldName, JsonNode value)\n    {\n        _children.put(fieldName, value);\n        return this;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.node;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Node that maps to JSON Object structures in JSON content.\n *<p>\n * Note: class was <code>final</code> temporarily for Jackson 2.2.\n */\npublic class ObjectNode\n    extends ContainerNode<ObjectNode>\n{\n    // Note: LinkedHashMap for backwards compatibility\n    protected final Map<String, JsonNode> _children;\n\n    public ObjectNode(JsonNodeFactory nc) {\n        super(nc);\n        _children = new LinkedHashMap<String, JsonNode>();\n    }\n\n    /**\n     * @since 2.4\n     */\n    public ObjectNode(JsonNodeFactory nc, Map<String, JsonNode> kids) {\n        super(nc);\n        _children = kids;\n    }\n    \n    @Override\n    protected JsonNode _at(JsonPointer ptr) {\n        return get(ptr.getMatchingProperty());\n    }\n\n    /* Question: should this delegate to `JsonNodeFactory`? It does not absolutely\n     * have to, as long as sub-types override the method but...\n     */\n    // note: co-variant for type safety\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public ObjectNode deepCopy()\n    {\n        ObjectNode ret = new ObjectNode(_nodeFactory);\n\n        for (Map.Entry<String, JsonNode> entry: _children.entrySet())\n            ret._children.put(entry.getKey(), entry.getValue().deepCopy());\n\n        return ret;\n    }\n\n    /*\n    /**********************************************************\n    /* Implementation of core JsonNode API\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNodeType getNodeType() {\n        return JsonNodeType.OBJECT;\n    }\n\n    @Override public JsonToken asToken() { return JsonToken.START_OBJECT; }\n\n    @Override\n    public int size() {\n        return _children.size();\n    }\n\n    @Override\n    public Iterator<JsonNode> elements() {\n        return _children.values().iterator();\n    }\n\n    @Override\n    public JsonNode get(int index) { return null; }\n\n    @Override\n    public JsonNode get(String fieldName) {\n        return _children.get(fieldName);\n    }\n\n    @Override\n    public Iterator<String> fieldNames() {\n        return _children.keySet().iterator();\n    }\n\n    @Override\n    public JsonNode path(int index) {\n        return MissingNode.getInstance();\n    }\n\n    @Override\n    public JsonNode path(String fieldName)\n    {\n        JsonNode n = _children.get(fieldName);\n        if (n != null) {\n            return n;\n        }\n        return MissingNode.getInstance();\n    }\n\n    /**\n     * Method to use for accessing all fields (with both names\n     * and values) of this JSON Object.\n     */\n    @Override\n    public Iterator<Map.Entry<String, JsonNode>> fields() {\n        return _children.entrySet().iterator();\n    }\n\n    @Override\n    public ObjectNode with(String propertyName) {\n        JsonNode n = _children.get(propertyName);\n        if (n != null) {\n            if (n instanceof ObjectNode) {\n                return (ObjectNode) n;\n            }\n            throw new UnsupportedOperationException(\"Property '\" + propertyName\n                + \"' has value that is not of type ObjectNode (but \" + n\n                .getClass().getName() + \")\");\n        }\n        ObjectNode result = objectNode();\n        _children.put(propertyName, result);\n        return result;\n    }\n\n    @Override\n    public ArrayNode withArray(String propertyName)\n    {\n        JsonNode n = _children.get(propertyName);\n        if (n != null) {\n            if (n instanceof ArrayNode) {\n                return (ArrayNode) n;\n            }\n            throw new UnsupportedOperationException(\"Property '\" + propertyName\n                + \"' has value that is not of type ArrayNode (but \" + n\n                .getClass().getName() + \")\");\n        }\n        ArrayNode result = arrayNode();\n        _children.put(propertyName, result);\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, finding value nodes\n    /**********************************************************\n     */\n    \n    @Override\n    public JsonNode findValue(String fieldName)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                return entry.getValue();\n            }\n            JsonNode value = entry.getValue().findValue(fieldName);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                if (foundSoFar == null) {\n                    foundSoFar = new ArrayList<JsonNode>();\n                }\n                foundSoFar.add(entry.getValue());\n            } else { // only add children if parent not added\n                foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n            }\n        }\n        return foundSoFar;\n    }\n\n    @Override\n    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                if (foundSoFar == null) {\n                    foundSoFar = new ArrayList<String>();\n                }\n                foundSoFar.add(entry.getValue().asText());\n            } else { // only add children if parent not added\n                foundSoFar = entry.getValue().findValuesAsText(fieldName,\n                    foundSoFar);\n            }\n        }\n        return foundSoFar;\n    }\n    \n    @Override\n    public ObjectNode findParent(String fieldName)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                return this;\n            }\n            JsonNode value = entry.getValue().findParent(fieldName);\n            if (value != null) {\n                return (ObjectNode) value;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n    {\n        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n            if (fieldName.equals(entry.getKey())) {\n                if (foundSoFar == null) {\n                    foundSoFar = new ArrayList<JsonNode>();\n                }\n                foundSoFar.add(this);\n            } else { // only add children if parent not added\n                foundSoFar = entry.getValue()\n                    .findParents(fieldName, foundSoFar);\n            }\n        }\n        return foundSoFar;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to serialize this node and\n     * all of its descendants using specified JSON generator.\n     */\n    @Override\n    public void serialize(JsonGenerator jg, SerializerProvider provider)\n        throws IOException, JsonProcessingException\n    {\n        jg.writeStartObject();\n        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n            jg.writeFieldName(en.getKey());\n                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n                 *   extend BaseJsonNode? Or if not, at least implement\n                 *   JsonSerializable? Let's start with former, change if\n                 *   we must.\n                 */\n            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n        }\n        jg.writeEndObject();\n    }\n\n    @Override\n    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n            TypeSerializer typeSer)\n        throws IOException, JsonProcessingException\n    {\n        typeSer.writeTypePrefixForObject(this, jg);\n        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n            jg.writeFieldName(en.getKey());\n            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n        }\n        typeSer.writeTypeSuffixForObject(this, jg);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended ObjectNode API, mutators, since 2.1\n    /**********************************************************\n     */\n\n    /**\n     * Method that will set specified field, replacing old value, if any.\n     * Note that this is identical to {@link #replace(String, JsonNode)},\n     * except for return value.\n     *<p>\n     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}\n     * where chaining with 'this' is desired.\n     *\n     * @param value to set field to; if null, will be converted\n     *   to a {@link NullNode} first  (to remove field entry, call\n     *   {@link #remove} instead)\n     *\n     * @return This node after adding/replacing property value (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode set(String fieldName, JsonNode value)\n    {\n        if (value == null) {\n            value = nullNode();\n        }\n        _children.put(fieldName, value);\n        return this;\n    }\n\n    /**\n     * Method for adding given properties to this object node, overriding\n     * any existing values for those properties.\n     * \n     * @param properties Properties to add\n     * \n     * @return This node after adding/replacing property values (to allow chaining)\n     *\n     * @since 2.1\n     */\n    @JsonIgnore // work-around for [databind#815]\n    public JsonNode setAll(Map<String,? extends JsonNode> properties)\n    {\n        for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {\n            JsonNode n = en.getValue();\n            if (n == null) {\n                n = nullNode();\n            }\n            _children.put(en.getKey(), n);\n        }\n        return this;\n    }\n\n    /**\n     * Method for adding all properties of the given Object, overriding\n     * any existing values for those properties.\n     * \n     * @param other Object of which properties to add to this object\n     *\n     * @return This node after addition (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode setAll(ObjectNode other)\n    {\n        _children.putAll(other._children);\n        return this;\n    }\n    \n    /**\n     * Method for replacing value of specific property with passed\n     * value, and returning value (or null if none).\n     *\n     * @param fieldName Property of which value to replace\n     * @param value Value to set property to, replacing old value if any\n     * \n     * @return Old value of the property; null if there was no such property\n     *   with value\n     * \n     * @since 2.1\n     */\n    public JsonNode replace(String fieldName, JsonNode value)\n    {\n        if (value == null) { // let's not store 'raw' nulls but nodes\n            value = nullNode();\n        }\n        return _children.put(fieldName, value);\n    }\n\n    /**\n     * Method for removing field entry from this ObjectNode, and\n     * returning instance after removal.\n     * \n     * @return This node after removing entry (if any)\n     * \n     * @since 2.1\n     */\n    public JsonNode without(String fieldName)\n    {\n        _children.remove(fieldName);\n        return this;\n    }\n\n    /**\n     * Method for removing specified field properties out of\n     * this ObjectNode.\n     * \n     * @param fieldNames Names of fields to remove\n     * \n     * @return This node after removing entries\n     * \n     * @since 2.1\n     */\n    public ObjectNode without(Collection<String> fieldNames)\n    {\n        _children.keySet().removeAll(fieldNames);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended ObjectNode API, mutators, generic\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will set specified field, replacing old value, if any.\n     *\n     * @param value to set field to; if null, will be converted\n     *   to a {@link NullNode} first  (to remove field entry, call\n     *   {@link #remove} instead)\n     *   \n     * @return Old value of the field, if any; null if there was no\n     *   old value.\n     *   \n     * @deprecated Since 2.4 use either {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},\n     */\n    @Deprecated\n    public JsonNode put(String fieldName, JsonNode value)\n    {\n        if (value == null) { // let's not store 'raw' nulls but nodes\n            value = nullNode();\n        }\n        return _children.put(fieldName, value);\n    }\n    \n    /**\n     * Method for removing field entry from this ObjectNode.\n     * Will return value of the field, if such field existed;\n     * null if not.\n     * \n     * @return Value of specified field, if it existed; null if not\n     */\n    public JsonNode remove(String fieldName) {\n        return _children.remove(fieldName);\n    }\n\n    /**\n     * Method for removing specified field properties out of\n     * this ObjectNode.\n     * \n     * @param fieldNames Names of fields to remove\n     * \n     * @return This node after removing entries\n     */\n    public ObjectNode remove(Collection<String> fieldNames)\n    {\n        _children.keySet().removeAll(fieldNames);\n        return this;\n    }\n    \n    /**\n     * Method for removing all field properties, such that this\n     * ObjectNode will contain no properties after call.\n     * \n     * @return This node after removing all entries\n     */\n    @Override\n    public ObjectNode removeAll()\n    {\n        _children.clear();\n        return this;\n    }\n\n    /**\n     * Method for adding given properties to this object node, overriding\n     * any existing values for those properties.\n     * \n     * @param properties Properties to add\n     * \n     * @return This node after adding/replacing property values (to allow chaining)\n     * \n     * @deprecated Since 2.4 use {@link #setAll(Map)},\n     */\n    @Deprecated\n    public JsonNode putAll(Map<String,? extends JsonNode> properties) {\n        return setAll(properties);\n    }\n\n    /**\n     * Method for adding all properties of the given Object, overriding\n     * any existing values for those properties.\n     * \n     * @param other Object of which properties to add to this object\n     * \n     * @return This node (to allow chaining)\n     * \n     * @deprecated Since 2.4 use {@link #setAll(ObjectNode)},\n     */\n    @Deprecated\n    public JsonNode putAll(ObjectNode other) {\n        return setAll(other);\n    }\n\n    /**\n     * Method for removing all field properties out of this ObjectNode\n     * <b>except</b> for ones specified in argument.\n     * \n     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n     * \n     * @return This node (to allow call chaining)\n     */\n    public ObjectNode retain(Collection<String> fieldNames)\n    {\n        _children.keySet().retainAll(fieldNames);\n        return this;\n    }\n\n    /**\n     * Method for removing all field properties out of this ObjectNode\n     * <b>except</b> for ones specified in argument.\n     * \n     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n     * \n     * @return This node (to allow call chaining)\n     */\n    public ObjectNode retain(String... fieldNames) {\n        return retain(Arrays.asList(fieldNames));\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended ObjectNode API, mutators, typed\n    /**********************************************************\n     */\n\n    /**\n     * Method that will construct an ArrayNode and add it as a\n     * field of this ObjectNode, replacing old value, if any.\n     *<p>\n     * <b>NOTE</b>: Unlike all <b>put(...)</b> methods, return value\n     * is <b>NOT</b> this <code>ObjectNode</code>, but the\n     * <b>newly created</b> <code>ArrayNode</code> instance.\n     *\n     * @return Newly constructed ArrayNode (NOT the old value,\n     *   which could be of any type)\n     */\n    public ArrayNode putArray(String fieldName)\n    {\n        ArrayNode n  = arrayNode();\n        _put(fieldName, n);\n        return n;\n    }\n\n    /**\n     * Method that will construct an ObjectNode and add it as a\n     * field of this ObjectNode, replacing old value, if any.\n     *<p>\n     * <b>NOTE</b>: Unlike all <b>put(...)</b> methods, return value\n     * is <b>NOT</b> this <code>ObjectNode</code>, but the\n     * <b>newly created</b> <code>ObjectNode</code> instance.\n     *\n     * @return Newly constructed ObjectNode (NOT the old value,\n     *   which could be of any type)\n     */\n    public ObjectNode putObject(String fieldName)\n    {\n        ObjectNode n = objectNode();\n        _put(fieldName, n);\n        return n;\n    }\n\n    /**\n     * @return This node (to allow chaining)\n     */\n    public ObjectNode putPOJO(String fieldName, Object pojo) {\n        return _put(fieldName, pojoNode(pojo));\n    }\n\n    /**\n     * @return This node (to allow chaining)\n     */\n    public ObjectNode putNull(String fieldName)\n    {\n        _children.put(fieldName, nullNode());\n        return this;\n    }\n\n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, short v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Short v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.shortValue()));\n    }\n\n    /**\n     * Method for setting value of a field to specified numeric value.\n     * The underlying {@link JsonNode} that will be added is constructed\n     * using {@link JsonNodeFactory#numberNode(int)}, and may be\n     *  \"smaller\" (like {@link ShortNode}) in cases where value fits within\n     *  range of a smaller integral numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, int v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Integer v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.intValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * The underlying {@link JsonNode} that will be added is constructed\n     * using {@link JsonNodeFactory#numberNode(long)}, and may be\n     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n     *  range of a smaller integral numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, long v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Method for setting value of a field to specified numeric value.\n     * The underlying {@link JsonNode} that will be added is constructed\n     * using {@link JsonNodeFactory#numberNode(Long)}, and may be\n     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n     *  range of a smaller integral numeric value.\n     * <p>\n     * Note that this is alternative to {@link #put(String, long)} needed to avoid\n     * bumping into NPE issues with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Long v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.longValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, float v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Float v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.floatValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, double v) {\n        return _put(fieldName, numberNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Double v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v.doubleValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified numeric value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, BigDecimal v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : numberNode(v));\n    }\n\n    /**\n     * Method for setting value of a field to specified String value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, String v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : textNode(v));\n    }\n\n    /**\n     * Method for setting value of a field to specified String value.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, boolean v) {\n        return _put(fieldName, booleanNode(v));\n    }\n\n    /**\n     * Alternative method that we need to avoid bumping into NPE issues\n     * with auto-unboxing.\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, Boolean v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : booleanNode(v.booleanValue()));\n    }\n    \n    /**\n     * Method for setting value of a field to specified binary value\n     * \n     * @return This node (to allow chaining)\n     */\n    public ObjectNode put(String fieldName, byte[] v) {\n        return _put(fieldName, (v == null) ? nullNode()\n                : binaryNode(v));\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof ObjectNode) {\n            return _childrenEqual((ObjectNode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _childrenEqual(ObjectNode other)\n    {\n        return _children.equals(other._children);\n    }\n    \n    @Override\n    public int hashCode()\n    {\n        return _children.hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(32 + (size() << 4));\n        sb.append(\"{\");\n        int count = 0;\n        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n            if (count > 0) {\n                sb.append(\",\");\n            }\n            ++count;\n            TextNode.appendQuoted(sb, en.getKey());\n            sb.append(':');\n            sb.append(en.getValue().toString());\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods (overridable)\n    /**********************************************************\n     */\n\n    protected ObjectNode _put(String fieldName, JsonNode value)\n    {\n        _children.put(fieldName, value);\n        return this;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 21, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector", "buggy_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.RawSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    public JacksonAnnotationIntrospector() { }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotation properties\n    /**********************************************************\n     */\n\n    /**\n     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n     * are considered bundles.\n     */\n    @Override\n    public boolean isAnnotationBundle(Annotation ann) {\n        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotations\n    /**********************************************************\n     */\n\n    /**\n     * Since 2.6, we have supported use of {@link JsonProperty} for specifying\n     * explicit serialized name\n     */\n        // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n        //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n        //   reasons, including odd representation JVM uses); has to do for now\n            // We know that values are actually static fields with matching name so:\n            // no such field, or access; neither which we can do much about\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findRootName(AnnotatedClass ac)\n    {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7 or later\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    @Override // since 2.6\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        if (ignore == null) {\n            return null;\n        }\n        // 13-May-2015, tatu: As per [databind#95], allow read-only/write-only props\n        if (forSerialization) {\n            if (ignore.allowGetters()) {\n                return null;\n            }\n        } else {\n            if (ignore.allowSetters()) {\n                return null;\n            }\n        }\n        return ignore.value();\n    }\n    \n    @Override\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.ignoreUnknown();\n    }\n\n    @Override\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    /**\n     * @deprecated (since 2.3) Use {@link #findFilterId(Annotated)} instead\n     */\n    @Deprecated\n    @Override\n    public Object findFilterId(AnnotatedClass ac) {\n        return _findFilterId(ac);\n    }\n    \n    @Override\n    public Object findFilterId(Annotated a) {\n        return _findFilterId(a);\n    }\n\n    protected final Object _findFilterId(Annotated a)\n    {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            // Empty String is same as not having annotation, to allow overrides\n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNamingStrategy(AnnotatedClass ac)\n    {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    } \n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n    \n    @Override\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n        VisibilityChecker<?> checker)\n    {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String findImplicitPropertyName(AnnotatedMember param) {\n        // not known by default (until JDK8) for creators; default \n        //\n        return null;\n    }\n    \n    @Override\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }\n\n    @Override\n    public Boolean hasRequiredMarker(AnnotatedMember m)\n    {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }\n\n    @Override\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }\n\n    @Override\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }\n\n    @Override\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }\n    \n    @Override\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        // Since annotations do not allow nulls, need to assume empty means \"none\"\n        return str.isEmpty() ? null : str;\n    }\n    \n    @Override\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }\n\n    @Override        \n    public ReferenceProperty findReferenceType(AnnotatedMember member)\n    {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }\n\n    @Override\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n    {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        // if not enabled, just means annotation is not enabled; not necessarily\n        // that unwrapping should not be done (relevant when using chained introspectors)\n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }\n\n    @Override\n    public Object findInjectableValueId(AnnotatedMember m)\n    {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        /* Empty String means that we should use name of declared\n         * value class.\n         */\n        String id = ann.value();\n        if (id.length() == 0) {\n            // slight complication; for setters, type \n            if (!(m instanceof AnnotatedMethod)) {\n                return m.getRawType().getName();\n            }\n            AnnotatedMethod am = (AnnotatedMethod) m;\n            if (am.getParameterCount() == 0) {\n                return m.getRawType().getName();\n            }\n            return am.getRawParameterType(0).getName();\n        }\n        return id;\n    }\n\n    @Override\n    public Class<?>[] findViews(Annotated a)\n    {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic Type handling\n    /**********************************************************\n     */\n\n    @Override\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType)\n    {\n        return _findTypeResolver(config, ac, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        if (baseType.isContainerType()) return null;\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType)\n    {\n        /* First: let's ensure property is a container type: caller should have\n         * verified but just to be sure\n         */\n        if (!containerType.isContainerType()) {\n            throw new IllegalArgumentException(\"Must call method with a container type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }\n    \n    @Override\n    public List<NamedType> findSubtypes(Annotated a)\n    {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }\n\n    @Override        \n    public String findTypeName(AnnotatedClass ac)\n    {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }\n\n    @Override\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        // In future may need to allow passing namespace?\n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }\n\n    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref != null) {\n            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n        }\n        return objectIdInfo;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n    */\n\n    @Override\n    public Object findSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n         *  if we need to get raw indicator from other sources need to add\n         *  separate accessor within {@link AnnotationIntrospector} interface.\n         */\n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            // let's construct instance with nominal type:\n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }\n\n    @Override\n    public Object findKeySerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNullSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            return inc.value();\n        }\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            JsonSerialize.Inclusion i2 = ann.include();\n            switch (i2) {\n            case ALWAYS:\n                return JsonInclude.Include.ALWAYS;\n            case NON_NULL:\n                return JsonInclude.Include.NON_NULL;\n            case NON_DEFAULT:\n                return JsonInclude.Include.NON_DEFAULT;\n            case NON_EMPTY:\n                return JsonInclude.Include.NON_EMPTY;\n            case DEFAULT_INCLUSION: // since 2.3 -- fall through, use default\n                break;\n            }\n        }\n        return defValue;\n    }\n\n    @Override\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        return (inc == null) ? defValue : inc.content();\n    }\n\n    @Override\n    public Class<?> findSerializationType(Annotated am)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n    \n    @Override\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n    \n    @Override\n    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }\n\n    @Override\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }\n\n    @Override\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }\n\n    @Override\n    @Deprecated\n    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n        return _findSortAlpha(ac);\n    }\n\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        return (order == null) ? null : order.alphabetic();\n    }\n\n    @Override\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        // First: any attribute-backed properties?\n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        // Then: general-purpose virtual properties?\n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n    {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        // could add Index, Description in future, if those matter\n        String attrName = attr.value();\n\n        // allow explicit renaming; if none, default to attribute name\n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        // can construct the property writer\n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n            MapperConfig<?> config, AnnotatedClass ac)\n    {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        // one more thing: give it necessary contextual information\n        return bpw.withConfig(config, ac, propDef, type);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n\n    @Override\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        // value of 'false' means disabled...\n        return (ann != null && ann.value());\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    @Override\n    public Object findDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findKeyDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n\n    @Override\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n    {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n\n    @Override\n    public Object findDeserializationConverter(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findDeserializationContentConverter(AnnotatedMember a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: Class annotations\n    /**********************************************************\n     */\n    \n    @Override\n    public Object findValueInstantiator(AnnotatedClass ac)\n    {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        // no 'null' marker yet, so:\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n    {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n    {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated a)\n    {\n        String name;\n\n        // @JsonSetter has precedence over @JsonProperty, being more specific\n        // @JsonDeserialize implies that there is a property, but no name\n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            name = js.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonDeserialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                    name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n    \n    @Override\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }\n\n    @Override\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (handled separately\n         */\n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }\n\n    @Override\n    public boolean hasCreatorAnnotation(Annotated a)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n    }\n\n    @Override\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected boolean _isIgnorable(Annotated a)\n    {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        return (ann != null && ann.value());\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }\n\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }\n\n    /**\n     * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n     * if given annotated element indicates one is needed.\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n            Annotated ann, JavaType baseType)\n    {\n        // First: maybe we have explicit type resolver?\n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            /* let's not try to force access override (would need to pass\n             * settings through if we did, since that's not doable on some\n             * platforms)\n             */\n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { // if not, use standard one, if indicated by annotations\n            if (info == null) {\n                return null;\n            }\n            // bit special; must return 'marker' to block use of default typing:\n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        // Does it define a custom type id resolver?\n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) { // [JACKSON-359]\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        /* 13-Aug-2011, tatu: One complication wrt [JACKSON-453]; external id\n         *   only works for properties; so if declared for a Class, we will need\n         *   to map it to \"PROPERTY\" instead of \"EXTERNAL_PROPERTY\"\n         */\n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n        //   valid use (can not instantiate as default)\n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }\n\n    /**\n     * Helper method for constructing standard {@link TypeResolverBuilder}\n     * implementation.\n     */\n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }\n\n    /**\n     * Helper method for dealing with \"no type info\" marker; can't be null\n     * (as it'd be replaced by default typing)\n     */\n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.RawSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    public JacksonAnnotationIntrospector() { }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotation properties\n    /**********************************************************\n     */\n\n    /**\n     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n     * are considered bundles.\n     */\n    @Override\n    public boolean isAnnotationBundle(Annotation ann) {\n        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotations\n    /**********************************************************\n     */\n\n    /**\n     * Since 2.6, we have supported use of {@link JsonProperty} for specifying\n     * explicit serialized name\n     */\n    @Override\n    public String findEnumValue(Enum<?> value)\n    {\n        // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n        //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n        //   reasons, including odd representation JVM uses); has to do for now\n        try {\n            // We know that values are actually static fields with matching name so:\n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                String n = prop.value();\n                if (n != null && !n.isEmpty()) {\n                    return n;\n                }\n            }\n        } catch (Exception e) {\n            // no such field, or access; neither which we can do much about\n        }\n        return value.name();\n    }\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findRootName(AnnotatedClass ac)\n    {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7 or later\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    @Override // since 2.6\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        if (ignore == null) {\n            return null;\n        }\n        // 13-May-2015, tatu: As per [databind#95], allow read-only/write-only props\n        if (forSerialization) {\n            if (ignore.allowGetters()) {\n                return null;\n            }\n        } else {\n            if (ignore.allowSetters()) {\n                return null;\n            }\n        }\n        return ignore.value();\n    }\n    \n    @Override\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.ignoreUnknown();\n    }\n\n    @Override\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    /**\n     * @deprecated (since 2.3) Use {@link #findFilterId(Annotated)} instead\n     */\n    @Deprecated\n    @Override\n    public Object findFilterId(AnnotatedClass ac) {\n        return _findFilterId(ac);\n    }\n    \n    @Override\n    public Object findFilterId(Annotated a) {\n        return _findFilterId(a);\n    }\n\n    protected final Object _findFilterId(Annotated a)\n    {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            // Empty String is same as not having annotation, to allow overrides\n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNamingStrategy(AnnotatedClass ac)\n    {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    } \n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n    \n    @Override\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n        VisibilityChecker<?> checker)\n    {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String findImplicitPropertyName(AnnotatedMember param) {\n        // not known by default (until JDK8) for creators; default \n        //\n        return null;\n    }\n    \n    @Override\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }\n\n    @Override\n    public Boolean hasRequiredMarker(AnnotatedMember m)\n    {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }\n\n    @Override\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }\n\n    @Override\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }\n\n    @Override\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }\n    \n    @Override\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        // Since annotations do not allow nulls, need to assume empty means \"none\"\n        return str.isEmpty() ? null : str;\n    }\n    \n    @Override\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }\n\n    @Override        \n    public ReferenceProperty findReferenceType(AnnotatedMember member)\n    {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }\n\n    @Override\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n    {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        // if not enabled, just means annotation is not enabled; not necessarily\n        // that unwrapping should not be done (relevant when using chained introspectors)\n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }\n\n    @Override\n    public Object findInjectableValueId(AnnotatedMember m)\n    {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        /* Empty String means that we should use name of declared\n         * value class.\n         */\n        String id = ann.value();\n        if (id.length() == 0) {\n            // slight complication; for setters, type \n            if (!(m instanceof AnnotatedMethod)) {\n                return m.getRawType().getName();\n            }\n            AnnotatedMethod am = (AnnotatedMethod) m;\n            if (am.getParameterCount() == 0) {\n                return m.getRawType().getName();\n            }\n            return am.getRawParameterType(0).getName();\n        }\n        return id;\n    }\n\n    @Override\n    public Class<?>[] findViews(Annotated a)\n    {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic Type handling\n    /**********************************************************\n     */\n\n    @Override\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType)\n    {\n        return _findTypeResolver(config, ac, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        if (baseType.isContainerType()) return null;\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType)\n    {\n        /* First: let's ensure property is a container type: caller should have\n         * verified but just to be sure\n         */\n        if (!containerType.isContainerType()) {\n            throw new IllegalArgumentException(\"Must call method with a container type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }\n    \n    @Override\n    public List<NamedType> findSubtypes(Annotated a)\n    {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }\n\n    @Override        \n    public String findTypeName(AnnotatedClass ac)\n    {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }\n\n    @Override\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        // In future may need to allow passing namespace?\n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }\n\n    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref != null) {\n            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n        }\n        return objectIdInfo;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n    */\n\n    @Override\n    public Object findSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n         *  if we need to get raw indicator from other sources need to add\n         *  separate accessor within {@link AnnotationIntrospector} interface.\n         */\n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            // let's construct instance with nominal type:\n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }\n\n    @Override\n    public Object findKeySerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNullSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            return inc.value();\n        }\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            JsonSerialize.Inclusion i2 = ann.include();\n            switch (i2) {\n            case ALWAYS:\n                return JsonInclude.Include.ALWAYS;\n            case NON_NULL:\n                return JsonInclude.Include.NON_NULL;\n            case NON_DEFAULT:\n                return JsonInclude.Include.NON_DEFAULT;\n            case NON_EMPTY:\n                return JsonInclude.Include.NON_EMPTY;\n            case DEFAULT_INCLUSION: // since 2.3 -- fall through, use default\n                break;\n            }\n        }\n        return defValue;\n    }\n\n    @Override\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        return (inc == null) ? defValue : inc.content();\n    }\n\n    @Override\n    public Class<?> findSerializationType(Annotated am)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n    \n    @Override\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n    \n    @Override\n    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }\n\n    @Override\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }\n\n    @Override\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }\n\n    @Override\n    @Deprecated\n    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n        return _findSortAlpha(ac);\n    }\n\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        return (order == null) ? null : order.alphabetic();\n    }\n\n    @Override\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        // First: any attribute-backed properties?\n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        // Then: general-purpose virtual properties?\n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n    {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        // could add Index, Description in future, if those matter\n        String attrName = attr.value();\n\n        // allow explicit renaming; if none, default to attribute name\n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        // can construct the property writer\n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n            MapperConfig<?> config, AnnotatedClass ac)\n    {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        // one more thing: give it necessary contextual information\n        return bpw.withConfig(config, ac, propDef, type);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n\n    @Override\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        // value of 'false' means disabled...\n        return (ann != null && ann.value());\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    @Override\n    public Object findDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findKeyDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n\n    @Override\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n    {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n\n    @Override\n    public Object findDeserializationConverter(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findDeserializationContentConverter(AnnotatedMember a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: Class annotations\n    /**********************************************************\n     */\n    \n    @Override\n    public Object findValueInstantiator(AnnotatedClass ac)\n    {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        // no 'null' marker yet, so:\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n    {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n    {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated a)\n    {\n        String name;\n\n        // @JsonSetter has precedence over @JsonProperty, being more specific\n        // @JsonDeserialize implies that there is a property, but no name\n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            name = js.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonDeserialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                    name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n    \n    @Override\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }\n\n    @Override\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (handled separately\n         */\n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }\n\n    @Override\n    public boolean hasCreatorAnnotation(Annotated a)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n    }\n\n    @Override\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected boolean _isIgnorable(Annotated a)\n    {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        return (ann != null && ann.value());\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }\n\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }\n\n    /**\n     * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n     * if given annotated element indicates one is needed.\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n            Annotated ann, JavaType baseType)\n    {\n        // First: maybe we have explicit type resolver?\n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            /* let's not try to force access override (would need to pass\n             * settings through if we did, since that's not doable on some\n             * platforms)\n             */\n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { // if not, use standard one, if indicated by annotations\n            if (info == null) {\n                return null;\n            }\n            // bit special; must return 'marker' to block use of default typing:\n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        // Does it define a custom type id resolver?\n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) { // [JACKSON-359]\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        /* 13-Aug-2011, tatu: One complication wrt [JACKSON-453]; external id\n         *   only works for properties; so if declared for a Class, we will need\n         *   to map it to \"PROPERTY\" instead of \"EXTERNAL_PROPERTY\"\n         */\n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n        //   valid use (can not instantiate as default)\n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }\n\n    /**\n     * Helper method for constructing standard {@link TypeResolverBuilder}\n     * implementation.\n     */\n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }\n\n    /**\n     * Helper method for dealing with \"no type info\" marker; can't be null\n     * (as it'd be replaced by default typing)\n     */\n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 22, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.BasicSerializerFactory", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.*;\nimport com.fasterxml.jackson.databind.ser.std.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Factory class that can provide serializers for standard JDK classes,\n * as well as custom classes that extend standard classes or implement\n * one of \"well-known\" interfaces (such as {@link java.util.Collection}).\n *<p>\n * Since all the serializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is essentially stateless.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class BasicSerializerFactory\n    extends SerializerFactory\n    implements java.io.Serializable\n{\n    /*\n    /**********************************************************\n    /* Configuration, lookup tables/maps\n    /**********************************************************\n     */\n\n    /**\n     * Since these are all JDK classes, we shouldn't have to worry\n     * about ClassLoader used to load them. Rather, we can just\n     * use the class name, and keep things simple and efficient.\n     */\n    protected final static HashMap<String, JsonSerializer<?>> _concrete =\n        new HashMap<String, JsonSerializer<?>>();\n    \n    /**\n     * Actually it may not make much sense to eagerly instantiate all\n     * kinds of serializers: so this Map actually contains class references,\n     * not instances\n     */\n    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy =\n        new HashMap<String, Class<? extends JsonSerializer<?>>>();\n    \n    static {\n        /* String and string-like types (note: date types explicitly\n         * not included -- can use either textual or numeric serialization)\n         */\n        _concrete.put(String.class.getName(), new StringSerializer());\n        final ToStringSerializer sls = ToStringSerializer.instance;\n        _concrete.put(StringBuffer.class.getName(), sls);\n        _concrete.put(StringBuilder.class.getName(), sls);\n        _concrete.put(Character.class.getName(), sls);\n        _concrete.put(Character.TYPE.getName(), sls);\n\n        // Primitives/wrappers for primitives (primitives needed for Beans)\n        NumberSerializers.addAll(_concrete);\n        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));\n        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n\n        // Other numbers, more complicated\n        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n\n        // Other discrete non-container types:\n        // First, Date/Time zoo:\n        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);\n        DateSerializer dateSer = DateSerializer.instance;\n        _concrete.put(java.util.Date.class.getName(), dateSer);\n        // note: timestamps are very similar to java.util.Date, thus serialized as such\n        _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n        \n        // leave some of less commonly used ones as lazy, no point in proactive construction\n        _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);\n        _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);\n\n        // And then other standard non-structured JDK types\n        for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {\n            Object value = en.getValue();\n            if (value instanceof JsonSerializer<?>) {\n                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);\n            } else if (value instanceof Class<?>) {\n                @SuppressWarnings(\"unchecked\")\n                Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;\n                _concreteLazy.put(en.getKey().getName(), cls);\n            } else { // should never happen, but:\n                throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName());\n            }\n        }\n\n        // Jackson-specific type(s)\n        // (Q: can this ever be sub-classed?)\n        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Configuration settings for this factory; immutable instance (just like this\n     * factory), new version created via copy-constructor (fluent-style)\n     */\n    protected final SerializerFactoryConfig _factoryConfig;\n\n    /*\n    /**********************************************************\n    /* Life cycle\n    /**********************************************************\n     */\n\n    /**\n     * We will provide default constructor to allow sub-classing,\n     * but make it protected so that no non-singleton instances of\n     * the class will be instantiated.\n     */\n    protected BasicSerializerFactory(SerializerFactoryConfig config) {\n        _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config;\n    }\n    \n    /**\n     * Method for getting current {@link SerializerFactoryConfig}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    /**\n     * Method used for creating a new instance of this factory, but with different\n     * configuration. Reason for specifying factory method (instead of plain constructor)\n     * is to allow proper sub-classing of factories.\n     *<p>\n     * Note that custom sub-classes generally <b>must override</b> implementation\n     * of this method, as it usually requires instantiating a new instance of\n     * factory type. Check out javadocs for\n     * {@link com.fasterxml.jackson.databind.ser.BeanSerializerFactory} for more details.\n     */\n    public abstract SerializerFactory withConfig(SerializerFactoryConfig config);\n\n    /**\n     * Convenience method for creating a new factory instance with an additional\n     * serializer provider.\n     */\n    @Override\n    public final SerializerFactory withAdditionalSerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalSerializers(additional));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with an additional\n     * key serializer provider.\n     */\n    @Override\n    public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));\n    }\n    \n    /**\n     * Convenience method for creating a new factory instance with additional bean\n     * serializer modifier.\n     */\n    @Override\n    public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {\n        return withConfig(_factoryConfig.withSerializerModifier(modifier));\n    }\n\n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n    \n    // Implemented by sub-classes\n    @Override\n    public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType type)\n        throws JsonMappingException;\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createKeySerializer(SerializationConfig config,\n            JavaType keyType, JsonSerializer<Object> defaultImpl)\n    {\n        // We should not need any member method info; at most class annotations for Map type\n        // ... at least, not here.\n        BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());\n        JsonSerializer<?> ser = null;\n        // Minor optimization: to avoid constructing beanDesc, bail out if none registered\n        if (_factoryConfig.hasKeySerializers()) {\n            // Only thing we have here are module-provided key serializers:\n            for (Serializers serializers : _factoryConfig.keySerializers()) {\n                ser = serializers.findSerializer(config, keyType, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        if (ser == null) {\n            ser = defaultImpl;\n            if (ser == null) {\n                ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);\n                // As per [databind#47], also need to support @JsonValue\n                if (ser == null) {\n                    beanDesc = config.introspect(keyType);\n                    AnnotatedMethod am = beanDesc.findJsonValueMethod();\n                    if (am != null) {\n                        final Class<?> rawType = am.getRawReturnType();\n                        JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,\n                                rawType, true);\n                        Method m = am.getAnnotated();\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(m);\n                        }\n                        ser = new JsonValueSerializer(m, delegate);\n                    } else {\n                        ser = StdKeySerializers.getDefault();\n                    }\n                }\n            }\n        }\n        \n        // [Issue#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);\n            }\n        }\n        return (JsonSerializer<Object>) ser;\n    }\n\n    /**\n     * Method called to construct a type serializer for values with given declared\n     * base type. This is called for values other than those of bean property\n     * types.\n     */\n    @Override\n    public TypeSerializer createTypeSerializer(SerializationConfig config,\n            JavaType baseType)\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);\n        }\n        if (b == null) {\n            return null;\n        }\n        // 10-Jun-2015, tatu: Since not created for Bean Property, no need for post-processing\n        //    wrt EXTERNAL_PROPERTY\n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    /*\n    /**********************************************************\n    /* Additional API for other core classes\n    /**********************************************************\n     */\n\n    protected abstract Iterable<Serializers> customSerializers();\n\n    /*\n    /**********************************************************\n    /* Overridable secondary serializer accessor methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that will use fast lookup (and identity comparison) methods to\n     * see if we know serializer to use for given type.\n     */\n    protected final JsonSerializer<?> findSerializerByLookup(JavaType type,\n            SerializationConfig config, BeanDescription beanDesc,\n            boolean staticTyping)\n    {\n        Class<?> raw = type.getRawClass();\n        String clsName = raw.getName();\n        if (type.isReferenceType()) {\n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                return new AtomicReferenceSerializer((ReferenceType) type);\n            }\n        }\n        JsonSerializer<?> ser = _concrete.get(clsName);\n        if (ser == null) {\n            Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n            if (serClass != null) {\n                try {\n                    return serClass.newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n                            +e.getMessage(), e);\n                }\n            }\n        }\n        return ser;\n    }\n\n    /**\n     * Method called to see if one of primary per-class annotations\n     * (or related, like implementing of {@link JsonSerializable})\n     * determines the serializer to use.\n     *<p>\n     * Currently handles things like:\n     *<ul>\n     * <li>If type implements {@link JsonSerializable}, use that\n     *  </li>\n     * <li>If type has {@link com.fasterxml.jackson.annotation.JsonValue} annotation (or equivalent), build serializer\n     *    based on that property\n     *  </li>\n     *</ul>\n     *\n     * @since 2.0\n     */\n    protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, \n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> raw = type.getRawClass();\n        // First: JsonSerializable?\n        if (JsonSerializable.class.isAssignableFrom(raw)) {\n            return SerializableSerializer.instance;\n        }\n        // Second: @JsonValue for any type\n        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n        if (valueMethod != null) {\n            Method m = valueMethod.getAnnotated();\n            if (prov.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(m);\n            }\n            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n            return new JsonValueSerializer(m, ser);\n        }\n        // No well-known annotations...\n        return null;\n    }\n    \n    /**\n     * Method for checking if we can determine serializer to use based on set of\n     * known primary types, checking for set of known base types (exact matches\n     * having been compared against with <code>findSerializerByLookup</code>).\n     * This does not include \"secondary\" interfaces, but\n     * mostly concrete or abstract base classes.\n     */\n    protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, \n            JavaType type, BeanDescription beanDesc,\n            boolean staticTyping)\n        throws JsonMappingException\n    {\n        Class<?> raw = type.getRawClass();\n        \n        // Then check for optional/external serializers [JACKSON-386]\n        JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);\n        if (ser != null) {\n            return ser;\n        }\n        \n        if (Calendar.class.isAssignableFrom(raw)) {\n            return CalendarSerializer.instance;\n        }\n        if (java.util.Date.class.isAssignableFrom(raw)) {\n            return DateSerializer.instance;\n        }\n        if (Map.Entry.class.isAssignableFrom(raw)) {\n            // 28-Apr-2015, tatu: TypeFactory does it all for us already so\n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n        }\n        if (ByteBuffer.class.isAssignableFrom(raw)) {\n            return new ByteBufferSerializer();\n        }\n        if (InetAddress.class.isAssignableFrom(raw)) {\n            return new InetAddressSerializer();\n        }\n        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n            return new InetSocketAddressSerializer();\n        }\n        if (TimeZone.class.isAssignableFrom(raw)) {\n            return new TimeZoneSerializer();\n        }\n        if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {\n            return ToStringSerializer.instance;\n        }\n        if (Number.class.isAssignableFrom(raw)) {\n            // 21-May-2014, tatu: Couple of alternatives actually\n            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n            if (format != null) {\n                switch (format.getShape()) {\n                case STRING:\n                    return ToStringSerializer.instance;\n                case OBJECT: // need to bail out to let it be serialized as POJO\n                case ARRAY: // or, I guess ARRAY; otherwise no point in speculating\n                    return null;\n                default:\n                }\n            }\n            return NumberSerializer.instance;\n        }\n        if (Enum.class.isAssignableFrom(raw)) {\n            return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n        }\n        return null;\n    }\n\n    /**\n     * Overridable method called after checking all other types.\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, \n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);\n    }\n        \n    /**\n     * Reflection-based serialized find method, which checks if\n     * given class implements one of recognized \"add-on\" interfaces.\n     * Add-on here means a role that is usually or can be a secondary\n     * trait: for example,\n     * bean classes may implement {@link Iterable}, but their main\n     * function is usually something else. The reason for\n     */\n    protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,\n            JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n    {\n        Class<?> type = javaType.getRawClass();\n\n        if (Iterator.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n        }\n        if (Iterable.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n        }\n        if (CharSequence.class.isAssignableFrom(type)) {\n            return ToStringSerializer.instance;\n        }\n        return null;\n    }\n    \n    /**\n     * Helper method called to check if a class or method\n     * has an annotation\n     * (@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using)\n     * that tells the class to use for serialization.\n     * Returns null if no such annotation found.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object serDef = prov.getAnnotationIntrospector().findSerializer(a);\n        if (serDef == null) {\n            return null;\n        }\n        JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);\n        // One more thing however: may need to also apply a converter:\n        return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);\n    }\n\n    /**\n     * Helper method that will check whether given annotated entity (usually class,\n     * but may also be a property accessor) indicates that a {@link Converter} is to\n     * be used; and if so, to construct and return suitable serializer for it.\n     * If not, will simply return given serializer as is.\n     */\n    protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov,\n            Annotated a, JsonSerializer<?> ser)\n        throws JsonMappingException\n    {\n        Converter<Object,Object> conv = findConverter(prov, a);\n        if (conv == null) {\n            return ser;\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected Converter<Object,Object> findConverter(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return prov.converterInstance(a, convDef);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods, container types:\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        final SerializationConfig config = prov.getConfig();\n\n        /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,\n         *   with just one important exception: if value type is \"untyped\", let's\n         *   leave it as is; no clean way to make it work.\n         */\n        if (!staticTyping && type.useStaticType()) {\n            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n                staticTyping = true;\n            }\n        }\n        \n        // Let's see what we can learn about element/content/value type, type serializer for it:\n        JavaType elementType = type.getContentType();\n        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                elementType);\n\n        // if elements have type serializer, can not force static typing:\n        if (elementTypeSerializer != null) {\n            staticTyping = false;\n        }\n        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                beanDesc.getClassInfo());\n        if (type.isMapLikeType()) { // implements java.util.Map\n            MapLikeType mlt = (MapLikeType) type;\n            /* 29-Sep-2012, tatu: This is actually too early to (try to) find\n             *  key serializer from property annotations, and can lead to caching\n             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.\n             *  But we do need to check class annotations.\n             */\n            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n            if (mlt.isTrueMapType()) {\n                return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n                        keySerializer, elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                MapLikeType mlType = (MapLikeType) type;\n                ser = serializers.findMapLikeSerializer(config,\n                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                    }\n                    return ser;\n                }\n            }\n            return null;\n        }\n        if (type.isCollectionLikeType()) {\n            CollectionLikeType clt = (CollectionLikeType) type;\n            if (clt.isTrueCollectionType()) {\n                return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n                        elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            CollectionLikeType clType = (CollectionLikeType) type;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                ser = serializers.findCollectionLikeSerializer(config,\n                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                        }\n                    }\n                    return ser;\n                }\n            }\n            return null;\n        }\n        if (type.isArrayType()) {\n            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n                    elementTypeSerializer, elementValueSerializer);\n        }\n        return null;\n    }\n\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.List} types that support efficient by-index access\n     * \n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n            CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = null;\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findCollectionSerializer(config,\n                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                break;\n            }\n        }\n\n        if (ser == null) {\n                // We may also want to use serialize Collections \"as beans\", if (and only if)\n                // this is specified with `@JsonFormat(shape=Object)`\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                    return null;\n                }\n                Class<?> raw = type.getRawClass();\n                if (EnumSet.class.isAssignableFrom(raw)) {\n                    // this may or may not be available (Class doesn't; type of field/method does)\n                    JavaType enumType = type.getContentType();\n                    // and even if nominally there is something, only use if it really is enum\n                    if (!enumType.isEnumType()) {\n                        enumType = null;\n                    }\n                    ser = buildEnumSetSerializer(enumType);\n                } else {\n                    Class<?> elementRaw = type.getContentType().getRawClass();\n                    if (isIndexedList(raw)) {\n                        if (elementRaw == String.class) {\n                            // [JACKSON-829] Must NOT use if we have custom serializer\n                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                                ser = IndexedStringListSerializer.instance;\n                            }\n                        } else {\n                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                        }\n                    } else if (elementRaw == String.class) {\n                        // [JACKSON-829] Must NOT use if we have custom serializer\n                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                            ser = StringCollectionSerializer.instance;\n                        }\n                    }\n                    if (ser == null) {\n                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                }\n            }\n        }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods, for Collections\n    /**********************************************************\n     */\n\n    protected boolean isIndexedList(Class<?> cls)\n    {\n        return RandomAccess.class.isAssignableFrom(cls);\n    }\n\n    public  ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType,\n            boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n    public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType,\n            boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n\n    public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) {\n        return new EnumSetSerializer(enumType);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods, for Maps\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.Map} types.\n     */\n    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,\n            MapType type, BeanDescription beanDesc,\n            boolean staticTyping, JsonSerializer<Object> keySerializer,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = null;\n\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        \n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findMapSerializer(config, type, beanDesc,\n                    keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) { break; }\n        }\n        if (ser == null) {\n                // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n                /*\n                if (EnumMap.class.isAssignableFrom(type.getRawClass())\n                        && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {\n                    JavaType keyType = type.getKeyType();\n                    // Need to find key enum values...\n                    EnumValues enums = null;\n                    if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n                        @SuppressWarnings(\"unchecked\")\n                        Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n                        enums = EnumValues.construct(config, enumClass);\n                    }\n                    ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                        elementTypeSerializer, elementValueSerializer);\n                } else {\n                */\n                Object filterId = findFilterId(config, beanDesc);\n                AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n                        type, staticTyping, elementTypeSerializer,\n                        keySerializer, elementValueSerializer, filterId);\n                Object suppressableValue = findSuppressableContentValue(config,\n                        type.getContentType(), beanDesc);\n                if (suppressableValue != null) {\n                    mapSer = mapSer.withContentInclusion(suppressableValue);\n                }\n                ser = mapSer;\n            }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    /**\n     *<p>\n     * NOTE: although return type is left opaque, it really needs to be\n     * <code>JsonInclude.Include</code> for things to work as expected.\n     *\n     * @since 2.5\n     */\n    protected Object findSuppressableContentValue(SerializationConfig config,\n            JavaType contentType, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n\n        if (incl != null) {\n            switch (incl) {\n            case NON_DEFAULT:\n                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean \"NON_EMPTY\"...\n                incl = JsonInclude.Include.NON_EMPTY;\n                break;\n            default:\n                // all other modes actually good as is, unless we'll find better ways\n                break;\n            }\n            return incl;\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods, for Arrays\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * <code>Object[]</code> (and subtypes, except for String).\n     */\n    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n            ArrayType type, BeanDescription beanDesc,\n            boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array\n        //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n        //   so we need not do primary annotation lookup here.\n        //   So all we need is (1) Custom, (2) Default array serializers\n        JsonSerializer<?> ser = null;\n\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n             ser = serializers.findArraySerializer(config,\n                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n                 break;\n             }\n        }\n        \n        if (ser == null) {\n             Class<?> raw = type.getRawClass();\n             // Important: do NOT use standard serializers if non-standard element value serializer specified\n             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                 if (String[].class == raw) {\n                     ser = StringArraySerializer.instance;\n                 } else {\n                     // other standard types?\n                     ser = StdArraySerializers.findStandardImpl(raw);\n                 }\n             }\n             if (ser == null) {\n                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                         elementValueSerializer);\n             }\n         }\n         // [databind#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n             }\n         }\n         return ser;\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods, for non-container types\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.5\n     */\n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated // since 2.5\n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n    {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n\n    /**\n     * @since 2.5\n     */\n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated // since 2.5\n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc,\n            boolean staticTyping)\n        throws JsonMappingException\n    {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n    \n    /**\n     * @since 2.5\n     */\n    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n            JavaType keyType, JavaType valueType)\n        throws JsonMappingException\n    {\n        return new MapEntrySerializer(valueType, keyType, valueType,\n                staticTyping, createTypeSerializer(config, valueType), null);\n    }\n\n    protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        /* As per [databind#24], may want to use alternate shape, serialize as JSON Object.\n         * Challenge here is that EnumSerializer does not know how to produce\n         * POJO style serialization, so we must handle that special case separately;\n         * otherwise pass it to EnumSerializer.\n         */\n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n            // one special case: suppress serialization of \"getDeclaringClass()\"...\n            ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n            // returning null will mean that eventually BeanSerializer gets constructed\n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n        JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n        // [Issue#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    /*\n    /**********************************************************\n    /* Other helper methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to encapsulate details of annotation-based type coercion\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,\n            Annotated a, T type)\n    {\n        // first: let's check class for the instance itself:\n        Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n        if (superclass != null) {\n            try {\n                type = (T) type.widenBy(superclass);\n            } catch (IllegalArgumentException iae) {\n                throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n            }\n        }\n        return modifySecondaryTypesByAnnotation(config, a, type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,\n            Annotated a, T type)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapType)) {\n                    throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n                }\n                try {\n                    type = (T) ((MapType) type).widenKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n                }\n            }\n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = (T) type.widenContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n                }\n            }\n        }\n        return type;\n    }\n\n    /**\n     * Helper method called to try to find whether there is an annotation in the\n     * class that indicates key serializer to use.\n     * If so, will try to instantiate key serializer and return it; otherwise returns null.\n     */\n    protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findKeySerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    /**\n     * Helper method called to try to find whether there is an annotation in the\n     * class that indicates content (\"value\") serializer to use.\n     * If so, will try to instantiate key serializer and return it; otherwise returns null.\n     */\n    protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findContentSerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    /**\n     * Method called to find filter that is configured to be used with bean\n     * serializer being built, if any.\n     */\n    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n        return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n    }\n\n    /**\n     * Helper method to check whether global settings and/or class\n     * annotations for the bean class indicate that static typing\n     * (declared types)  should be used for properties.\n     * (instead of dynamic runtime types).\n     * \n     * @since 2.1 (earlier had variant with additional 'property' parameter)\n     */\n    protected boolean usesStaticTyping(SerializationConfig config,\n            BeanDescription beanDesc, TypeSerializer typeSer)\n    {\n        /* 16-Aug-2010, tatu: If there is a (value) type serializer, we can not force\n         *    static typing; that would make it impossible to handle expected subtypes\n         */\n        if (typeSer != null) {\n            return false;\n        }\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n        if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {\n            return (t == JsonSerialize.Typing.STATIC);\n        }\n        return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n    }\n\n    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n    {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.*;\nimport com.fasterxml.jackson.databind.ser.std.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Factory class that can provide serializers for standard JDK classes,\n * as well as custom classes that extend standard classes or implement\n * one of \"well-known\" interfaces (such as {@link java.util.Collection}).\n *<p>\n * Since all the serializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is essentially stateless.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class BasicSerializerFactory\n    extends SerializerFactory\n    implements java.io.Serializable\n{\n    /*\n    /**********************************************************\n    /* Configuration, lookup tables/maps\n    /**********************************************************\n     */\n\n    /**\n     * Since these are all JDK classes, we shouldn't have to worry\n     * about ClassLoader used to load them. Rather, we can just\n     * use the class name, and keep things simple and efficient.\n     */\n    protected final static HashMap<String, JsonSerializer<?>> _concrete =\n        new HashMap<String, JsonSerializer<?>>();\n    \n    /**\n     * Actually it may not make much sense to eagerly instantiate all\n     * kinds of serializers: so this Map actually contains class references,\n     * not instances\n     */\n    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy =\n        new HashMap<String, Class<? extends JsonSerializer<?>>>();\n    \n    static {\n        /* String and string-like types (note: date types explicitly\n         * not included -- can use either textual or numeric serialization)\n         */\n        _concrete.put(String.class.getName(), new StringSerializer());\n        final ToStringSerializer sls = ToStringSerializer.instance;\n        _concrete.put(StringBuffer.class.getName(), sls);\n        _concrete.put(StringBuilder.class.getName(), sls);\n        _concrete.put(Character.class.getName(), sls);\n        _concrete.put(Character.TYPE.getName(), sls);\n\n        // Primitives/wrappers for primitives (primitives needed for Beans)\n        NumberSerializers.addAll(_concrete);\n        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));\n        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n\n        // Other numbers, more complicated\n        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n\n        // Other discrete non-container types:\n        // First, Date/Time zoo:\n        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);\n        DateSerializer dateSer = DateSerializer.instance;\n        _concrete.put(java.util.Date.class.getName(), dateSer);\n        // note: timestamps are very similar to java.util.Date, thus serialized as such\n        _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n        \n        // leave some of less commonly used ones as lazy, no point in proactive construction\n        _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);\n        _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);\n\n        // And then other standard non-structured JDK types\n        for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {\n            Object value = en.getValue();\n            if (value instanceof JsonSerializer<?>) {\n                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);\n            } else if (value instanceof Class<?>) {\n                @SuppressWarnings(\"unchecked\")\n                Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;\n                _concreteLazy.put(en.getKey().getName(), cls);\n            } else { // should never happen, but:\n                throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName());\n            }\n        }\n\n        // Jackson-specific type(s)\n        // (Q: can this ever be sub-classed?)\n        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Configuration settings for this factory; immutable instance (just like this\n     * factory), new version created via copy-constructor (fluent-style)\n     */\n    protected final SerializerFactoryConfig _factoryConfig;\n\n    /*\n    /**********************************************************\n    /* Life cycle\n    /**********************************************************\n     */\n\n    /**\n     * We will provide default constructor to allow sub-classing,\n     * but make it protected so that no non-singleton instances of\n     * the class will be instantiated.\n     */\n    protected BasicSerializerFactory(SerializerFactoryConfig config) {\n        _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config;\n    }\n    \n    /**\n     * Method for getting current {@link SerializerFactoryConfig}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    /**\n     * Method used for creating a new instance of this factory, but with different\n     * configuration. Reason for specifying factory method (instead of plain constructor)\n     * is to allow proper sub-classing of factories.\n     *<p>\n     * Note that custom sub-classes generally <b>must override</b> implementation\n     * of this method, as it usually requires instantiating a new instance of\n     * factory type. Check out javadocs for\n     * {@link com.fasterxml.jackson.databind.ser.BeanSerializerFactory} for more details.\n     */\n    public abstract SerializerFactory withConfig(SerializerFactoryConfig config);\n\n    /**\n     * Convenience method for creating a new factory instance with an additional\n     * serializer provider.\n     */\n    @Override\n    public final SerializerFactory withAdditionalSerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalSerializers(additional));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with an additional\n     * key serializer provider.\n     */\n    @Override\n    public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));\n    }\n    \n    /**\n     * Convenience method for creating a new factory instance with additional bean\n     * serializer modifier.\n     */\n    @Override\n    public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {\n        return withConfig(_factoryConfig.withSerializerModifier(modifier));\n    }\n\n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n    \n    // Implemented by sub-classes\n    @Override\n    public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType type)\n        throws JsonMappingException;\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createKeySerializer(SerializationConfig config,\n            JavaType keyType, JsonSerializer<Object> defaultImpl)\n    {\n        // We should not need any member method info; at most class annotations for Map type\n        // ... at least, not here.\n        BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());\n        JsonSerializer<?> ser = null;\n        // Minor optimization: to avoid constructing beanDesc, bail out if none registered\n        if (_factoryConfig.hasKeySerializers()) {\n            // Only thing we have here are module-provided key serializers:\n            for (Serializers serializers : _factoryConfig.keySerializers()) {\n                ser = serializers.findSerializer(config, keyType, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n        }\n        if (ser == null) {\n            ser = defaultImpl;\n            if (ser == null) {\n                ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);\n                // As per [databind#47], also need to support @JsonValue\n                if (ser == null) {\n                    beanDesc = config.introspect(keyType);\n                    AnnotatedMethod am = beanDesc.findJsonValueMethod();\n                    if (am != null) {\n                        final Class<?> rawType = am.getRawReturnType();\n                        JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,\n                                rawType, true);\n                        Method m = am.getAnnotated();\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(m);\n                        }\n                        ser = new JsonValueSerializer(m, delegate);\n                    } else {\n                        ser = StdKeySerializers.getDefault();\n                    }\n                }\n            }\n        }\n        \n        // [Issue#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);\n            }\n        }\n        return (JsonSerializer<Object>) ser;\n    }\n\n    /**\n     * Method called to construct a type serializer for values with given declared\n     * base type. This is called for values other than those of bean property\n     * types.\n     */\n    @Override\n    public TypeSerializer createTypeSerializer(SerializationConfig config,\n            JavaType baseType)\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config, ac);\n        }\n        if (b == null) {\n            return null;\n        }\n        // 10-Jun-2015, tatu: Since not created for Bean Property, no need for post-processing\n        //    wrt EXTERNAL_PROPERTY\n        return b.buildTypeSerializer(config, baseType, subtypes);\n    }\n\n    /*\n    /**********************************************************\n    /* Additional API for other core classes\n    /**********************************************************\n     */\n\n    protected abstract Iterable<Serializers> customSerializers();\n\n    /*\n    /**********************************************************\n    /* Overridable secondary serializer accessor methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that will use fast lookup (and identity comparison) methods to\n     * see if we know serializer to use for given type.\n     */\n    protected final JsonSerializer<?> findSerializerByLookup(JavaType type,\n            SerializationConfig config, BeanDescription beanDesc,\n            boolean staticTyping)\n    {\n        Class<?> raw = type.getRawClass();\n        String clsName = raw.getName();\n        if (type.isReferenceType()) {\n            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {\n                return new AtomicReferenceSerializer((ReferenceType) type);\n            }\n        }\n        JsonSerializer<?> ser = _concrete.get(clsName);\n        if (ser == null) {\n            Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n            if (serClass != null) {\n                try {\n                    return serClass.newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n                            +e.getMessage(), e);\n                }\n            }\n        }\n        return ser;\n    }\n\n    /**\n     * Method called to see if one of primary per-class annotations\n     * (or related, like implementing of {@link JsonSerializable})\n     * determines the serializer to use.\n     *<p>\n     * Currently handles things like:\n     *<ul>\n     * <li>If type implements {@link JsonSerializable}, use that\n     *  </li>\n     * <li>If type has {@link com.fasterxml.jackson.annotation.JsonValue} annotation (or equivalent), build serializer\n     *    based on that property\n     *  </li>\n     *</ul>\n     *\n     * @since 2.0\n     */\n    protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, \n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> raw = type.getRawClass();\n        // First: JsonSerializable?\n        if (JsonSerializable.class.isAssignableFrom(raw)) {\n            return SerializableSerializer.instance;\n        }\n        // Second: @JsonValue for any type\n        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n        if (valueMethod != null) {\n            Method m = valueMethod.getAnnotated();\n            if (prov.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(m);\n            }\n            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n            return new JsonValueSerializer(m, ser);\n        }\n        // No well-known annotations...\n        return null;\n    }\n    \n    /**\n     * Method for checking if we can determine serializer to use based on set of\n     * known primary types, checking for set of known base types (exact matches\n     * having been compared against with <code>findSerializerByLookup</code>).\n     * This does not include \"secondary\" interfaces, but\n     * mostly concrete or abstract base classes.\n     */\n    protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, \n            JavaType type, BeanDescription beanDesc,\n            boolean staticTyping)\n        throws JsonMappingException\n    {\n        Class<?> raw = type.getRawClass();\n        \n        // Then check for optional/external serializers [JACKSON-386]\n        JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);\n        if (ser != null) {\n            return ser;\n        }\n        \n        if (Calendar.class.isAssignableFrom(raw)) {\n            return CalendarSerializer.instance;\n        }\n        if (java.util.Date.class.isAssignableFrom(raw)) {\n            return DateSerializer.instance;\n        }\n        if (Map.Entry.class.isAssignableFrom(raw)) {\n            // 28-Apr-2015, tatu: TypeFactory does it all for us already so\n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n        }\n        if (ByteBuffer.class.isAssignableFrom(raw)) {\n            return new ByteBufferSerializer();\n        }\n        if (InetAddress.class.isAssignableFrom(raw)) {\n            return new InetAddressSerializer();\n        }\n        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n            return new InetSocketAddressSerializer();\n        }\n        if (TimeZone.class.isAssignableFrom(raw)) {\n            return new TimeZoneSerializer();\n        }\n        if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {\n            return ToStringSerializer.instance;\n        }\n        if (Number.class.isAssignableFrom(raw)) {\n            // 21-May-2014, tatu: Couple of alternatives actually\n            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n            if (format != null) {\n                switch (format.getShape()) {\n                case STRING:\n                    return ToStringSerializer.instance;\n                case OBJECT: // need to bail out to let it be serialized as POJO\n                case ARRAY: // or, I guess ARRAY; otherwise no point in speculating\n                    return null;\n                default:\n                }\n            }\n            return NumberSerializer.instance;\n        }\n        if (Enum.class.isAssignableFrom(raw)) {\n            return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n        }\n        return null;\n    }\n\n    /**\n     * Overridable method called after checking all other types.\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, \n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);\n    }\n        \n    /**\n     * Reflection-based serialized find method, which checks if\n     * given class implements one of recognized \"add-on\" interfaces.\n     * Add-on here means a role that is usually or can be a secondary\n     * trait: for example,\n     * bean classes may implement {@link Iterable}, but their main\n     * function is usually something else. The reason for\n     */\n    protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,\n            JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n    {\n        Class<?> type = javaType.getRawClass();\n\n        if (Iterator.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n        }\n        if (Iterable.class.isAssignableFrom(type)) {\n            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n            JavaType vt = (params == null || params.length != 1) ?\n                    TypeFactory.unknownType() : params[0];\n            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n        }\n        if (CharSequence.class.isAssignableFrom(type)) {\n            return ToStringSerializer.instance;\n        }\n        return null;\n    }\n    \n    /**\n     * Helper method called to check if a class or method\n     * has an annotation\n     * (@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using)\n     * that tells the class to use for serialization.\n     * Returns null if no such annotation found.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object serDef = prov.getAnnotationIntrospector().findSerializer(a);\n        if (serDef == null) {\n            return null;\n        }\n        JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);\n        // One more thing however: may need to also apply a converter:\n        return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);\n    }\n\n    /**\n     * Helper method that will check whether given annotated entity (usually class,\n     * but may also be a property accessor) indicates that a {@link Converter} is to\n     * be used; and if so, to construct and return suitable serializer for it.\n     * If not, will simply return given serializer as is.\n     */\n    protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov,\n            Annotated a, JsonSerializer<?> ser)\n        throws JsonMappingException\n    {\n        Converter<Object,Object> conv = findConverter(prov, a);\n        if (conv == null) {\n            return ser;\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected Converter<Object,Object> findConverter(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return prov.converterInstance(a, convDef);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods, container types:\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        final SerializationConfig config = prov.getConfig();\n\n        /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,\n         *   with just one important exception: if value type is \"untyped\", let's\n         *   leave it as is; no clean way to make it work.\n         */\n        if (!staticTyping && type.useStaticType()) {\n            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n                staticTyping = true;\n            }\n        }\n        \n        // Let's see what we can learn about element/content/value type, type serializer for it:\n        JavaType elementType = type.getContentType();\n        TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                elementType);\n\n        // if elements have type serializer, can not force static typing:\n        if (elementTypeSerializer != null) {\n            staticTyping = false;\n        }\n        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                beanDesc.getClassInfo());\n        if (type.isMapLikeType()) { // implements java.util.Map\n            MapLikeType mlt = (MapLikeType) type;\n            /* 29-Sep-2012, tatu: This is actually too early to (try to) find\n             *  key serializer from property annotations, and can lead to caching\n             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.\n             *  But we do need to check class annotations.\n             */\n            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n            if (mlt.isTrueMapType()) {\n                return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,\n                        keySerializer, elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            MapLikeType mlType = (MapLikeType) type;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                ser = serializers.findMapLikeSerializer(config,\n                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n                if (ser != null) {\n                    break;\n                }\n            }\n            if (ser == null) { // (2) Annotations-based ones:\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                }\n            }\n            return ser;\n        }\n        if (type.isCollectionLikeType()) {\n            CollectionLikeType clt = (CollectionLikeType) type;\n            if (clt.isTrueCollectionType()) {\n                return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,\n                        elementTypeSerializer, elementValueSerializer);\n            }\n            // With Map-like, just 2 options: (1) Custom, (2) Annotations\n            JsonSerializer<?> ser = null;\n            CollectionLikeType clType = (CollectionLikeType) type;\n            for (Serializers serializers : customSerializers()) { // (1) Custom\n                ser = serializers.findCollectionLikeSerializer(config,\n                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n                if (ser != null) {\n                    break;\n                }\n            }\n            if (ser == null) { // (2) Annotations-based ones:\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                    }\n                }\n            }\n            return ser;\n        }\n        if (type.isArrayType()) {\n            return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,\n                    elementTypeSerializer, elementValueSerializer);\n        }\n        return null;\n    }\n\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.List} types that support efficient by-index access\n     * \n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov,\n            CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n        throws JsonMappingException\n    {\n        SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findCollectionSerializer(config,\n                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                break;\n            }\n        }\n\n        if (ser == null) {\n            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n            if (ser == null) {\n                // We may also want to use serialize Collections \"as beans\", if (and only if)\n                // this is specified with `@JsonFormat(shape=Object)`\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n                    return null;\n                }\n                Class<?> raw = type.getRawClass();\n                if (EnumSet.class.isAssignableFrom(raw)) {\n                    // this may or may not be available (Class doesn't; type of field/method does)\n                    JavaType enumType = type.getContentType();\n                    // and even if nominally there is something, only use if it really is enum\n                    if (!enumType.isEnumType()) {\n                        enumType = null;\n                    }\n                    ser = buildEnumSetSerializer(enumType);\n                } else {\n                    Class<?> elementRaw = type.getContentType().getRawClass();\n                    if (isIndexedList(raw)) {\n                        if (elementRaw == String.class) {\n                            // [JACKSON-829] Must NOT use if we have custom serializer\n                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                                ser = IndexedStringListSerializer.instance;\n                            }\n                        } else {\n                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                        }\n                    } else if (elementRaw == String.class) {\n                        // [JACKSON-829] Must NOT use if we have custom serializer\n                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                            ser = StringCollectionSerializer.instance;\n                        }\n                    }\n                    if (ser == null) {\n                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                elementTypeSerializer, elementValueSerializer);\n                    }\n                }\n            }\n        }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods, for Collections\n    /**********************************************************\n     */\n\n    protected boolean isIndexedList(Class<?> cls)\n    {\n        return RandomAccess.class.isAssignableFrom(cls);\n    }\n\n    public  ContainerSerializer<?> buildIndexedListSerializer(JavaType elemType,\n            boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new IndexedListSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n    public ContainerSerializer<?> buildCollectionSerializer(JavaType elemType,\n            boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) {\n        return new CollectionSerializer(elemType, staticTyping, vts, valueSerializer);\n    }\n\n    public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) {\n        return new EnumSetSerializer(enumType);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods, for Maps\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.Map} types.\n     */\n    protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov,\n            MapType type, BeanDescription beanDesc,\n            boolean staticTyping, JsonSerializer<Object> keySerializer,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        final SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n\n        // Order of lookups:\n        // 1. Custom serializers\n        // 2. Annotations (@JsonValue, @JsonDeserialize)\n        // 3. Defaults\n        \n        for (Serializers serializers : customSerializers()) { // (1) Custom\n            ser = serializers.findMapSerializer(config, type, beanDesc,\n                    keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) { break; }\n        }\n        if (ser == null) {\n            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n            if (ser == null) {\n                // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n                /*\n                if (EnumMap.class.isAssignableFrom(type.getRawClass())\n                        && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {\n                    JavaType keyType = type.getKeyType();\n                    // Need to find key enum values...\n                    EnumValues enums = null;\n                    if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n                        @SuppressWarnings(\"unchecked\")\n                        Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n                        enums = EnumValues.construct(config, enumClass);\n                    }\n                    ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                        elementTypeSerializer, elementValueSerializer);\n                } else {\n                */\n                Object filterId = findFilterId(config, beanDesc);\n                AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),\n                        type, staticTyping, elementTypeSerializer,\n                        keySerializer, elementValueSerializer, filterId);\n                Object suppressableValue = findSuppressableContentValue(config,\n                        type.getContentType(), beanDesc);\n                if (suppressableValue != null) {\n                    mapSer = mapSer.withContentInclusion(suppressableValue);\n                }\n                ser = mapSer;\n            }\n        }\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    /**\n     *<p>\n     * NOTE: although return type is left opaque, it really needs to be\n     * <code>JsonInclude.Include</code> for things to work as expected.\n     *\n     * @since 2.5\n     */\n    protected Object findSuppressableContentValue(SerializationConfig config,\n            JavaType contentType, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n\n        if (incl != null) {\n            switch (incl) {\n            case NON_DEFAULT:\n                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean \"NON_EMPTY\"...\n                incl = JsonInclude.Include.NON_EMPTY;\n                break;\n            default:\n                // all other modes actually good as is, unless we'll find better ways\n                break;\n            }\n            return incl;\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods, for Arrays\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * <code>Object[]</code> (and subtypes, except for String).\n     */\n    protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,\n            ArrayType type, BeanDescription beanDesc,\n            boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException\n    {\n        // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array\n        //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n        //   so we need not do primary annotation lookup here.\n        //   So all we need is (1) Custom, (2) Default array serializers\n        SerializationConfig config = prov.getConfig();\n        JsonSerializer<?> ser = null;\n\n        for (Serializers serializers : customSerializers()) { // (1) Custom\n             ser = serializers.findArraySerializer(config,\n                     type, beanDesc, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n                 break;\n             }\n        }\n        \n        if (ser == null) {\n             Class<?> raw = type.getRawClass();\n             // Important: do NOT use standard serializers if non-standard element value serializer specified\n             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                 if (String[].class == raw) {\n                     ser = StringArraySerializer.instance;\n                 } else {\n                     // other standard types?\n                     ser = StdArraySerializers.findStandardImpl(raw);\n                 }\n             }\n             if (ser == null) {\n                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n                         elementValueSerializer);\n             }\n         }\n         // [databind#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n             }\n         }\n         return ser;\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods, for non-container types\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.5\n     */\n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated // since 2.5\n    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n    {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n\n    /**\n     * @since 2.5\n     */\n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));\n    }\n\n    @Deprecated // since 2.5\n    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc,\n            boolean staticTyping)\n        throws JsonMappingException\n    {\n        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n        JavaType vt = (params == null || params.length != 1) ?\n                TypeFactory.unknownType() : params[0];\n        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n    }\n    \n    /**\n     * @since 2.5\n     */\n    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n            JavaType keyType, JavaType valueType)\n        throws JsonMappingException\n    {\n        return new MapEntrySerializer(valueType, keyType, valueType,\n                staticTyping, createTypeSerializer(config, valueType), null);\n    }\n\n    protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        /* As per [databind#24], may want to use alternate shape, serialize as JSON Object.\n         * Challenge here is that EnumSerializer does not know how to produce\n         * POJO style serialization, so we must handle that special case separately;\n         * otherwise pass it to EnumSerializer.\n         */\n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n            // one special case: suppress serialization of \"getDeclaringClass()\"...\n            ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n            // returning null will mean that eventually BeanSerializer gets constructed\n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n        JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n        // [Issue#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n            }\n        }\n        return ser;\n    }\n\n    /*\n    /**********************************************************\n    /* Other helper methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to encapsulate details of annotation-based type coercion\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,\n            Annotated a, T type)\n    {\n        // first: let's check class for the instance itself:\n        Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n        if (superclass != null) {\n            try {\n                type = (T) type.widenBy(superclass);\n            } catch (IllegalArgumentException iae) {\n                throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n            }\n        }\n        return modifySecondaryTypesByAnnotation(config, a, type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,\n            Annotated a, T type)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapType)) {\n                    throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n                }\n                try {\n                    type = (T) ((MapType) type).widenKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n                }\n            }\n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = (T) type.widenContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n                }\n            }\n        }\n        return type;\n    }\n\n    /**\n     * Helper method called to try to find whether there is an annotation in the\n     * class that indicates key serializer to use.\n     * If so, will try to instantiate key serializer and return it; otherwise returns null.\n     */\n    protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findKeySerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    /**\n     * Helper method called to try to find whether there is an annotation in the\n     * class that indicates content (\"value\") serializer to use.\n     * If so, will try to instantiate key serializer and return it; otherwise returns null.\n     */\n    protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov,\n            Annotated a)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n        Object serDef = intr.findContentSerializer(a);\n        if (serDef != null) {\n            return prov.serializerInstance(a, serDef);\n        }\n        return null;\n    }\n\n    /**\n     * Method called to find filter that is configured to be used with bean\n     * serializer being built, if any.\n     */\n    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n        return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n    }\n\n    /**\n     * Helper method to check whether global settings and/or class\n     * annotations for the bean class indicate that static typing\n     * (declared types)  should be used for properties.\n     * (instead of dynamic runtime types).\n     * \n     * @since 2.1 (earlier had variant with additional 'property' parameter)\n     */\n    protected boolean usesStaticTyping(SerializationConfig config,\n            BeanDescription beanDesc, TypeSerializer typeSer)\n    {\n        /* 16-Aug-2010, tatu: If there is a (value) type serializer, we can not force\n         *    static typing; that would make it impossible to handle expected subtypes\n         */\n        if (typeSer != null) {\n            return false;\n        }\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n        if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {\n            return (t == JsonSerialize.Typing.STATIC);\n        }\n        return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n    }\n\n    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n    {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.ser.BeanSerializerFactory", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n     * thus a single shared global (== singleton) instance can be used\n     * without thread-safety issues.\n     */\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: creation, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for creating instances with specified configuration.\n     */\n    protected BeanSerializerFactory(SerializerFactoryConfig config)\n    {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to attach additional\n     * serializer providers into this serializer factory. This is typically\n     * handled by constructing a new instance with additional serializers,\n     * to ensure thread-safe access.\n     */\n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional serializers, or losing serializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        // [databind#731]: Should skip if nominally java.lang.Object\n        if (ser == null && !delegateType.isJavaLangObject()) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n        if (ser != null) {\n            return ser;\n        }\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n            // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n            //    this call was BEFORE custom serializer lookup, which was wrong.\n        }\n        \n        if (ser == null) {\n            // Otherwise, we will check \"primary types\"; both marker types that\n            // indicate specific handling (JsonSerializable), or main types that have\n            // precedence over container types\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [databind#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public methods that are not part of\n    /* JsonSerializerFactory API\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to construct a {@link BeanSerializer} for\n     * given class. Returns null if no properties are found.\n     */\n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First things first: we know some types are not beans...\n        if (!isPotentialBeanType(type.getRawClass())) {\n            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n            //   as per [Issue#24]\n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * non-container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param baseType Declared type to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property values, if one is needed; null if not.\n     */\n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        TypeSerializer typeSer;\n\n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            typeSer = createTypeSerializer(config, baseType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(\n                    config, accessor, baseType);\n            typeSer = b.buildTypeSerializer(config, baseType, subtypes);\n        }\n        return typeSer;\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param containerType Declared type of the container to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property value contents, if one is needed; null if not.\n     */    \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        TypeSerializer typeSer;\n\n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            typeSer = createTypeSerializer(config, contentType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config,\n                    accessor, contentType);\n            typeSer = b.buildTypeSerializer(config, contentType, subtypes);\n        }\n        return typeSer;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        } else {\n            props = removeOverlappingTypeIds(prov, beanDesc, builder, props);\n        }\n        \n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                        typeSer, null, null, /*filterId*/ null);\n            }\n            // TODO: can we find full PropertyName?\n            PropertyName name = PropertyName.construct(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    /**\n     * Method called to construct a filtered writer, for given view\n     * definitions. Default implementation constructs filter that checks\n     * active view type to views property is to be included in.\n     */\n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n            Class<?>[] inViews)\n    {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n            BeanDescription beanDesc)\n    {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public introspection methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    /**\n     * Method used to collect all actual serializable properties.\n     * Can be overridden to implement custom detection schemes.\n     */\n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder)\n        throws JsonMappingException\n    {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        // [JACKSON-429]: ignore specified types\n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        // and possibly remove ones without matching mutator...\n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        // nothing? can't proceed (caller may or may not throw an exception)\n        if (properties.isEmpty()) {\n            return null;\n        }\n        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            // [JACKSON-762]: type id? Requires special handling:\n            if (property.isTypeId()) {\n                if (accessor != null) { // only add if we can access... but otherwise?\n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            // [JACKSON-235]: suppress writing of back references\n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public methods for manipulating bean properties\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable method that can filter out properties. Default implementation\n     * checks annotations class may have.\n     */\n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac, true);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Method called to handle view information for constructed serializer,\n     * based on bean property writers.\n     *<p>\n     * Note that this method is designed to be overridden by sub-classes\n     * if they want to provide custom view handling. As such it is not\n     * considered an internal implementation detail, and will be supported\n     * as part of API going forward.\n     */\n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n    {\n        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        // Simple: view information is stored within individual writers, need to combine:\n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { // no view info? include or exclude by default?\n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    /**\n     * Method that will apply by-type limitations (as per [JACKSON-429]);\n     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n     * annotation but can be supplied by module-provided introspectors too.\n     */\n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                // default to false, non-ignorable\n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            // lotsa work, and yes, it is ignorable type, so:\n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method that will remove all properties that do not have a mutator.\n     */\n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            // one caveat: as per [JACKSON-806], only remove implicit properties;\n            // explicitly annotated ones should remain\n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method called to ensure that we do not have \"duplicate\" type ids.\n     * Added to resolve [databind#222]\n     *\n     * @since 2.6\n     */\n    protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder,\n            List<BeanPropertyWriter> props)\n    {\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            TypeSerializer td = bpw.getTypeSerializer();\n            if ((td == null) || (td.getTypeInclusion() != As.EXTERNAL_PROPERTY)) {\n                continue;\n            }\n            String n = td.getPropertyName();\n            PropertyName typePropName = PropertyName.construct(n);\n\n            for (BeanPropertyWriter w2 : props) {\n                if ((w2 != bpw) && w2.wouldConflictWithName(typePropName)) {\n                    bpw.assignTypeSerializer(null);\n                    break;\n                }\n            }\n        }\n        return props;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */\n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, TypeBindings typeContext,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n         *  here will NOT be resolved or contextualized, unless done here, so:\n         */\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())\n                || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.impl.FilteredBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\nimport com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\nimport com.fasterxml.jackson.databind.ser.std.MapSerializer;\nimport com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n     * thus a single shared global (== singleton) instance can be used\n     * without thread-safety issues.\n     */\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: creation, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for creating instances with specified configuration.\n     */\n    protected BeanSerializerFactory(SerializerFactoryConfig config)\n    {\n        super(config);\n    }\n    \n    /**\n     * Method used by module registration functionality, to attach additional\n     * serializer providers into this serializer factory. This is typically\n     * handled by constructing a new instance with additional serializers,\n     * to ensure thread-safe access.\n     */\n    @Override\n    public SerializerFactory withConfig(SerializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional serializers, or losing serializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanSerializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n                    +\"additional serializer definitions\");\n        }\n        return new BeanSerializerFactory(config);\n    }\n\n    @Override\n    protected Iterable<Serializers> customSerializers() {\n        return _factoryConfig.serializers();\n    }\n    \n    /*\n    /**********************************************************\n    /* SerializerFactory impl\n    /**********************************************************\n     */\n\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException\n    {\n        // Very first thing, let's check if there is explicit serializer annotation:\n        final SerializationConfig config = prov.getConfig();\n        BeanDescription beanDesc = config.introspect(origType);\n        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser != null) {\n            return (JsonSerializer<Object>) ser;\n        }\n        boolean staticTyping;\n        // Next: we may have annotations that further define types to use...\n        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n        if (type == origType) { // no changes, won't force static typing\n            staticTyping = false;\n        } else { // changes; assume static typing; plus, need to re-introspect if class differs\n            staticTyping = true;\n            if (!type.hasRawClass(origType.getRawClass())) {\n                beanDesc = config.introspect(type);\n            }\n        }\n        // Slight detour: do we have a Converter to consider?\n        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n        if (conv == null) { // no, simple\n            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n        }\n        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n        \n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n            // [#359]: explicitly check (again) for @JsonSerializer...\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n        // [databind#731]: Should skip if nominally java.lang.Object\n        if (ser == null && !delegateType.isJavaLangObject()) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException\n    {\n        JsonSerializer<?> ser = null;\n        final SerializationConfig config = prov.getConfig();\n        \n        // Container types differ from non-container types\n        // (note: called method checks for module-provided serializers)\n        if (type.isContainerType()) {\n            if (!staticTyping) {\n                staticTyping = usesStaticTyping(config, beanDesc, null);\n                // [Issue#23]: Need to figure out how to force passed parameterization\n                //  to stick...\n                /*\n                if (property == null) {\n                    JavaType t = origType.getContentType();\n                    if (t != null && !t.hasRawClass(Object.class)) {\n                        staticTyping = true;\n                    }\n                }\n                */\n            }\n            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n            // Will return right away, since called method does post-processing:\n            if (ser != null) {\n                return ser;\n            }\n        } else {\n            // Modules may provide serializers of POJO types:\n            for (Serializers serializers : customSerializers()) {\n                ser = serializers.findSerializer(config, type, beanDesc);\n                if (ser != null) {\n                    break;\n                }\n            }\n            // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n            //    this call was BEFORE custom serializer lookup, which was wrong.\n            if (ser == null) {\n                ser = findSerializerByAnnotations(prov, type, beanDesc);\n            }\n        }\n        \n        if (ser == null) {\n            // Otherwise, we will check \"primary types\"; both marker types that\n            // indicate specific handling (JsonSerializable), or main types that have\n            // precedence over container types\n            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n            if (ser == null) {\n                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                if (ser == null) {\n                    // And this is where this class comes in: if type is not a\n                    // known \"primary JDK type\", perhaps it's a bean? We can still\n                    // get a null, if we can't find a single suitable bean property.\n                    ser = findBeanSerializer(prov, type, beanDesc);\n                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                    if (ser == null) {\n                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n                        //   post-processed\n                        if (ser == null) {\n                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                        }\n                    }\n                }\n            }\n        }\n        if (ser != null) {\n            // [databind#120]: Allow post-processing\n            if (_factoryConfig.hasSerializerModifiers()) {\n                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                    ser = mod.modifySerializer(config, beanDesc, ser);\n                }\n            }\n        }\n        return ser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public methods that are not part of\n    /* JsonSerializerFactory API\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to construct a {@link BeanSerializer} for\n     * given class. Returns null if no properties are found.\n     */\n    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First things first: we know some types are not beans...\n        if (!isPotentialBeanType(type.getRawClass())) {\n            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n            //   as per [Issue#24]\n            if (!type.isEnumType()) {\n                return null;\n            }\n        }\n        return constructBeanSerializer(prov, beanDesc);\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * non-container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param baseType Declared type to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property values, if one is needed; null if not.\n     */\n    public TypeSerializer findPropertyTypeSerializer(JavaType baseType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n        TypeSerializer typeSer;\n\n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            typeSer = createTypeSerializer(config, baseType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(\n                    config, accessor, baseType);\n            typeSer = b.buildTypeSerializer(config, baseType, subtypes);\n        }\n        return typeSer;\n    }\n\n    /**\n     * Method called to create a type information serializer for values of given\n     * container property\n     * if one is needed. If not needed (no polymorphic handling configured), should\n     * return null.\n     *\n     * @param containerType Declared type of the container to use as the base type for type information serializer\n     * \n     * @return Type serializer to use for property value contents, if one is needed; null if not.\n     */    \n    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n            SerializationConfig config, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        JavaType contentType = containerType.getContentType();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n        TypeSerializer typeSer;\n\n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            typeSer = createTypeSerializer(config, contentType);\n        } else {\n            Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByClass(config,\n                    accessor, contentType);\n            typeSer = b.buildTypeSerializer(config, contentType, subtypes);\n        }\n        return typeSer;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n        // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n        if (beanDesc.getBeanClass() == Object.class) {\n            return prov.getUnknownTypeSerializer(Object.class);\n//            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n        }\n        final SerializationConfig config = prov.getConfig();\n        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n        builder.setConfig(config);\n\n        // First: any detectable (auto-detect, annotations) properties to serialize?\n        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n        if (props == null) {\n            props = new ArrayList<BeanPropertyWriter>();\n        } else {\n            props = removeOverlappingTypeIds(prov, beanDesc, builder, props);\n        }\n        \n        // [databind#638]: Allow injection of \"virtual\" properties:\n        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n\n        // [JACKSON-440] Need to allow modification bean properties to serialize:\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.changeProperties(config, beanDesc, props);\n            }\n        }\n\n        // Any properties to suppress?\n        props = filterBeanProperties(config, beanDesc, props);\n\n        // [JACKSON-440] Need to allow reordering of properties to serialize\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                props = mod.orderProperties(config, beanDesc, props);\n            }\n        }\n\n        /* And if Object Id is needed, some preparation for that as well: better\n         * do before view handling, mostly for the custom id case which needs\n         * access to a property\n         */\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n        \n        builder.setProperties(props);\n        builder.setFilterId(findFilterId(config, beanDesc));\n        \n        AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n        if (anyGetter != null) {\n            if (config.canOverrideAccessModifiers()) {\n                anyGetter.fixAccess();\n            }\n            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n            // copied from BasicSerializerFactory.buildMapSerializer():\n            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n            JavaType valueType = type.getContentType();\n            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n            // last 2 nulls; don't know key, value serializers (yet)\n            // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n            if (anySer == null) {\n                // TODO: support '@JsonIgnoreProperties' with any setter?\n                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                        typeSer, null, null, /*filterId*/ null);\n            }\n            // TODO: can we find full PropertyName?\n            PropertyName name = PropertyName.construct(anyGetter.getName());\n            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n        // Next: need to gather view information, if any:\n        processViews(config, builder);\n\n        // Finally: let interested parties mess with the result bit more...\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        \n        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n        \n        if (ser == null) {\n            // If we get this far, there were no properties found, so no regular BeanSerializer\n            // would be constructed. But, couple of exceptions.\n            // First: if there are known annotations, just create 'empty bean' serializer\n            if (beanDesc.hasKnownClassAnnotations()) {\n                return builder.createDummy();\n            }\n        }\n        return ser;\n    }\n\n    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName().getSimpleName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                        props.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }\n\n    /**\n     * Method called to construct a filtered writer, for given view\n     * definitions. Default implementation constructs filter that checks\n     * active view type to views property is to be included in.\n     */\n    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer,\n            Class<?>[] inViews)\n    {\n        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n    }\n    \n    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n            BeanDescription beanDesc)\n    {\n        return new PropertyBuilder(config, beanDesc);\n    }\n\n    protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {\n        return new BeanSerializerBuilder(beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable non-public introspection methods\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to skip processing for types that we know\n     * can not be (i.e. are never consider to be) beans: \n     * things like primitives, Arrays, Enums, and proxy types.\n     *<p>\n     * Note that usually we shouldn't really be getting these sort of\n     * types anyway; but better safe than sorry.\n     */\n    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n    }\n\n    /**\n     * Method used to collect all actual serializable properties.\n     * Can be overridden to implement custom detection schemes.\n     */\n    protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder)\n        throws JsonMappingException\n    {\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n        final SerializationConfig config = prov.getConfig();\n\n        // [JACKSON-429]: ignore specified types\n        removeIgnorableTypes(config, beanDesc, properties);\n        \n        // and possibly remove ones without matching mutator...\n        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n            removeSetterlessGetters(config, beanDesc, properties);\n        }\n        \n        // nothing? can't proceed (caller may or may not throw an exception)\n        if (properties.isEmpty()) {\n            return null;\n        }\n        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n        boolean staticTyping = usesStaticTyping(config, beanDesc, null);\n        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n        \n        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n        for (BeanPropertyDefinition property : properties) {\n            final AnnotatedMember accessor = property.getAccessor();\n            // [JACKSON-762]: type id? Requires special handling:\n            if (property.isTypeId()) {\n                if (accessor != null) { // only add if we can access... but otherwise?\n                    if (config.canOverrideAccessModifiers()) {\n                        accessor.fixAccess();\n                    }\n                    builder.setTypeId(accessor);\n                }\n                continue;\n            }\n            // [JACKSON-235]: suppress writing of back references\n            AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n            if (refType != null && refType.isBackReference()) {\n                continue;\n            }\n            if (accessor instanceof AnnotatedMethod) {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));\n            } else {\n                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));\n            }\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable non-public methods for manipulating bean properties\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable method that can filter out properties. Default implementation\n     * checks annotations class may have.\n     */\n    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        String[] ignored = intr.findPropertiesToIgnore(ac, true);\n        if (ignored != null && ignored.length > 0) {\n            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n            Iterator<BeanPropertyWriter> it = props.iterator();\n            while (it.hasNext()) {\n                if (ignoredSet.contains(it.next().getName())) {\n                    it.remove();\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Method called to handle view information for constructed serializer,\n     * based on bean property writers.\n     *<p>\n     * Note that this method is designed to be overridden by sub-classes\n     * if they want to provide custom view handling. As such it is not\n     * considered an internal implementation detail, and will be supported\n     * as part of API going forward.\n     */\n    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n    {\n        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n        List<BeanPropertyWriter> props = builder.getProperties();\n        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n        final int propCount = props.size();\n        int viewsFound = 0;\n        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n        // Simple: view information is stored within individual writers, need to combine:\n        for (int i = 0; i < propCount; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            Class<?>[] views = bpw.getViews();\n            if (views == null) { // no view info? include or exclude by default?\n                if (includeByDefault) {\n                    filtered[i] = bpw;\n                }\n            } else {\n                ++viewsFound;\n                filtered[i] = constructFilteredBeanWriter(bpw, views);\n            }\n        }\n        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n        if (includeByDefault && viewsFound == 0) {\n            return;\n        }\n        builder.setFilteredProperties(filtered);\n    }\n\n    /**\n     * Method that will apply by-type limitations (as per [JACKSON-429]);\n     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n     * annotation but can be supplied by module-provided introspectors too.\n     */\n    protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            AnnotatedMember accessor = property.getAccessor();\n            if (accessor == null) {\n                it.remove();\n                continue;\n            }\n            Class<?> type = accessor.getRawType();\n            Boolean result = ignores.get(type);\n            if (result == null) {\n                BeanDescription desc = config.introspectClassAnnotations(type);\n                AnnotatedClass ac = desc.getClassInfo();\n                result = intr.isIgnorableType(ac);\n                // default to false, non-ignorable\n                if (result == null) {\n                    result = Boolean.FALSE;\n                }\n                ignores.put(type, result);\n            }\n            // lotsa work, and yes, it is ignorable type, so:\n            if (result.booleanValue()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method that will remove all properties that do not have a mutator.\n     */\n    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,\n            List<BeanPropertyDefinition> properties)\n    {\n        Iterator<BeanPropertyDefinition> it = properties.iterator();\n        while (it.hasNext()) {\n            BeanPropertyDefinition property = it.next();\n            // one caveat: as per [JACKSON-806], only remove implicit properties;\n            // explicitly annotated ones should remain\n            if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) {\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Helper method called to ensure that we do not have \"duplicate\" type ids.\n     * Added to resolve [databind#222]\n     *\n     * @since 2.6\n     */\n    protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializerProvider prov,\n            BeanDescription beanDesc, BeanSerializerBuilder builder,\n            List<BeanPropertyWriter> props)\n    {\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            BeanPropertyWriter bpw = props.get(i);\n            TypeSerializer td = bpw.getTypeSerializer();\n            if ((td == null) || (td.getTypeInclusion() != As.EXTERNAL_PROPERTY)) {\n                continue;\n            }\n            String n = td.getPropertyName();\n            PropertyName typePropName = PropertyName.construct(n);\n\n            for (BeanPropertyWriter w2 : props) {\n                if ((w2 != bpw) && w2.wouldConflictWithName(typePropName)) {\n                    bpw.assignTypeSerializer(null);\n                    break;\n                }\n            }\n        }\n        return props;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n     * given member (field or method).\n     */\n    protected BeanPropertyWriter _constructWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, TypeBindings typeContext,\n            PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor)\n        throws JsonMappingException\n    {\n        final PropertyName name = propDef.getFullName();\n        if (prov.canOverrideAccessModifiers()) {\n            accessor.fixAccess();\n        }\n        JavaType type = accessor.getType(typeContext);\n        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n                pb.getClassAnnotations(), accessor, propDef.getMetadata());\n\n        // Does member specify a serializer? If so, let's use it.\n        JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n                accessor);\n        /* 02-Feb-2012, tatu: Unlike most other code paths, serializer produced\n         *  here will NOT be resolved or contextualized, unless done here, so:\n         */\n        if (annotatedSerializer instanceof ResolvableSerializer) {\n            ((ResolvableSerializer) annotatedSerializer).resolve(prov);\n        }\n        // 05-Sep-2013, tatu: should be primary property serializer so:\n        annotatedSerializer = prov.handlePrimaryContextualization(annotatedSerializer, property);\n        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n        TypeSerializer contentTypeSer = null;\n        // 16-Feb-2014, cgc: contentType serializers for collection-like and map-like types\n        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())\n                || type.isCollectionLikeType() || type.isMapLikeType()) {\n            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n        }\n        // and if not JAXB collection/array with annotations, maybe regular type info?\n        TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor);\n        BeanPropertyWriter pbw = pb.buildWriter(prov, propDef, type, annotatedSerializer,\n                        typeSer, contentTypeSer, accessor, staticTyping);\n        return pbw;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 23, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.std.NumberSerializers", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\n\n/**\n * Container class for serializers used for handling standard JDK-provided types.\n */\n@SuppressWarnings(\"serial\")\npublic class NumberSerializers\n{\n    protected NumberSerializers() { }\n\n    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers)\n    {\n        final JsonSerializer<?> intS = new IntegerSerializer();\n        allDeserializers.put(Integer.class.getName(), intS);\n        allDeserializers.put(Integer.TYPE.getName(), intS);\n        allDeserializers.put(Long.class.getName(), LongSerializer.instance);\n        allDeserializers.put(Long.TYPE.getName(), LongSerializer.instance);\n        allDeserializers.put(Byte.class.getName(), IntLikeSerializer.instance);\n        allDeserializers.put(Byte.TYPE.getName(), IntLikeSerializer.instance);\n        allDeserializers.put(Short.class.getName(), ShortSerializer.instance);\n        allDeserializers.put(Short.TYPE.getName(), ShortSerializer.instance);\n\n        // Numbers, limited length floating point\n        allDeserializers.put(Float.class.getName(), FloatSerializer.instance);\n        allDeserializers.put(Float.TYPE.getName(), FloatSerializer.instance);\n        allDeserializers.put(Double.class.getName(), DoubleSerializer.instance);\n        allDeserializers.put(Double.TYPE.getName(), DoubleSerializer.instance);\n    }\n\n    /*\n    /**********************************************************\n    /* Shared base class\n    /**********************************************************\n     */\n\n    protected abstract static class Base<T> extends StdScalarSerializer<T>\n        implements ContextualSerializer\n    {\n\n        protected final JsonParser.NumberType _numberType;\n        protected final String _schemaType;\n        protected final boolean _isInt;\n\n        protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {\n            super(cls, false);\n            _numberType = numberType;\n            _schemaType = schemaType;\n            _isInt = (numberType == JsonParser.NumberType.INT)\n                    || (numberType == JsonParser.NumberType.LONG)\n                    || (numberType == JsonParser.NumberType.BIG_INTEGER)\n                    ;\n        }\n\n        @Override\n        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n            return createSchemaNode(_schemaType, true);\n        }\n\n        @Override\n        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n        {\n            if (_isInt) {\n                JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n                if (v2 != null) {\n                    v2.numberType(_numberType);\n                }\n            } else {\n                JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n                if (v2 != null) {\n                    v2.numberType(_numberType);\n                }\n            }\n        }\n\n        @Override\n        public JsonSerializer<?> createContextual(SerializerProvider prov,\n                BeanProperty property) throws JsonMappingException\n        {\n            if (property != null) {\n                AnnotatedMember m = property.getMember();\n                if (m != null) {\n                    JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(m);\n                    if (format != null) {\n                        switch (format.getShape()) {\n                        case STRING:\n                            return ToStringSerializer.instance;\n                        default:\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Concrete serializers, numerics\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    public final static class ShortSerializer extends Base<Short>\n    {\n        final static ShortSerializer instance = new ShortSerializer();\n\n        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, \"number\"); }\n\n\n        @Override\n        public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(value.shortValue());\n        }\n    }\n\n    /**\n     * This is the special serializer for regular {@link java.lang.Integer}s\n     * (and primitive ints)\n     *<p>\n     * Since this is one of \"native\" types, no type information is ever\n     * included on serialization (unlike for most scalar types)\n     *<p>\n     * NOTE: as of 2.6, generic signature changed to Object, to avoid generation\n     * of bridge methods.\n     */\n    @JacksonStdImpl\n    public final static class IntegerSerializer extends Base<Object>\n    {\n        public IntegerSerializer() { super(Integer.class, JsonParser.NumberType.INT ,\"integer\"); }\n    \n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Integer) value).intValue());\n        }\n        \n        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n        @Override\n        public void serializeWithType(Object value, JsonGenerator gen,\n                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n            // no type info, just regular serialization\n            serialize(value, gen, provider);            \n        }\n\n    }\n\n    /**\n     * Similar to {@link IntegerSerializer}, but will not cast to Integer:\n     * instead, cast is to {@link java.lang.Number}, and conversion is\n     * by calling {@link java.lang.Number#intValue}.\n     */\n    @JacksonStdImpl\n    public final static class IntLikeSerializer extends Base<Number>\n    {\n        final static IntLikeSerializer instance = new IntLikeSerializer();\n\n        public IntLikeSerializer() {\n            super(Number.class, JsonParser.NumberType.INT, \"integer\");\n        }\n\n\n        @Override\n        public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(value.intValue());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class LongSerializer extends Base<Object>\n    {\n\n        final static LongSerializer instance = new LongSerializer();\n    \n        public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, \"number\"); }\n\n\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Long) value).longValue());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class FloatSerializer extends Base<Object>\n    {\n\n        final static FloatSerializer instance = new FloatSerializer();\n\n        public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, \"number\"); }\n\n\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Float) value).floatValue());\n        }\n    }\n\n    /**\n     * This is the special serializer for regular {@link java.lang.Double}s\n     * (and primitive doubles)\n     *<p>\n     * Since this is one of \"native\" types, no type information is ever\n     * included on serialization (unlike for most scalar types as of 1.5)\n     */\n    @JacksonStdImpl\n    public final static class DoubleSerializer extends Base<Object>\n    {\n\n        final static DoubleSerializer instance = new DoubleSerializer();\n    \n        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, \"number\"); }\n\n\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Double) value).doubleValue());\n        }\n\n        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n        @Override\n        public void serializeWithType(Object value, JsonGenerator gen,\n                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n            // no type info, just regular serialization\n            serialize(value, gen, provider);            \n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\n\n/**\n * Container class for serializers used for handling standard JDK-provided types.\n */\n@SuppressWarnings(\"serial\")\npublic class NumberSerializers\n{\n    protected NumberSerializers() { }\n\n    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers)\n    {\n        final JsonSerializer<?> intS = new IntegerSerializer();\n        allDeserializers.put(Integer.class.getName(), intS);\n        allDeserializers.put(Integer.TYPE.getName(), intS);\n        allDeserializers.put(Long.class.getName(), LongSerializer.instance);\n        allDeserializers.put(Long.TYPE.getName(), LongSerializer.instance);\n        allDeserializers.put(Byte.class.getName(), IntLikeSerializer.instance);\n        allDeserializers.put(Byte.TYPE.getName(), IntLikeSerializer.instance);\n        allDeserializers.put(Short.class.getName(), ShortSerializer.instance);\n        allDeserializers.put(Short.TYPE.getName(), ShortSerializer.instance);\n\n        // Numbers, limited length floating point\n        allDeserializers.put(Float.class.getName(), FloatSerializer.instance);\n        allDeserializers.put(Float.TYPE.getName(), FloatSerializer.instance);\n        allDeserializers.put(Double.class.getName(), DoubleSerializer.instance);\n        allDeserializers.put(Double.TYPE.getName(), DoubleSerializer.instance);\n    }\n\n    /*\n    /**********************************************************\n    /* Shared base class\n    /**********************************************************\n     */\n\n    protected abstract static class Base<T> extends StdScalarSerializer<T>\n        implements ContextualSerializer\n    {\n        protected final static Integer EMPTY_INTEGER = Integer.valueOf(0);\n\n        protected final JsonParser.NumberType _numberType;\n        protected final String _schemaType;\n        protected final boolean _isInt;\n\n        protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {\n            super(cls, false);\n            _numberType = numberType;\n            _schemaType = schemaType;\n            _isInt = (numberType == JsonParser.NumberType.INT)\n                    || (numberType == JsonParser.NumberType.LONG)\n                    || (numberType == JsonParser.NumberType.BIG_INTEGER)\n                    ;\n        }\n\n        @Override\n        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n            return createSchemaNode(_schemaType, true);\n        }\n\n        @Override\n        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n        {\n            if (_isInt) {\n                JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n                if (v2 != null) {\n                    v2.numberType(_numberType);\n                }\n            } else {\n                JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n                if (v2 != null) {\n                    v2.numberType(_numberType);\n                }\n            }\n        }\n\n        @Override\n        public JsonSerializer<?> createContextual(SerializerProvider prov,\n                BeanProperty property) throws JsonMappingException\n        {\n            if (property != null) {\n                AnnotatedMember m = property.getMember();\n                if (m != null) {\n                    JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(m);\n                    if (format != null) {\n                        switch (format.getShape()) {\n                        case STRING:\n                            return ToStringSerializer.instance;\n                        default:\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Concrete serializers, numerics\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    public final static class ShortSerializer extends Base<Short>\n    {\n        private final static Short EMPTY = (short) 0;\n        final static ShortSerializer instance = new ShortSerializer();\n\n        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, \"number\"); }\n\n        @Override\n        public boolean isEmpty(SerializerProvider prov, Short value) {\n            return EMPTY.equals(value);\n        }\n\n        @Override\n        public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(value.shortValue());\n        }\n    }\n\n    /**\n     * This is the special serializer for regular {@link java.lang.Integer}s\n     * (and primitive ints)\n     *<p>\n     * Since this is one of \"native\" types, no type information is ever\n     * included on serialization (unlike for most scalar types)\n     *<p>\n     * NOTE: as of 2.6, generic signature changed to Object, to avoid generation\n     * of bridge methods.\n     */\n    @JacksonStdImpl\n    public final static class IntegerSerializer extends Base<Object>\n    {\n        public IntegerSerializer() { super(Integer.class, JsonParser.NumberType.INT ,\"integer\"); }\n    \n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Integer) value).intValue());\n        }\n        \n        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n        @Override\n        public void serializeWithType(Object value, JsonGenerator gen,\n                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n            // no type info, just regular serialization\n            serialize(value, gen, provider);            \n        }\n\n        @Override\n        public boolean isEmpty(SerializerProvider prov, Object value) {\n            return EMPTY_INTEGER.equals(value);\n        }\n    }\n\n    /**\n     * Similar to {@link IntegerSerializer}, but will not cast to Integer:\n     * instead, cast is to {@link java.lang.Number}, and conversion is\n     * by calling {@link java.lang.Number#intValue}.\n     */\n    @JacksonStdImpl\n    public final static class IntLikeSerializer extends Base<Number>\n    {\n        final static IntLikeSerializer instance = new IntLikeSerializer();\n\n        public IntLikeSerializer() {\n            super(Number.class, JsonParser.NumberType.INT, \"integer\");\n        }\n\n        @Override\n        public boolean isEmpty(SerializerProvider prov, Number value) {\n            return value.intValue() == 0;\n        }\n\n        @Override\n        public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(value.intValue());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class LongSerializer extends Base<Object>\n    {\n        private final static Long EMPTY = 0L;\n\n        final static LongSerializer instance = new LongSerializer();\n    \n        public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, \"number\"); }\n\n        @Override\n        public boolean isEmpty(SerializerProvider prov, Object value) {\n            return EMPTY.equals(value);\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Long) value).longValue());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class FloatSerializer extends Base<Object>\n    {\n        private final static Float EMPTY = 0f;\n\n        final static FloatSerializer instance = new FloatSerializer();\n\n        public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, \"number\"); }\n\n        @Override\n        public boolean isEmpty(SerializerProvider prov, Object value) {\n            return EMPTY.equals(value);\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Float) value).floatValue());\n        }\n    }\n\n    /**\n     * This is the special serializer for regular {@link java.lang.Double}s\n     * (and primitive doubles)\n     *<p>\n     * Since this is one of \"native\" types, no type information is ever\n     * included on serialization (unlike for most scalar types as of 1.5)\n     */\n    @JacksonStdImpl\n    public final static class DoubleSerializer extends Base<Object>\n    {\n        private final static Double EMPTY = 0d;\n\n        final static DoubleSerializer instance = new DoubleSerializer();\n    \n        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, \"number\"); }\n\n        @Override\n        public boolean isEmpty(SerializerProvider prov, Object value) {\n            return EMPTY.equals(value);\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n            gen.writeNumber(((Double) value).doubleValue());\n        }\n\n        // IMPORTANT: copied from `NonTypedScalarSerializerBase`\n        @Override\n        public void serializeWithType(Object value, JsonGenerator gen,\n                SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n            // no type info, just regular serialization\n            serialize(value, gen, provider);            \n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 24, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.cfg.BaseSettings", "buggy_version": "package com.fasterxml.jackson.databind.cfg;\n\nimport java.text.DateFormat;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.Base64Variant;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\n\n/**\n * Immutable container class used to store simple configuration\n * settings. Since instances are fully immutable, instances can\n * be freely shared and used without synchronization.\n */\npublic final class BaseSettings\n    implements java.io.Serializable\n{\n    // for 2.6\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Configuration settings; introspection, related\n    /**********************************************************\n     */\n    \n    /**\n     * Introspector used to figure out Bean properties needed for bean serialization\n     * and deserialization. Overridable so that it is possible to change low-level\n     * details of introspection, like adding new annotation types.\n     */\n    protected final ClassIntrospector _classIntrospector;\n\n    /**\n     * Introspector used for accessing annotation value based configuration.\n     */\n    protected final AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * Object used for determining whether specific property elements\n     * (method, constructors, fields) can be auto-detected based on\n     * their visibility (access modifiers). Can be changed to allow\n     * different minimum visibility levels for auto-detection. Note\n     * that this is the global handler; individual types (classes)\n     * can further override active checker used (using\n     * {@link JsonAutoDetect} annotation)\n     */\n    protected final VisibilityChecker<?> _visibilityChecker;\n\n    /**\n     * Custom property naming strategy in use, if any.\n     */\n    protected final PropertyNamingStrategy _propertyNamingStrategy;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected final TypeFactory _typeFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings; type resolution\n    /**********************************************************\n     */\n\n    /**\n     * Type information handler used for \"untyped\" values (ones declared\n     * to have type <code>Object.class</code>)\n     */\n    protected final TypeResolverBuilder<?> _typeResolverBuilder;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings; other\n    /**********************************************************\n     */\n    \n    /**\n     * Custom date format to use for de-serialization. If specified, will be\n     * used instead of {@link com.fasterxml.jackson.databind.util.StdDateFormat}.\n     *<p>\n     * Note that the configured format object will be cloned once per\n     * deserialization process (first time it is needed)\n     */\n    protected final DateFormat _dateFormat;\n\n    /**\n     * Object used for creating instances of handlers (serializers, deserializers,\n     * type and type id resolvers), given class to instantiate. This is typically\n     * used to do additional configuration (with dependency injection, for example)\n     * beyond simply construction of instances; or to use alternative constructors.\n     */\n    protected final HandlerInstantiator _handlerInstantiator;\n\n    /**\n     * Default {@link java.util.Locale} used with serialization formats.\n     * Default value is {@link Locale#getDefault()}.\n     */\n    protected final Locale _locale;\n\n    /**\n     * Default {@link java.util.TimeZone} used with serialization formats.\n     * Default value is {@link TimeZone#getDefault()}, which is typically the\n     * local time zone (unless overridden for JVM).\n     *<p>\n     * Note that if a new value is set, time zone is also assigned to\n     * {@link #_dateFormat} of this object.\n     */\n    protected final TimeZone _timeZone;\n\n    /**\n     * Explicitly default {@link Base64Variant} to use for handling\n     * binary data (<code>byte[]</code>), used with data formats\n     * that use base64 encoding (like JSON, CSV).\n     * \n     * @since 2.1\n     */\n    protected final Base64Variant _defaultBase64;\n    \n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n\n    public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai,\n            VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n            TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi,\n            Locale locale, TimeZone tz, Base64Variant defaultBase64)\n    {\n        _classIntrospector = ci;\n        _annotationIntrospector = ai;\n        _visibilityChecker = vc;\n        _propertyNamingStrategy = pns;\n        _typeFactory = tf;\n        _typeResolverBuilder = typer;\n        _dateFormat = dateFormat;\n        _handlerInstantiator = hi;\n        _locale = locale;\n        _timeZone = tz;\n        _defaultBase64 = defaultBase64;\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    public BaseSettings withClassIntrospector(ClassIntrospector ci) {\n        if (_classIntrospector == ci) {\n            return this;\n        }\n        return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n    \n    public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) {\n        if (_annotationIntrospector == ai) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(ai, _annotationIntrospector));\n    }\n\n    public BaseSettings withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(_annotationIntrospector, ai));\n    }\n    \n    public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n        if (_visibilityChecker == vc) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                _visibilityChecker.withVisibility(forMethod, visibility),\n                _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n    \n    public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n        if (_propertyNamingStrategy == pns) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withTypeFactory(TypeFactory tf) {\n        if (_typeFactory == tf) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n        if (_typeResolverBuilder == typer) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                typer, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n    \n    public BaseSettings withDateFormat(DateFormat df) {\n        if (_dateFormat == df) {\n            return this;\n        }\n        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                tz, _defaultBase64);\n    }\n\n    public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n        if (_handlerInstantiator == hi) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, hi, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings with(Locale l) {\n        if (_locale == l) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l,\n                _timeZone, _defaultBase64);\n    }\n\n    /**\n     * Fluent factory for constructing a new instance that uses specified TimeZone.\n     * Note that timezone used with also be assigned to configured {@link DateFormat},\n     * changing time formatting defaults.\n     */\n    public BaseSettings with(TimeZone tz)\n    {\n        if (tz == null) {\n            throw new IllegalArgumentException();\n        }\n        DateFormat df = _dateFormat;\n        if (df instanceof StdDateFormat) {\n            df = ((StdDateFormat) df).withTimeZone(tz);\n        } else {\n            // we don't know if original format might be shared; better create a clone:\n            df = (DateFormat) df.clone();\n            df.setTimeZone(tz);\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                tz, _defaultBase64);\n    }\n\n    /**\n     * @since 2.1\n     */\n    public BaseSettings with(Base64Variant base64) {\n        if (base64 == _defaultBase64) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, base64);\n    }\n    \n    /*\n    /**********************************************************\n    /* API\n    /**********************************************************\n     */\n\n    public ClassIntrospector getClassIntrospector() {\n        return _classIntrospector;\n    }\n    \n    public AnnotationIntrospector getAnnotationIntrospector() {\n        return _annotationIntrospector;\n    }\n\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _visibilityChecker;\n    }\n\n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        return _propertyNamingStrategy;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    public TypeResolverBuilder<?> getTypeResolverBuilder() {\n        return _typeResolverBuilder;\n    }\n    \n    public DateFormat getDateFormat() {\n        return _dateFormat;\n    }\n\n    public HandlerInstantiator getHandlerInstantiator() {\n        return _handlerInstantiator;\n    }\n\n    public Locale getLocale() {\n        return _locale;\n    }\n\n    public TimeZone getTimeZone() {\n        return _timeZone;\n    }\n\n    public Base64Variant getBase64Variant() {\n        return _defaultBase64;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.cfg;\n\nimport java.text.DateFormat;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.Base64Variant;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\n\n/**\n * Immutable container class used to store simple configuration\n * settings. Since instances are fully immutable, instances can\n * be freely shared and used without synchronization.\n */\npublic final class BaseSettings\n    implements java.io.Serializable\n{\n    // for 2.6\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Configuration settings; introspection, related\n    /**********************************************************\n     */\n    \n    /**\n     * Introspector used to figure out Bean properties needed for bean serialization\n     * and deserialization. Overridable so that it is possible to change low-level\n     * details of introspection, like adding new annotation types.\n     */\n    protected final ClassIntrospector _classIntrospector;\n\n    /**\n     * Introspector used for accessing annotation value based configuration.\n     */\n    protected final AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * Object used for determining whether specific property elements\n     * (method, constructors, fields) can be auto-detected based on\n     * their visibility (access modifiers). Can be changed to allow\n     * different minimum visibility levels for auto-detection. Note\n     * that this is the global handler; individual types (classes)\n     * can further override active checker used (using\n     * {@link JsonAutoDetect} annotation)\n     */\n    protected final VisibilityChecker<?> _visibilityChecker;\n\n    /**\n     * Custom property naming strategy in use, if any.\n     */\n    protected final PropertyNamingStrategy _propertyNamingStrategy;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected final TypeFactory _typeFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings; type resolution\n    /**********************************************************\n     */\n\n    /**\n     * Type information handler used for \"untyped\" values (ones declared\n     * to have type <code>Object.class</code>)\n     */\n    protected final TypeResolverBuilder<?> _typeResolverBuilder;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings; other\n    /**********************************************************\n     */\n    \n    /**\n     * Custom date format to use for de-serialization. If specified, will be\n     * used instead of {@link com.fasterxml.jackson.databind.util.StdDateFormat}.\n     *<p>\n     * Note that the configured format object will be cloned once per\n     * deserialization process (first time it is needed)\n     */\n    protected final DateFormat _dateFormat;\n\n    /**\n     * Object used for creating instances of handlers (serializers, deserializers,\n     * type and type id resolvers), given class to instantiate. This is typically\n     * used to do additional configuration (with dependency injection, for example)\n     * beyond simply construction of instances; or to use alternative constructors.\n     */\n    protected final HandlerInstantiator _handlerInstantiator;\n\n    /**\n     * Default {@link java.util.Locale} used with serialization formats.\n     * Default value is {@link Locale#getDefault()}.\n     */\n    protected final Locale _locale;\n\n    /**\n     * Default {@link java.util.TimeZone} used with serialization formats.\n     * Default value is {@link TimeZone#getDefault()}, which is typically the\n     * local time zone (unless overridden for JVM).\n     *<p>\n     * Note that if a new value is set, time zone is also assigned to\n     * {@link #_dateFormat} of this object.\n     */\n    protected final TimeZone _timeZone;\n\n    /**\n     * Explicitly default {@link Base64Variant} to use for handling\n     * binary data (<code>byte[]</code>), used with data formats\n     * that use base64 encoding (like JSON, CSV).\n     * \n     * @since 2.1\n     */\n    protected final Base64Variant _defaultBase64;\n    \n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n\n    public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai,\n            VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n            TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi,\n            Locale locale, TimeZone tz, Base64Variant defaultBase64)\n    {\n        _classIntrospector = ci;\n        _annotationIntrospector = ai;\n        _visibilityChecker = vc;\n        _propertyNamingStrategy = pns;\n        _typeFactory = tf;\n        _typeResolverBuilder = typer;\n        _dateFormat = dateFormat;\n        _handlerInstantiator = hi;\n        _locale = locale;\n        _timeZone = tz;\n        _defaultBase64 = defaultBase64;\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    public BaseSettings withClassIntrospector(ClassIntrospector ci) {\n        if (_classIntrospector == ci) {\n            return this;\n        }\n        return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n    \n    public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) {\n        if (_annotationIntrospector == ai) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(ai, _annotationIntrospector));\n    }\n\n    public BaseSettings withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(_annotationIntrospector, ai));\n    }\n    \n    public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n        if (_visibilityChecker == vc) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                _visibilityChecker.withVisibility(forMethod, visibility),\n                _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n    \n    public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n        if (_propertyNamingStrategy == pns) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withTypeFactory(TypeFactory tf) {\n        if (_typeFactory == tf) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n        if (_typeResolverBuilder == typer) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                typer, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n    \n    public BaseSettings withDateFormat(DateFormat df) {\n        if (_dateFormat == df) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n        if (_handlerInstantiator == hi) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, hi, _locale,\n                _timeZone, _defaultBase64);\n    }\n\n    public BaseSettings with(Locale l) {\n        if (_locale == l) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l,\n                _timeZone, _defaultBase64);\n    }\n\n    /**\n     * Fluent factory for constructing a new instance that uses specified TimeZone.\n     * Note that timezone used with also be assigned to configured {@link DateFormat},\n     * changing time formatting defaults.\n     */\n    public BaseSettings with(TimeZone tz)\n    {\n        if (tz == null) {\n            throw new IllegalArgumentException();\n        }\n        DateFormat df = _dateFormat;\n        if (df instanceof StdDateFormat) {\n            df = ((StdDateFormat) df).withTimeZone(tz);\n        } else {\n            // we don't know if original format might be shared; better create a clone:\n            df = (DateFormat) df.clone();\n            df.setTimeZone(tz);\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                tz, _defaultBase64);\n    }\n\n    /**\n     * @since 2.1\n     */\n    public BaseSettings with(Base64Variant base64) {\n        if (base64 == _defaultBase64) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n                _timeZone, base64);\n    }\n    \n    /*\n    /**********************************************************\n    /* API\n    /**********************************************************\n     */\n\n    public ClassIntrospector getClassIntrospector() {\n        return _classIntrospector;\n    }\n    \n    public AnnotationIntrospector getAnnotationIntrospector() {\n        return _annotationIntrospector;\n    }\n\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _visibilityChecker;\n    }\n\n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        return _propertyNamingStrategy;\n    }\n\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    public TypeResolverBuilder<?> getTypeResolverBuilder() {\n        return _typeResolverBuilder;\n    }\n    \n    public DateFormat getDateFormat() {\n        return _dateFormat;\n    }\n\n    public HandlerInstantiator getHandlerInstantiator() {\n        return _handlerInstantiator;\n    }\n\n    public Locale getLocale() {\n        return _locale;\n    }\n\n    public TimeZone getTimeZone() {\n        return _timeZone;\n    }\n\n    public Base64Variant getBase64Variant() {\n        return _defaultBase64;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 25, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.BasicDeserializerFactory", "buggy_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport com.fasterxml.jackson.core.JsonLocation;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n\n    /**\n     * We need a placeholder for creator properties that don't have name\n     * but are marked with `@JsonWrapped` annotation.\n     */\n    protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\");\n    \n    /* We do some defaulting for abstract Map classes and\n     * interfaces, to avoid having to use exact types or annotations in\n     * cases where the most common concrete Maps will do.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Map>> _mapFallbacks =\n        new HashMap<String, Class<? extends Map>>();\n    static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    /* We do some defaulting for abstract Collection classes and\n     * interfaces, to avoid having to use exact types or annotations in\n     * cases where the most common concrete Collection will do.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks =\n        new HashMap<String, Class<? extends Collection>>();\n    static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        // then 1.6 types:\n        /* 17-May-2013, tatu: [Issue#216] Should be fine to use straight Class references EXCEPT\n         *   that some godforsaken platforms (... looking at you, Android) do not\n         *   include these. So, use \"soft\" references...\n         */\n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n    \n    /*\n    /**********************************************************\n    /* Config\n    /**********************************************************\n     */\n    \n    /**\n     * Configuration settings for this factory; immutable instance (just like this\n     * factory), new version created via copy-constructor (fluent-style)\n     */\n    protected final DeserializerFactoryConfig _factoryConfig;\n    \n    /*\n    /**********************************************************\n    /* Life cycle\n    /**********************************************************\n     */\n\n    protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    /**\n     * Method for getting current {@link DeserializerFactoryConfig}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config);\n    \n    /*\n    /********************************************************\n    /* Configuration handling: fluent factories\n    /********************************************************\n     */\n\n    /**\n     * Convenience method for creating a new factory instance with additional deserializer\n     * provider.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link KeyDeserializers}.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link BeanDeserializerModifier}.\n     */\n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link AbstractTypeResolver}.\n     */\n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link ValueInstantiators}.\n     */\n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    /*\n    /**********************************************************\n    /* DeserializerFactory impl (partial): type mappings\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException\n    {\n        // first, general mappings\n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            // Should not have to worry about cycles; but better verify since they will invariably occur... :-)\n            // (also: guard against invalid resolution to a non-related type)\n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\");\n            }\n            type = next;\n        }\n    }\n\n    /**\n     * Method that will find abstract type mapping for specified type, doing a single\n     * lookup through registered abstract type resolvers; will not do recursive lookups.\n     */\n    private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n        throws JsonMappingException\n    {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): ValueInstantiators\n    /**********************************************************\n     */\n\n    /**\n     * Value instantiator is created both based on creator annotations,\n     * and on optional externally provided instantiators (registered through\n     * module interface).\n     */\n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        // [JACKSON-633] Check @JsonValueInstantiator before anything else\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            /* Second: see if some of standard Jackson/JDK types might provide value\n             * instantiators.\n             */\n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        // finally: anyone want to modify ValueInstantiator?\n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                // let's do sanity check; easier to spot buggy handlers\n                if (instantiator == null) {\n                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n                }\n            }\n        }\n\n        // Sanity check: does the chosen instantatior have incomplete creators?\n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }\n\n    /**\n     * Method that will construct standard default {@link ValueInstantiator}\n     * using annotations (like @JsonCreator) and visibility rules\n     */\n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        // need to construct suitable visibility checker:\n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n         *  (which has creator parameters sprinkled around) with actual creator\n         *  declarations (which are needed to access creator annotation, amongst other things).\n         *  Easiest to combine that info first, then pass it to remaining processing.\n         */\n        /* 15-Mar-2015, tatu: Alas, this won't help with constructors that only have implicit\n         *   names. Those will need to be resolved later on.\n         */\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        /* Important: first add factory methods; then constructors, so\n         * latter can override former!\n         */\n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        // constructors only usable on concrete types:\n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { // since emptyMap is immutable need to create a 'real' one\n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n            Annotated annotated, Object instDef)\n        throws JsonMappingException\n    {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    protected void _addDeserializerConstructors\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        // First things first: the \"default constructor\" (zero-arg\n        // constructor; whether implicit or explicit) is NOT included\n        // in list of constructors, so needs to be handled separately.\n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        // may need to keep track for [#725]\n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            // some single-arg factory methods (String, number) are auto-detected\n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    // one more thing: sever link to creator property, to avoid possible later\n                    // problems with \"unresolved\" constructor property\n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                // regardless, fully handled\n                continue;\n            }\n\n            // 2 or more args; all params must have names or be injectable\n            // 14-Mar-2015, tatu (2.6): Or, as per [#725], implicit names will also\n            //   do, with some constraints. But that will require bit post processing...\n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                // One more thing: implicit names are ok iff ctor has creator annotation\n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            // Ok: if named or injectable, we have more work to do\n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                // simple case; everything covered:\n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    // Secondary: all but one injectable, one un-annotated (un-named)\n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                // otherwise, epic fail?\n                // 16-Mar-2015, tatu: due to [#725], need to be more permissive. For now let's\n                //    only report problem if there's no implicit name\n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    // Let's consider non-static inner class as a special case...\n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \"\n                                +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\");\n                    }\n                    throw new IllegalArgumentException(\"Argument #\"+ix\n                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n            // [#725]: as a fallback, all-implicit names may work as well\n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        // last option, as per [#725]: consider implicit-names-only, visible constructor,\n        // if just one found\n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            List<AnnotatedConstructor> implicitCtors) throws JsonMappingException\n    {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        // Further checks: (a) must have names for all parameters, (b) only one visible\n        // Also, since earlier matching of properties and creators relied on existence of\n        // `@JsonCreator` (or equivalent) annotation, we need to do bit more re-inspection...\n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            // as per earlier notes, only end up here if no properties associated with creator\n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                // must have name (implicit fine)\n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param, /*injectId*/ null);\n            }\n            if (found != null) { // only one allowed\n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        // found one and only one visible? Ship it!\n        if (found != null) {\n            creators.addPropertyCreator(found, /*isCreator*/ false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            // Also: add properties, to keep error messages complete wrt known properties...\n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        // If explicit name, or inject id, property-based\n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        // in absence of everything else, default to delegating\n        return false;\n    }\n    \n    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n        throws JsonMappingException\n    {\n        // otherwise either 'simple' number, String, or general delegate:\n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        // Delegating Creator ok iff it has @JsonCreator (etc)\n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    protected void _addDeserializerFactoryMethods\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            // zero-arg methods must be annotated; if so, are \"default creators\" [JACKSON-850]\n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            // some single-arg factory methods (String, number) are auto-detected\n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { // not property based but delegating\n                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    // otherwise just ignored\n                    continue;\n                }\n                // fall through if there's name\n            } else {\n                // more than 2 args, must have @JsonCreator\n                if (!isCreator) {\n                    continue;\n                }\n            }\n            // 1 or more args; all params must have name annotations\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                // One more thing: implicit names are ok iff ctor has creator annotation\n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n                 *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n                 *  let's add one more work around\n                 */\n                /*\n                PropertyName name2 = _findExplicitParamName(param, intr);\n                if (name2 != null && !name2.isEmpty()) {\n                    // Hmmh. Ok, fine. So what are we to do with it... ?\n                    // For now... skip. May need to revisit this, should this become problematic\n                    continue main_loop;\n                }\n                */\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            // Ok: if named or injectable, we have more work to do\n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                // simple case; everything covered:\n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { // otherwise, epic fail\n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            AnnotatedMethod factory, boolean isCreator)\n        throws JsonMappingException\n    {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method that will construct a property object that represents\n     * a logical property passed via Creator (constructor or static\n     * factory method)\n     */\n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, PropertyName name, int index,\n            AnnotatedParameter param,\n            Object injectableValueId)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                boolean req = (b != null && b.booleanValue());\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(req, desc, idx, def);\n            }\n        }\n            \n        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n        BeanProperty.Std property = new BeanProperty.Std(name, t0,\n                intr.findWrapperName(param),\n                beanDesc.getClassAnnotations(), param, metadata);\n        JavaType type = resolveType(ctxt, beanDesc, t0, param);\n        if (type != t0) {\n            property = property.withType(type);\n        }\n        // Is there an annotation that specifies exact deserializer?\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n\n        // If yes, we are mostly done:\n        type = modifyTypeByAnnotation(ctxt, param, type);\n\n        // Type deserializer: either comes from property (and already resolved)\n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        // or if not, based on type being referenced:\n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        // Note: contextualization of typeDeser _should_ occur in constructor of CreatorProperty\n        // so it is not called directly here\n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        if (deser != null) {\n            // As per [Issue#462] need to ensure we contextualize deserializer before passing it on\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            // 14-Apr-2014, tatu: Need to also consider possible implicit name\n            //  (for JDK8, or via paranamer)\n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }\n\n    @Deprecated // in 2.6, remove from 2.7\n    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }\n\n    @Deprecated // in 2.6, remove from 2.7\n    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            PropertyName n = intr.findNameForDeserialization(param);\n            return (n != null) && n.hasSimpleName();\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: array deserializers\n    /**********************************************************\n     */\n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n            ArrayType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        // 23-Nov-2010, tatu: Custom array deserializer?\n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Collection(-like) deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n            CollectionType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { // not defined by annotation\n                // One special type: EnumSet:\n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n        \n        /* One twist: if we are being asked to instantiate an interface or\n         * abstract Collection, we need to either find something that implements\n         * the thing, or give up.\n         *\n         * Note that we do NOT try to guess based on secondary interfaces\n         * here; that would probably not work correctly since casts would\n         * fail later on (as the primary type is not the interface we'd\n         * be implementing)\n         */\n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    // But if so, also need to re-check creators...\n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    // [Issue#161]: No default constructor for ArrayBlockingQueue...\n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n                    }\n                }\n                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n                if (contentType.getRawClass() == String.class) {\n                    // no value type deserializer because Strings are one of natural/native types:\n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)\n    {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n            CollectionLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            // and then new with 2.2: ability to post-process it too (Issue#120)\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Map(-like) deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n            MapType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        // Then optional type info (1.5); either attached to type, or resolved separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            // Value handling is identical for all, but EnumMap requires special handling for keys\n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            // Otherwise, generic handler works ok.\n    \n            /* But there is one more twist: if we are being asked to instantiate\n             * an interface or abstract Map, we need to either find something\n             * that implements the thing, or give up.\n             *\n             * Note that we do NOT try to guess based on secondary interfaces\n             * here; that would probably not work correctly since casts would\n             * fail later on (as the primary type is not the interface we'd\n             * be implementing)\n             */\n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        // But if so, also need to re-check creators...\n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                    md.setIgnorableProperties(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), false));\n                    deser = md;\n                }\n            }\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n            MapLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        /* !!! 24-Jan-2012, tatu: NOTE: impls MUST use resolve() to find key deserializer!\n        if (keyDes == null) {\n            keyDes = p.findKeyDeserializer(config, keyType, property);\n        }\n        */\n        // Then optional type info (1.5); either attached to type, or resolve separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            // and then new with 2.2: ability to post-process it too (Issue#120)\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Enum deserializers\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method for constructing serializers of {@link Enum} types.\n     */\n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (deser == null) {\n            // [JACKSON-193] May have @JsonCreator for static factory method:\n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    int argCount = factory.getParameterCount();\n                    if (argCount == 1) {\n                        Class<?> returnType = factory.getRawReturnType();\n                        // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                        if (returnType.isAssignableFrom(enumClass)) {\n                            deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory);\n                            break;\n                        }\n                    }\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n            // [JACKSON-749] Also, need to consider @JsonValue, if one found\n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Tree deserializers\n    /**********************************************************\n     */\n    \n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n            JavaType nodeType, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): type deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // [JACKSON-505]: May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n\n    /**\n     * Overridable method called after checking all other types.\n     * \n     * @since 2.2\n     */\n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): key deserializers\n    /**********************************************************\n     */\n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        \n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDescription beanDesc = config.introspect(type);\n        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n        }\n        Class<?> enumClass = type.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // [JACKSON-193] May have @JsonCreator for static factory method:\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getGenericParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember());\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method called to create a type information deserializer for values of\n     * given non-container property, if one is needed.\n     * If not needed (no polymorphic handling configured for property), should return null.\n     *<p>\n     * Note that this method is only called for non-container bean properties,\n     * and not for values in container types or root values (or container properties)\n     *\n     * @param baseType Declared base type of the value to deserializer (actual\n     *    deserializer type will be this type or its subtype)\n     * \n     * @return Type deserializer to use for given base type, if one is needed; null if not.\n     */\n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, AnnotatedMember annotated)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n    /**\n     * Method called to find and create a type information deserializer for values of\n     * given container (list, array, map) property, if one is needed.\n     * If not needed (no polymorphic handling configured for property), should return null.\n     *<p>\n     * Note that this method is only called for container bean properties,\n     * and not for values in container types or root values (or non-container properties)\n     * \n     * @param containerType Type of property; must be a container type\n     * @param propertyEntity Field or method that contains container property\n     */    \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config,\n            JavaType containerType, AnnotatedMember propertyEntity)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        // Defaulting: if no annotations on member, check class\n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    /**\n     * Helper method called to find one of default serializers for \"well-known\"\n     * platform types: JDK-provided types, and small number of public Jackson\n     * API types.\n     * \n     * @since 2.2\n     */\n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        // Object (\"untyped\"), String equivalents:\n        if (rawType == CLASS_OBJECT) {\n            // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.\n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        \n        if (type.isReferenceType()) {\n            JavaType referencedType = type.getReferencedType();\n            if (AtomicReference.class.isAssignableFrom(rawType)) {\n                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n                return new AtomicReferenceDeserializer(referencedType, vts, deser);\n            }\n            // Hmmh. Should we continue here for unknown referential types?\n        }\n        if (rawType == CLASS_ITERABLE) {\n            // [Issue#199]: Can and should 'upgrade' to a Collection type:\n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            // Should we re-introspect beanDesc? For now let's not...\n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            // 28-Apr-2015, tatu: TypeFactory does it all for us already so\n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        // and a few Jackson types as well:\n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, finding custom deserializers\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods, value/content/key type introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization.\n     * Returns null if no such annotation found.\n     */\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        return ctxt.deserializerInstance(ann, deserDef);\n    }\n\n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type of field, or the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n    \n    /**\n     * Helper method used to resolve method return types and field\n     * types. The main trick here is that the containing bean may\n     * have type variable binding information (when deserializing\n     * using generic type passed as type reference), which is\n     * needed in some cases.\n     */\n    protected JavaType resolveType(DeserializationContext ctxt,\n            BeanDescription beanDesc, JavaType type, AnnotatedMember member)\n        throws JsonMappingException\n    {\n        // [JACKSON-154]: Also need to handle keyUsing, contentUsing\n        if (type.isContainerType()) {\n            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }\n            // and all container types have content types...\n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n             *    information to use for polymorphic members; and specifically types for\n             *    collection values (contents).\n             *    ... but only applies to members (fields, methods), not classes\n             */\n            if (member instanceof AnnotatedMember) {\n            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n            \t        ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            \tif (contentTypeDeser != null) {\n            \t    type = type.withContentTypeHandler(contentTypeDeser);\n            \t}\n            }\n        }\n        TypeDeserializer valueTypeDeser;\n\n        if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        } else { // classes just have Jackson annotations\n            // probably only occurs if 'property' is null anyway\n            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n        }\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n        return type;\n    }\n    \n    protected EnumResolver constructEnumResolver(Class<?> enumClass,\n            DeserializationConfig config, AnnotatedMethod jsonValueMethod)\n    {\n        if (jsonValueMethod != null) {\n            Method accessor = jsonValueMethod.getAnnotated();\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(accessor);\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n        }\n        // [JACKSON-212]: may need to use Enum.toString()\n        if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) {\n            return EnumResolver.constructUnsafeUsingToString(enumClass);\n        }\n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)\n    {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\n\nimport com.fasterxml.jackson.core.JsonLocation;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\nimport com.fasterxml.jackson.databind.deser.std.*;\nimport com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n\n    /**\n     * We need a placeholder for creator properties that don't have name\n     * but are marked with `@JsonWrapped` annotation.\n     */\n    protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\");\n    \n    /* We do some defaulting for abstract Map classes and\n     * interfaces, to avoid having to use exact types or annotations in\n     * cases where the most common concrete Maps will do.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Map>> _mapFallbacks =\n        new HashMap<String, Class<? extends Map>>();\n    static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    /* We do some defaulting for abstract Collection classes and\n     * interfaces, to avoid having to use exact types or annotations in\n     * cases where the most common concrete Collection will do.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks =\n        new HashMap<String, Class<? extends Collection>>();\n    static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        // then 1.6 types:\n        /* 17-May-2013, tatu: [Issue#216] Should be fine to use straight Class references EXCEPT\n         *   that some godforsaken platforms (... looking at you, Android) do not\n         *   include these. So, use \"soft\" references...\n         */\n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n    \n    /*\n    /**********************************************************\n    /* Config\n    /**********************************************************\n     */\n    \n    /**\n     * Configuration settings for this factory; immutable instance (just like this\n     * factory), new version created via copy-constructor (fluent-style)\n     */\n    protected final DeserializerFactoryConfig _factoryConfig;\n    \n    /*\n    /**********************************************************\n    /* Life cycle\n    /**********************************************************\n     */\n\n    protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n        _factoryConfig = config;\n    }\n    \n    /**\n     * Method for getting current {@link DeserializerFactoryConfig}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config);\n    \n    /*\n    /********************************************************\n    /* Configuration handling: fluent factories\n    /********************************************************\n     */\n\n    /**\n     * Convenience method for creating a new factory instance with additional deserializer\n     * provider.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link KeyDeserializers}.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }\n    \n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link BeanDeserializerModifier}.\n     */\n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link AbstractTypeResolver}.\n     */\n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link ValueInstantiators}.\n     */\n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }\n\n    /*\n    /**********************************************************\n    /* DeserializerFactory impl (partial): type mappings\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException\n    {\n        // first, general mappings\n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            // Should not have to worry about cycles; but better verify since they will invariably occur... :-)\n            // (also: guard against invalid resolution to a non-related type)\n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\");\n            }\n            type = next;\n        }\n    }\n\n    /**\n     * Method that will find abstract type mapping for specified type, doing a single\n     * lookup through registered abstract type resolvers; will not do recursive lookups.\n     */\n    private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n        throws JsonMappingException\n    {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): ValueInstantiators\n    /**********************************************************\n     */\n\n    /**\n     * Value instantiator is created both based on creator annotations,\n     * and on optional externally provided instantiators (registered through\n     * module interface).\n     */\n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        // [JACKSON-633] Check @JsonValueInstantiator before anything else\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            /* Second: see if some of standard Jackson/JDK types might provide value\n             * instantiators.\n             */\n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        // finally: anyone want to modify ValueInstantiator?\n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                // let's do sanity check; easier to spot buggy handlers\n                if (instantiator == null) {\n                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n                }\n            }\n        }\n\n        // Sanity check: does the chosen instantatior have incomplete creators?\n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }\n\n    /**\n     * Method that will construct standard default {@link ValueInstantiator}\n     * using annotations (like @JsonCreator) and visibility rules\n     */\n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        // need to construct suitable visibility checker:\n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n         *  (which has creator parameters sprinkled around) with actual creator\n         *  declarations (which are needed to access creator annotation, amongst other things).\n         *  Easiest to combine that info first, then pass it to remaining processing.\n         */\n        /* 15-Mar-2015, tatu: Alas, this won't help with constructors that only have implicit\n         *   names. Those will need to be resolved later on.\n         */\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        /* Important: first add factory methods; then constructors, so\n         * latter can override former!\n         */\n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        // constructors only usable on concrete types:\n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { // since emptyMap is immutable need to create a 'real' one\n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n            Annotated annotated, Object instDef)\n        throws JsonMappingException\n    {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    protected void _addDeserializerConstructors\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        // First things first: the \"default constructor\" (zero-arg\n        // constructor; whether implicit or explicit) is NOT included\n        // in list of constructors, so needs to be handled separately.\n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        // may need to keep track for [#725]\n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            // some single-arg factory methods (String, number) are auto-detected\n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    // one more thing: sever link to creator property, to avoid possible later\n                    // problems with \"unresolved\" constructor property\n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                // regardless, fully handled\n                continue;\n            }\n\n            // 2 or more args; all params must have names or be injectable\n            // 14-Mar-2015, tatu (2.6): Or, as per [#725], implicit names will also\n            //   do, with some constraints. But that will require bit post processing...\n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                // One more thing: implicit names are ok iff ctor has creator annotation\n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            // Ok: if named or injectable, we have more work to do\n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                // simple case; everything covered:\n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    // Secondary: all but one injectable, one un-annotated (un-named)\n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                // otherwise, epic fail?\n                // 16-Mar-2015, tatu: due to [#725], need to be more permissive. For now let's\n                //    only report problem if there's no implicit name\n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    // Let's consider non-static inner class as a special case...\n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \"\n                                +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\");\n                    }\n                    throw new IllegalArgumentException(\"Argument #\"+ix\n                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n            // [#725]: as a fallback, all-implicit names may work as well\n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        // last option, as per [#725]: consider implicit-names-only, visible constructor,\n        // if just one found\n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            List<AnnotatedConstructor> implicitCtors) throws JsonMappingException\n    {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        // Further checks: (a) must have names for all parameters, (b) only one visible\n        // Also, since earlier matching of properties and creators relied on existence of\n        // `@JsonCreator` (or equivalent) annotation, we need to do bit more re-inspection...\n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            // as per earlier notes, only end up here if no properties associated with creator\n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                // must have name (implicit fine)\n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param, /*injectId*/ null);\n            }\n            if (found != null) { // only one allowed\n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        // found one and only one visible? Ship it!\n        if (found != null) {\n            creators.addPropertyCreator(found, /*isCreator*/ false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            // Also: add properties, to keep error messages complete wrt known properties...\n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }\n\n    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        // If explicit name, or inject id, property-based\n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        // in absence of everything else, default to delegating\n        return false;\n    }\n    \n    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n        throws JsonMappingException\n    {\n        // otherwise either 'simple' number, String, or general delegate:\n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        // Delegating Creator ok iff it has @JsonCreator (etc)\n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    protected void _addDeserializerFactoryMethods\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            // zero-arg methods must be annotated; if so, are \"default creators\" [JACKSON-850]\n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            // some single-arg factory methods (String, number) are auto-detected\n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { // not property based but delegating\n                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    // otherwise just ignored\n                    continue;\n                }\n                // fall through if there's name\n            } else {\n                // more than 2 args, must have @JsonCreator\n                if (!isCreator) {\n                    continue;\n                }\n            }\n            // 1 or more args; all params must have name annotations\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                // One more thing: implicit names are ok iff ctor has creator annotation\n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n                 *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n                 *  let's add one more work around\n                 */\n                /*\n                PropertyName name2 = _findExplicitParamName(param, intr);\n                if (name2 != null && !name2.isEmpty()) {\n                    // Hmmh. Ok, fine. So what are we to do with it... ?\n                    // For now... skip. May need to revisit this, should this become problematic\n                    continue main_loop;\n                }\n                */\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            // Ok: if named or injectable, we have more work to do\n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                // simple case; everything covered:\n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { // otherwise, epic fail\n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }\n\n    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            AnnotatedMethod factory, boolean isCreator)\n        throws JsonMappingException\n    {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method that will construct a property object that represents\n     * a logical property passed via Creator (constructor or static\n     * factory method)\n     */\n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, PropertyName name, int index,\n            AnnotatedParameter param,\n            Object injectableValueId)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                boolean req = (b != null && b.booleanValue());\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(req, desc, idx, def);\n            }\n        }\n            \n        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n        BeanProperty.Std property = new BeanProperty.Std(name, t0,\n                intr.findWrapperName(param),\n                beanDesc.getClassAnnotations(), param, metadata);\n        JavaType type = resolveType(ctxt, beanDesc, t0, param);\n        if (type != t0) {\n            property = property.withType(type);\n        }\n        // Is there an annotation that specifies exact deserializer?\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n\n        // If yes, we are mostly done:\n        type = modifyTypeByAnnotation(ctxt, param, type);\n\n        // Type deserializer: either comes from property (and already resolved)\n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        // or if not, based on type being referenced:\n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        // Note: contextualization of typeDeser _should_ occur in constructor of CreatorProperty\n        // so it is not called directly here\n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        if (deser != null) {\n            // As per [Issue#462] need to ensure we contextualize deserializer before passing it on\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }\n\n    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            // 14-Apr-2014, tatu: Need to also consider possible implicit name\n            //  (for JDK8, or via paranamer)\n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }\n\n    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }\n\n    @Deprecated // in 2.6, remove from 2.7\n    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }\n\n    @Deprecated // in 2.6, remove from 2.7\n    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            PropertyName n = intr.findNameForDeserialization(param);\n            return (n != null) && n.hasSimpleName();\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: array deserializers\n    /**********************************************************\n     */\n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n            ArrayType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        // 23-Nov-2010, tatu: Custom array deserializer?\n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Collection(-like) deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n            CollectionType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { // not defined by annotation\n                // One special type: EnumSet:\n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n        \n        /* One twist: if we are being asked to instantiate an interface or\n         * abstract Collection, we need to either find something that implements\n         * the thing, or give up.\n         *\n         * Note that we do NOT try to guess based on secondary interfaces\n         * here; that would probably not work correctly since casts would\n         * fail later on (as the primary type is not the interface we'd\n         * be implementing)\n         */\n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    // But if so, also need to re-check creators...\n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    // [Issue#161]: No default constructor for ArrayBlockingQueue...\n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n                    }\n                }\n                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n                if (contentType.getRawClass() == String.class) {\n                    // no value type deserializer because Strings are one of natural/native types:\n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)\n    {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }\n    \n    // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n            CollectionLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            // and then new with 2.2: ability to post-process it too (Issue#120)\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Map(-like) deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n            MapType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        // Then optional type info (1.5); either attached to type, or resolved separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        \n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            // Value handling is identical for all, but EnumMap requires special handling for keys\n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            // Otherwise, generic handler works ok.\n    \n            /* But there is one more twist: if we are being asked to instantiate\n             * an interface or abstract Map, we need to either find something\n             * that implements the thing, or give up.\n             *\n             * Note that we do NOT try to guess based on secondary interfaces\n             * here; that would probably not work correctly since casts would\n             * fail later on (as the primary type is not the interface we'd\n             * be implementing)\n             */\n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        // But if so, also need to re-check creators...\n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n                    md.setIgnorableProperties(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), false));\n                    deser = md;\n                }\n            }\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n            MapLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        /* !!! 24-Jan-2012, tatu: NOTE: impls MUST use resolve() to find key deserializer!\n        if (keyDes == null) {\n            keyDes = p.findKeyDeserializer(config, keyType, property);\n        }\n        */\n        // Then optional type info (1.5); either attached to type, or resolve separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            // and then new with 2.2: ability to post-process it too (Issue#120)\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Enum deserializers\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method for constructing serializers of {@link Enum} types.\n     */\n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (deser == null) {\n            // [JACKSON-193] May have @JsonCreator for static factory method:\n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    int argCount = factory.getParameterCount();\n                    if (argCount == 1) {\n                        Class<?> returnType = factory.getRawReturnType();\n                        // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                        if (returnType.isAssignableFrom(enumClass)) {\n                            deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory);\n                            break;\n                        }\n                    }\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n            // [JACKSON-749] Also, need to consider @JsonValue, if one found\n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Tree deserializers\n    /**********************************************************\n     */\n    \n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n            JavaType nodeType, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): type deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // [JACKSON-505]: May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n\n    /**\n     * Overridable method called after checking all other types.\n     * \n     * @since 2.2\n     */\n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): key deserializers\n    /**********************************************************\n     */\n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        \n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDescription beanDesc = config.introspect(type);\n        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n        }\n        Class<?> enumClass = type.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // [JACKSON-193] May have @JsonCreator for static factory method:\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getGenericParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember());\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method called to create a type information deserializer for values of\n     * given non-container property, if one is needed.\n     * If not needed (no polymorphic handling configured for property), should return null.\n     *<p>\n     * Note that this method is only called for non-container bean properties,\n     * and not for values in container types or root values (or container properties)\n     *\n     * @param baseType Declared base type of the value to deserializer (actual\n     *    deserializer type will be this type or its subtype)\n     * \n     * @return Type deserializer to use for given base type, if one is needed; null if not.\n     */\n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, AnnotatedMember annotated)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n    /**\n     * Method called to find and create a type information deserializer for values of\n     * given container (list, array, map) property, if one is needed.\n     * If not needed (no polymorphic handling configured for property), should return null.\n     *<p>\n     * Note that this method is only called for container bean properties,\n     * and not for values in container types or root values (or non-container properties)\n     * \n     * @param containerType Type of property; must be a container type\n     * @param propertyEntity Field or method that contains container property\n     */    \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config,\n            JavaType containerType, AnnotatedMember propertyEntity)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        // Defaulting: if no annotations on member, check class\n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    /**\n     * Helper method called to find one of default serializers for \"well-known\"\n     * platform types: JDK-provided types, and small number of public Jackson\n     * API types.\n     * \n     * @since 2.2\n     */\n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        // Object (\"untyped\"), String equivalents:\n        if (rawType == CLASS_OBJECT) {\n            // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.\n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        \n        if (type.isReferenceType()) {\n            JavaType referencedType = type.getReferencedType();\n            if (AtomicReference.class.isAssignableFrom(rawType)) {\n                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n                return new AtomicReferenceDeserializer(referencedType, vts, deser);\n            }\n            // Hmmh. Should we continue here for unknown referential types?\n        }\n        if (rawType == CLASS_ITERABLE) {\n            // [Issue#199]: Can and should 'upgrade' to a Collection type:\n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            // Should we re-introspect beanDesc? For now let's not...\n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            // 28-Apr-2015, tatu: TypeFactory does it all for us already so\n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        // and a few Jackson types as well:\n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, finding custom deserializers\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods, value/content/key type introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization.\n     * Returns null if no such annotation found.\n     */\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        return ctxt.deserializerInstance(ann, deserDef);\n    }\n\n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type of field, or the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n    \n    /**\n     * Helper method used to resolve method return types and field\n     * types. The main trick here is that the containing bean may\n     * have type variable binding information (when deserializing\n     * using generic type passed as type reference), which is\n     * needed in some cases.\n     */\n    protected JavaType resolveType(DeserializationContext ctxt,\n            BeanDescription beanDesc, JavaType type, AnnotatedMember member)\n        throws JsonMappingException\n    {\n        // [JACKSON-154]: Also need to handle keyUsing, contentUsing\n        if (type.isContainerType()) {\n            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }\n            // and all container types have content types...\n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n             *    information to use for polymorphic members; and specifically types for\n             *    collection values (contents).\n             *    ... but only applies to members (fields, methods), not classes\n             */\n            if (member instanceof AnnotatedMember) {\n            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n            \t        ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            \tif (contentTypeDeser != null) {\n            \t    type = type.withContentTypeHandler(contentTypeDeser);\n            \t}\n            }\n        }\n        TypeDeserializer valueTypeDeser;\n\n        if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        } else { // classes just have Jackson annotations\n            // probably only occurs if 'property' is null anyway\n            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n        }\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n        return type;\n    }\n    \n    protected EnumResolver constructEnumResolver(Class<?> enumClass,\n            DeserializationConfig config, AnnotatedMethod jsonValueMethod)\n    {\n        if (jsonValueMethod != null) {\n            Method accessor = jsonValueMethod.getAnnotated();\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(accessor);\n            }\n            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n        }\n        // [JACKSON-212]: may need to use Enum.toString()\n        if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) {\n            return EnumResolver.constructUnsafeUsingToString(enumClass);\n        }\n        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n    }\n\n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)\n    {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache", "buggy_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * We will also cache some dynamically constructed deserializers;\n     * specifically, ones that are expensive to construct.\n     * This currently means bean and Enum deserializers; starting with\n     * 2.5, container deserializers will also be cached.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * define a relatively low concurrency setting.\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n\n    /**\n     * During deserializer construction process we may need to keep track of partially\n     * completed deserializers, to resolve cyclic dependencies. This is the\n     * map used for storing deserializers before they are fully complete.\n     */\n    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public DeserializerCache() { }\n\n    /*\n    /**********************************************************\n    /* JDK serialization handling\n    /**********************************************************\n     */\n\n    Object writeReplace() {\n        // instead of making this transient, just clear it:\n        _incompleteDeserializers.clear();\n        // TODO: clear out \"cheap\" cached deserializers?\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Access to caching aspects\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to determine how many deserializers this\n     * provider is caching currently \n     * (if it does caching: default implementation does)\n     * Exact count depends on what kind of deserializers get cached;\n     * default implementation caches only dynamically constructed deserializers,\n     * but not eagerly constructed standard deserializers (which is different\n     * from how serializer provider works).\n     *<p>\n     * The main use case for this method is to allow conditional flushing of\n     * deserializer cache, if certain number of entries is reached.\n     */\n    public int cachedDeserializersCount() {\n        return _cachedDeserializers.size();\n    }\n\n    /**\n     * Method that will drop all dynamically constructed deserializers (ones that\n     * are counted as result value for {@link #cachedDeserializersCount}).\n     * This can be used to remove memory usage (in case some deserializers are\n     * only used once or so), or to force re-construction of deserializers after\n     * configuration changes for mapper than owns the provider.\n     */\n    public void flushCachedDeserializers() {\n        _cachedDeserializers.clear();       \n    }\n\n    /*\n    /**********************************************************\n    /* General deserializer locating method\n    /**********************************************************\n     */\n\n    /**\n     * Method called to get hold of a deserializer for a value of given type;\n     * or if no such deserializer can be found, a default handler (which\n     * may do a best-effort generic serialization or just simply\n     * throw an exception when invoked).\n     *<p>\n     * Note: this method is only called for value types; not for keys.\n     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n     *<p>\n     * Note also that deserializer returned is guaranteed to be resolved\n     * (if it is of type {@link ResolvableDeserializer}), but\n     * not contextualized (wrt {@link ContextualDeserializer}): caller\n     * has to handle latter if necessary.\n     *\n     * @param ctxt Deserialization context\n     * @param propertyType Declared type of the value to deserializer (obtained using\n     *   'setter' method signature and/or type annotations\n     *\n     * @throws JsonMappingException if there are fatal problems with\n     *   accessing suitable deserializer; including that of not\n     *   finding any serializer\n     */\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            // If not, need to request factory to construct (or recycle)\n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                /* Should we let caller handle it? Let's have a helper method\n                 * decide it; can throw an exception, or return a valid\n                 * deserializer\n                 */\n                deser = _handleUnknownValueDeserializer(propertyType);\n            }\n        }\n        return deser;\n    }\n\n    /**\n     * Method called to get hold of a deserializer to use for deserializing\n     * keys for {@link java.util.Map}.\n     *\n     * @throws JsonMappingException if there are fatal problems with\n     *   accessing suitable key deserializer; including that of not\n     *   finding any serializer\n     */\n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) { // if none found, need to use a placeholder that'll fail\n            return _handleUnknownKeyDeserializer(type);\n        }\n        // First: need to resolve?\n        if (kd instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) kd).resolve(ctxt);\n        }\n        return kd;\n    }\n\n    /**\n     * Method called to find out whether provider would be able to find\n     * a deserializer for given type, using a root reference (i.e. not\n     * through fields or membership in an array or collection)\n     */\n    public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Note: mostly copied from findValueDeserializer, except for\n         * handling of unknown types\n         */\n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n        }\n        return (deser != null);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods that handle cache lookups\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomValueHandler(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n    /**\n     * Method that will try to create a deserializer for given type,\n     * and resolve and cache it if necessary\n     * \n     * @param ctxt Currently active deserialization context\n     * @param type Type of property to deserialize\n     */\n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            // Or perhaps being resolved right now?\n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            // Nope: need to create and possibly cache\n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                // also: any deserializers that have been created are complete by now\n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n    /**\n     * Method that handles actual construction (via factory) and caching (both\n     * intermediate and eventual)\n     */\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            /* We better only expose checked exceptions, since those\n             * are what caller is expected to handle\n             */\n            throw new JsonMappingException(iae.getMessage(), null, iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (isResolvable) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for actual construction of deserializers\n    /**********************************************************\n     */\n    \n    /**\n     * Method that does the heavy lifting of checking for per-type annotations,\n     * find out full type, and figure out which actual factory method\n     * to call.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { // nope, just construct in normal way\n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // If not, let's see which factory method to use:\n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                MapLikeType mlt = (MapLikeType) type;\n                if (mlt.isTrueMapType()) {\n                    return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                }\n                return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n            }\n            if (type.isCollectionLikeType()) {\n                /* 03-Aug-2012, tatu: As per [Issue#40], one exception is if shape\n                 *   is to be Shape.OBJECT. Ideally we'd determine it bit later on\n                 *   (to allow custom handler checks), but that won't work for other\n                 *   reasons. So do it here.\n                 */\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization.\n     * Returns null if no such annotation found.\n     */\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        // One more thing however: may need to also apply a converter:\n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    /**\n     * Helper method that will check whether given annotated entity (usually class,\n     * but may also be a property accessor) indicates that a {@link Converter} is to\n     * be used; and if so, to construct and return suitable serializer for it.\n     * If not, will simply return given serializer as is.\n     */\n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt,\n            Annotated a, JsonDeserializer<Object> deser)\n        throws JsonMappingException\n    {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n            return deser;\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type derived from the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.4.6\n     */\n    private boolean _hasCustomValueHandler(JavaType t) {\n        if (t.isContainerType()) {\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n            }\n        }\n        return false;\n    }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n    {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable error reporting methods\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n        throws JsonMappingException\n    {\n        /* Let's try to figure out the reason, to give better error\n         * messages\n         */\n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n        }\n        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n    }\n\n    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n        throws JsonMappingException\n    {\n        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n    }\n\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * We will also cache some dynamically constructed deserializers;\n     * specifically, ones that are expensive to construct.\n     * This currently means bean and Enum deserializers; starting with\n     * 2.5, container deserializers will also be cached.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * define a relatively low concurrency setting.\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n\n    /**\n     * During deserializer construction process we may need to keep track of partially\n     * completed deserializers, to resolve cyclic dependencies. This is the\n     * map used for storing deserializers before they are fully complete.\n     */\n    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public DeserializerCache() { }\n\n    /*\n    /**********************************************************\n    /* JDK serialization handling\n    /**********************************************************\n     */\n\n    Object writeReplace() {\n        // instead of making this transient, just clear it:\n        _incompleteDeserializers.clear();\n        // TODO: clear out \"cheap\" cached deserializers?\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Access to caching aspects\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to determine how many deserializers this\n     * provider is caching currently \n     * (if it does caching: default implementation does)\n     * Exact count depends on what kind of deserializers get cached;\n     * default implementation caches only dynamically constructed deserializers,\n     * but not eagerly constructed standard deserializers (which is different\n     * from how serializer provider works).\n     *<p>\n     * The main use case for this method is to allow conditional flushing of\n     * deserializer cache, if certain number of entries is reached.\n     */\n    public int cachedDeserializersCount() {\n        return _cachedDeserializers.size();\n    }\n\n    /**\n     * Method that will drop all dynamically constructed deserializers (ones that\n     * are counted as result value for {@link #cachedDeserializersCount}).\n     * This can be used to remove memory usage (in case some deserializers are\n     * only used once or so), or to force re-construction of deserializers after\n     * configuration changes for mapper than owns the provider.\n     */\n    public void flushCachedDeserializers() {\n        _cachedDeserializers.clear();       \n    }\n\n    /*\n    /**********************************************************\n    /* General deserializer locating method\n    /**********************************************************\n     */\n\n    /**\n     * Method called to get hold of a deserializer for a value of given type;\n     * or if no such deserializer can be found, a default handler (which\n     * may do a best-effort generic serialization or just simply\n     * throw an exception when invoked).\n     *<p>\n     * Note: this method is only called for value types; not for keys.\n     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n     *<p>\n     * Note also that deserializer returned is guaranteed to be resolved\n     * (if it is of type {@link ResolvableDeserializer}), but\n     * not contextualized (wrt {@link ContextualDeserializer}): caller\n     * has to handle latter if necessary.\n     *\n     * @param ctxt Deserialization context\n     * @param propertyType Declared type of the value to deserializer (obtained using\n     *   'setter' method signature and/or type annotations\n     *\n     * @throws JsonMappingException if there are fatal problems with\n     *   accessing suitable deserializer; including that of not\n     *   finding any serializer\n     */\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            // If not, need to request factory to construct (or recycle)\n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                /* Should we let caller handle it? Let's have a helper method\n                 * decide it; can throw an exception, or return a valid\n                 * deserializer\n                 */\n                deser = _handleUnknownValueDeserializer(propertyType);\n            }\n        }\n        return deser;\n    }\n\n    /**\n     * Method called to get hold of a deserializer to use for deserializing\n     * keys for {@link java.util.Map}.\n     *\n     * @throws JsonMappingException if there are fatal problems with\n     *   accessing suitable key deserializer; including that of not\n     *   finding any serializer\n     */\n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) { // if none found, need to use a placeholder that'll fail\n            return _handleUnknownKeyDeserializer(type);\n        }\n        // First: need to resolve?\n        if (kd instanceof ResolvableDeserializer) {\n            ((ResolvableDeserializer) kd).resolve(ctxt);\n        }\n        return kd;\n    }\n\n    /**\n     * Method called to find out whether provider would be able to find\n     * a deserializer for given type, using a root reference (i.e. not\n     * through fields or membership in an array or collection)\n     */\n    public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Note: mostly copied from findValueDeserializer, except for\n         * handling of unknown types\n         */\n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n        }\n        return (deser != null);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods that handle cache lookups\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomValueHandler(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n    /**\n     * Method that will try to create a deserializer for given type,\n     * and resolve and cache it if necessary\n     * \n     * @param ctxt Currently active deserialization context\n     * @param type Type of property to deserialize\n     */\n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            // Or perhaps being resolved right now?\n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            // Nope: need to create and possibly cache\n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                // also: any deserializers that have been created are complete by now\n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n    /**\n     * Method that handles actual construction (via factory) and caching (both\n     * intermediate and eventual)\n     */\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            /* We better only expose checked exceptions, since those\n             * are what caller is expected to handle\n             */\n            throw new JsonMappingException(iae.getMessage(), null, iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (isResolvable) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for actual construction of deserializers\n    /**********************************************************\n     */\n    \n    /**\n     * Method that does the heavy lifting of checking for per-type annotations,\n     * find out full type, and figure out which actual factory method\n     * to call.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { // nope, just construct in normal way\n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // If not, let's see which factory method to use:\n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                MapLikeType mlt = (MapLikeType) type;\n                if (mlt.isTrueMapType()) {\n                    return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                }\n                return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n            }\n            if (type.isCollectionLikeType()) {\n                /* 03-Aug-2012, tatu: As per [Issue#40], one exception is if shape\n                 *   is to be Shape.OBJECT. Ideally we'd determine it bit later on\n                 *   (to allow custom handler checks), but that won't work for other\n                 *   reasons. So do it here.\n                 */\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization.\n     * Returns null if no such annotation found.\n     */\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        // One more thing however: may need to also apply a converter:\n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    /**\n     * Helper method that will check whether given annotated entity (usually class,\n     * but may also be a property accessor) indicates that a {@link Converter} is to\n     * be used; and if so, to construct and return suitable serializer for it.\n     * If not, will simply return given serializer as is.\n     */\n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt,\n            Annotated a, JsonDeserializer<Object> deser)\n        throws JsonMappingException\n    {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n            return deser;\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n            return null;\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type derived from the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.4.6\n     */\n    private boolean _hasCustomValueHandler(JavaType t) {\n        if (t.isContainerType()) {\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n            }\n        }\n        return false;\n    }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n    {\n        if (src == null) {\n            return null;\n        }\n        if (!(src instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n        }\n        Class<?> cls = (Class<?>) src;\n        if (cls == noneClass || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable error reporting methods\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n        throws JsonMappingException\n    {\n        /* Let's try to figure out the reason, to give better error\n         * messages\n         */\n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n        }\n        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n    }\n\n    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n        throws JsonMappingException\n    {\n        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n    }\n\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase", "buggy_version": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    \n    protected final TypeIdResolver _idResolver;\n    \n    protected final JavaType _baseType;\n\n    /**\n     * Property that contains value for which type information\n     * is included; null if value is a root value.\n     * Note that this value is not assigned during construction\n     * but only when {@link #forProperty} is called to create\n     * a copy.\n     */\n    protected final BeanProperty _property;\n\n    /**\n     * Type to use as the default implementation, if type id is\n     * missing or can not be resolved.\n     */\n    protected final JavaType _defaultImpl;\n\n    /**\n     * Name of type property used; needed for non-property versions too,\n     * in cases where type id is to be exposed as part of JSON.\n     */\n    protected final String _typePropertyName;\n    \n    protected final boolean _typeIdVisible;\n    \n    /**\n     * For efficient operation we will lazily build mappings from type ids\n     * to actual deserializers, once needed.\n     */\n    protected final Map<String,JsonDeserializer<Object>> _deserializers;\n\n    protected JsonDeserializer<Object> _defaultImplDeserializer;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n    {\n        _baseType = baseType;\n        _idResolver = idRes;\n        _typePropertyName = typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        // defaults are fine, although concurrency of 4 bit more frugal than 16:\n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);\n        if (defaultImpl == null) {\n            _defaultImpl = null;\n        } else {\n            /* 16-Oct-2011, tatu: should call this via TypeFactory; this is\n             *    not entirely safe... however, since Collections/Maps are\n             *    seldom (if ever) base types, may be ok.\n             */\n            _defaultImpl = baseType.forcedNarrowBy(defaultImpl);\n        }\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)\n    {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop);\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n    \n    @Override\n    public abstract JsonTypeInfo.As getTypeInclusion();\n\n    public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    type = _baseType.narrowBy(type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException\n    {\n        /* 06-Feb-2013, tatu: As per [Issue#148], consider default implementation value of\n         *   {@link java.lang.Void} to mean \"serialize as null\"; as well as DeserializationFeature\n         *   to do swift mapping to null\n         */\n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids. Assumption from there is that only native\n     * type ids are to be used.\n     * \n     * @since 2.3\n     */\n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids, and such type id has been found.\n     * \n     * @since 2.4\n     */\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            /* 04-May-2014, tatu: Should error be obligatory, or should there be another method\n             *   for \"try to deserialize with native tpye id\"?\n             */\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n            }\n        } else {\n            String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);\n            deser = _findDeserializer(ctxt, typeIdStr);\n        }\n        return deser.deserialize(jp, ctxt);\n    }\n\n    /**\n     * Helper method called when given type id can not be resolved into \n     * concrete deserializer either directly (using given {@link  TypeIdResolver}),\n     * or using default type.\n     * Default implementation simply throws a {@link com.fasterxml.jackson.databind.JsonMappingException} to\n     * indicate the problem; sub-classes may choose\n     *\n     * @return If it is possible to resolve type id into a {@link JsonDeserializer}\n     *   should return that deserializer; otherwise throw an exception to indicate\n     *   the problem.\n     *\n     * @since 2.5\n     */\n    protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n            TypeIdResolver idResolver, JavaType baseType)\n        throws IOException\n    {\n        String extraDesc;\n        if (idResolver instanceof TypeIdResolverBase) {\n            extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();\n            if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    \n    protected final TypeIdResolver _idResolver;\n    \n    protected final JavaType _baseType;\n\n    /**\n     * Property that contains value for which type information\n     * is included; null if value is a root value.\n     * Note that this value is not assigned during construction\n     * but only when {@link #forProperty} is called to create\n     * a copy.\n     */\n    protected final BeanProperty _property;\n\n    /**\n     * Type to use as the default implementation, if type id is\n     * missing or can not be resolved.\n     */\n    protected final JavaType _defaultImpl;\n\n    /**\n     * Name of type property used; needed for non-property versions too,\n     * in cases where type id is to be exposed as part of JSON.\n     */\n    protected final String _typePropertyName;\n    \n    protected final boolean _typeIdVisible;\n    \n    /**\n     * For efficient operation we will lazily build mappings from type ids\n     * to actual deserializers, once needed.\n     */\n    protected final Map<String,JsonDeserializer<Object>> _deserializers;\n\n    protected JsonDeserializer<Object> _defaultImplDeserializer;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n    {\n        _baseType = baseType;\n        _idResolver = idRes;\n        _typePropertyName = typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        // defaults are fine, although concurrency of 4 bit more frugal than 16:\n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);\n        if (defaultImpl == null) {\n            _defaultImpl = null;\n        } else {\n            /* 16-Oct-2011, tatu: should call this via TypeFactory; this is\n             *    not entirely safe... however, since Collections/Maps are\n             *    seldom (if ever) base types, may be ok.\n             */\n            _defaultImpl = baseType.forcedNarrowBy(defaultImpl);\n        }\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)\n    {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop);\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n    \n    @Override\n    public abstract JsonTypeInfo.As getTypeInclusion();\n\n    public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException\n    {\n        /* 06-Feb-2013, tatu: As per [Issue#148], consider default implementation value of\n         *   {@link java.lang.Void} to mean \"serialize as null\"; as well as DeserializationFeature\n         *   to do swift mapping to null\n         */\n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids. Assumption from there is that only native\n     * type ids are to be used.\n     * \n     * @since 2.3\n     */\n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids, and such type id has been found.\n     * \n     * @since 2.4\n     */\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            /* 04-May-2014, tatu: Should error be obligatory, or should there be another method\n             *   for \"try to deserialize with native tpye id\"?\n             */\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n            }\n        } else {\n            String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);\n            deser = _findDeserializer(ctxt, typeIdStr);\n        }\n        return deser.deserialize(jp, ctxt);\n    }\n\n    /**\n     * Helper method called when given type id can not be resolved into \n     * concrete deserializer either directly (using given {@link  TypeIdResolver}),\n     * or using default type.\n     * Default implementation simply throws a {@link com.fasterxml.jackson.databind.JsonMappingException} to\n     * indicate the problem; sub-classes may choose\n     *\n     * @return If it is possible to resolve type id into a {@link JsonDeserializer}\n     *   should return that deserializer; otherwise throw an exception to indicate\n     *   the problem.\n     *\n     * @since 2.5\n     */\n    protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n            TypeIdResolver idResolver, JavaType baseType)\n        throws IOException\n    {\n        String extraDesc;\n        if (idResolver instanceof TypeIdResolverBase) {\n            extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();\n            if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.module.SimpleAbstractTypeResolver", "buggy_version": "package com.fasterxml.jackson.databind.module;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\n\nimport com.fasterxml.jackson.databind.AbstractTypeResolver;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.ClassKey;\n\n/**\n * Simple {@link AbstractTypeResolver} implementation, which is\n * based on static mapping from abstract super types into\n * sub types (concrete or abstract), but retaining generic\n * parameterization.\n * Can be used for things like specifying which implementation of\n * {@link java.util.Collection} to use:\n *<pre>\n *  SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver();\n *  // To make all properties declared as Collection, List, to LinkedList\n *  resolver.addMapping(Collection.class, LinkedList.class);\n *  resolver.addMapping(List.class, LinkedList.class);\n *</pre>\n * Can also be used as an alternative to per-class annotations when defining\n * concrete implementations; however, only works with abstract types (since\n * this is only called for abstract types)\n */\npublic class SimpleAbstractTypeResolver\n    extends AbstractTypeResolver\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 8635483102371490919L;\n\n    /**\n     * Mappings from super types to subtypes\n     */\n    protected final HashMap<ClassKey,Class<?>> _mappings = new HashMap<ClassKey,Class<?>>();\n\n    /**\n     * Method for adding a mapping from super type to specific subtype.\n     * Arguments will be checked by method, to ensure that <code>superType</code>\n     * is abstract (since resolver is never called for concrete classes);\n     * as well as to ensure that there is supertype/subtype relationship\n     * (to ensure there won't be cycles during resolution).\n     * \n     * @param superType Abstract type to resolve\n     * @param subType Sub-class of superType, to map superTo to\n     * \n     * @return This resolver, to allow chaining of initializations\n     */\n    public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType)\n    {\n        // Sanity checks, just in case someone tries to force typing...\n        if (superType == subType) {\n            throw new IllegalArgumentException(\"Can not add mapping from class to itself\");\n        }\n        if (!superType.isAssignableFrom(subType)) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" to \"+subType.getName()+\", as latter is not a subtype of former\");\n        }\n        if (!Modifier.isAbstract(superType.getModifiers())) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" since it is not abstract\");\n        }\n        _mappings.put(new ClassKey(superType), subType);\n        return this;\n    }\n\n    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n    {\n        // this is the main mapping base, so let's \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n        return type.narrowBy(dst);\n    }\n\n    \n    @Override\n    public JavaType resolveAbstractType(DeserializationConfig config, JavaType type)\n    {\n        // never materialize anything, so:\n        return null;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.module;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\n\nimport com.fasterxml.jackson.databind.AbstractTypeResolver;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.ClassKey;\n\n/**\n * Simple {@link AbstractTypeResolver} implementation, which is\n * based on static mapping from abstract super types into\n * sub types (concrete or abstract), but retaining generic\n * parameterization.\n * Can be used for things like specifying which implementation of\n * {@link java.util.Collection} to use:\n *<pre>\n *  SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver();\n *  // To make all properties declared as Collection, List, to LinkedList\n *  resolver.addMapping(Collection.class, LinkedList.class);\n *  resolver.addMapping(List.class, LinkedList.class);\n *</pre>\n * Can also be used as an alternative to per-class annotations when defining\n * concrete implementations; however, only works with abstract types (since\n * this is only called for abstract types)\n */\npublic class SimpleAbstractTypeResolver\n    extends AbstractTypeResolver\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 8635483102371490919L;\n\n    /**\n     * Mappings from super types to subtypes\n     */\n    protected final HashMap<ClassKey,Class<?>> _mappings = new HashMap<ClassKey,Class<?>>();\n\n    /**\n     * Method for adding a mapping from super type to specific subtype.\n     * Arguments will be checked by method, to ensure that <code>superType</code>\n     * is abstract (since resolver is never called for concrete classes);\n     * as well as to ensure that there is supertype/subtype relationship\n     * (to ensure there won't be cycles during resolution).\n     * \n     * @param superType Abstract type to resolve\n     * @param subType Sub-class of superType, to map superTo to\n     * \n     * @return This resolver, to allow chaining of initializations\n     */\n    public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType)\n    {\n        // Sanity checks, just in case someone tries to force typing...\n        if (superType == subType) {\n            throw new IllegalArgumentException(\"Can not add mapping from class to itself\");\n        }\n        if (!superType.isAssignableFrom(subType)) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" to \"+subType.getName()+\", as latter is not a subtype of former\");\n        }\n        if (!Modifier.isAbstract(superType.getModifiers())) {\n            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n                    +\" since it is not abstract\");\n        }\n        _mappings.put(new ClassKey(superType), subType);\n        return this;\n    }\n\n    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n    {\n        // this is the main mapping base, so let's \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n        return config.getTypeFactory().constructSpecializedType(type, dst);\n    }\n\n    \n    @Override\n    public JavaType resolveAbstractType(DeserializationConfig config, JavaType type)\n    {\n        // never materialize anything, so:\n        return null;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 26, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.BeanPropertyWriter", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.SerializableString;\nimport com.fasterxml.jackson.core.io.SerializedString;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\n@JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\npublic class BeanPropertyWriter extends PropertyWriter\n    implements BeanProperty\n{\n    // as of 2.6.2\n\n    /**\n     * Marker object used to indicate \"do not serialize if empty\"\n     */\n    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n\n    /**\n     * Marker we use to indicate case where we have done format lookup,\n     * but found nothing; marker used to avoid having to repeat such lookups.\n     *\n     * @since 2.6\n     */\n    protected final static JsonFormat.Value NO_FORMAT = new JsonFormat.Value();\n\n    /*\n    /**********************************************************\n    /* Basic property metadata: name, type, other\n    /**********************************************************\n     */\n\n    /**\n     * Logical name of the property; will be used as the field name\n     * under which value for the property is written.\n     *<p>\n     * NOTE: do NOT change name of this field; it is accessed by\n     * Afterburner module (until 2.4; not directly from 2.5)\n     * ALSO NOTE: ... and while it really ought to be `SerializableString`,\n     * changing that is also binary-incompatible change. So nope.\n     */\n    protected final SerializedString _name;\n\n    /**\n     * Wrapper name to use for this element, if any\n     * \n     * @since 2.2\n     */\n    protected final PropertyName _wrapperName;\n\n    /**\n     * Type property is declared to have, either in class definition \n     * or associated annotations.\n     */\n    protected final JavaType _declaredType;\n\n    /**\n     * Type to use for locating serializer; normally same as return\n     * type of the accessor method, but may be overridden by annotations.\n     */\n    protected final JavaType _cfgSerializationType;\n\n    /**\n     * Base type of the property, if the declared type is \"non-trivial\";\n     * meaning it is either a structured type (collection, map, array),\n     * or parameterized. Used to retain type information about contained\n     * type, which is mostly necessary if type meta-data is to be\n     * included.\n     */\n    protected JavaType _nonTrivialBaseType;\n\n    /**\n     * Annotations from context (most often, class that declares property,\n     * or in case of sub-class serializer, from that sub-class)\n     *<p>\n     * NOTE: transient just to support JDK serializability; Annotations\n     * do not serialize. At all.\n     */\n    protected final transient Annotations _contextAnnotations;\n    \n    /**\n     * Additional information about property\n     *\n     * @since 2.3\n     */\n    protected final PropertyMetadata _metadata;\n\n    /**\n     * Lazily accessed value for per-property format override definition.\n     * \n     * @since 2.6\n     */\n    protected transient JsonFormat.Value _format;\n\n    /*\n    /**********************************************************\n    /* Settings for accessing property value to serialize\n    /**********************************************************\n     */\n\n    /**\n     * Member (field, method) that represents property and allows access\n     * to associated annotations.\n     */\n    protected final AnnotatedMember _member;\n    \n    /**\n     * Accessor method used to get property value, for\n     * method-accessible properties.\n     * Null if and only if {@link #_field} is null.\n     *<p>\n     * `transient` (and non-final) only to support JDK serializability.\n     */\n    protected transient Method _accessorMethod;\n    \n    /**\n     * Field that contains the property value for field-accessible\n     * properties.\n     * Null if and only if {@link #_accessorMethod} is null.\n     *<p>\n     * `transient` (and non-final) only to support JDK serializability.\n     */\n    protected transient Field _field;\n\n    /*\n    /**********************************************************\n    /* Serializers needed\n    /**********************************************************\n     */\n\n    /**\n     * Serializer to use for writing out the value: null if it can not\n     * be known statically; non-null if it can.\n     */\n    protected JsonSerializer<Object> _serializer;\n\n    /**\n     * Serializer used for writing out null values, if any: if null,\n     * null values are to be suppressed.\n     */\n    protected JsonSerializer<Object> _nullSerializer;\n\n    /**\n     * If property being serialized needs type information to be\n     * included this is the type serializer to use.\n     * Declared type (possibly augmented with annotations) of property\n     * is used for determining exact mechanism to use (compared to\n     * actual runtime type used for serializing actual state).\n     */\n    protected TypeSerializer _typeSerializer;\n\n    /**\n     * In case serializer is not known statically (i.e. <code>_serializer</code>\n     * is null), we will use a lookup structure for storing dynamically\n     * resolved mapping from type(s) to serializer(s).\n     */\n    protected transient PropertySerializerMap _dynamicSerializers;\n\n    /*\n    /**********************************************************\n    /* Filtering\n    /**********************************************************\n     */\n\n    /**\n     * Whether null values are to be suppressed (nothing written out if\n     * value is null) or not. Note that this is a configuration value\n     * during construction, and actual handling relies on setting\n     * (or not) of {@link #_nullSerializer}.\n     */\n    protected final boolean _suppressNulls;\n\n    /**\n     * Value that is considered default value of the property; used for\n     * default-value-suppression if enabled.\n     */\n    protected final Object _suppressableValue;\n\n    /**\n     * Alternate set of property writers used when view-based filtering\n     * is available for the Bean.\n     */\n    protected final Class<?>[] _includeInViews;\n\n    /*\n    /**********************************************************\n    /* Opaque internal data that bean serializer factory and\n    /* bean serializers can add.\n    /**********************************************************\n     */\n\n    protected transient HashMap<Object,Object> _internalSettings;\n\n    /*\n    /**********************************************************\n    /* Construction, configuration\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public BeanPropertyWriter(BeanPropertyDefinition propDef,\n            AnnotatedMember member, Annotations contextAnnotations,\n            JavaType declaredType,\n            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n            boolean suppressNulls, Object suppressableValue)\n    {\n        _member = member;\n        _contextAnnotations = contextAnnotations;\n\n        _name = new SerializedString(propDef.getName());\n        _wrapperName = propDef.getWrapperName();\n        _metadata = propDef.getMetadata();\n        _includeInViews = propDef.findViews();\n\n        _declaredType = declaredType;\n        _serializer = (JsonSerializer<Object>) ser;\n        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyForProperties() : null;\n        _typeSerializer = typeSer;\n        _cfgSerializationType = serType;\n\n        if (member instanceof AnnotatedField) {\n            _accessorMethod = null;\n            _field = (Field) member.getMember();\n        } else if (member instanceof AnnotatedMethod) {\n            _accessorMethod = (Method) member.getMember();\n            _field = null;\n        } else {\n            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed for virtual props\n            _accessorMethod = null;\n            _field = null;\n        }\n        _suppressNulls = suppressNulls;\n        _suppressableValue = suppressableValue;\n\n        // this will be resolved later on, unless nulls are to be suppressed\n        _nullSerializer = null;\n    }\n\n    /**\n     * Constructor that may be of use to virtual properties, when there is need for\n     * the zero-arg (\"default\") constructor, and actual initialization is done\n     * after constructor call.\n     * \n     * @since 2.5\n     */\n    protected BeanPropertyWriter() {\n        _member = null;\n        _contextAnnotations = null;\n\n        _name = null;\n        _wrapperName = null;\n        _metadata = null;\n        _includeInViews = null;\n\n        _declaredType = null;\n        _serializer = null;\n        _dynamicSerializers = null;\n        _typeSerializer = null;\n        _cfgSerializationType = null;\n\n        _accessorMethod = null;\n        _field = null;\n        _suppressNulls = false;\n        _suppressableValue = null;\n\n        _nullSerializer = null;\n    }\n\n    /**\n     * \"Copy constructor\" to be used by filtering sub-classes\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base) {\n        this(base, base._name);\n    }\n\n    /**\n     * @since 2.5\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base, PropertyName name)\n    {\n        /* 02-Dec-2014, tatu: This is a big mess, alas, what with dependency\n         *   to MapperConfig to encode, and Afterburner having heartburn\n         *   for SerializableString (vs SerializedString).\n         *   Hope it can be resolved/reworked in 2.6 timeframe, if not for 2.5\n         */\n        _name = new SerializedString(name.getSimpleName());\n        _wrapperName = base._wrapperName;\n\n        _contextAnnotations = base._contextAnnotations;\n        _declaredType = base._declaredType;\n\n        _member = base._member;\n        _accessorMethod = base._accessorMethod;\n        _field = base._field;\n\n        _serializer = base._serializer;\n        _nullSerializer = base._nullSerializer;\n        // one more thing: copy internal settings, if any (since 1.7)\n        if (base._internalSettings != null) {\n            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n        }\n        _cfgSerializationType = base._cfgSerializationType;\n        _dynamicSerializers = base._dynamicSerializers;\n        _suppressNulls = base._suppressNulls;\n        _suppressableValue = base._suppressableValue;\n        _includeInViews = base._includeInViews;\n        _typeSerializer = base._typeSerializer;\n        _nonTrivialBaseType = base._nonTrivialBaseType;\n        _metadata = base._metadata;\n    }\n\n    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n        _name = name;\n        _wrapperName = base._wrapperName;\n\n        _member = base._member;\n        _contextAnnotations = base._contextAnnotations;\n        _declaredType = base._declaredType;\n        _accessorMethod = base._accessorMethod;\n        _field = base._field;\n        _serializer = base._serializer;\n        _nullSerializer = base._nullSerializer;\n        if (base._internalSettings != null) {\n            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n        }\n        _cfgSerializationType = base._cfgSerializationType;\n        _dynamicSerializers = base._dynamicSerializers;\n        _suppressNulls = base._suppressNulls;\n        _suppressableValue = base._suppressableValue;\n        _includeInViews = base._includeInViews;\n        _typeSerializer = base._typeSerializer;\n        _nonTrivialBaseType = base._nonTrivialBaseType;\n        _metadata = base._metadata;\n    }\n\n    public BeanPropertyWriter rename(NameTransformer transformer) {\n        String newName = transformer.transform(_name.getValue());\n        if (newName.equals(_name.toString())) {\n            return this;\n        }\n        return _new(PropertyName.construct(newName));\n    }\n\n    /**\n     * Overridable factory method used by sub-classes\n     *\n     * @since 2.6.0\n     */\n    protected BeanPropertyWriter _new(PropertyName newName) {\n        return new BeanPropertyWriter(this, newName);\n    }\n\n    /**\n     * Method called to set, reset or clear the configured type serializer\n     * for property.\n     *\n     * @since 2.6\n     */\n    public void assignTypeSerializer(TypeSerializer typeSer) {\n        _typeSerializer = typeSer;\n    }\n\n    /**\n     * Method called to assign value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignSerializer(JsonSerializer<Object> ser) {\n        // may need to disable check in future?\n        if (_serializer != null && _serializer != ser) {\n            throw new IllegalStateException(\"Can not override serializer\");\n        }\n        _serializer = ser;\n    }\n\n    /**\n     * Method called to assign null value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignNullSerializer(JsonSerializer<Object> nullSer) {\n        // may need to disable check in future?\n        if (_nullSerializer != null && _nullSerializer != nullSer) {\n            throw new IllegalStateException(\"Can not override null serializer\");\n        }\n        _nullSerializer = nullSer;\n    }\n\n    /**\n     * Method called create an instance that handles details of unwrapping\n     * contained value.\n     */\n    public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) {\n        return new UnwrappingBeanPropertyWriter(this, unwrapper);\n    }\n\n    /**\n     * Method called to define type to consider as \"non-trivial\" basetype,\n     * needed for dynamic serialization resolution for complex (usually container)\n     * types\n     */\n    public void setNonTrivialBaseType(JavaType t) {\n        _nonTrivialBaseType = t;\n    }\n\n    /*\n    /**********************************************************\n    /* JDK Serializability\n    /**********************************************************\n     */\n\n    /* Ideally would not require mutable state, and instead would re-create with\n     * final settings. However, as things are, with sub-types and all, simplest\n     * to just change Field/Method value directly.\n     */\n    Object readResolve() {\n        if (_member instanceof AnnotatedField) {\n            _accessorMethod = null;\n            _field = (Field) _member.getMember();\n        } else if (_member instanceof AnnotatedMethod) {\n            _accessorMethod = (Method) _member.getMember();\n            _field = null;\n        }\n        if (_serializer == null) {\n            _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* BeanProperty impl\n    /**********************************************************\n     */\n\n    // Note: also part of 'PropertyWriter'\n    @Override public String getName() { return _name.getValue(); }\n\n    // Note: also part of 'PropertyWriter'\n    @Override public PropertyName getFullName() { // !!! TODO: impl properly\n        return new PropertyName(_name.getValue());\n    }\n\n    @Override public JavaType getType() { return _declaredType; }\n    @Override public PropertyName getWrapperName() { return _wrapperName; }\n    @Override public boolean isRequired() { return _metadata.isRequired(); }\n    @Override public PropertyMetadata getMetadata() { return _metadata; }\n\n    // Note: also part of 'PropertyWriter'\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return (_member == null) ? null : _member.getAnnotation(acls);\n    }\n\n    // Note: also part of 'PropertyWriter'\n    @Override\n    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n    }\n    \n    @Override\n    public JsonFormat.Value findFormatOverrides(AnnotationIntrospector intr) {\n        JsonFormat.Value f = _format;\n        if (f == null) { // not yet looked up, do that\n            f = ((intr == null) || (_member == null)) ? null\n                    : intr.findFormat(_member);\n            _format = (f == null) ? NO_FORMAT : f;\n        }\n        return (f == NO_FORMAT) ? null : f;\n    }\n\n    @Override public AnnotatedMember getMember() { return _member; }\n\n    // @since 2.3 -- needed so it can be overridden by unwrapping writer\n    protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode) {\n        propertiesNode.set(getName(), schemaNode);\n    }\n\n    /**\n     * Note: will be defined in {@link BeanProperty}; as of now is not yet.\n     *<p>\n     * TODO: move to {@link BeanProperty} in near future, once all standard\n     * implementations define it.\n     * \n     * @since 2.5\n     */\n    public boolean isVirtual() { return false; }\n    \n    /*\n    /**********************************************************\n    /* Managing and accessing of opaque internal settings\n    /* (used by extensions)\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value of specified internal setting.\n     * \n     * @return Value of the setting, if any; null if none.\n     */\n    public Object getInternalSetting(Object key)  {\n        return (_internalSettings == null) ? null : _internalSettings.get(key);\n    }\n    \n    /**\n     * Method for setting specific internal setting to given value\n     * \n     * @return Old value of the setting, if any (null if none)\n     */\n    public Object setInternalSetting(Object key, Object value) {\n        if (_internalSettings == null) {\n            _internalSettings = new HashMap<Object,Object>();\n        }\n        return _internalSettings.put(key, value);\n    }\n\n    /**\n     * Method for removing entry for specified internal setting.\n     * \n     * @return Existing value of the setting, if any (null if none)\n     */\n    public Object removeInternalSetting(Object key) {\n        Object removed = null;\n        if (_internalSettings != null) {\n            removed = _internalSettings.remove(key);\n            // to reduce memory usage, let's also drop the Map itself, if empty\n            if (_internalSettings.size() == 0) {\n                _internalSettings = null;\n            }\n        }\n        return removed;\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    public SerializableString getSerializedName() { return _name; }\n    \n    public boolean hasSerializer() { return _serializer != null; }\n    public boolean hasNullSerializer() { return _nullSerializer != null; }\n\n    /**\n     * @since 2.6\n     */\n    public TypeSerializer getTypeSerializer() { return _typeSerializer; }\n\n    /**\n     * Accessor that will return true if this bean property has to support\n     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n     *<p>\n     * Default implementation simply returns false.\n     * \n     * @since 2.3\n     */\n    public boolean isUnwrapping() { return false; }\n    \n    public boolean willSuppressNulls() { return _suppressNulls; }\n\n    /**\n     * Method called to check to see if this property has a name that would\n     * conflict with a given name.\n     *\n     * @since 2.6\n     */\n    public boolean wouldConflictWithName(PropertyName name) {\n        if (_wrapperName != null) {\n            return _wrapperName.equals(name);\n        }\n        // Bit convoluted since our support for namespaces is spotty but:\n        return name.hasSimpleName(_name.getValue())\n                && !name.hasNamespace();\n    }\n    \n    // Needed by BeanSerializer#getSchema\n    public JsonSerializer<Object> getSerializer() { return _serializer; }\n\n    public JavaType getSerializationType() { return _cfgSerializationType; }\n\n    public Class<?> getRawSerializationType() {\n        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n    }\n    \n    public Class<?> getPropertyType() {\n        return (_accessorMethod != null) ? _accessorMethod.getReturnType() : _field.getType();\n    }\n\n    /**\n     * Get the generic property type of this property writer.\n     *\n     * @return The property type, or null if not found.\n     */\n    public Type getGenericPropertyType() {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getGenericReturnType();\n        }\n        if (_field != null) {\n            return _field.getGenericType();\n        }\n        return null;\n    }\n\n    public Class<?>[] getViews() { return _includeInViews; }\n\n    /*\n    /**********************************************************\n    /* PropertyWriter methods (serialization)\n    /**********************************************************\n     */\n\n    /**\n     * Method called to access property that this bean stands for, from\n     * within given bean, and to serialize it as a JSON Object field\n     * using appropriate serializer.\n     */\n    @Override\n    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n    {\n        // inlined 'get()'\n        final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n\n        // Null handling is bit different, check that first\n        if (value == null) {\n            if (_nullSerializer != null) {\n                gen.writeFieldName(_name);\n                _nullSerializer.serialize(null, gen, prov);\n            }\n            return;\n        }\n        // then find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap m = _dynamicSerializers;\n            ser = m.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(m, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(prov, value)) {\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) {\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            // three choices: exception; handled by call; or pass-through\n            if (_handleSelfReference(bean, gen, prov, ser)) {\n                return;\n            }\n        }\n        gen.writeFieldName(_name);\n        if (_typeSerializer == null) {\n            ser.serialize(value, gen, prov);\n        } else {\n            ser.serializeWithType(value, gen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to indicate that serialization of a field was omitted\n     * due to filtering, in cases where backend data format does not allow\n     * basic omission.\n     * \n     * @since 2.3\n     */\n    @Override\n    public void serializeAsOmittedField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n    {\n        if (!gen.canOmitFields()) {\n            gen.writeOmittedField(_name.getValue());\n        }\n    }\n    \n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.3\n     */\n    @Override\n    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n        throws Exception\n    {\n        // inlined 'get()'\n        final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, gen, prov);\n            } else { // can NOT suppress entries in tabular output\n                gen.writeNull();\n            }\n            return;\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(prov, value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, gen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, gen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            if (_handleSelfReference(bean, gen, prov, ser)) {\n                return;\n            }\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, gen, prov);\n        } else {\n            ser.serializeWithType(value, gen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to serialize a placeholder used in tabular output when\n     * real value is not to be included (is filtered out), but when we need\n     * an entry so that field indexes will not be off. Typically this should\n     * output null or empty String, depending on datatype.\n     * \n     * @since 2.1\n     */\n    @Override\n    public void serializeAsPlaceholder(Object bean, JsonGenerator gen, SerializerProvider prov)\n        throws Exception\n    {\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, gen, prov);\n        } else {\n            gen.writeNull();\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* PropertyWriter methods (schema generation)\n    /**********************************************************\n     */\n\n    // Also part of BeanProperty implementation\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor v)\n        throws JsonMappingException\n    {\n        if (v != null) {\n            if (isRequired()) {\n                v.property(this); \n            } else {\n                v.optionalProperty(this);\n            }\n        }\n    }\n\n    // // // Legacy support for JsonFormatVisitable\n\n    /**\n     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n     * \n     * @param propertiesNode Node which the given property would exist within\n     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n     *  processing\n     */\n    @Override\n    @Deprecated\n    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n        throws JsonMappingException\n    {\n        JavaType propType = getSerializationType();\n        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n        JsonNode schemaNode;\n        // Maybe it already has annotated/statically configured serializer?\n        JsonSerializer<Object> ser = getSerializer();\n        if (ser == null) { // nope\n            ser = provider.findValueSerializer(getType(), this);\n        }\n        boolean isOptional = !isRequired();\n        if (ser instanceof SchemaAware) {\n            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n        } else {  \n            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n        }\n        _depositSchemaProperty(propertiesNode, schemaNode);\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n            Class<?> type, SerializerProvider provider) throws JsonMappingException\n    {\n        PropertySerializerMap.SerializerAndMapResult result;\n        if (_nonTrivialBaseType != null) {\n            JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n            result = map.findAndAddPrimarySerializer(t, provider, this);\n        } else {\n            result = map.findAndAddPrimarySerializer(type, provider, this);\n        }\n        // did we get a new map of serializers? If so, start using it\n        if (map != result.map) {\n            _dynamicSerializers = result.map;\n        }\n        return result.serializer;\n    }\n    \n    /**\n     * Method that can be used to access value of the property this\n     * Object describes, from given bean instance.\n     *<p>\n     * Note: method is final as it should not need to be overridden -- rather,\n     * calling method(s) ({@link #serializeAsField}) should be overridden\n     * to change the behavior\n     */\n    public final Object get(Object bean) throws Exception {\n        return (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n    }\n\n    /**\n     * Method called to handle a direct self-reference through this property.\n     * Method can choose to indicate an error by throwing {@link JsonMappingException};\n     * fully handle serialization (and return true); or indicate that it should be\n     * serialized normally (return false).\n     *<p>\n     * Default implementation will throw {@link JsonMappingException} if\n     * {@link SerializationFeature#FAIL_ON_SELF_REFERENCES} is enabled;\n     * or return <code>false</code> if it is disabled.\n     *\n     * @return True if method fully handled self-referential value; false if not (caller\n     *    is to handle it) or {@link JsonMappingException} if there is no way handle it\n     */\n    protected boolean _handleSelfReference(Object bean, JsonGenerator gen, SerializerProvider prov, JsonSerializer<?> ser)\n            throws JsonMappingException {\n        if (prov.isEnabled(SerializationFeature.FAIL_ON_SELF_REFERENCES)\n                && !ser.usesObjectId()) {\n            // 05-Feb-2013, tatu: Usually a problem, but NOT if we are handling\n            //    object id; this may be the case for BeanSerializers at least.\n            // 13-Feb-2014, tatu: another possible ok case: custom serializer (something\n            //   OTHER than {@link BeanSerializerBase}\n            if (ser instanceof BeanSerializerBase) {\n                throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"property '\").append(getName()).append(\"' (\");\n        if (_accessorMethod != null) {\n            sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n        } else if (_field != null) {\n            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n        } else {\n            sb.append(\"virtual\");\n        }\n        if (_serializer == null) {\n            sb.append(\", no static serializer\");\n        } else {\n            sb.append(\", static serializer of type \"+_serializer.getClass().getName());\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.SerializableString;\nimport com.fasterxml.jackson.core.io.SerializedString;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\nimport com.fasterxml.jackson.databind.jsonschema.SchemaAware;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\nimport com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\n@JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\npublic class BeanPropertyWriter extends PropertyWriter\n    implements BeanProperty,\n        java.io.Serializable // since 2.6.2\n{\n    // as of 2.6.2\n    private static final long serialVersionUID = 4603296144163950020L;\n\n    /**\n     * Marker object used to indicate \"do not serialize if empty\"\n     */\n    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n\n    /**\n     * Marker we use to indicate case where we have done format lookup,\n     * but found nothing; marker used to avoid having to repeat such lookups.\n     *\n     * @since 2.6\n     */\n    protected final static JsonFormat.Value NO_FORMAT = new JsonFormat.Value();\n\n    /*\n    /**********************************************************\n    /* Basic property metadata: name, type, other\n    /**********************************************************\n     */\n\n    /**\n     * Logical name of the property; will be used as the field name\n     * under which value for the property is written.\n     *<p>\n     * NOTE: do NOT change name of this field; it is accessed by\n     * Afterburner module (until 2.4; not directly from 2.5)\n     * ALSO NOTE: ... and while it really ought to be `SerializableString`,\n     * changing that is also binary-incompatible change. So nope.\n     */\n    protected final SerializedString _name;\n\n    /**\n     * Wrapper name to use for this element, if any\n     * \n     * @since 2.2\n     */\n    protected final PropertyName _wrapperName;\n\n    /**\n     * Type property is declared to have, either in class definition \n     * or associated annotations.\n     */\n    protected final JavaType _declaredType;\n\n    /**\n     * Type to use for locating serializer; normally same as return\n     * type of the accessor method, but may be overridden by annotations.\n     */\n    protected final JavaType _cfgSerializationType;\n\n    /**\n     * Base type of the property, if the declared type is \"non-trivial\";\n     * meaning it is either a structured type (collection, map, array),\n     * or parameterized. Used to retain type information about contained\n     * type, which is mostly necessary if type meta-data is to be\n     * included.\n     */\n    protected JavaType _nonTrivialBaseType;\n\n    /**\n     * Annotations from context (most often, class that declares property,\n     * or in case of sub-class serializer, from that sub-class)\n     *<p>\n     * NOTE: transient just to support JDK serializability; Annotations\n     * do not serialize. At all.\n     */\n    protected final transient Annotations _contextAnnotations;\n    \n    /**\n     * Additional information about property\n     *\n     * @since 2.3\n     */\n    protected final PropertyMetadata _metadata;\n\n    /**\n     * Lazily accessed value for per-property format override definition.\n     * \n     * @since 2.6\n     */\n    protected transient JsonFormat.Value _format;\n\n    /*\n    /**********************************************************\n    /* Settings for accessing property value to serialize\n    /**********************************************************\n     */\n\n    /**\n     * Member (field, method) that represents property and allows access\n     * to associated annotations.\n     */\n    protected final AnnotatedMember _member;\n    \n    /**\n     * Accessor method used to get property value, for\n     * method-accessible properties.\n     * Null if and only if {@link #_field} is null.\n     *<p>\n     * `transient` (and non-final) only to support JDK serializability.\n     */\n    protected transient Method _accessorMethod;\n    \n    /**\n     * Field that contains the property value for field-accessible\n     * properties.\n     * Null if and only if {@link #_accessorMethod} is null.\n     *<p>\n     * `transient` (and non-final) only to support JDK serializability.\n     */\n    protected transient Field _field;\n\n    /*\n    /**********************************************************\n    /* Serializers needed\n    /**********************************************************\n     */\n\n    /**\n     * Serializer to use for writing out the value: null if it can not\n     * be known statically; non-null if it can.\n     */\n    protected JsonSerializer<Object> _serializer;\n\n    /**\n     * Serializer used for writing out null values, if any: if null,\n     * null values are to be suppressed.\n     */\n    protected JsonSerializer<Object> _nullSerializer;\n\n    /**\n     * If property being serialized needs type information to be\n     * included this is the type serializer to use.\n     * Declared type (possibly augmented with annotations) of property\n     * is used for determining exact mechanism to use (compared to\n     * actual runtime type used for serializing actual state).\n     */\n    protected TypeSerializer _typeSerializer;\n\n    /**\n     * In case serializer is not known statically (i.e. <code>_serializer</code>\n     * is null), we will use a lookup structure for storing dynamically\n     * resolved mapping from type(s) to serializer(s).\n     */\n    protected transient PropertySerializerMap _dynamicSerializers;\n\n    /*\n    /**********************************************************\n    /* Filtering\n    /**********************************************************\n     */\n\n    /**\n     * Whether null values are to be suppressed (nothing written out if\n     * value is null) or not. Note that this is a configuration value\n     * during construction, and actual handling relies on setting\n     * (or not) of {@link #_nullSerializer}.\n     */\n    protected final boolean _suppressNulls;\n\n    /**\n     * Value that is considered default value of the property; used for\n     * default-value-suppression if enabled.\n     */\n    protected final Object _suppressableValue;\n\n    /**\n     * Alternate set of property writers used when view-based filtering\n     * is available for the Bean.\n     */\n    protected final Class<?>[] _includeInViews;\n\n    /*\n    /**********************************************************\n    /* Opaque internal data that bean serializer factory and\n    /* bean serializers can add.\n    /**********************************************************\n     */\n\n    protected transient HashMap<Object,Object> _internalSettings;\n\n    /*\n    /**********************************************************\n    /* Construction, configuration\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public BeanPropertyWriter(BeanPropertyDefinition propDef,\n            AnnotatedMember member, Annotations contextAnnotations,\n            JavaType declaredType,\n            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n            boolean suppressNulls, Object suppressableValue)\n    {\n        _member = member;\n        _contextAnnotations = contextAnnotations;\n\n        _name = new SerializedString(propDef.getName());\n        _wrapperName = propDef.getWrapperName();\n        _metadata = propDef.getMetadata();\n        _includeInViews = propDef.findViews();\n\n        _declaredType = declaredType;\n        _serializer = (JsonSerializer<Object>) ser;\n        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyForProperties() : null;\n        _typeSerializer = typeSer;\n        _cfgSerializationType = serType;\n\n        if (member instanceof AnnotatedField) {\n            _accessorMethod = null;\n            _field = (Field) member.getMember();\n        } else if (member instanceof AnnotatedMethod) {\n            _accessorMethod = (Method) member.getMember();\n            _field = null;\n        } else {\n            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed for virtual props\n            _accessorMethod = null;\n            _field = null;\n        }\n        _suppressNulls = suppressNulls;\n        _suppressableValue = suppressableValue;\n\n        // this will be resolved later on, unless nulls are to be suppressed\n        _nullSerializer = null;\n    }\n\n    /**\n     * Constructor that may be of use to virtual properties, when there is need for\n     * the zero-arg (\"default\") constructor, and actual initialization is done\n     * after constructor call.\n     * \n     * @since 2.5\n     */\n    protected BeanPropertyWriter() {\n        _member = null;\n        _contextAnnotations = null;\n\n        _name = null;\n        _wrapperName = null;\n        _metadata = null;\n        _includeInViews = null;\n\n        _declaredType = null;\n        _serializer = null;\n        _dynamicSerializers = null;\n        _typeSerializer = null;\n        _cfgSerializationType = null;\n\n        _accessorMethod = null;\n        _field = null;\n        _suppressNulls = false;\n        _suppressableValue = null;\n\n        _nullSerializer = null;\n    }\n\n    /**\n     * \"Copy constructor\" to be used by filtering sub-classes\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base) {\n        this(base, base._name);\n    }\n\n    /**\n     * @since 2.5\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base, PropertyName name)\n    {\n        /* 02-Dec-2014, tatu: This is a big mess, alas, what with dependency\n         *   to MapperConfig to encode, and Afterburner having heartburn\n         *   for SerializableString (vs SerializedString).\n         *   Hope it can be resolved/reworked in 2.6 timeframe, if not for 2.5\n         */\n        _name = new SerializedString(name.getSimpleName());\n        _wrapperName = base._wrapperName;\n\n        _contextAnnotations = base._contextAnnotations;\n        _declaredType = base._declaredType;\n\n        _member = base._member;\n        _accessorMethod = base._accessorMethod;\n        _field = base._field;\n\n        _serializer = base._serializer;\n        _nullSerializer = base._nullSerializer;\n        // one more thing: copy internal settings, if any (since 1.7)\n        if (base._internalSettings != null) {\n            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n        }\n        _cfgSerializationType = base._cfgSerializationType;\n        _dynamicSerializers = base._dynamicSerializers;\n        _suppressNulls = base._suppressNulls;\n        _suppressableValue = base._suppressableValue;\n        _includeInViews = base._includeInViews;\n        _typeSerializer = base._typeSerializer;\n        _nonTrivialBaseType = base._nonTrivialBaseType;\n        _metadata = base._metadata;\n    }\n\n    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n        _name = name;\n        _wrapperName = base._wrapperName;\n\n        _member = base._member;\n        _contextAnnotations = base._contextAnnotations;\n        _declaredType = base._declaredType;\n        _accessorMethod = base._accessorMethod;\n        _field = base._field;\n        _serializer = base._serializer;\n        _nullSerializer = base._nullSerializer;\n        if (base._internalSettings != null) {\n            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n        }\n        _cfgSerializationType = base._cfgSerializationType;\n        _dynamicSerializers = base._dynamicSerializers;\n        _suppressNulls = base._suppressNulls;\n        _suppressableValue = base._suppressableValue;\n        _includeInViews = base._includeInViews;\n        _typeSerializer = base._typeSerializer;\n        _nonTrivialBaseType = base._nonTrivialBaseType;\n        _metadata = base._metadata;\n    }\n\n    public BeanPropertyWriter rename(NameTransformer transformer) {\n        String newName = transformer.transform(_name.getValue());\n        if (newName.equals(_name.toString())) {\n            return this;\n        }\n        return _new(PropertyName.construct(newName));\n    }\n\n    /**\n     * Overridable factory method used by sub-classes\n     *\n     * @since 2.6.0\n     */\n    protected BeanPropertyWriter _new(PropertyName newName) {\n        return new BeanPropertyWriter(this, newName);\n    }\n\n    /**\n     * Method called to set, reset or clear the configured type serializer\n     * for property.\n     *\n     * @since 2.6\n     */\n    public void assignTypeSerializer(TypeSerializer typeSer) {\n        _typeSerializer = typeSer;\n    }\n\n    /**\n     * Method called to assign value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignSerializer(JsonSerializer<Object> ser) {\n        // may need to disable check in future?\n        if (_serializer != null && _serializer != ser) {\n            throw new IllegalStateException(\"Can not override serializer\");\n        }\n        _serializer = ser;\n    }\n\n    /**\n     * Method called to assign null value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignNullSerializer(JsonSerializer<Object> nullSer) {\n        // may need to disable check in future?\n        if (_nullSerializer != null && _nullSerializer != nullSer) {\n            throw new IllegalStateException(\"Can not override null serializer\");\n        }\n        _nullSerializer = nullSer;\n    }\n\n    /**\n     * Method called create an instance that handles details of unwrapping\n     * contained value.\n     */\n    public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) {\n        return new UnwrappingBeanPropertyWriter(this, unwrapper);\n    }\n\n    /**\n     * Method called to define type to consider as \"non-trivial\" basetype,\n     * needed for dynamic serialization resolution for complex (usually container)\n     * types\n     */\n    public void setNonTrivialBaseType(JavaType t) {\n        _nonTrivialBaseType = t;\n    }\n\n    /*\n    /**********************************************************\n    /* JDK Serializability\n    /**********************************************************\n     */\n\n    /* Ideally would not require mutable state, and instead would re-create with\n     * final settings. However, as things are, with sub-types and all, simplest\n     * to just change Field/Method value directly.\n     */\n    Object readResolve() {\n        if (_member instanceof AnnotatedField) {\n            _accessorMethod = null;\n            _field = (Field) _member.getMember();\n        } else if (_member instanceof AnnotatedMethod) {\n            _accessorMethod = (Method) _member.getMember();\n            _field = null;\n        }\n        if (_serializer == null) {\n            _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* BeanProperty impl\n    /**********************************************************\n     */\n\n    // Note: also part of 'PropertyWriter'\n    @Override public String getName() { return _name.getValue(); }\n\n    // Note: also part of 'PropertyWriter'\n    @Override public PropertyName getFullName() { // !!! TODO: impl properly\n        return new PropertyName(_name.getValue());\n    }\n\n    @Override public JavaType getType() { return _declaredType; }\n    @Override public PropertyName getWrapperName() { return _wrapperName; }\n    @Override public boolean isRequired() { return _metadata.isRequired(); }\n    @Override public PropertyMetadata getMetadata() { return _metadata; }\n\n    // Note: also part of 'PropertyWriter'\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return (_member == null) ? null : _member.getAnnotation(acls);\n    }\n\n    // Note: also part of 'PropertyWriter'\n    @Override\n    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n    }\n    \n    @Override\n    public JsonFormat.Value findFormatOverrides(AnnotationIntrospector intr) {\n        JsonFormat.Value f = _format;\n        if (f == null) { // not yet looked up, do that\n            f = ((intr == null) || (_member == null)) ? null\n                    : intr.findFormat(_member);\n            _format = (f == null) ? NO_FORMAT : f;\n        }\n        return (f == NO_FORMAT) ? null : f;\n    }\n\n    @Override public AnnotatedMember getMember() { return _member; }\n\n    // @since 2.3 -- needed so it can be overridden by unwrapping writer\n    protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode) {\n        propertiesNode.set(getName(), schemaNode);\n    }\n\n    /**\n     * Note: will be defined in {@link BeanProperty}; as of now is not yet.\n     *<p>\n     * TODO: move to {@link BeanProperty} in near future, once all standard\n     * implementations define it.\n     * \n     * @since 2.5\n     */\n    public boolean isVirtual() { return false; }\n    \n    /*\n    /**********************************************************\n    /* Managing and accessing of opaque internal settings\n    /* (used by extensions)\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value of specified internal setting.\n     * \n     * @return Value of the setting, if any; null if none.\n     */\n    public Object getInternalSetting(Object key)  {\n        return (_internalSettings == null) ? null : _internalSettings.get(key);\n    }\n    \n    /**\n     * Method for setting specific internal setting to given value\n     * \n     * @return Old value of the setting, if any (null if none)\n     */\n    public Object setInternalSetting(Object key, Object value) {\n        if (_internalSettings == null) {\n            _internalSettings = new HashMap<Object,Object>();\n        }\n        return _internalSettings.put(key, value);\n    }\n\n    /**\n     * Method for removing entry for specified internal setting.\n     * \n     * @return Existing value of the setting, if any (null if none)\n     */\n    public Object removeInternalSetting(Object key) {\n        Object removed = null;\n        if (_internalSettings != null) {\n            removed = _internalSettings.remove(key);\n            // to reduce memory usage, let's also drop the Map itself, if empty\n            if (_internalSettings.size() == 0) {\n                _internalSettings = null;\n            }\n        }\n        return removed;\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    public SerializableString getSerializedName() { return _name; }\n    \n    public boolean hasSerializer() { return _serializer != null; }\n    public boolean hasNullSerializer() { return _nullSerializer != null; }\n\n    /**\n     * @since 2.6\n     */\n    public TypeSerializer getTypeSerializer() { return _typeSerializer; }\n\n    /**\n     * Accessor that will return true if this bean property has to support\n     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n     *<p>\n     * Default implementation simply returns false.\n     * \n     * @since 2.3\n     */\n    public boolean isUnwrapping() { return false; }\n    \n    public boolean willSuppressNulls() { return _suppressNulls; }\n\n    /**\n     * Method called to check to see if this property has a name that would\n     * conflict with a given name.\n     *\n     * @since 2.6\n     */\n    public boolean wouldConflictWithName(PropertyName name) {\n        if (_wrapperName != null) {\n            return _wrapperName.equals(name);\n        }\n        // Bit convoluted since our support for namespaces is spotty but:\n        return name.hasSimpleName(_name.getValue())\n                && !name.hasNamespace();\n    }\n    \n    // Needed by BeanSerializer#getSchema\n    public JsonSerializer<Object> getSerializer() { return _serializer; }\n\n    public JavaType getSerializationType() { return _cfgSerializationType; }\n\n    public Class<?> getRawSerializationType() {\n        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n    }\n    \n    public Class<?> getPropertyType() {\n        return (_accessorMethod != null) ? _accessorMethod.getReturnType() : _field.getType();\n    }\n\n    /**\n     * Get the generic property type of this property writer.\n     *\n     * @return The property type, or null if not found.\n     */\n    public Type getGenericPropertyType() {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getGenericReturnType();\n        }\n        if (_field != null) {\n            return _field.getGenericType();\n        }\n        return null;\n    }\n\n    public Class<?>[] getViews() { return _includeInViews; }\n\n    /*\n    /**********************************************************\n    /* PropertyWriter methods (serialization)\n    /**********************************************************\n     */\n\n    /**\n     * Method called to access property that this bean stands for, from\n     * within given bean, and to serialize it as a JSON Object field\n     * using appropriate serializer.\n     */\n    @Override\n    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n    {\n        // inlined 'get()'\n        final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n\n        // Null handling is bit different, check that first\n        if (value == null) {\n            if (_nullSerializer != null) {\n                gen.writeFieldName(_name);\n                _nullSerializer.serialize(null, gen, prov);\n            }\n            return;\n        }\n        // then find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap m = _dynamicSerializers;\n            ser = m.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(m, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(prov, value)) {\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) {\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            // three choices: exception; handled by call; or pass-through\n            if (_handleSelfReference(bean, gen, prov, ser)) {\n                return;\n            }\n        }\n        gen.writeFieldName(_name);\n        if (_typeSerializer == null) {\n            ser.serialize(value, gen, prov);\n        } else {\n            ser.serializeWithType(value, gen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to indicate that serialization of a field was omitted\n     * due to filtering, in cases where backend data format does not allow\n     * basic omission.\n     * \n     * @since 2.3\n     */\n    @Override\n    public void serializeAsOmittedField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n    {\n        if (!gen.canOmitFields()) {\n            gen.writeOmittedField(_name.getValue());\n        }\n    }\n    \n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.3\n     */\n    @Override\n    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n        throws Exception\n    {\n        // inlined 'get()'\n        final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, gen, prov);\n            } else { // can NOT suppress entries in tabular output\n                gen.writeNull();\n            }\n            return;\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(prov, value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, gen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, gen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            if (_handleSelfReference(bean, gen, prov, ser)) {\n                return;\n            }\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, gen, prov);\n        } else {\n            ser.serializeWithType(value, gen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to serialize a placeholder used in tabular output when\n     * real value is not to be included (is filtered out), but when we need\n     * an entry so that field indexes will not be off. Typically this should\n     * output null or empty String, depending on datatype.\n     * \n     * @since 2.1\n     */\n    @Override\n    public void serializeAsPlaceholder(Object bean, JsonGenerator gen, SerializerProvider prov)\n        throws Exception\n    {\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, gen, prov);\n        } else {\n            gen.writeNull();\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* PropertyWriter methods (schema generation)\n    /**********************************************************\n     */\n\n    // Also part of BeanProperty implementation\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor v)\n        throws JsonMappingException\n    {\n        if (v != null) {\n            if (isRequired()) {\n                v.property(this); \n            } else {\n                v.optionalProperty(this);\n            }\n        }\n    }\n\n    // // // Legacy support for JsonFormatVisitable\n\n    /**\n     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n     * \n     * @param propertiesNode Node which the given property would exist within\n     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n     *  processing\n     */\n    @Override\n    @Deprecated\n    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n        throws JsonMappingException\n    {\n        JavaType propType = getSerializationType();\n        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n        JsonNode schemaNode;\n        // Maybe it already has annotated/statically configured serializer?\n        JsonSerializer<Object> ser = getSerializer();\n        if (ser == null) { // nope\n            ser = provider.findValueSerializer(getType(), this);\n        }\n        boolean isOptional = !isRequired();\n        if (ser instanceof SchemaAware) {\n            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n        } else {  \n            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n        }\n        _depositSchemaProperty(propertiesNode, schemaNode);\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n            Class<?> type, SerializerProvider provider) throws JsonMappingException\n    {\n        PropertySerializerMap.SerializerAndMapResult result;\n        if (_nonTrivialBaseType != null) {\n            JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n            result = map.findAndAddPrimarySerializer(t, provider, this);\n        } else {\n            result = map.findAndAddPrimarySerializer(type, provider, this);\n        }\n        // did we get a new map of serializers? If so, start using it\n        if (map != result.map) {\n            _dynamicSerializers = result.map;\n        }\n        return result.serializer;\n    }\n    \n    /**\n     * Method that can be used to access value of the property this\n     * Object describes, from given bean instance.\n     *<p>\n     * Note: method is final as it should not need to be overridden -- rather,\n     * calling method(s) ({@link #serializeAsField}) should be overridden\n     * to change the behavior\n     */\n    public final Object get(Object bean) throws Exception {\n        return (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n    }\n\n    /**\n     * Method called to handle a direct self-reference through this property.\n     * Method can choose to indicate an error by throwing {@link JsonMappingException};\n     * fully handle serialization (and return true); or indicate that it should be\n     * serialized normally (return false).\n     *<p>\n     * Default implementation will throw {@link JsonMappingException} if\n     * {@link SerializationFeature#FAIL_ON_SELF_REFERENCES} is enabled;\n     * or return <code>false</code> if it is disabled.\n     *\n     * @return True if method fully handled self-referential value; false if not (caller\n     *    is to handle it) or {@link JsonMappingException} if there is no way handle it\n     */\n    protected boolean _handleSelfReference(Object bean, JsonGenerator gen, SerializerProvider prov, JsonSerializer<?> ser)\n            throws JsonMappingException {\n        if (prov.isEnabled(SerializationFeature.FAIL_ON_SELF_REFERENCES)\n                && !ser.usesObjectId()) {\n            // 05-Feb-2013, tatu: Usually a problem, but NOT if we are handling\n            //    object id; this may be the case for BeanSerializers at least.\n            // 13-Feb-2014, tatu: another possible ok case: custom serializer (something\n            //   OTHER than {@link BeanSerializerBase}\n            if (ser instanceof BeanSerializerBase) {\n                throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"property '\").append(getName()).append(\"' (\");\n        if (_accessorMethod != null) {\n            sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n        } else if (_field != null) {\n            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n        } else {\n            sb.append(\"virtual\");\n        }\n        if (_serializer == null) {\n            sb.append(\", no static serializer\");\n        } else {\n            sb.append(\", static serializer of type \"+_serializer.getClass().getName());\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 27, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.7?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, hasViews);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n        super(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n        super(src, ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n        super(src, unwrapper);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n        super(src, oir);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps) {\n        super(src, ignorableProps);\n    }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n        /* bit kludgy but we don't want to accidentally change type; sub-classes\n         * MUST override this method to support unwrapped properties...\n         */\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        /* main thing really is to just enforce ignoring of unknown\n         * properties; since there may be multiple unwrapped values\n         * and properties for all may be interleaved...\n         */\n        return new BeanDeserializer(this, unwrapper);\n    }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     *<p>\n     * NOTE: was declared 'final' in 2.2; should NOT be to let extensions\n     * like Afterburner change definition.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        JsonToken t = p.getCurrentToken();\n        return _deserializeOther(p, ctxt, t);\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n\t    return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, t);\n            }\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapInstantiationProblem(e, ctxt);\n                        bean = null; // never gets here\n                    }\n                    if (bean == null) {\n                        throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // As per [JACKSON-313], things marked as ignorable should not be\n            // passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.getCurrentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapInstantiationProblem(e, ctxt);\n                        continue; // never gets here\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        tokens.close();\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.7?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, hasViews);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n        super(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n        super(src, ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n        super(src, unwrapper);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n        super(src, oir);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps) {\n        super(src, ignorableProps);\n    }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n        /* bit kludgy but we don't want to accidentally change type; sub-classes\n         * MUST override this method to support unwrapped properties...\n         */\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        /* main thing really is to just enforce ignoring of unknown\n         * properties; since there may be multiple unwrapped values\n         * and properties for all may be interleaved...\n         */\n        return new BeanDeserializer(this, unwrapper);\n    }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     *<p>\n     * NOTE: was declared 'final' in 2.2; should NOT be to let extensions\n     * like Afterburner change definition.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        JsonToken t = p.getCurrentToken();\n        return _deserializeOther(p, ctxt, t);\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n\t    return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, t);\n            }\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapInstantiationProblem(e, ctxt);\n                        bean = null; // never gets here\n                    }\n                    if (bean == null) {\n                        throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // As per [JACKSON-313], things marked as ignorable should not be\n            // passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.getCurrentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapInstantiationProblem(e, ctxt);\n                        continue; // never gets here\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        tokens.close();\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 28, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.util.RawValue;\n\n/**\n * Deserializer that can build instances of {@link JsonNode} from any\n * JSON content, using appropriate {@link JsonNode} type.\n */\n@SuppressWarnings(\"serial\")\npublic class JsonNodeDeserializer\n    extends BaseNodeDeserializer<JsonNode>\n{\n    /**\n     * Singleton instance of generic deserializer for {@link JsonNode}.\n     * Only used for types other than JSON Object and Array.\n     */\n    private final static JsonNodeDeserializer instance = new JsonNodeDeserializer();\n\n    protected JsonNodeDeserializer() { super(JsonNode.class); }\n\n    /**\n     * Factory method for accessing deserializer for specific node type\n     */\n    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)\n    {\n        if (nodeClass == ObjectNode.class) {\n            return ObjectDeserializer.getInstance();\n        }\n        if (nodeClass == ArrayNode.class) {\n            return ArrayDeserializer.getInstance();\n        }\n        // For others, generic one works fine\n        return instance;\n    }\n    \n    /*\n    /**********************************************************\n    /* Actual deserializer implementations\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getNullValue(DeserializationContext ctxt) {\n        return NullNode.getInstance();\n    }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7\n    public JsonNode getNullValue() {\n        return NullNode.getInstance();\n    }\n\n    /**\n     * Implementation that will produce types of any JSON nodes; not just one\n     * deserializer is registered to handle (in case of more specialized handler).\n     * Overridden by typed sub-classes for more thorough checking\n     */\n    @Override\n    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n        default:\n            return deserializeAny(p, ctxt, ctxt.getNodeFactory());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Specific instances for more accurate types\n    /**********************************************************\n     */\n\n    final static class ObjectDeserializer\n        extends BaseNodeDeserializer<ObjectNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ObjectDeserializer _instance = new ObjectDeserializer();\n\n        protected ObjectDeserializer() { super(ObjectNode.class); }\n\n        public static ObjectDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n    }\n}\n\n/**\n * Base class for all actual {@link JsonNode} deserializer\n * implementations\n */\n@SuppressWarnings(\"serial\")\nabstract class BaseNodeDeserializer<T extends JsonNode>\n    extends StdDeserializer<T>\n{\n    public BaseNodeDeserializer(Class<T> vc) {\n        super(vc);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        /* Output can be as JSON Object, Array or scalar: no way to know\n         * a priori. So:\n         */\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n     *   sense to also mark this is cachable, since lookup not exactly free, and\n     *   since it's not uncommon to \"read anything\"\n     */\n    @Override\n    public boolean isCachable() { return true; }\n\n    /*\n    /**********************************************************\n    /* Overridable methods\n    /**********************************************************\n     */\n\n    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }\n\n    /**\n     * Method called when there is a duplicate value for a field.\n     * By default we don't care, and the last value is used.\n     * Can be overridden to provide alternate handling, such as throwing\n     * an exception, or choosing different strategy for combining values\n     * or choosing which one to keep.\n     *\n     * @param fieldName Name of the field for which duplicate value was found\n     * @param objectNode Object node that contains values\n     * @param oldValue Value that existed for the object node before newValue\n     *   was added\n     * @param newValue Newly added value just added to the object node\n     */\n    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory,\n            String fieldName, ObjectNode objectNode,\n            JsonNode oldValue, JsonNode newValue)\n        throws JsonProcessingException\n    {\n        // [Issue#237]: Report an error if asked to do so:\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n                return node;\n            }\n            if (t != JsonToken.FIELD_NAME) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, nodeFactory,\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }\n\n    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n            JsonToken t = p.nextToken();\n            if (t == null) {\n                throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                node.add(deserializeObject(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                node.add(deserializeArray(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_END_ARRAY:\n                return node;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                node.add(_fromEmbedded(p, ctxt, nodeFactory));\n            case JsonTokenId.ID_STRING:\n                node.add(nodeFactory.textNode(p.getText()));\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                node.add(_fromInt(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_TRUE:\n                node.add(nodeFactory.booleanNode(true));\n                break;\n            case JsonTokenId.ID_FALSE:\n                node.add(nodeFactory.booleanNode(false));\n                break;\n            case JsonTokenId.ID_NULL:\n                node.add(nodeFactory.nullNode());\n                break;\n            default:\n                node.add(deserializeAny(p, ctxt, nodeFactory));\n                break;\n            }\n        }\n    }\n\n    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: // for empty JSON Objects we may point to this\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            // These states can not be mapped; input stream is\n            // off by an event or two\n\n        //case END_OBJECT:\n        //case END_ARRAY:\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt;\n        int feats = ctxt.getDeserializationFeatures();\n        if ((feats & F_MASK_INT_COERCIONS) != 0) {\n            if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.BIG_INTEGER;\n            } else if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.LONG;\n            } else {\n                nt = p.getNumberType();\n            }\n        } else {\n            nt = p.getNumberType();\n        }\n        if (nt == JsonParser.NumberType.INT) {\n            return nodeFactory.numberNode(p.getIntValue());\n        }\n        if (nt == JsonParser.NumberType.LONG) {\n            return nodeFactory.numberNode(p.getLongValue());\n        }\n        return nodeFactory.numberNode(p.getBigIntegerValue());\n    }\n\n    protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt = p.getNumberType();\n        if (nt == JsonParser.NumberType.BIG_DECIMAL\n            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return nodeFactory.numberNode(p.getDecimalValue());\n        }\n        return nodeFactory.numberNode(p.getDoubleValue());\n    }\n\n    protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        // [JACKSON-796]\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) { // should this occur?\n            return nodeFactory.nullNode();\n        }\n        Class<?> type = ob.getClass();\n        if (type == byte[].class) { // most common special case\n            return nodeFactory.binaryNode((byte[]) ob);\n        }\n        // [databind#743]: Don't forget RawValue\n        if (ob instanceof RawValue) {\n            return nodeFactory.rawValueNode((RawValue) ob);\n        }\n        if (ob instanceof JsonNode) {\n            // [Issue#433]: but could also be a JsonNode hiding in there!\n            return (JsonNode) ob;\n        }\n        // any other special handling needed?\n        return nodeFactory.pojoNode(ob);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.util.RawValue;\n\n/**\n * Deserializer that can build instances of {@link JsonNode} from any\n * JSON content, using appropriate {@link JsonNode} type.\n */\n@SuppressWarnings(\"serial\")\npublic class JsonNodeDeserializer\n    extends BaseNodeDeserializer<JsonNode>\n{\n    /**\n     * Singleton instance of generic deserializer for {@link JsonNode}.\n     * Only used for types other than JSON Object and Array.\n     */\n    private final static JsonNodeDeserializer instance = new JsonNodeDeserializer();\n\n    protected JsonNodeDeserializer() { super(JsonNode.class); }\n\n    /**\n     * Factory method for accessing deserializer for specific node type\n     */\n    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)\n    {\n        if (nodeClass == ObjectNode.class) {\n            return ObjectDeserializer.getInstance();\n        }\n        if (nodeClass == ArrayNode.class) {\n            return ArrayDeserializer.getInstance();\n        }\n        // For others, generic one works fine\n        return instance;\n    }\n    \n    /*\n    /**********************************************************\n    /* Actual deserializer implementations\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getNullValue(DeserializationContext ctxt) {\n        return NullNode.getInstance();\n    }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7\n    public JsonNode getNullValue() {\n        return NullNode.getInstance();\n    }\n\n    /**\n     * Implementation that will produce types of any JSON nodes; not just one\n     * deserializer is registered to handle (in case of more specialized handler).\n     * Overridden by typed sub-classes for more thorough checking\n     */\n    @Override\n    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n        default:\n            return deserializeAny(p, ctxt, ctxt.getNodeFactory());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Specific instances for more accurate types\n    /**********************************************************\n     */\n\n    final static class ObjectDeserializer\n        extends BaseNodeDeserializer<ObjectNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ObjectDeserializer _instance = new ObjectDeserializer();\n\n        protected ObjectDeserializer() { super(ObjectNode.class); }\n\n        public static ObjectDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n    }\n}\n\n/**\n * Base class for all actual {@link JsonNode} deserializer\n * implementations\n */\n@SuppressWarnings(\"serial\")\nabstract class BaseNodeDeserializer<T extends JsonNode>\n    extends StdDeserializer<T>\n{\n    public BaseNodeDeserializer(Class<T> vc) {\n        super(vc);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        /* Output can be as JSON Object, Array or scalar: no way to know\n         * a priori. So:\n         */\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n     *   sense to also mark this is cachable, since lookup not exactly free, and\n     *   since it's not uncommon to \"read anything\"\n     */\n    @Override\n    public boolean isCachable() { return true; }\n\n    /*\n    /**********************************************************\n    /* Overridable methods\n    /**********************************************************\n     */\n\n    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }\n\n    /**\n     * Method called when there is a duplicate value for a field.\n     * By default we don't care, and the last value is used.\n     * Can be overridden to provide alternate handling, such as throwing\n     * an exception, or choosing different strategy for combining values\n     * or choosing which one to keep.\n     *\n     * @param fieldName Name of the field for which duplicate value was found\n     * @param objectNode Object node that contains values\n     * @param oldValue Value that existed for the object node before newValue\n     *   was added\n     * @param newValue Newly added value just added to the object node\n     */\n    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory,\n            String fieldName, ObjectNode objectNode,\n            JsonNode oldValue, JsonNode newValue)\n        throws JsonProcessingException\n    {\n        // [Issue#237]: Report an error if asked to do so:\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n                return node;\n            }\n            if (t != JsonToken.FIELD_NAME) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, nodeFactory,\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }\n\n    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n            JsonToken t = p.nextToken();\n            if (t == null) {\n                throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                node.add(deserializeObject(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                node.add(deserializeArray(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_END_ARRAY:\n                return node;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                node.add(_fromEmbedded(p, ctxt, nodeFactory));\n            case JsonTokenId.ID_STRING:\n                node.add(nodeFactory.textNode(p.getText()));\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                node.add(_fromInt(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_TRUE:\n                node.add(nodeFactory.booleanNode(true));\n                break;\n            case JsonTokenId.ID_FALSE:\n                node.add(nodeFactory.booleanNode(false));\n                break;\n            case JsonTokenId.ID_NULL:\n                node.add(nodeFactory.nullNode());\n                break;\n            default:\n                node.add(deserializeAny(p, ctxt, nodeFactory));\n                break;\n            }\n        }\n    }\n\n    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: // for empty JSON Objects we may point to this\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            // These states can not be mapped; input stream is\n            // off by an event or two\n\n        //case END_OBJECT:\n        //case END_ARRAY:\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt;\n        int feats = ctxt.getDeserializationFeatures();\n        if ((feats & F_MASK_INT_COERCIONS) != 0) {\n            if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.BIG_INTEGER;\n            } else if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.LONG;\n            } else {\n                nt = p.getNumberType();\n            }\n        } else {\n            nt = p.getNumberType();\n        }\n        if (nt == JsonParser.NumberType.INT) {\n            return nodeFactory.numberNode(p.getIntValue());\n        }\n        if (nt == JsonParser.NumberType.LONG) {\n            return nodeFactory.numberNode(p.getLongValue());\n        }\n        return nodeFactory.numberNode(p.getBigIntegerValue());\n    }\n\n    protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt = p.getNumberType();\n        if (nt == JsonParser.NumberType.BIG_DECIMAL\n            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return nodeFactory.numberNode(p.getDecimalValue());\n        }\n        return nodeFactory.numberNode(p.getDoubleValue());\n    }\n\n    protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        // [JACKSON-796]\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) { // should this occur?\n            return nodeFactory.nullNode();\n        }\n        Class<?> type = ob.getClass();\n        if (type == byte[].class) { // most common special case\n            return nodeFactory.binaryNode((byte[]) ob);\n        }\n        // [databind#743]: Don't forget RawValue\n        if (ob instanceof RawValue) {\n            return nodeFactory.rawValueNode((RawValue) ob);\n        }\n        if (ob instanceof JsonNode) {\n            // [Issue#433]: but could also be a JsonNode hiding in there!\n            return (JsonNode) ob;\n        }\n        // any other special handling needed?\n        return nodeFactory.pojoNode(ob);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 29, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler", "buggy_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n    \n    protected ExternalTypeHandler(ExtTypedProperty[] properties,\n            HashMap<String, Integer> nameToPropertyIndex,\n            String[] typeIds, TokenBuffer[] tokens)\n    {\n        _properties = properties;        \n        _nameToPropertyIndex = nameToPropertyIndex;\n        _typeIds = typeIds;\n        _tokens = tokens;\n    }\n\n    protected ExternalTypeHandler(ExternalTypeHandler h)\n    {\n        _properties = h._properties;\n        _nameToPropertyIndex = h._nameToPropertyIndex;\n        int len = _properties.length;\n        _typeIds = new String[len];\n        _tokens = new TokenBuffer[len];\n    }\n    \n    public ExternalTypeHandler start() {\n        return new ExternalTypeHandler(this);\n    }\n\n    /**\n     * Method called to see if given property/value pair is an external type\n     * id; and if so handle it. This is <b>only</b> to be called in case\n     * containing POJO has similarly named property as the external type id;\n     * otherwise {@link #handlePropertyValue} should be called instead.\n     */\n    public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n            String propName, Object bean)\n        throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        if (!prop.hasTypePropertyName(propName)) {\n            return false;\n        }\n        String typeId = jp.getText();\n        // note: can NOT skip child values (should always be String anyway)\n        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n        // Minor optimization: deserialize properties as soon as we have all we need:\n        if (canDeserialize) {\n            _deserializeAndSet(jp, ctxt, bean, index, typeId);\n            // clear stored data, to avoid deserializing+setting twice:\n            _tokens[index] = null;\n        } else {\n            _typeIds[index] = typeId;\n        }\n        return true;\n    }\n    \n    /**\n     * Method called to ask handler to handle value of given property,\n     * at point where parser points to the first token of the value.\n     * Handling can mean either resolving type id it contains (if it matches type\n     * property name), or by buffering the value for further use.\n     * \n     * @return True, if the given property was properly handled\n     */\n    public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n            String propName, Object bean) throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        boolean canDeserialize;\n        if (prop.hasTypePropertyName(propName)) {\n            _typeIds[index] = jp.getText();\n            jp.skipChildren();\n            canDeserialize = (bean != null) && (_tokens[index] != null);\n        } else {\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tokens = new TokenBuffer(jp);\n            tokens.copyCurrentStructure(jp);\n            _tokens[index] = tokens;\n            canDeserialize = (bean != null) && (_typeIds[index] != null);\n        }\n        /* Minor optimization: let's deserialize properties as soon as\n         * we have all pertinent information:\n         */\n        if (canDeserialize) {\n            String typeId = _typeIds[index];\n            // clear stored data, to avoid deserializing+setting twice:\n            _typeIds[index] = null;\n            _deserializeAndSet(jp, ctxt, bean, index, typeId);\n            _tokens[index] = null;\n        }\n        return true;\n    }\n\n    /**\n     * Method called after JSON Object closes, and has to ensure that all external\n     * type ids have been handled.\n     */\n    @SuppressWarnings(\"resource\")\n    public Object complete(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (int i = 0, len = _properties.length; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                TokenBuffer tokens = _tokens[i];\n                // let's allow missing both type and property (may already have been set, too)\n                // but not just one\n                if (tokens == null) {\n                    continue;\n                }\n                // [databind#118]: Need to mind natural types, for which no type id\n                // will be included.\n                JsonToken t = tokens.firstToken();\n                if (t != null && t.isScalarValue()) {\n                    JsonParser buffered = tokens.asParser(p);\n                    buffered.nextToken();\n                    SettableBeanProperty extProp = _properties[i].getProperty();\n                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n                    if (result != null) {\n                        extProp.set(bean, result);\n                        continue;\n                    }\n                    // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                    if (!_properties[i].hasDefaultType()) {\n                        throw ctxt.mappingException(\"Missing external type id property '%s'\",\n                                _properties[i].getTypePropertyName());                                \n                    }\n                    typeId = _properties[i].getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n                throw ctxt.mappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            _deserializeAndSet(p, ctxt, bean, i, typeId);\n        }\n        return bean;\n    }\n\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser jp, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n                if (!_properties[i].hasDefaultType()) {\n                    throw ctxt.mappingException(\"Missing external type id property '%s'\",\n                            _properties[i].getTypePropertyName());\n                }\n                typeId = _properties[i].getDefaultTypeId();\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n                throw ctxt.mappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(jp, ctxt, i, typeId);\n        }\n        // second: fill in creator properties:\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (creator.findCreatorProperty(prop.getName()) != null) {\n                buffer.assignParameter(prop, values[i]);\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (creator.findCreatorProperty(prop.getName()) == null) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n\n        TokenBuffer merged = new TokenBuffer(p);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        return _properties[index].getProperty().deserialize(mp, ctxt);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, int index, String typeId) throws IOException\n    {\n        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n         * style to ensure we can handle all kinds of JSON constructs.\n         */\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        TokenBuffer merged = new TokenBuffer(p);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        \n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n    \n    public static class Builder\n    {\n        private final ArrayList<ExtTypedProperty> _properties = new ArrayList<ExtTypedProperty>();\n        private final HashMap<String, Integer> _nameToPropertyIndex = new HashMap<String, Integer>();\n\n        public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            Integer index = _properties.size();\n            _properties.add(new ExtTypedProperty(property, typeDeser));\n            _nameToPropertyIndex.put(property.getName(), index);\n            _nameToPropertyIndex.put(typeDeser.getPropertyName(), index);\n        }\n        \n        public ExternalTypeHandler build() {\n            return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]),\n                    _nameToPropertyIndex, null, null);\n        }\n    }\n\n    private final static class ExtTypedProperty\n    {\n        private final SettableBeanProperty _property;\n        private final TypeDeserializer _typeDeserializer;\n        private final String _typePropertyName;\n        \n        public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            _property = property;\n            _typeDeserializer = typeDeser;\n            _typePropertyName = typeDeser.getPropertyName();\n        }\n\n        public boolean hasTypePropertyName(String n) {\n            return n.equals(_typePropertyName);\n        }\n\n        public boolean hasDefaultType() {\n            return _typeDeserializer.getDefaultImpl() != null;\n        }\n\n        public String getDefaultTypeId() {\n            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n            if (defaultType == null) {\n                return null;\n            }\n            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n        }\n        \n        public String getTypePropertyName() { return _typePropertyName; }\n        \n        public SettableBeanProperty getProperty() {\n            return _property;\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n    \n    protected ExternalTypeHandler(ExtTypedProperty[] properties,\n            HashMap<String, Integer> nameToPropertyIndex,\n            String[] typeIds, TokenBuffer[] tokens)\n    {\n        _properties = properties;        \n        _nameToPropertyIndex = nameToPropertyIndex;\n        _typeIds = typeIds;\n        _tokens = tokens;\n    }\n\n    protected ExternalTypeHandler(ExternalTypeHandler h)\n    {\n        _properties = h._properties;\n        _nameToPropertyIndex = h._nameToPropertyIndex;\n        int len = _properties.length;\n        _typeIds = new String[len];\n        _tokens = new TokenBuffer[len];\n    }\n    \n    public ExternalTypeHandler start() {\n        return new ExternalTypeHandler(this);\n    }\n\n    /**\n     * Method called to see if given property/value pair is an external type\n     * id; and if so handle it. This is <b>only</b> to be called in case\n     * containing POJO has similarly named property as the external type id;\n     * otherwise {@link #handlePropertyValue} should be called instead.\n     */\n    public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n            String propName, Object bean)\n        throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        if (!prop.hasTypePropertyName(propName)) {\n            return false;\n        }\n        String typeId = jp.getText();\n        // note: can NOT skip child values (should always be String anyway)\n        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n        // Minor optimization: deserialize properties as soon as we have all we need:\n        if (canDeserialize) {\n            _deserializeAndSet(jp, ctxt, bean, index, typeId);\n            // clear stored data, to avoid deserializing+setting twice:\n            _tokens[index] = null;\n        } else {\n            _typeIds[index] = typeId;\n        }\n        return true;\n    }\n    \n    /**\n     * Method called to ask handler to handle value of given property,\n     * at point where parser points to the first token of the value.\n     * Handling can mean either resolving type id it contains (if it matches type\n     * property name), or by buffering the value for further use.\n     * \n     * @return True, if the given property was properly handled\n     */\n    public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n            String propName, Object bean) throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        boolean canDeserialize;\n        if (prop.hasTypePropertyName(propName)) {\n            _typeIds[index] = jp.getText();\n            jp.skipChildren();\n            canDeserialize = (bean != null) && (_tokens[index] != null);\n        } else {\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tokens = new TokenBuffer(jp);\n            tokens.copyCurrentStructure(jp);\n            _tokens[index] = tokens;\n            canDeserialize = (bean != null) && (_typeIds[index] != null);\n        }\n        /* Minor optimization: let's deserialize properties as soon as\n         * we have all pertinent information:\n         */\n        if (canDeserialize) {\n            String typeId = _typeIds[index];\n            // clear stored data, to avoid deserializing+setting twice:\n            _typeIds[index] = null;\n            _deserializeAndSet(jp, ctxt, bean, index, typeId);\n            _tokens[index] = null;\n        }\n        return true;\n    }\n\n    /**\n     * Method called after JSON Object closes, and has to ensure that all external\n     * type ids have been handled.\n     */\n    @SuppressWarnings(\"resource\")\n    public Object complete(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (int i = 0, len = _properties.length; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                TokenBuffer tokens = _tokens[i];\n                // let's allow missing both type and property (may already have been set, too)\n                // but not just one\n                if (tokens == null) {\n                    continue;\n                }\n                // [databind#118]: Need to mind natural types, for which no type id\n                // will be included.\n                JsonToken t = tokens.firstToken();\n                if (t != null && t.isScalarValue()) {\n                    JsonParser buffered = tokens.asParser(p);\n                    buffered.nextToken();\n                    SettableBeanProperty extProp = _properties[i].getProperty();\n                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n                    if (result != null) {\n                        extProp.set(bean, result);\n                        continue;\n                    }\n                    // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                    if (!_properties[i].hasDefaultType()) {\n                        throw ctxt.mappingException(\"Missing external type id property '%s'\",\n                                _properties[i].getTypePropertyName());                                \n                    }\n                    typeId = _properties[i].getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n                throw ctxt.mappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            _deserializeAndSet(p, ctxt, bean, i, typeId);\n        }\n        return bean;\n    }\n\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser jp, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n                if (!_properties[i].hasDefaultType()) {\n                    throw ctxt.mappingException(\"Missing external type id property '%s'\",\n                            _properties[i].getTypePropertyName());\n                }\n                typeId = _properties[i].getDefaultTypeId();\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n                throw ctxt.mappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(jp, ctxt, i, typeId);\n        }\n        // second: fill in creator properties:\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (creator.findCreatorProperty(prop.getName()) != null) {\n                buffer.assignParameter(prop, values[i]);\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (creator.findCreatorProperty(prop.getName()) == null) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n\n        TokenBuffer merged = new TokenBuffer(p);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        return _properties[index].getProperty().deserialize(mp, ctxt);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, int index, String typeId) throws IOException\n    {\n        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n         * style to ensure we can handle all kinds of JSON constructs.\n         */\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            _properties[index].getProperty().set(bean, null);\n            return;\n        }\n        TokenBuffer merged = new TokenBuffer(p);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        \n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n    \n    public static class Builder\n    {\n        private final ArrayList<ExtTypedProperty> _properties = new ArrayList<ExtTypedProperty>();\n        private final HashMap<String, Integer> _nameToPropertyIndex = new HashMap<String, Integer>();\n\n        public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            Integer index = _properties.size();\n            _properties.add(new ExtTypedProperty(property, typeDeser));\n            _nameToPropertyIndex.put(property.getName(), index);\n            _nameToPropertyIndex.put(typeDeser.getPropertyName(), index);\n        }\n        \n        public ExternalTypeHandler build() {\n            return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]),\n                    _nameToPropertyIndex, null, null);\n        }\n    }\n\n    private final static class ExtTypedProperty\n    {\n        private final SettableBeanProperty _property;\n        private final TypeDeserializer _typeDeserializer;\n        private final String _typePropertyName;\n        \n        public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            _property = property;\n            _typeDeserializer = typeDeser;\n            _typePropertyName = typeDeser.getPropertyName();\n        }\n\n        public boolean hasTypePropertyName(String n) {\n            return n.equals(_typePropertyName);\n        }\n\n        public boolean hasDefaultType() {\n            return _typeDeserializer.getDefaultImpl() != null;\n        }\n\n        public String getDefaultTypeId() {\n            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n            if (defaultType == null) {\n                return null;\n            }\n            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n        }\n        \n        public String getTypePropertyName() { return _typePropertyName; }\n        \n        public SettableBeanProperty getProperty() {\n            return _property;\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 30, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ObjectMapper", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * ObjectMapper provides functionality for reading and writing JSON,\n * either to and from basic POJOs (Plain Old Java Objects), or to and from\n * a general-purpose JSON Tree Model ({@link JsonNode}), as well as\n * related functionality for performing conversions.\n * It is also highly customizable to work both with different styles of JSON\n * content, and to support more advanced Object concepts such as\n * polymorphism and Object identity.\n * <code>ObjectMapper</code> also acts as a factory for more advanced {@link ObjectReader}\n * and {@link ObjectWriter} classes.\n * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will\n * use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n * Note that although most read and write methods are exposed through this class,\n * some of the functionality is only exposed via {@link ObjectReader} and\n * {@link ObjectWriter}: specifically, reading/writing of longer sequences of\n * values is only available through {@link ObjectReader#readValues(InputStream)}\n * and {@link ObjectWriter#writeValues(OutputStream)}.\n *<p>\nSimplest usage is of form:\n<pre>\n  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!\n  MyValue value = new MyValue();\n  // ... and configure\n  File newState = new File(\"my-stuff.json\");\n  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance\n  // or, read\n  MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class);\n\n  // Or if you prefer JSON Tree representation:\n  JsonNode root = mapper.readTree(newState);\n  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:\n  int age = root.at(\"/personal/age\").getValueAsInt(); \n</pre>\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes. Usage via {@link ObjectCodec} is,\n * however, usually only for cases where dependency to {@link ObjectMapper} is\n * either not possible (from Streaming API), or undesireable (when only relying\n * on Streaming API).\n *<p> \n * Mapper instances are fully thread-safe provided that ALL configuration of the\n * instance occurs before ANY read or write calls. If configuration of a mapper\n * is modified after first usage, changes may or may not take effect, and configuration\n * calls themselves may fail.\n * If you need to use different configuration, you have two main possibilities:\n *<ul>\n * <li>Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.\n *    Both types are fully immutable and you can freely create new instances with different\n *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers\n *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is\n *    a very light-weight operation so it is usually appropriate to create these on per-call\n *    basis, as needed, for configuring things like optional indentation of JSON.\n *  </li>\n * <li>If the specific kind of configurability is not available via {@link ObjectReader} and\n *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:\n *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).\n *   To help with this usage, you may want to use method {@link #copy()} which creates a clone\n *   of the mapper with specific configuration, and allows configuration of the copied instance\n *   before it gets used. Note that {@link #copy} operation is as expensive as constructing\n *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers\n *   if you intend to use them for multiple operations.\n *  </li>\n * </ul>\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Helper classes, enums\n    /**********************************************************\n     */\n\n    /**\n     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n     * to specify what kind of types (classes) default typing should\n     * be used for. It will only be used if no explicit type information\n     * is found, but this enumeration further limits subset of those types.\n     *<p>\n     * Since 2.4 there are special exceptions for JSON Tree model\n     * types (sub-types of {@link TreeNode}: default typing is never\n     * applied to them\n     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n     */\n    public enum DefaultTyping {\n        /**\n         * This value means that only properties that have\n         * {@link java.lang.Object} as declared type (including\n         * generic types without explicit type) will use default\n         * typing.\n         */\n        JAVA_LANG_OBJECT,\n        \n        /**\n         * Value that means that default typing will be used for\n         * properties with declared type of {@link java.lang.Object}\n         * or an abstract type (abstract class or interface).\n         * Note that this does <b>not</b> include array types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        OBJECT_AND_NON_CONCRETE,\n\n        /**\n         * Value that means that default typing will be used for\n         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n         * plus all array types for them.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_CONCRETE_AND_ARRAYS,\n        \n        /**\n         * Value that means that default typing will be used for\n         * all non-final types, with exception of small number of\n         * \"natural\" types (String, Boolean, Integer, Double), which\n         * can be correctly inferred from JSON; as well as for\n         * all arrays of non-final types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_FINAL\n    }\n\n    /**\n     * Customized {@link TypeResolverBuilder} that provides type resolver builders\n     * used with so-called \"default typing\"\n     * (see {@link ObjectMapper#enableDefaultTyping()} for details).\n     *<p>\n     * Type resolver construction is based on configuration: implementation takes care\n     * of only providing builders in cases where type information should be applied.\n     * This is important since build calls may be sent for any and all types, and\n     * type information should NOT be applied to all of them.\n     */\n    public static class DefaultTypeResolverBuilder\n        extends StdTypeResolverBuilder\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Definition of what types is this default typer valid for.\n         */\n        protected final DefaultTyping _appliesFor;\n\n        public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n                return t.isJavaLangObject();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    // 16-May-2009, tatu: Ditto ^^^\n    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n\n    protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n\n    /**\n     * @deprecated Since 2.6, do not use: will be removed in 2.7 or later\n     */\n    @Deprecated\n    protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter();\n\n    /**\n     * Base settings contain defaults used for all {@link ObjectMapper}\n     * instances.\n     */\n    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(\n            null, // can not share global ClassIntrospector any more (2.5+)\n            DEFAULT_ANNOTATION_INTROSPECTOR,\n            STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n            null, StdDateFormat.instance, null,\n            Locale.getDefault(),\n            null, // to indicate \"use default TimeZone\"\n            Base64Variants.getDefaultVariant() // 2.1\n    );\n\n    /*\n    /**********************************************************\n    /* Configuration settings, shared\n    /**********************************************************\n     */\n\n    /**\n     * Factory used to create {@link JsonParser} and {@link JsonGenerator}\n     * instances as necessary.\n     */\n    protected final JsonFactory _jsonFactory;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected TypeFactory _typeFactory;\n\n    /**\n     * Provider for values to inject in deserialized POJOs.\n     */\n    protected InjectableValues _injectableValues;\n\n    /**\n     * Thing used for registering sub-types, resolving them to\n     * super/sub-types as needed.\n     */\n    protected SubtypeResolver _subtypeResolver;\n\n    /*\n    /**********************************************************\n    /* Configuration settings: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Mapping that defines how to apply mix-in annotations: key is\n     * the type to received additional annotations, and value is the\n     * type that has annotations to \"mix in\".\n     *<p>\n     * Annotations associated with the value classes will be used to\n     * override annotations of the key class, associated with the\n     * same field or method. They can be further masked by sub-classes:\n     * you can think of it as injecting annotations between the target\n     * class and its sub-classes (or interfaces)\n     * \n     * @since 2.6 (earlier was a simple {@link java.util.Map}\n     */\n    protected SimpleMixInResolver _mixIns;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected SerializationConfig _serializationConfig;\n\n    /**\n     * Object that manages access to serializers used for serialization,\n     * including caching.\n     * It is configured with {@link #_serializerFactory} to allow\n     * for constructing custom serializers.\n     *<p>\n     * Note: while serializers are only exposed {@link SerializerProvider},\n     * mappers and readers need to access additional API defined by\n     * {@link DefaultSerializerProvider}\n     */\n    protected DefaultSerializerProvider _serializerProvider;\n\n    /**\n     * Serializer factory used for constructing serializers.\n     */\n    protected SerializerFactory _serializerFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected DeserializationConfig _deserializationConfig;\n\n    /**\n     * Blueprint context object; stored here to allow custom\n     * sub-classes. Contains references to objects needed for\n     * deserialization construction (cache, factory).\n     */\n    protected DefaultDeserializationContext _deserializationContext;\n\n    /*\n    /**********************************************************\n    /* Module-related\n    /**********************************************************\n     */\n\n    /**\n     * Set of module types (as per {@link Module#getTypeId()} that have been\n     * registered; kept track of iff {@link MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS}\n     * is enabled, so that duplicate registration calls can be ignored\n     * (to avoid adding same handlers multiple times, mostly).\n     * \n     * @since 2.5\n     */\n    protected Set<Object> _registeredModuleTypes;\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /* Note: handling of serializers and deserializers is not symmetric;\n     * and as a result, only root-level deserializers can be cached here.\n     * This is mostly because typing and resolution for deserializers is\n     * fully static; whereas it is quite dynamic for serialization.\n     */\n\n    /**\n     * We will use a separate main-level Map for keeping track\n     * of root-level deserializers. This is where most successful\n     * cache lookups get resolved.\n     * Map will contain resolvers for all kinds of types, including\n     * container types: this is different from the component cache\n     * which will only cache bean deserializers.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * explicitly define a low concurrency setting.\n     *<p>\n     * Since version 1.5, these may are either \"raw\" deserializers (when\n     * no type information is needed for base type), or type-wrapped\n     * deserializers (if it is needed)\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructing instance\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor, which will construct the default\n     * {@link JsonFactory} as necessary, use\n     * {@link SerializerProvider} as its\n     * {@link SerializerProvider}, and\n     * {@link BeanSerializerFactory} as its\n     * {@link SerializerFactory}.\n     * This means that it\n     * can serialize all standard JDK types, as well as regular\n     * Java Beans (based on method names and Jackson-specific annotations),\n     * but does not support JAXB annotations.\n     */\n    public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s.\n     */\n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    /**\n     * Copy-constructor, mostly used to support {@link #copy}.\n     * \n     * @since 2.1\n     */\n    protected ObjectMapper(ObjectMapper src)\n    {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _typeFactory = src._typeFactory;\n        _injectableValues = src._injectableValues;\n\n        SimpleMixInResolver mixins = src._mixIns.copy();\n        _mixIns = mixins;\n        RootNameLookup rootNames = new RootNameLookup();\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins, rootNames);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = src._serializerFactory;\n\n        // as per [databind#922], make sure to copy registered modules as appropriate\n        Set<Object> reg = _registeredModuleTypes;\n        if (reg == null) {\n            _registeredModuleTypes = null;\n        } else {\n            _registeredModuleTypes = new LinkedHashSet<Object>(reg);\n        }\n    }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s, and uses given providers for accessing\n     * serializers and deserializers.\n     * \n     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n     * @param dc Blueprint deserialization context instance to use for creating\n     *    actual context objects; if null, will construct standard\n     *    {@link DeserializationContext}\n     */\n    public ObjectMapper(JsonFactory jf,\n            DefaultSerializerProvider sp, DefaultDeserializationContext dc)\n    {\n        /* 02-Mar-2009, tatu: Important: we MUST default to using\n         *   the mapping factory, otherwise tree serialization will\n         *   have problems with POJONodes.\n         * 03-Jan-2010, tatu: and obviously we also must pass 'this',\n         *    to create actual linking.\n         */\n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { // as per [JACKSON-741]\n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        RootNameLookup rootNames = new RootNameLookup();\n        // and default type factory is shared one\n        _typeFactory = TypeFactory.defaultInstance();\n\n        SimpleMixInResolver mixins = new SimpleMixInResolver(null);\n        _mixIns = mixins;\n\n        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n        _serializationConfig = new SerializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n\n        // Some overrides we may need\n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    /**\n     * Overridable helper method used to construct default {@link ClassIntrospector}\n     * to use.\n     * \n     * @since 2.5\n     */\n    protected ClassIntrospector defaultClassIntrospector() {\n        return new BasicClassIntrospector();\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override\n    /**********************************************************\n     */\n    \n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    /**\n     * @since 2.1\n     */\n    protected void _checkInvalidCopy(Class<?> exp)\n    {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override if providing custom\n    /* ObjectReader/ObjectWriter implementations\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectReader}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _newReader(DeserializationConfig config) {\n        return new ObjectReader(this, config);\n    }\n\n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectReader}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _newReader(DeserializationConfig config,\n            JavaType valueType, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues) {\n        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n    }\n\n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectWriter _newWriter(SerializationConfig config) {\n        return new ObjectWriter(this, config);\n    }\n\n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n        return new ObjectWriter(this, config, schema);\n    }\n    \n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectWriter _newWriter(SerializationConfig config,\n            JavaType rootType, PrettyPrinter pp) {\n        return new ObjectWriter(this, config, rootType, pp);\n    }\n\n    /*\n    /**********************************************************\n    /* Versioned impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* com.fasterxml.jackson.databind.Module registration, discovery\n    /**********************************************************\n     */\n\n    /**\n     * Method for registering a module that can extend functionality\n     * provided by this mapper; for example, by adding providers for\n     * custom serializers and deserializers.\n     * \n     * @param module com.fasterxml.jackson.databind.Module to register\n     */\n    public ObjectMapper registerModule(Module module)\n    {\n        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n            Object typeId = module.getTypeId();\n            if (typeId != null) {\n                if (_registeredModuleTypes == null) {\n                    // plus let's keep them in order too, easier to debug or expose\n                    // in registration order if that matter\n                    _registeredModuleTypes = new LinkedHashSet<Object>();\n                }\n                // try adding; if already had it, should skip\n                if (!_registeredModuleTypes.add(typeId)) {\n                    return this;\n                }\n            }\n        }\n        \n        /* Let's ensure we have access to name and version information, \n         * even if we do not have immediate use for either. This way we know\n         * that they will be available from beginning\n         */\n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        // And then call registration\n        module.setupModule(new Module.SetupContext()\n        {\n            // // // Accessors\n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                // why do we need the cast here?!?\n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            // // // Methods for registering handlers: deserializers\n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            // // // Methods for registering handlers: serializers\n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            // // // Methods for registering handlers: other\n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixIn(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Module... modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)\n    {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    /**\n     * Convenience method that is functionally equivalent to:\n     *<code>\n     *   mapper.registerModules(mapper.findModules());\n     *</code>\n     *<p>\n     * As with {@link #findModules()}, no caching is done for modules, so care\n     * needs to be taken to either create and share a single mapper instance;\n     * or to cache introspected set of modules.\n     *\n     * @since 2.2\n     */\n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: main config object access\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns the shared default {@link SerializationConfig}\n     * object that defines configuration settings for serialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    /**\n     * Method that returns\n     * the shared default {@link DeserializationConfig} object\n     * that defines configuration settings for deserialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    /**\n     * Method for getting current {@link DeserializationContext}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of context object.\n    */\n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: ser/deser factory, provider access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for setting specific {@link SerializerFactory} to use\n     * for constructing (bean) serializers.\n     */\n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    /**\n     * Method for getting current {@link SerializerFactory}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of factory object.\n     */\n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    /**\n     * Method for setting specific {@link SerializerProvider} to use\n     * for handling caching of {@link JsonSerializer} instances.\n     */\n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: mix-in annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method to use for defining mix-in annotations to use for augmenting\n     * annotations that processable (serializable / deserializable)\n     * classes have.\n     * Mixing in is done when introspecting class annotations and properties.\n     * Map passed contains keys that are target classes (ones to augment\n     * with new annotation overrides), and values that are source classes\n     * (have annotations to use for augmentation).\n     * Annotations from source classes (and their supertypes)\n     * will <b>override</b>\n     * annotations that target classes (and their super-types) have.\n     *<p>\n     * Note that this method will CLEAR any previously defined mix-ins\n     * for this mapper.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)\n    {\n        // NOTE: does NOT change possible externally configured resolver, just local defs\n        _mixIns.setLocalDefinitions(sourceMixins);\n        return this;\n    }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     *\n     * @since 2.5\n     */\n    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n    {\n        _mixIns.addLocalDefinition(target, mixinSource);\n        return this;\n    }\n\n    /**\n     * Method that can be called to specify given resolver for locating\n     * mix-in classes to use, overriding directly added mappings.\n     * Note that direct mappings are not cleared, but they are only applied\n     * if resolver does not provide mix-in matches.\n     *\n     * @since 2.6\n     */\n    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)\n    {\n        SimpleMixInResolver r = _mixIns.withOverrides(resolver);\n        if (r != _mixIns) {\n            _mixIns = r;\n            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);\n            _serializationConfig = new SerializationConfig(_serializationConfig, r);\n        }\n        return this;\n    }\n    \n    public Class<?> findMixInClassFor(Class<?> cls) {\n        return _mixIns.findMixInClassFor(cls);\n    }\n\n    // For testing only:\n    public int mixInCount() {\n        return _mixIns.localSize();\n    }\n\n    /**\n     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns}.\n     */\n    @Deprecated\n    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        setMixIns(sourceMixins);\n    }\n\n    /**\n     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.\n     */\n    @Deprecated\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        addMixIn(target, mixinSource);\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     */\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    /**\n     * @deprecated Since 2.6 use {@link #setVisibility(VisibilityChecker)} instead.\n     */\n    @Deprecated\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        setVisibility(vc);\n    }\n\n    /**\n     * Method for setting currently configured {@link VisibilityChecker},\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     * This default checker is used if no per-class overrides\n     * are defined.\n     * \n     * @since 2.6\n     */\n    public ObjectMapper setVisibility(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n        return this;\n    }\n    \n    /**\n     * Convenience method that allows changing configuration for\n     * underlying {@link VisibilityChecker}s, to change details of what kinds of\n     * properties are auto-detected.\n     * Basically short cut for doing:\n     *<pre>\n     *  mapper.setVisibilityChecker(\n     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)\n     *  );\n     *</pre>\n     * one common use case would be to do:\n     *<pre>\n     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);\n     *</pre>\n     * which would make all member fields serializable without further annotations,\n     * instead of just public fields (default setting).\n     * \n     * @param forMethod Type of property descriptor affected (field, getter/isGetter,\n     *     setter, creator)\n     * @param visibility Minimum visibility to require for the property descriptors of type\n     * \n     * @return Modified mapper instance (that is, \"this\"), to allow chaining\n     *    of configuration calls\n     */\n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    /**\n     * Method for accessing subtype resolver in use.\n     */\n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    /**\n     * Method for setting custom subtype resolver to use.\n     */\n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    /**\n     * Method for setting {@link AnnotationIntrospector} used by this\n     * mapper instance for both serialization and deserialization.\n     * Note that doing this will replace the current introspector, which\n     * may lead to unavailability of core Jackson annotations.\n     * If you want to combine handling of multiple introspectors,\n     * have a look at {@link com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair}.\n     * \n     * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair\n     */\n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} instances used\n     * by this mapper instance for serialization and deserialization,\n     * specifying them separately so that different introspection can be\n     * used for different aspects\n     * \n     * @since 2.1\n     * \n     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n     *    serialization\n     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n     *    deserialization\n     * \n     * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair\n     */\n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    /**\n     * Method for setting custom property naming strategy to use.\n     */\n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    /**\n     * @since 2.5\n     */\n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        // arbitrary choice but let's do:\n        return _serializationConfig.getPropertyNamingStrategy();\n    }\n    \n    /**\n     * Method for setting default POJO property inclusion strategy for serialization.\n     */\n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n\n    /**\n     * Method for specifying {@link PrettyPrinter} to use when \"default pretty-printing\"\n     * is enabled (by enabling {@link SerializationFeature#INDENT_OUTPUT})\n     * \n     * @param pp Pretty printer to use by default.\n     * \n     * @return This mapper, useful for call-chaining\n     * \n     * @since 2.6\n     */\n    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {\n        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Type information configuration (1.5+)\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     *<P>\n     * NOTE: use of <code>JsonTypeInfo.As#EXTERNAL_PROPERTY</code> <b>NOT SUPPORTED</b>;\n     * and attempts of do so will throw an {@link IllegalArgumentException} to make\n     * this limitation explicit.\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n    {\n        /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n         *   use \"As.EXTERNAL_PROPERTY\", since that will not work (with 2.5+)\n         */\n        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n        }\n        \n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information -- needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --\n     * using \"As.PROPERTY\" inclusion mechanism and specified property name\n     * to use for inclusion (default being \"@class\" since default type information\n     * always uses class name as type identifier)\n     */\n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    /**\n     * Method for disabling automatic inclusion of type information; if so, only\n     * explicitly annotated types (ones with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have\n     * additional embedded type information.\n     */\n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Type for given class is determined from appropriate annotation;\n     * or if missing, default name (unqualified class name)\n     */\n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Name may be provided as part of argument, but if not will\n     * be based on annotations or use default name (unqualified\n     * class name).\n     */\n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration, basic type handling\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting currently configured {@link TypeFactory} instance.\n     */\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    /**\n     * Method that can be used to override {@link TypeFactory} instance\n     * used by this mapper.\n     *<p>\n     * Note: will also set {@link TypeFactory} that deserialization and\n     * serialization config objects use.\n     */\n    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    /**\n     * Convenience method for constructing {@link JavaType} out of given\n     * type (typically <code>java.lang.Class</code>), but without explicit\n     * context.\n     */\n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonNodeFactory}\n     * that this mapper will use when directly constructing\n     * root {@link JsonNode} instances for Trees.\n     *<p>\n     * Note: this is just a shortcut for calling\n     *<pre>\n     *   getDeserializationConfig().getNodeFactory()\n     *</pre>\n     */\n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n    \n    /**\n     * Method for specifying {@link JsonNodeFactory} to use for\n     * constructing root level tree nodes (via method\n     * {@link #createObjectNode}\n     */\n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for adding specified {@link DeserializationProblemHandler}\n     * to be used for handling specific problems during deserialization.\n     */\n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    /**\n     * Method for removing all registered {@link DeserializationProblemHandler}s\n     * instances from this mapper.\n     */\n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link DeserializationConfig}\n     * object.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any deserialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, serialization\n    /**********************************************************\n     */\n\n    /**\n     * @deprecated Since 2.6, use {@link #setFilterProvider} instead (allows chaining)\n     */\n    @Deprecated\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    /**\n     * Method for configuring this mapper to use specified {@link FilterProvider} for\n     * mapping Filter Ids to actual filter instances.\n     *<p>\n     * Note that usually it is better to use method {@link #writer(FilterProvider)};\n     * however, sometimes\n     * this method is more convenient. For example, some frameworks only allow configuring\n     * of ObjectMapper instances and not {@link ObjectWriter}s.\n     * \n     * @since 2.6\n     */\n    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n        return this;\n    }\n\n    /**\n     * Method that will configure default {@link Base64Variant} that\n     * <code>byte[]</code> serializers and deserializers will use.\n     * \n     * @param v Base64 variant to use\n     * \n     * @return This mapper, for convenience to allow chaining\n     * \n     * @since 2.1\n     */\n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link SerializationConfig}\n     * object, which contains serialization-specific configuration settings.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any serialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(SerializationConfig config) {\n        _serializationConfig = config;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonFactory} that this\n     * mapper uses if it needs to construct {@link JsonParser}s\n     * and/or {@link JsonGenerator}s.\n     *\n     * @return {@link JsonFactory} that this mapper uses when it needs to\n     *   construct Json parser and generators\n     */\n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    /**\n     * Method for configuring the default {@link DateFormat} to use when serializing time\n     * values as Strings, and deserializing from JSON Strings.\n     * This is preferably to directly modifying {@link SerializationConfig} and\n     * {@link DeserializationConfig} instances.\n     * If you need per-request configuration, use {@link #writer(DateFormat)} to\n     * create properly configured {@link ObjectWriter} and use that; this because\n     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n     * thread-safe when configuring methods (such as this one) are NOT called.\n     */\n    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    /**\n     * @since 2.5\n     */\n    public DateFormat getDateFormat() {\n        // arbitrary choice but let's do:\n        return _serializationConfig.getDateFormat();\n    }\n    \n    /**\n     * Method for configuring {@link HandlerInstantiator} to use for creating\n     * instances of handlers (such as serializers, deserializers, type and type\n     * id resolvers), given a class.\n     *\n     * @param hi Instantiator to use; if null, use the default implementation\n     */\n    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    /**\n     * Method for configuring {@link InjectableValues} which used to find\n     * values to inject.\n     */\n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n\n    /**\n     * @since 2.6\n     */\n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    /**\n     * Method for overriding default locale to use for formatting.\n     * Default value used is {@link Locale#getDefault()}.\n     */\n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    /**\n     * Method for overriding default TimeZone to use for formatting.\n     * Default value used is UTC (NOT local timezone).\n     */\n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: MapperFeature\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given {@link MapperFeature} is enabled.\n     */\n    public boolean isEnabled(MapperFeature f) {\n        // ok to use either one, should be kept in sync\n        return _serializationConfig.isEnabled(f);\n    }\n    \n    /**\n     * Method for changing state of an on/off mapper feature for\n     * this mapper instance.\n     */\n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: SerializationFeature\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given serialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Method for changing state of an on/off serialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: DeserializationFeature\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given deserialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Method for changing state of an on/off deserialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: JsonParser.Feature\n    /**********************************************************\n     */\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _deserializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    /**\n     * Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method\n     * on {@link #getFactory}.\n     */\n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n    \n    /**\n     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper disable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: JsonGenerator.Feature\n    /**********************************************************\n     */\n\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _serializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    /**\n     * Method for changing state of an on/off {@link JsonGenerator} feature for\n     * generator instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method\n     * on {@link #getFactory}.\n     */\n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f,  state);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper disable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration, simple features: JsonFactory.Feature\n    /**********************************************************\n     */\n    \n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): deserialization\n    /* (mapping from JSON to Java types);\n    /* main methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        /* 02-Mar-2009, tatu: One twist; deserialization provider\n         *   will map JSON null straight into Java null. But what\n         *   we want to return is the \"null node\" instead.\n         */\n        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n         *   calling readValue(), since that'll choke on it otherwise\n         */\n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     *<p>\n     * Note that {@link ObjectReader} has more complete set of variants.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n            throws IOException, JsonProcessingException\n    {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        // false -> do NOT close JsonParser (since caller passed it)\n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API not included in ObjectCodec: deserialization\n    /* (mapping from JSON to Java types)\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *<p>\n     * If a low-level I/O problem (missing input, network error) occurs,\n     * a {@link IOException} will be thrown.\n     * If a parsing problem occurs (invalid JSON),\n     * {@link JsonParseException} will be thrown.\n     * If no content is found from input (end-of-input), Java\n     * <code>null</code> will be returned.\n     * \n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     *   \n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *<p>\n     * If a low-level I/O problem (missing input, network error) occurs,\n     * a {@link IOException} will be thrown.\n     * If a parsing problem occurs (invalid JSON),\n     * {@link JsonParseException} will be thrown.\n     * If no content is found from input (end-of-input), Java\n     * <code>null</code> will be returned.\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *<p>\n     * If a low-level I/O problem (missing input, network error) occurs,\n     * a {@link IOException} will be thrown.\n     * If a parsing problem occurs (invalid JSON),\n     * {@link JsonParseException} will be thrown.\n     * If no content is found from input (end-of-input), Java\n     * <code>null</code> will be returned.\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     *\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     *\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): serialization\n    /* (mapping from Java types to Json)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using provided {@link JsonGenerator}.\n     */\n    @Override\n    public void writeValue(JsonGenerator g, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig config = getSerializationConfig();\n\n        /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual\n         *    'config.initialize(g)` here, since it is assumed that generator\n         *    has been configured by caller. But for some reason we don't\n         *    trust indentation settings...\n         */\n        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            if (g.getPrettyPrinter() == null) {\n                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());\n            }\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(g, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(g, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from TreeCodec via ObjectCodec): Tree Model support\n    /**********************************************************\n     */\n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     * Method to serialize given JSON Tree, using generator\n     * provided.\n     */\n    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    /**\n     * Method for constructing a {@link JsonParser} out of JSON tree\n     * representation.\n     * \n     * @param n Root node of the tree that resulting parser will read from\n     */\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    /**\n     * Convenience conversion method that will bind data given JSON tree\n     * contains into specific value (usually bean) type.\n     *<p>\n     * Functionally equivalent to:\n     *<pre>\n     *   objectMapper.convertValue(n, valueClass);\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: while results are usually identical to that of serialization followed\n     * by deserialization, this is not always the case. In some cases serialization\n     * into intermediate representation will retain encapsulation of things like\n     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n     * node identity ({@link JsonNode}). If so, result is a valid tree, but values\n     * are not re-constructed through actual JSON representation. So if transformation\n     * requires actual materialization of JSON (or other data format that this mapper\n     * produces), it will be necessary to do actual serialization.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could serialize an instance of given Class.\n     * Check is done\n     * by checking whether a serializer can be found for the type.\n     *<p>\n     * NOTE: since this method does NOT throw exceptions, but internal\n     * processing may, caller usually has little information as to why\n     * serialization would fail. If you want access to internal {@link Exception},\n     * call {@link #canSerialize(Class, AtomicReference)} instead.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canSerialize(Class)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could deserialize an Object of given type.\n     * Check is done by checking whether a registered deserializer can\n     * be found or built for the type; if not (either by no mapping being\n     * found, or through an <code>Exception</code> being thrown, false\n     * is returned.\n     *<p>\n     * <b>NOTE</b>: in case an exception is thrown during course of trying\n     * co construct matching deserializer, it will be effectively swallowed.\n     * If you want access to that exception, call\n     * {@link #canDeserialize(JavaType, AtomicReference)} instead.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canDeserialize(JavaType type)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canDeserialize(JavaType)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API, deserialization,\n    /* convenience methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//      _setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API: serialization\n    /* (mapping from Java types to JSON)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, written to File provided.\n     */\n    public void writeValue(File resultFile, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using output stream provided (using encoding\n     * {@link JsonEncoding#UTF8}).\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(OutputStream out, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using Writer provided.\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(Writer w, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    /**\n     * Method that can be used to serialize any Java value as\n     * a byte array. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n     * and getting bytes, but more efficient.\n     * Encoding used will be UTF-8.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectWriters\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for constructing {@link ObjectWriter}\n     * with default settings.\n     */\n    public ObjectWriter writer() {\n        return _newWriter(getSerializationConfig());\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature feature) {\n        return _newWriter(getSerializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature first,\n            SerializationFeature... other) {\n        return _newWriter(getSerializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified {@link DateFormat}; or, if\n     * null passed, using timestamp (64-bit number.\n     */\n    public ObjectWriter writer(DateFormat df) {\n        return _newWriter(getSerializationConfig().with(df));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified JSON View (filter).\n     */\n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return _newWriter(getSerializationConfig().withView(serializationView));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     *<p>\n     * Main reason for using this method is performance, as writer is able\n     * to pre-fetch serializer to use before write, and if writer is used\n     * more than once this avoids addition per-value serializer lookups.\n     * \n     * @since 2.5\n     */\n    public ObjectWriter writerFor(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     *<p>\n     * Main reason for using this method is performance, as writer is able\n     * to pre-fetch serializer to use before write, and if writer is used\n     * more than once this avoids addition per-value serializer lookups.\n     * \n     * @since 2.5\n     */\n    public ObjectWriter writerFor(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     *<p>\n     * Main reason for using this method is performance, as writer is able\n     * to pre-fetch serializer to use before write, and if writer is used\n     * more than once this avoids addition per-value serializer lookups.\n     * \n     * @since 2.5\n     */\n    public ObjectWriter writerFor(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified pretty printer for indentation\n     * (or if null, no pretty printer)\n     */\n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using the default pretty printer for indentation\n     */\n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        SerializationConfig config = getSerializationConfig();\n        return _newWriter(config,\n                /*root type*/ null, config.getDefaultPrettyPrinter());\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified filter provider.\n     */\n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * pass specific schema object to {@link JsonGenerator} used for\n     * writing content.\n     * \n     * @param schema Schema to pass to generator\n     */\n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newWriter(getSerializationConfig(), schema);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return _newWriter(getSerializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified character escaping details for output.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return _newWriter(getSerializationConfig()).with(escapes);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(ContextAttributes attrs) {\n        return _newWriter(getSerializationConfig().with(attrs));\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead\n     */\n    @Deprecated\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectReaders\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * default settings. Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader() {\n        return _newReader(getDeserializationConfig()).with(_injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature feature) {\n        return _newReader(getDeserializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature first,\n            DeserializationFeature... other) {\n        return _newReader(getDeserializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * update given Object (usually Bean, but can be a Collection or Map\n     * as well, but NOT an array) with JSON data. Deserialization occurs\n     * normally except that the root-level value in JSON is not used for\n     * instantiating a new object; instead give updateable object is used\n     * as root.\n     * Runtime type of value object is used for locating deserializer,\n     * unless overridden by other factory methods of {@link ObjectReader}\n     */\n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified {@link JsonNodeFactory} for constructing JSON trees.\n     */\n    public ObjectReader reader(JsonNodeFactory f) {\n        return _newReader(getDeserializationConfig()).with(f);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * pass specific schema object to {@link JsonParser} used for\n     * reading content.\n     * \n     * @param schema Schema to pass to parser\n     */\n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newReader(getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified injectable values.\n     * \n     * @param injectableValues Injectable values to use\n     */\n    public ObjectReader reader(InjectableValues injectableValues) {\n        return _newReader(getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * deserialize objects using specified JSON View (filter).\n     */\n    public ObjectReader readerWithView(Class<?> view) {\n        return _newReader(getDeserializationConfig().withView(view));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return _newReader(getDeserializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectReader reader(ContextAttributes attrs) {\n        return _newReader(getDeserializationConfig().with(attrs));\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #readerFor(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectReader reader(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #readerFor(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader reader(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #readerFor(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: convenience type conversion\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for doing two-step conversion from given value, into\n     * instance of given value type, if (but only if!) conversion is needed.\n     * If given value is already of requested type, value is returned as is.\n     *<p>\n     * This method is functionally similar to first\n     * serializing given value into JSON, and then binding JSON data into value\n     * of given type, but should be more efficient since full serialization does\n     * not (need to) occur.\n     * However, same converters (serializers, deserializers) will be used as for\n     * data binding, meaning same object mapper configuration works.\n     *<p>\n     * Note that it is possible that in some cases behavior does differ from\n     * full serialize-then-deserialize cycle: in most case differences are\n     * unintentional (that is, flaws to fix) and should be reported.\n     * It is not guaranteed, however, that the behavior is 100% the same:\n     * the goal is just to allow efficient value conversions for structurally\n     * compatible Objects, according to standard Jackson configuration.\n     *<p>\n     * Further note that functianality is not designed to support \"advanced\" use\n     * cases, such as conversion of polymorphic values, or cases where Object Identity\n     * is used.\n     *      \n     * @throws IllegalArgumentException If conversion fails due to incompatible type;\n     *    if so, root cause will contain underlying checked exception data binding\n     *    functionality threw\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    /**\n     * See {@link #convertValue(Object, Class)}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n        throws IllegalArgumentException\n    {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    /**\n     * See {@link #convertValue(Object, Class)}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: JSON Schema generation\n    /**********************************************************\n     */\n\n    /**\n     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n     * instance for specified class.\n     *\n     * @param t The class to generate schema for\n     * @return Constructed JSON schema.\n     * \n     * @deprecated Since 2.6 use external JSON Schema generator (https://github.com/FasterXML/jackson-module-jsonSchema)\n     */\n    @Deprecated\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">JSON Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     * Visitation uses <code>Serializer</code> hierarchy and related properties\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">JSON Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for serialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used for constructing\n     * {@link SerializerProvider} to use for serialization.\n     */\n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    /**\n     * @deprecated Since 2.6, use {@link SerializationConfig#constructDefaultPrettyPrinter()} directly\n     */\n    @Deprecated\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _serializationConfig.constructDefaultPrettyPrinter();\n    }\n\n    /**\n     * Method called to configure the generator as necessary and then\n     * call write functionality\n     */\n    protected final void _configAndWriteValue(JsonGenerator g, Object value)\n        throws IOException\n    {\n        SerializationConfig cfg = getSerializationConfig();\n        cfg.initialize(g); // since 2.5\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            /* won't try to close twice; also, must catch exception (so it \n             * will not mask exception that is pending)\n             */\n            if (!closed) {\n                /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                 *    structures, which typically causes more damage.\n                 */\n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass)\n        throws IOException\n    {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        cfg.initialize(g); // since 2.5\n\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            if (!closed) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            JsonGenerator tmpGen = g;\n            g = null;\n            tmpGen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (g != null) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods for deserialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n    }\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: may need to read the next token, to initialize\n         * state (either before first read from parser, or after\n         * previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            // ok, let's get the value\n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            // Need to consume the token too\n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    /**\n     * Method called to ensure that given parser is ready for reading\n     * content for data binding.\n     *\n     * @return First token to be used for data binding after this call:\n     *  can never be null as exception will be thrown if parser can not\n     *  provide more tokens.\n     *\n     * @throws IOException if the underlying input source has problems during\n     *   parsing\n     * @throws JsonParseException if parser has problems parsing content\n     * @throws JsonMappingException if the parser does not have any more\n     *   content to map (note: Json \"null\" value is considered content;\n     *   enf-of-stream not)\n     */\n    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        _deserializationConfig.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            // and then we must get something...\n            t = p.nextToken();\n            if (t == null) {\n                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                 *   not an actual parsing problem\n                 */\n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, \n            DeserializationConfig config,\n            JavaType rootType, JsonDeserializer<Object> deser)\n        throws IOException\n    {\n        PropertyName expRootName = config.findRootName(rootType);\n        // 12-Jun-2015, tatu: Should try to support namespaces etc but...\n        String expSimpleName = expRootName.getSimpleName();\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        p.nextToken();\n        Object result = deser.deserialize(p, ctxt);\n        // and last, verify that we now get matching END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.SegmentedStringWriter;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.util.*;\nimport com.fasterxml.jackson.databind.cfg.BaseSettings;\nimport com.fasterxml.jackson.databind.cfg.ContextAttributes;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.node.*;\nimport com.fasterxml.jackson.databind.ser.*;\nimport com.fasterxml.jackson.databind.type.*;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * ObjectMapper provides functionality for reading and writing JSON,\n * either to and from basic POJOs (Plain Old Java Objects), or to and from\n * a general-purpose JSON Tree Model ({@link JsonNode}), as well as\n * related functionality for performing conversions.\n * It is also highly customizable to work both with different styles of JSON\n * content, and to support more advanced Object concepts such as\n * polymorphism and Object identity.\n * <code>ObjectMapper</code> also acts as a factory for more advanced {@link ObjectReader}\n * and {@link ObjectWriter} classes.\n * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will\n * use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n * Note that although most read and write methods are exposed through this class,\n * some of the functionality is only exposed via {@link ObjectReader} and\n * {@link ObjectWriter}: specifically, reading/writing of longer sequences of\n * values is only available through {@link ObjectReader#readValues(InputStream)}\n * and {@link ObjectWriter#writeValues(OutputStream)}.\n *<p>\nSimplest usage is of form:\n<pre>\n  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!\n  MyValue value = new MyValue();\n  // ... and configure\n  File newState = new File(\"my-stuff.json\");\n  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance\n  // or, read\n  MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class);\n\n  // Or if you prefer JSON Tree representation:\n  JsonNode root = mapper.readTree(newState);\n  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:\n  int age = root.at(\"/personal/age\").getValueAsInt(); \n</pre>\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes. Usage via {@link ObjectCodec} is,\n * however, usually only for cases where dependency to {@link ObjectMapper} is\n * either not possible (from Streaming API), or undesireable (when only relying\n * on Streaming API).\n *<p> \n * Mapper instances are fully thread-safe provided that ALL configuration of the\n * instance occurs before ANY read or write calls. If configuration of a mapper\n * is modified after first usage, changes may or may not take effect, and configuration\n * calls themselves may fail.\n * If you need to use different configuration, you have two main possibilities:\n *<ul>\n * <li>Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.\n *    Both types are fully immutable and you can freely create new instances with different\n *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers\n *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is\n *    a very light-weight operation so it is usually appropriate to create these on per-call\n *    basis, as needed, for configuring things like optional indentation of JSON.\n *  </li>\n * <li>If the specific kind of configurability is not available via {@link ObjectReader} and\n *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:\n *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).\n *   To help with this usage, you may want to use method {@link #copy()} which creates a clone\n *   of the mapper with specific configuration, and allows configuration of the copied instance\n *   before it gets used. Note that {@link #copy} operation is as expensive as constructing\n *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers\n *   if you intend to use them for multiple operations.\n *  </li>\n * </ul>\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Helper classes, enums\n    /**********************************************************\n     */\n\n    /**\n     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n     * to specify what kind of types (classes) default typing should\n     * be used for. It will only be used if no explicit type information\n     * is found, but this enumeration further limits subset of those types.\n     *<p>\n     * Since 2.4 there are special exceptions for JSON Tree model\n     * types (sub-types of {@link TreeNode}: default typing is never\n     * applied to them\n     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n     */\n    public enum DefaultTyping {\n        /**\n         * This value means that only properties that have\n         * {@link java.lang.Object} as declared type (including\n         * generic types without explicit type) will use default\n         * typing.\n         */\n        JAVA_LANG_OBJECT,\n        \n        /**\n         * Value that means that default typing will be used for\n         * properties with declared type of {@link java.lang.Object}\n         * or an abstract type (abstract class or interface).\n         * Note that this does <b>not</b> include array types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        OBJECT_AND_NON_CONCRETE,\n\n        /**\n         * Value that means that default typing will be used for\n         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n         * plus all array types for them.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_CONCRETE_AND_ARRAYS,\n        \n        /**\n         * Value that means that default typing will be used for\n         * all non-final types, with exception of small number of\n         * \"natural\" types (String, Boolean, Integer, Double), which\n         * can be correctly inferred from JSON; as well as for\n         * all arrays of non-final types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_FINAL\n    }\n\n    /**\n     * Customized {@link TypeResolverBuilder} that provides type resolver builders\n     * used with so-called \"default typing\"\n     * (see {@link ObjectMapper#enableDefaultTyping()} for details).\n     *<p>\n     * Type resolver construction is based on configuration: implementation takes care\n     * of only providing builders in cases where type information should be applied.\n     * This is important since build calls may be sent for any and all types, and\n     * type information should NOT be applied to all of them.\n     */\n    public static class DefaultTypeResolverBuilder\n        extends StdTypeResolverBuilder\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Definition of what types is this default typer valid for.\n         */\n        protected final DefaultTyping _appliesFor;\n\n        public DefaultTypeResolverBuilder(DefaultTyping t) {\n            _appliesFor = t;\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n                return t.isJavaLangObject()\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n                return t.isJavaLangObject();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    // 16-May-2009, tatu: Ditto ^^^\n    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n\n    protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n\n    /**\n     * @deprecated Since 2.6, do not use: will be removed in 2.7 or later\n     */\n    @Deprecated\n    protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter();\n\n    /**\n     * Base settings contain defaults used for all {@link ObjectMapper}\n     * instances.\n     */\n    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(\n            null, // can not share global ClassIntrospector any more (2.5+)\n            DEFAULT_ANNOTATION_INTROSPECTOR,\n            STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n            null, StdDateFormat.instance, null,\n            Locale.getDefault(),\n            null, // to indicate \"use default TimeZone\"\n            Base64Variants.getDefaultVariant() // 2.1\n    );\n\n    /*\n    /**********************************************************\n    /* Configuration settings, shared\n    /**********************************************************\n     */\n\n    /**\n     * Factory used to create {@link JsonParser} and {@link JsonGenerator}\n     * instances as necessary.\n     */\n    protected final JsonFactory _jsonFactory;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected TypeFactory _typeFactory;\n\n    /**\n     * Provider for values to inject in deserialized POJOs.\n     */\n    protected InjectableValues _injectableValues;\n\n    /**\n     * Thing used for registering sub-types, resolving them to\n     * super/sub-types as needed.\n     */\n    protected SubtypeResolver _subtypeResolver;\n\n    /*\n    /**********************************************************\n    /* Configuration settings: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Mapping that defines how to apply mix-in annotations: key is\n     * the type to received additional annotations, and value is the\n     * type that has annotations to \"mix in\".\n     *<p>\n     * Annotations associated with the value classes will be used to\n     * override annotations of the key class, associated with the\n     * same field or method. They can be further masked by sub-classes:\n     * you can think of it as injecting annotations between the target\n     * class and its sub-classes (or interfaces)\n     * \n     * @since 2.6 (earlier was a simple {@link java.util.Map}\n     */\n    protected SimpleMixInResolver _mixIns;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected SerializationConfig _serializationConfig;\n\n    /**\n     * Object that manages access to serializers used for serialization,\n     * including caching.\n     * It is configured with {@link #_serializerFactory} to allow\n     * for constructing custom serializers.\n     *<p>\n     * Note: while serializers are only exposed {@link SerializerProvider},\n     * mappers and readers need to access additional API defined by\n     * {@link DefaultSerializerProvider}\n     */\n    protected DefaultSerializerProvider _serializerProvider;\n\n    /**\n     * Serializer factory used for constructing serializers.\n     */\n    protected SerializerFactory _serializerFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected DeserializationConfig _deserializationConfig;\n\n    /**\n     * Blueprint context object; stored here to allow custom\n     * sub-classes. Contains references to objects needed for\n     * deserialization construction (cache, factory).\n     */\n    protected DefaultDeserializationContext _deserializationContext;\n\n    /*\n    /**********************************************************\n    /* Module-related\n    /**********************************************************\n     */\n\n    /**\n     * Set of module types (as per {@link Module#getTypeId()} that have been\n     * registered; kept track of iff {@link MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS}\n     * is enabled, so that duplicate registration calls can be ignored\n     * (to avoid adding same handlers multiple times, mostly).\n     * \n     * @since 2.5\n     */\n    protected Set<Object> _registeredModuleTypes;\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /* Note: handling of serializers and deserializers is not symmetric;\n     * and as a result, only root-level deserializers can be cached here.\n     * This is mostly because typing and resolution for deserializers is\n     * fully static; whereas it is quite dynamic for serialization.\n     */\n\n    /**\n     * We will use a separate main-level Map for keeping track\n     * of root-level deserializers. This is where most successful\n     * cache lookups get resolved.\n     * Map will contain resolvers for all kinds of types, including\n     * container types: this is different from the component cache\n     * which will only cache bean deserializers.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * explicitly define a low concurrency setting.\n     *<p>\n     * Since version 1.5, these may are either \"raw\" deserializers (when\n     * no type information is needed for base type), or type-wrapped\n     * deserializers (if it is needed)\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructing instance\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor, which will construct the default\n     * {@link JsonFactory} as necessary, use\n     * {@link SerializerProvider} as its\n     * {@link SerializerProvider}, and\n     * {@link BeanSerializerFactory} as its\n     * {@link SerializerFactory}.\n     * This means that it\n     * can serialize all standard JDK types, as well as regular\n     * Java Beans (based on method names and Jackson-specific annotations),\n     * but does not support JAXB annotations.\n     */\n    public ObjectMapper() {\n        this(null, null, null);\n    }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s.\n     */\n    public ObjectMapper(JsonFactory jf) {\n        this(jf, null, null);\n    }\n\n    /**\n     * Copy-constructor, mostly used to support {@link #copy}.\n     * \n     * @since 2.1\n     */\n    protected ObjectMapper(ObjectMapper src)\n    {\n        _jsonFactory = src._jsonFactory.copy();\n        _jsonFactory.setCodec(this);\n        _subtypeResolver = src._subtypeResolver;\n        _typeFactory = src._typeFactory;\n        _injectableValues = src._injectableValues;\n\n        SimpleMixInResolver mixins = src._mixIns.copy();\n        _mixIns = mixins;\n        RootNameLookup rootNames = new RootNameLookup();\n        _serializationConfig = new SerializationConfig(src._serializationConfig, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins, rootNames);\n        _serializerProvider = src._serializerProvider.copy();\n        _deserializationContext = src._deserializationContext.copy();\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = src._serializerFactory;\n\n        // as per [databind#922], make sure to copy registered modules as appropriate\n        Set<Object> reg = _registeredModuleTypes;\n        if (reg == null) {\n            _registeredModuleTypes = null;\n        } else {\n            _registeredModuleTypes = new LinkedHashSet<Object>(reg);\n        }\n    }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s, and uses given providers for accessing\n     * serializers and deserializers.\n     * \n     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n     * @param dc Blueprint deserialization context instance to use for creating\n     *    actual context objects; if null, will construct standard\n     *    {@link DeserializationContext}\n     */\n    public ObjectMapper(JsonFactory jf,\n            DefaultSerializerProvider sp, DefaultDeserializationContext dc)\n    {\n        /* 02-Mar-2009, tatu: Important: we MUST default to using\n         *   the mapping factory, otherwise tree serialization will\n         *   have problems with POJONodes.\n         * 03-Jan-2010, tatu: and obviously we also must pass 'this',\n         *    to create actual linking.\n         */\n        if (jf == null) {\n            _jsonFactory = new MappingJsonFactory(this);\n        } else {\n            _jsonFactory = jf;\n            if (jf.getCodec() == null) { // as per [JACKSON-741]\n                _jsonFactory.setCodec(this);\n            }\n        }\n        _subtypeResolver = new StdSubtypeResolver();\n        RootNameLookup rootNames = new RootNameLookup();\n        // and default type factory is shared one\n        _typeFactory = TypeFactory.defaultInstance();\n\n        SimpleMixInResolver mixins = new SimpleMixInResolver(null);\n        _mixIns = mixins;\n\n        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n        _serializationConfig = new SerializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n        _deserializationConfig = new DeserializationConfig(base,\n                    _subtypeResolver, mixins, rootNames);\n\n        // Some overrides we may need\n        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n        }\n        \n        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n        _deserializationContext = (dc == null) ?\n                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n\n        // Default serializer factory is stateless, can just assign\n        _serializerFactory = BeanSerializerFactory.instance;\n    }\n\n    /**\n     * Overridable helper method used to construct default {@link ClassIntrospector}\n     * to use.\n     * \n     * @since 2.5\n     */\n    protected ClassIntrospector defaultClassIntrospector() {\n        return new BasicClassIntrospector();\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override\n    /**********************************************************\n     */\n    \n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy() {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }\n\n    /**\n     * @since 2.1\n     */\n    protected void _checkInvalidCopy(Class<?> exp)\n    {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override if providing custom\n    /* ObjectReader/ObjectWriter implementations\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectReader}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _newReader(DeserializationConfig config) {\n        return new ObjectReader(this, config);\n    }\n\n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectReader}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _newReader(DeserializationConfig config,\n            JavaType valueType, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues) {\n        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n    }\n\n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectWriter _newWriter(SerializationConfig config) {\n        return new ObjectWriter(this, config);\n    }\n\n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n        return new ObjectWriter(this, config, schema);\n    }\n    \n    /**\n     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n     * instances of proper sub-type\n     * \n     * @since 2.5\n     */\n    protected ObjectWriter _newWriter(SerializationConfig config,\n            JavaType rootType, PrettyPrinter pp) {\n        return new ObjectWriter(this, config, rootType, pp);\n    }\n\n    /*\n    /**********************************************************\n    /* Versioned impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* com.fasterxml.jackson.databind.Module registration, discovery\n    /**********************************************************\n     */\n\n    /**\n     * Method for registering a module that can extend functionality\n     * provided by this mapper; for example, by adding providers for\n     * custom serializers and deserializers.\n     * \n     * @param module com.fasterxml.jackson.databind.Module to register\n     */\n    public ObjectMapper registerModule(Module module)\n    {\n        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n            Object typeId = module.getTypeId();\n            if (typeId != null) {\n                if (_registeredModuleTypes == null) {\n                    // plus let's keep them in order too, easier to debug or expose\n                    // in registration order if that matter\n                    _registeredModuleTypes = new LinkedHashSet<Object>();\n                }\n                // try adding; if already had it, should skip\n                if (!_registeredModuleTypes.add(typeId)) {\n                    return this;\n                }\n            }\n        }\n        \n        /* Let's ensure we have access to name and version information, \n         * even if we do not have immediate use for either. This way we know\n         * that they will be available from beginning\n         */\n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        // And then call registration\n        module.setupModule(new Module.SetupContext()\n        {\n            // // // Accessors\n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                // why do we need the cast here?!?\n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            // // // Methods for registering handlers: deserializers\n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            // // // Methods for registering handlers: serializers\n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            // // // Methods for registering handlers: other\n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixIn(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Module... modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n     *      registerModule(module);\n     *   }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Iterable<com.fasterxml.jackson.databind.Module> modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }\n    \n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules() {\n        return findModules(null);\n    }\n\n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<com.fasterxml.jackson.databind.Module> findModules(ClassLoader classLoader)\n    {\n        ArrayList<com.fasterxml.jackson.databind.Module> modules = new ArrayList<Module>();\n        ServiceLoader<com.fasterxml.jackson.databind.Module> loader = (classLoader == null) ?\n                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n        for (Module module : loader) {\n            modules.add(module);\n        }\n        return modules;\n    }\n\n    /**\n     * Convenience method that is functionally equivalent to:\n     *<code>\n     *   mapper.registerModules(mapper.findModules());\n     *</code>\n     *<p>\n     * As with {@link #findModules()}, no caching is done for modules, so care\n     * needs to be taken to either create and share a single mapper instance;\n     * or to cache introspected set of modules.\n     *\n     * @since 2.2\n     */\n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: main config object access\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns the shared default {@link SerializationConfig}\n     * object that defines configuration settings for serialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }\n\n    /**\n     * Method that returns\n     * the shared default {@link DeserializationConfig} object\n     * that defines configuration settings for deserialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }\n    \n    /**\n     * Method for getting current {@link DeserializationContext}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of context object.\n    */\n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: ser/deser factory, provider access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for setting specific {@link SerializerFactory} to use\n     * for constructing (bean) serializers.\n     */\n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }\n\n    /**\n     * Method for getting current {@link SerializerFactory}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of factory object.\n     */\n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }\n\n    /**\n     * Method for setting specific {@link SerializerProvider} to use\n     * for handling caching of {@link JsonSerializer} instances.\n     */\n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }\n\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: mix-in annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method to use for defining mix-in annotations to use for augmenting\n     * annotations that processable (serializable / deserializable)\n     * classes have.\n     * Mixing in is done when introspecting class annotations and properties.\n     * Map passed contains keys that are target classes (ones to augment\n     * with new annotation overrides), and values that are source classes\n     * (have annotations to use for augmentation).\n     * Annotations from source classes (and their supertypes)\n     * will <b>override</b>\n     * annotations that target classes (and their super-types) have.\n     *<p>\n     * Note that this method will CLEAR any previously defined mix-ins\n     * for this mapper.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)\n    {\n        // NOTE: does NOT change possible externally configured resolver, just local defs\n        _mixIns.setLocalDefinitions(sourceMixins);\n        return this;\n    }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     *\n     * @since 2.5\n     */\n    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n    {\n        _mixIns.addLocalDefinition(target, mixinSource);\n        return this;\n    }\n\n    /**\n     * Method that can be called to specify given resolver for locating\n     * mix-in classes to use, overriding directly added mappings.\n     * Note that direct mappings are not cleared, but they are only applied\n     * if resolver does not provide mix-in matches.\n     *\n     * @since 2.6\n     */\n    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)\n    {\n        SimpleMixInResolver r = _mixIns.withOverrides(resolver);\n        if (r != _mixIns) {\n            _mixIns = r;\n            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);\n            _serializationConfig = new SerializationConfig(_serializationConfig, r);\n        }\n        return this;\n    }\n    \n    public Class<?> findMixInClassFor(Class<?> cls) {\n        return _mixIns.findMixInClassFor(cls);\n    }\n\n    // For testing only:\n    public int mixInCount() {\n        return _mixIns.localSize();\n    }\n\n    /**\n     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns}.\n     */\n    @Deprecated\n    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n        setMixIns(sourceMixins);\n    }\n\n    /**\n     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.\n     */\n    @Deprecated\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n        addMixIn(target, mixinSource);\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     */\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }\n\n    /**\n     * @deprecated Since 2.6 use {@link #setVisibility(VisibilityChecker)} instead.\n     */\n    @Deprecated\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        setVisibility(vc);\n    }\n\n    /**\n     * Method for setting currently configured {@link VisibilityChecker},\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     * This default checker is used if no per-class overrides\n     * are defined.\n     * \n     * @since 2.6\n     */\n    public ObjectMapper setVisibility(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n        return this;\n    }\n    \n    /**\n     * Convenience method that allows changing configuration for\n     * underlying {@link VisibilityChecker}s, to change details of what kinds of\n     * properties are auto-detected.\n     * Basically short cut for doing:\n     *<pre>\n     *  mapper.setVisibilityChecker(\n     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)\n     *  );\n     *</pre>\n     * one common use case would be to do:\n     *<pre>\n     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);\n     *</pre>\n     * which would make all member fields serializable without further annotations,\n     * instead of just public fields (default setting).\n     * \n     * @param forMethod Type of property descriptor affected (field, getter/isGetter,\n     *     setter, creator)\n     * @param visibility Minimum visibility to require for the property descriptors of type\n     * \n     * @return Modified mapper instance (that is, \"this\"), to allow chaining\n     *    of configuration calls\n     */\n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }\n    \n    /**\n     * Method for accessing subtype resolver in use.\n     */\n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }\n\n    /**\n     * Method for setting custom subtype resolver to use.\n     */\n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }\n\n    /**\n     * Method for setting {@link AnnotationIntrospector} used by this\n     * mapper instance for both serialization and deserialization.\n     * Note that doing this will replace the current introspector, which\n     * may lead to unavailability of core Jackson annotations.\n     * If you want to combine handling of multiple introspectors,\n     * have a look at {@link com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair}.\n     * \n     * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair\n     */\n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} instances used\n     * by this mapper instance for serialization and deserialization,\n     * specifying them separately so that different introspection can be\n     * used for different aspects\n     * \n     * @since 2.1\n     * \n     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n     *    serialization\n     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n     *    deserialization\n     * \n     * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair\n     */\n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }\n    \n    /**\n     * Method for setting custom property naming strategy to use.\n     */\n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }\n\n    /**\n     * @since 2.5\n     */\n    public PropertyNamingStrategy getPropertyNamingStrategy() {\n        // arbitrary choice but let's do:\n        return _serializationConfig.getPropertyNamingStrategy();\n    }\n    \n    /**\n     * Method for setting default POJO property inclusion strategy for serialization.\n     */\n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }\n\n    /**\n     * Method for specifying {@link PrettyPrinter} to use when \"default pretty-printing\"\n     * is enabled (by enabling {@link SerializationFeature#INDENT_OUTPUT})\n     * \n     * @param pp Pretty printer to use by default.\n     * \n     * @return This mapper, useful for call-chaining\n     * \n     * @since 2.6\n     */\n    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {\n        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Type information configuration (1.5+)\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     *<P>\n     * NOTE: use of <code>JsonTypeInfo.As#EXTERNAL_PROPERTY</code> <b>NOT SUPPORTED</b>;\n     * and attempts of do so will throw an {@link IllegalArgumentException} to make\n     * this limitation explicit.\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n    {\n        /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n         *   use \"As.EXTERNAL_PROPERTY\", since that will not work (with 2.5+)\n         */\n        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n        }\n        \n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information -- needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --\n     * using \"As.PROPERTY\" inclusion mechanism and specified property name\n     * to use for inclusion (default being \"@class\" since default type information\n     * always uses class name as type identifier)\n     */\n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }\n    \n    /**\n     * Method for disabling automatic inclusion of type information; if so, only\n     * explicitly annotated types (ones with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have\n     * additional embedded type information.\n     */\n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }\n\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Type for given class is determined from appropriate annotation;\n     * or if missing, default name (unqualified class name)\n     */\n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Name may be provided as part of argument, but if not will\n     * be based on annotations or use default name (unqualified\n     * class name).\n     */\n    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration, basic type handling\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting currently configured {@link TypeFactory} instance.\n     */\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    /**\n     * Method that can be used to override {@link TypeFactory} instance\n     * used by this mapper.\n     *<p>\n     * Note: will also set {@link TypeFactory} that deserialization and\n     * serialization config objects use.\n     */\n    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n    \n    /**\n     * Convenience method for constructing {@link JavaType} out of given\n     * type (typically <code>java.lang.Class</code>), but without explicit\n     * context.\n     */\n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonNodeFactory}\n     * that this mapper will use when directly constructing\n     * root {@link JsonNode} instances for Trees.\n     *<p>\n     * Note: this is just a shortcut for calling\n     *<pre>\n     *   getDeserializationConfig().getNodeFactory()\n     *</pre>\n     */\n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }\n    \n    /**\n     * Method for specifying {@link JsonNodeFactory} to use for\n     * constructing root level tree nodes (via method\n     * {@link #createObjectNode}\n     */\n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for adding specified {@link DeserializationProblemHandler}\n     * to be used for handling specific problems during deserialization.\n     */\n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }\n\n    /**\n     * Method for removing all registered {@link DeserializationProblemHandler}s\n     * instances from this mapper.\n     */\n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link DeserializationConfig}\n     * object.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any deserialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, serialization\n    /**********************************************************\n     */\n\n    /**\n     * @deprecated Since 2.6, use {@link #setFilterProvider} instead (allows chaining)\n     */\n    @Deprecated\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }\n\n    /**\n     * Method for configuring this mapper to use specified {@link FilterProvider} for\n     * mapping Filter Ids to actual filter instances.\n     *<p>\n     * Note that usually it is better to use method {@link #writer(FilterProvider)};\n     * however, sometimes\n     * this method is more convenient. For example, some frameworks only allow configuring\n     * of ObjectMapper instances and not {@link ObjectWriter}s.\n     * \n     * @since 2.6\n     */\n    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n        return this;\n    }\n\n    /**\n     * Method that will configure default {@link Base64Variant} that\n     * <code>byte[]</code> serializers and deserializers will use.\n     * \n     * @param v Base64 variant to use\n     * \n     * @return This mapper, for convenience to allow chaining\n     * \n     * @since 2.1\n     */\n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }\n\n    /**\n     * Method that allows overriding of the underlying {@link SerializationConfig}\n     * object, which contains serialization-specific configuration settings.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any serialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(SerializationConfig config) {\n        _serializationConfig = config;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonFactory} that this\n     * mapper uses if it needs to construct {@link JsonParser}s\n     * and/or {@link JsonGenerator}s.\n     *\n     * @return {@link JsonFactory} that this mapper uses when it needs to\n     *   construct Json parser and generators\n     */\n    @Override\n    public JsonFactory getFactory() { return _jsonFactory; }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() { return getFactory(); }\n\n    /**\n     * Method for configuring the default {@link DateFormat} to use when serializing time\n     * values as Strings, and deserializing from JSON Strings.\n     * This is preferably to directly modifying {@link SerializationConfig} and\n     * {@link DeserializationConfig} instances.\n     * If you need per-request configuration, use {@link #writer(DateFormat)} to\n     * create properly configured {@link ObjectWriter} and use that; this because\n     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n     * thread-safe when configuring methods (such as this one) are NOT called.\n     */\n    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }\n\n    /**\n     * @since 2.5\n     */\n    public DateFormat getDateFormat() {\n        // arbitrary choice but let's do:\n        return _serializationConfig.getDateFormat();\n    }\n    \n    /**\n     * Method for configuring {@link HandlerInstantiator} to use for creating\n     * instances of handlers (such as serializers, deserializers, type and type\n     * id resolvers), given a class.\n     *\n     * @param hi Instantiator to use; if null, use the default implementation\n     */\n    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }\n    \n    /**\n     * Method for configuring {@link InjectableValues} which used to find\n     * values to inject.\n     */\n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }\n\n    /**\n     * @since 2.6\n     */\n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }\n\n    /**\n     * Method for overriding default locale to use for formatting.\n     * Default value used is {@link Locale#getDefault()}.\n     */\n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }\n\n    /**\n     * Method for overriding default TimeZone to use for formatting.\n     * Default value used is UTC (NOT local timezone).\n     */\n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: MapperFeature\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given {@link MapperFeature} is enabled.\n     */\n    public boolean isEnabled(MapperFeature f) {\n        // ok to use either one, should be kept in sync\n        return _serializationConfig.isEnabled(f);\n    }\n    \n    /**\n     * Method for changing state of an on/off mapper feature for\n     * this mapper instance.\n     */\n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: SerializationFeature\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given serialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(SerializationFeature f) {\n        return _serializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Method for changing state of an on/off serialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature f) {\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: DeserializationFeature\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given deserialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(DeserializationFeature f) {\n        return _deserializationConfig.isEnabled(f);\n    }\n\n    /**\n     * Method for changing state of an on/off deserialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.with(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(first, f);\n        return this;\n    }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature feature) {\n        _deserializationConfig = _deserializationConfig.without(feature);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature first,\n            DeserializationFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(first, f);\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: JsonParser.Feature\n    /**********************************************************\n     */\n\n    public boolean isEnabled(JsonParser.Feature f) {\n        return _deserializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    /**\n     * Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method\n     * on {@link #getFactory}.\n     */\n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n    \n    /**\n     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper disable(JsonParser.Feature... features) {\n        for (JsonParser.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features: JsonGenerator.Feature\n    /**********************************************************\n     */\n\n    public boolean isEnabled(JsonGenerator.Feature f) {\n        return _serializationConfig.isEnabled(f, _jsonFactory);\n    }\n\n    /**\n     * Method for changing state of an on/off {@link JsonGenerator} feature for\n     * generator instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method\n     * on {@link #getFactory}.\n     */\n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f,  state);\n        return this;\n    }\n\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.enable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper disable(JsonGenerator.Feature... features) {\n        for (JsonGenerator.Feature f : features) {\n            _jsonFactory.disable(f);\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration, simple features: JsonFactory.Feature\n    /**********************************************************\n     */\n    \n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonFactory.Feature f) {\n        return _jsonFactory.isEnabled(f);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): deserialization\n    /* (mapping from JSON to Java types);\n    /* main methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        /* 02-Mar-2009, tatu: One twist; deserialization provider\n         *   will map JSON null straight into Java null. But what\n         *   we want to return is the \"null node\" instead.\n         */\n        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n         *   calling readValue(), since that'll choke on it otherwise\n         */\n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     *<p>\n     * Note that {@link ObjectReader} has more complete set of variants.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n            throws IOException, JsonProcessingException\n    {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        // false -> do NOT close JsonParser (since caller passed it)\n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API not included in ObjectCodec: deserialization\n    /* (mapping from JSON to Java types)\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *<p>\n     * If a low-level I/O problem (missing input, network error) occurs,\n     * a {@link IOException} will be thrown.\n     * If a parsing problem occurs (invalid JSON),\n     * {@link JsonParseException} will be thrown.\n     * If no content is found from input (end-of-input), Java\n     * <code>null</code> will be returned.\n     * \n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     *   \n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *<p>\n     * If a low-level I/O problem (missing input, network error) occurs,\n     * a {@link IOException} will be thrown.\n     * If a parsing problem occurs (invalid JSON),\n     * {@link JsonParseException} will be thrown.\n     * If no content is found from input (end-of-input), Java\n     * <code>null</code> will be returned.\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *<p>\n     * If a low-level I/O problem (missing input, network error) occurs,\n     * a {@link IOException} will be thrown.\n     * If a parsing problem occurs (invalid JSON),\n     * {@link JsonParseException} will be thrown.\n     * If no content is found from input (end-of-input), Java\n     * <code>null</code> will be returned.\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     *\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     *\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     * \n     * @return a {@link JsonNode}, if valid JSON content found; null\n     *   if input has no content to bind -- note, however, that if\n     *   JSON <code>null</code> token is found, it will be represented\n     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n     *   for {@link JsonNode#isNull()}\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): serialization\n    /* (mapping from Java types to Json)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using provided {@link JsonGenerator}.\n     */\n    @Override\n    public void writeValue(JsonGenerator g, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig config = getSerializationConfig();\n\n        /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual\n         *    'config.initialize(g)` here, since it is assumed that generator\n         *    has been configured by caller. But for some reason we don't\n         *    trust indentation settings...\n         */\n        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            if (g.getPrettyPrinter() == null) {\n                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());\n            }\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(g, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(g, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from TreeCodec via ObjectCodec): Tree Model support\n    /**********************************************************\n     */\n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     * Method to serialize given JSON Tree, using generator\n     * provided.\n     */\n    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override    \n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }\n\n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }\n\n    /**\n     * Method for constructing a {@link JsonParser} out of JSON tree\n     * representation.\n     * \n     * @param n Root node of the tree that resulting parser will read from\n     */\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }\n\n    /**\n     * Convenience conversion method that will bind data given JSON tree\n     * contains into specific value (usually bean) type.\n     *<p>\n     * Functionally equivalent to:\n     *<pre>\n     *   objectMapper.convertValue(n, valueClass);\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: while results are usually identical to that of serialization followed\n     * by deserialization, this is not always the case. In some cases serialization\n     * into intermediate representation will retain encapsulation of things like\n     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n     * node identity ({@link JsonNode}). If so, result is a valid tree, but values\n     * are not re-constructed through actual JSON representation. So if transformation\n     * requires actual materialization of JSON (or other data format that this mapper\n     * produces), it will be necessary to do actual serialization.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could serialize an instance of given Class.\n     * Check is done\n     * by checking whether a serializer can be found for the type.\n     *<p>\n     * NOTE: since this method does NOT throw exceptions, but internal\n     * processing may, caller usually has little information as to why\n     * serialization would fail. If you want access to internal {@link Exception},\n     * call {@link #canSerialize(Class, AtomicReference)} instead.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canSerialize(Class)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n    }\n    \n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could deserialize an Object of given type.\n     * Check is done by checking whether a registered deserializer can\n     * be found or built for the type; if not (either by no mapping being\n     * found, or through an <code>Exception</code> being thrown, false\n     * is returned.\n     *<p>\n     * <b>NOTE</b>: in case an exception is thrown during course of trying\n     * co construct matching deserializer, it will be effectively swallowed.\n     * If you want access to that exception, call\n     * {@link #canDeserialize(JavaType, AtomicReference)} instead.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canDeserialize(JavaType type)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }\n\n    /**\n     * Method similar to {@link #canDeserialize(JavaType)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API, deserialization,\n    /* convenience methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    }\n\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//      _setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API: serialization\n    /* (mapping from Java types to JSON)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, written to File provided.\n     */\n    public void writeValue(File resultFile, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using output stream provided (using encoding\n     * {@link JsonEncoding#UTF8}).\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(OutputStream out, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using Writer provided.\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(Writer w, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }\n    \n    /**\n     * Method that can be used to serialize any Java value as\n     * a byte array. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n     * and getting bytes, but more efficient.\n     * Encoding used will be UTF-8.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectWriters\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for constructing {@link ObjectWriter}\n     * with default settings.\n     */\n    public ObjectWriter writer() {\n        return _newWriter(getSerializationConfig());\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature feature) {\n        return _newWriter(getSerializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature first,\n            SerializationFeature... other) {\n        return _newWriter(getSerializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified {@link DateFormat}; or, if\n     * null passed, using timestamp (64-bit number.\n     */\n    public ObjectWriter writer(DateFormat df) {\n        return _newWriter(getSerializationConfig().with(df));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified JSON View (filter).\n     */\n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return _newWriter(getSerializationConfig().withView(serializationView));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     *<p>\n     * Main reason for using this method is performance, as writer is able\n     * to pre-fetch serializer to use before write, and if writer is used\n     * more than once this avoids addition per-value serializer lookups.\n     * \n     * @since 2.5\n     */\n    public ObjectWriter writerFor(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     *<p>\n     * Main reason for using this method is performance, as writer is able\n     * to pre-fetch serializer to use before write, and if writer is used\n     * more than once this avoids addition per-value serializer lookups.\n     * \n     * @since 2.5\n     */\n    public ObjectWriter writerFor(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     *<p>\n     * Main reason for using this method is performance, as writer is able\n     * to pre-fetch serializer to use before write, and if writer is used\n     * more than once this avoids addition per-value serializer lookups.\n     * \n     * @since 2.5\n     */\n    public ObjectWriter writerFor(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified pretty printer for indentation\n     * (or if null, no pretty printer)\n     */\n    public ObjectWriter writer(PrettyPrinter pp) {\n        if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n        }\n        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using the default pretty printer for indentation\n     */\n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        SerializationConfig config = getSerializationConfig();\n        return _newWriter(config,\n                /*root type*/ null, config.getDefaultPrettyPrinter());\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified filter provider.\n     */\n    public ObjectWriter writer(FilterProvider filterProvider) {\n        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * pass specific schema object to {@link JsonGenerator} used for\n     * writing content.\n     * \n     * @param schema Schema to pass to generator\n     */\n    public ObjectWriter writer(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newWriter(getSerializationConfig(), schema);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectWriter writer(Base64Variant defaultBase64) {\n        return _newWriter(getSerializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified character escaping details for output.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(CharacterEscapes escapes) {\n        return _newWriter(getSerializationConfig()).with(escapes);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(ContextAttributes attrs) {\n        return _newWriter(getSerializationConfig().with(attrs));\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead\n     */\n    @Deprecated\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n        return _newWriter(getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectWriter writerWithType(JavaType rootType) {\n        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectReaders\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * default settings. Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader() {\n        return _newReader(getDeserializationConfig()).with(_injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature feature) {\n        return _newReader(getDeserializationConfig().with(feature));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature first,\n            DeserializationFeature... other) {\n        return _newReader(getDeserializationConfig().with(first, other));\n    }\n    \n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * update given Object (usually Bean, but can be a Collection or Map\n     * as well, but NOT an array) with JSON data. Deserialization occurs\n     * normally except that the root-level value in JSON is not used for\n     * instantiating a new object; instead give updateable object is used\n     * as root.\n     * Runtime type of value object is used for locating deserializer,\n     * unless overridden by other factory methods of {@link ObjectReader}\n     */\n    public ObjectReader readerForUpdating(Object valueToUpdate) {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified {@link JsonNodeFactory} for constructing JSON trees.\n     */\n    public ObjectReader reader(JsonNodeFactory f) {\n        return _newReader(getDeserializationConfig()).with(f);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * pass specific schema object to {@link JsonParser} used for\n     * reading content.\n     * \n     * @param schema Schema to pass to parser\n     */\n    public ObjectReader reader(FormatSchema schema) {\n        _verifySchemaType(schema);\n        return _newReader(getDeserializationConfig(), null, null,\n                schema, _injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified injectable values.\n     * \n     * @param injectableValues Injectable values to use\n     */\n    public ObjectReader reader(InjectableValues injectableValues) {\n        return _newReader(getDeserializationConfig(), null, null,\n                null, injectableValues);\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * deserialize objects using specified JSON View (filter).\n     */\n    public ObjectReader readerWithView(Class<?> view) {\n        return _newReader(getDeserializationConfig().withView(view));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectReader reader(Base64Variant defaultBase64) {\n        return _newReader(getDeserializationConfig().with(defaultBase64));\n    }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectReader reader(ContextAttributes attrs) {\n        return _newReader(getDeserializationConfig().with(attrs));\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #readerFor(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectReader reader(JavaType type) {\n        return _newReader(getDeserializationConfig(), type, null,\n                null, _injectableValues);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #readerFor(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader reader(Class<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /**\n     * @deprecated Since 2.5, use {@link #readerFor(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectReader reader(TypeReference<?> type) {\n        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n                null, _injectableValues);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: convenience type conversion\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for doing two-step conversion from given value, into\n     * instance of given value type, if (but only if!) conversion is needed.\n     * If given value is already of requested type, value is returned as is.\n     *<p>\n     * This method is functionally similar to first\n     * serializing given value into JSON, and then binding JSON data into value\n     * of given type, but should be more efficient since full serialization does\n     * not (need to) occur.\n     * However, same converters (serializers, deserializers) will be used as for\n     * data binding, meaning same object mapper configuration works.\n     *<p>\n     * Note that it is possible that in some cases behavior does differ from\n     * full serialize-then-deserialize cycle: in most case differences are\n     * unintentional (that is, flaws to fix) and should be reported.\n     * It is not guaranteed, however, that the behavior is 100% the same:\n     * the goal is just to allow efficient value conversions for structurally\n     * compatible Objects, according to standard Jackson configuration.\n     *<p>\n     * Further note that functianality is not designed to support \"advanced\" use\n     * cases, such as conversion of polymorphic values, or cases where Object Identity\n     * is used.\n     *      \n     * @throws IllegalArgumentException If conversion fails due to incompatible type;\n     *    if so, root cause will contain underlying checked exception data binding\n     *    functionality threw\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    /**\n     * See {@link #convertValue(Object, Class)}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n        throws IllegalArgumentException\n    {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    /**\n     * See {@link #convertValue(Object, Class)}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            buf = buf.forceUseOfBigDecimal(true);\n        }\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: JSON Schema generation\n    /**********************************************************\n     */\n\n    /**\n     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n     * instance for specified class.\n     *\n     * @param t The class to generate schema for\n     * @return Constructed JSON schema.\n     * \n     * @deprecated Since 2.6 use external JSON Schema generator (https://github.com/FasterXML/jackson-module-jsonSchema)\n     */\n    @Deprecated\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">JSON Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     * Visitation uses <code>Serializer</code> hierarchy and related properties\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">JSON Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for serialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used for constructing\n     * {@link SerializerProvider} to use for serialization.\n     */\n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }\n    \n    /**\n     * @deprecated Since 2.6, use {@link SerializationConfig#constructDefaultPrettyPrinter()} directly\n     */\n    @Deprecated\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _serializationConfig.constructDefaultPrettyPrinter();\n    }\n\n    /**\n     * Method called to configure the generator as necessary and then\n     * call write functionality\n     */\n    protected final void _configAndWriteValue(JsonGenerator g, Object value)\n        throws IOException\n    {\n        SerializationConfig cfg = getSerializationConfig();\n        cfg.initialize(g); // since 2.5\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            /* won't try to close twice; also, must catch exception (so it \n             * will not mask exception that is pending)\n             */\n            if (!closed) {\n                /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                 *    structures, which typically causes more damage.\n                 */\n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass)\n        throws IOException\n    {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        cfg.initialize(g); // since 2.5\n\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(g, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            closed = true;\n            g.close();\n        } finally {\n            if (!closed) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            JsonGenerator tmpGen = g;\n            g = null;\n            tmpGen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (g != null) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    g.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n    \n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(g, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                g.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods for deserialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg) {\n        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n    }\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: may need to read the next token, to initialize\n         * state (either before first read from parser, or after\n         * previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            // ok, let's get the value\n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            // Need to consume the token too\n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }\n    \n    /**\n     * Method called to ensure that given parser is ready for reading\n     * content for data binding.\n     *\n     * @return First token to be used for data binding after this call:\n     *  can never be null as exception will be thrown if parser can not\n     *  provide more tokens.\n     *\n     * @throws IOException if the underlying input source has problems during\n     *   parsing\n     * @throws JsonParseException if parser has problems parsing content\n     * @throws JsonMappingException if the parser does not have any more\n     *   content to map (note: Json \"null\" value is considered content;\n     *   enf-of-stream not)\n     */\n    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        _deserializationConfig.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n            // and then we must get something...\n            t = p.nextToken();\n            if (t == null) {\n                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                 *   not an actual parsing problem\n                 */\n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, \n            DeserializationConfig config,\n            JavaType rootType, JsonDeserializer<Object> deser)\n        throws IOException\n    {\n        PropertyName expRootName = config.findRootName(rootType);\n        // 12-Jun-2015, tatu: Should try to support namespaces etc but...\n        String expSimpleName = expRootName.getSimpleName();\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        p.nextToken();\n        Object result = deser.deserialize(p, ctxt);\n        // and last, verify that we now get matching END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.util.TokenBuffer", "buggy_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n\n    /**\n     * Flag set during construction, if use of {@link BigDecimal} is to be forced\n     * on all floating-point values.\n     *\n     * @since 2.7\n     */\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser p) {\n        this(p, null);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.7\n     */\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser p = other.asParser();\n        while (p.nextToken() != null) {\n            copyCurrentStructure(p);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator gen) throws IOException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    gen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    gen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                gen.writeStartObject();\n                break;\n            case END_OBJECT:\n                gen.writeEndObject();\n                break;\n            case START_ARRAY:\n                gen.writeStartArray();\n                break;\n            case END_ARRAY:\n                gen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    gen.writeFieldName((SerializableString) ob);\n                } else {\n                    gen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        gen.writeString((SerializableString) ob);\n                    } else {\n                        gen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        gen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        gen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        gen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        gen.writeNumber((Short) n);\n                    } else {\n                        gen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        gen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        gen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        gen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        gen.writeNull();\n                    } else if (n instanceof String) {\n                        gen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                gen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                gen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                gen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                {\n                    Object value = segment.get(ptr);\n                    if (value instanceof RawValue) {\n                        ((RawValue) value).serialize(gen);\n                    } else {\n                        gen.writeObject(value);\n                    }\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(p);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(p);\n        } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        if (offset > 0 || len != text.length()) {\n            text = text.substring(offset, offset+len);\n        }\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class || (value instanceof RawValue)) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        }\n        if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken() throws IOException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public String nextFieldName() throws IOException\n        {\n            // inlined common case from nextToken()\n            if (_closed || (_segment == null)) return null;\n\n            int ptr = _segmentPtr+1;\n            if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {\n                _segmentPtr = ptr;\n                Object ob = _segment.get(ptr); // inlined _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n                return name;\n            }\n            return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n\n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() {\n            // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                JsonReadContext parent = _parsingContext.getParent();\n                return parent.getCurrentName();\n            }\n            return _parsingContext.getCurrentName();\n        }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n\n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n\n    /**\n     * Flag set during construction, if use of {@link BigDecimal} is to be forced\n     * on all floating-point values.\n     *\n     * @since 2.7\n     */\n    protected boolean _forceBigDecimal;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser p) {\n        this(p, null);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        _forceBigDecimal = (ctxt == null) ? false\n                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n        _forceBigDecimal = b;\n        return this;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser p = other.asParser();\n        while (p.nextToken() != null) {\n            copyCurrentStructure(p);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator gen) throws IOException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    gen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    gen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                gen.writeStartObject();\n                break;\n            case END_OBJECT:\n                gen.writeEndObject();\n                break;\n            case START_ARRAY:\n                gen.writeStartArray();\n                break;\n            case END_ARRAY:\n                gen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    gen.writeFieldName((SerializableString) ob);\n                } else {\n                    gen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        gen.writeString((SerializableString) ob);\n                    } else {\n                        gen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        gen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        gen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        gen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        gen.writeNumber((Short) n);\n                    } else {\n                        gen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        gen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        gen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        gen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        gen.writeNull();\n                    } else if (n instanceof String) {\n                        gen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                gen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                gen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                gen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                {\n                    Object value = segment.get(ptr);\n                    if (value instanceof RawValue) {\n                        ((RawValue) value).serialize(gen);\n                    } else {\n                        gen.writeObject(value);\n                    }\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(p);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(p);\n        } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        if (offset > 0 || len != text.length()) {\n            text = text.substring(offset, offset+len);\n        }\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class || (value instanceof RawValue)) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        }\n        if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            if (_forceBigDecimal) {\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                writeNumber(p.getDecimalValue());\n            } else {\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n                }\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken() throws IOException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public String nextFieldName() throws IOException\n        {\n            // inlined common case from nextToken()\n            if (_closed || (_segment == null)) return null;\n\n            int ptr = _segmentPtr+1;\n            if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {\n                _segmentPtr = ptr;\n                Object ob = _segment.get(ptr); // inlined _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n                return name;\n            }\n            return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n\n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() {\n            // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                JsonReadContext parent = _parsingContext.getParent();\n                return parent.getCurrentName();\n            }\n            return _parsingContext.getCurrentName();\n        }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n\n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 31, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.util.TokenBuffer", "buggy_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n\n    /**\n     * Flag set during construction, if use of {@link BigDecimal} is to be forced\n     * on all floating-point values.\n     *\n     * @since 2.7\n     */\n    protected boolean _forceBigDecimal;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser p) {\n        this(p, null);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        _forceBigDecimal = (ctxt == null) ? false\n                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n        _forceBigDecimal = b;\n        return this;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser p = other.asParser();\n        while (p.nextToken() != null) {\n            copyCurrentStructure(p);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator gen) throws IOException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    gen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    gen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                gen.writeStartObject();\n                break;\n            case END_OBJECT:\n                gen.writeEndObject();\n                break;\n            case START_ARRAY:\n                gen.writeStartArray();\n                break;\n            case END_ARRAY:\n                gen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    gen.writeFieldName((SerializableString) ob);\n                } else {\n                    gen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        gen.writeString((SerializableString) ob);\n                    } else {\n                        gen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        gen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        gen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        gen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        gen.writeNumber((Short) n);\n                    } else {\n                        gen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        gen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        gen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        gen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        gen.writeNull();\n                    } else if (n instanceof String) {\n                        gen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                gen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                gen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                gen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                {\n                    Object value = segment.get(ptr);\n                    if (value instanceof RawValue) {\n                        ((RawValue) value).serialize(gen);\n                    } else {\n                        gen.writeObject(value);\n                    }\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(p);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per [databind#592], need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(p);\n        } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        if (offset > 0 || len != text.length()) {\n            text = text.substring(offset, offset+len);\n        }\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class || (value instanceof RawValue)) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        }\n        if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            if (_forceBigDecimal) {\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                writeNumber(p.getDecimalValue());\n            } else {\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n                }\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    /**\n     * Similar to {@link #_append(JsonToken)} but also updates context with\n     * knowledge that a scalar value was written\n     *\n     * @since 2.6.4\n     */\n\n    /**\n     * Similar to {@link #_append(JsonToken,Object)} but also updates context with\n     * knowledge that a scalar value was written\n     *\n     * @since 2.6.4\n     */\n    \n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken() throws IOException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public String nextFieldName() throws IOException\n        {\n            // inlined common case from nextToken()\n            if (_closed || (_segment == null)) return null;\n\n            int ptr = _segmentPtr+1;\n            if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {\n                _segmentPtr = ptr;\n                Object ob = _segment.get(ptr); // inlined _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n                return name;\n            }\n            return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n\n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() {\n            // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                JsonReadContext parent = _parsingContext.getParent();\n                return parent.getCurrentName();\n            }\n            return _parsingContext.getCurrentName();\n        }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n\n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.TreeMap;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.databind.*;\n\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n\n    /**\n     * Flag set during construction, if use of {@link BigDecimal} is to be forced\n     * on all floating-point values.\n     *\n     * @since 2.7\n     */\n    protected boolean _forceBigDecimal;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n        this(codec, false);\n    }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n        _objectCodec = codec;\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = hasNativeIds;\n        _hasNativeObjectIds = hasNativeIds;\n\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser p) {\n        this(p, null);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer(JsonParser p, DeserializationContext ctxt)\n    {\n        _objectCodec = p.getCodec();\n        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n        _writeContext = JsonWriteContext.createRootContext(null);\n        // at first we have just one segment\n        _first = _last = new Segment();\n        _appendAt = 0;\n        _hasNativeTypeIds = p.canReadTypeId();\n        _hasNativeObjectIds = p.canReadObjectId();\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        _forceBigDecimal = (ctxt == null) ? false\n                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n        _forceBigDecimal = b;\n        return this;\n    }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n    }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n        p.setLocation(src.getTokenLocation());\n        return p;\n    }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other) throws IOException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser p = other.asParser();\n        while (p.nextToken() != null) {\n            copyCurrentStructure(p);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator gen) throws IOException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    gen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    gen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                gen.writeStartObject();\n                break;\n            case END_OBJECT:\n                gen.writeEndObject();\n                break;\n            case START_ARRAY:\n                gen.writeStartArray();\n                break;\n            case END_ARRAY:\n                gen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    gen.writeFieldName((SerializableString) ob);\n                } else {\n                    gen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        gen.writeString((SerializableString) ob);\n                    } else {\n                        gen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        gen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        gen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        gen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        gen.writeNumber((Short) n);\n                    } else {\n                        gen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        gen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        gen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        gen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        gen.writeNull();\n                    } else if (n instanceof String) {\n                        gen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                gen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                gen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                gen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                {\n                    Object value = segment.get(ptr);\n                    if (value instanceof RawValue) {\n                        ((RawValue) value).serialize(gen);\n                    } else {\n                        gen.writeObject(value);\n                    }\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(p);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per [databind#592], need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(p);\n        } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }\n\n    @Override\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override\n    public ObjectCodec getCodec() { return _objectCodec; }\n\n    @Override\n    public final JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _appendValue(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _appendValue(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        if (offset > 0 || len != text.length()) {\n            text = text.substring(offset, offset+len);\n        }\n        _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException {\n        _appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException {\n        _appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException {\n        _appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException {\n        _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException {\n        _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException {\n        if (dec == null) {\n            writeNull();\n        } else {\n            _appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException {\n        if (v == null) {\n            writeNull();\n        } else {\n            _appendValue(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException {\n        _appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _appendValue(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class || (value instanceof RawValue)) {\n            _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        }\n        if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }\n\n    @Override\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }\n    \n    @Override\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }\n    \n    @Override\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            if (_forceBigDecimal) {\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                writeNumber(p.getDecimalValue());\n            } else {\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n                }\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    /**\n     * Similar to {@link #_append(JsonToken)} but also updates context with\n     * knowledge that a scalar value was written\n     *\n     * @since 2.6.4\n     */\n    protected final void _appendValue(JsonToken type)\n    {\n        _writeContext.writeValue();\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }\n\n    /**\n     * Similar to {@link #_append(JsonToken,Object)} but also updates context with\n     * knowledge that a scalar value was written\n     *\n     * @since 2.6.4\n     */\n    protected final void _appendValue(JsonToken type, Object value)\n    {\n        _writeContext.writeValue();\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n    \n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n            super(0);\n            _segment = firstSeg;\n            _segmentPtr = -1; // not yet read\n            _codec = codec;\n            _parsingContext = JsonReadContext.createRootContext(null);\n            _hasNativeTypeIds = hasNativeTypeIds;\n            _hasNativeObjectIds = hasNativeObjectIds;\n            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n        }\n\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }\n        \n        @Override\n        public ObjectCodec getCodec() { return _codec; }\n\n        @Override\n        public void setCodec(ObjectCodec c) { _codec = c; }\n\n        @Override\n        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken() throws IOException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }\n\n        @Override\n        public String nextFieldName() throws IOException\n        {\n            // inlined common case from nextToken()\n            if (_closed || (_segment == null)) return null;\n\n            int ptr = _segmentPtr+1;\n            if (ptr < Segment.TOKENS_PER_SEGMENT && _segment.type(ptr) == JsonToken.FIELD_NAME) {\n                _segmentPtr = ptr;\n                Object ob = _segment.get(ptr); // inlined _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n                return name;\n            }\n            return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n        }\n\n        @Override\n        public boolean isClosed() { return _closed; }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n\n        @Override\n        public JsonStreamContext getParsingContext() { return _parsingContext; }\n\n        @Override\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }\n\n        @Override\n        public String getCurrentName() {\n            // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                JsonReadContext parent = _parsingContext.getParent();\n                return parent.getCurrentName();\n            }\n            return _parsingContext.getCurrentName();\n        }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n\n        @Override\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }\n\n        @Override\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }\n\n        @Override\n        public int getTextOffset() { return 0; }\n\n        @Override\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }\n\n        @Override\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }\n\n        @Override\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n        public final static int TOKENS_PER_SEGMENT = 16;\n        \n        /**\n         * Static array used for fast conversion between token markers and\n         * matching {@link JsonToken} instances\n         */\n        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n        static {\n            // ... here we know that there are <= 15 values in JsonToken enum\n            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n            JsonToken[] t = JsonToken.values();\n            // and reserve entry 0 for \"not available\"\n            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n        }\n\n        // // // Linking\n        \n        protected Segment _next;\n        \n        // // // State\n\n        /**\n         * Bit field used to store types of buffered tokens; 4 bits per token.\n         * Value 0 is reserved for \"not in use\"\n         */\n        protected long _tokenTypes;\n\n        \n        // Actual tokens\n\n        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n\n        /**\n         * Lazily constructed Map for storing native type and object ids, if any\n         */\n        protected TreeMap<Integer,Object> _nativeIds;\n        \n        public Segment() { }\n\n        // // // Accessors\n\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }\n\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }\n        \n        public Object get(int index) {\n            return _tokens[index];\n        }\n\n        public Segment next() { return _next; }\n\n        /**\n         * Accessor for checking whether this segment may have native\n         * type or object ids.\n         */\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }\n        \n        // // // Mutators\n        \n        public Segment append(int index, JsonToken tokenType)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, objectId, typeId);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value);\n            return _next;\n        }\n\n        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }\n\n        public Segment appendRaw(int index, int rawTokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value, objectId, typeId);\n            return _next;\n        }\n\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType,\n                Object objectId, Object typeId)\n        {\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, JsonToken tokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private void set(int index, int rawTokenType, Object value)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }\n\n        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }\n\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }\n        \n        /**\n         * @since 2.3\n         */\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }\n\n        private final int _typeIdIndex(int i) { return i+i; }\n        private final int _objectIdIndex(int i) { return i+i+1; }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 32, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n/**\n * Deserializer implementation that is used if it is necessary to bind content of\n * \"unknown\" type; something declared as basic {@link java.lang.Object}\n * (either explicitly, or due to type erasure).\n * If so, \"natural\" mapping is used to convert JSON values to their natural\n * Java object matches: JSON arrays to Java {@link java.util.List}s (or, if configured,\n * Object[]), JSON objects to {@link java.util.Map}s, numbers to\n * {@link java.lang.Number}s, booleans to {@link java.lang.Boolean}s and\n * strings to {@link java.lang.String} (and nulls to nulls).\n */\n@JacksonStdImpl\npublic class UntypedObjectDeserializer\n    extends StdDeserializer<Object>\n    implements ResolvableDeserializer, ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final static Object[] NO_OBJECTS = new Object[0];\n\n    /**\n     * @deprecated Since 2.3, construct a new instance, needs to be resolved\n     */\n    @Deprecated\n    public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer(null, null);\n\n    /*\n    /**********************************************************\n    /* Possible custom deserializer overrides we need to use\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _mapDeserializer;\n\n    protected JsonDeserializer<Object> _listDeserializer;\n\n    protected JsonDeserializer<Object> _stringDeserializer;\n\n    protected JsonDeserializer<Object> _numberDeserializer;\n\n    /**\n     * If {@link java.util.List} has been mapped to non-default implementation,\n     * we'll store type here\n     *\n     * @since 2.6\n     */\n    protected JavaType _listType;\n\n    /**\n     * If {@link java.util.Map} has been mapped to non-default implementation,\n     * we'll store type here\n     *\n     * @since 2.6\n     */\n    protected JavaType _mapType;\n\n    /**\n     * @deprecated Since 2.6 use variant takes type arguments\n     */\n    @Deprecated\n    public UntypedObjectDeserializer() {\n        this(null, null);\n    }\n\n    public UntypedObjectDeserializer(JavaType listType, JavaType mapType) {\n        super(Object.class);\n        _listType = listType;\n        _mapType = mapType;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public UntypedObjectDeserializer(UntypedObjectDeserializer base,\n            JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser,\n            JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser)\n    {\n        super(Object.class);\n        _mapDeserializer = (JsonDeserializer<Object>) mapDeser;\n        _listDeserializer = (JsonDeserializer<Object>) listDeser;\n        _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n        _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n        _listType = base._listType;\n        _mapType = base._mapType;\n    }\n\n    /*\n    /**********************************************************\n    /* Initialization\n    /**********************************************************\n     */\n\n    /**\n     * We need to implement this method to properly find things to delegate\n     * to: it can not be done earlier since delegated deserializers almost\n     * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n    {\n        JavaType obType = ctxt.constructType(Object.class);\n        JavaType stringType = ctxt.constructType(String.class);\n        TypeFactory tf = ctxt.getTypeFactory();\n\n        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n         *    should always be called separately, from within \"createContextual()\".\n         *    But this is a very singular deserializer since it operates on `Object`\n         *    (and often for `?` type parameter), and as a result, easily and commonly\n         *    results in cycles, being value deserializer for various Maps and Collections.\n         *    Because of this, we must somehow break the cycles. This is done here by\n         *    forcing pseudo-contextualization with null property.\n         */\n\n        // So: first find possible custom instances\n        if (_listType == null) {\n            _listDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType)));\n        } else {\n            // NOTE: if non-default List type, always consider to be non-standard deser\n            _listDeserializer = _findCustomDeser(ctxt, _listType);\n        }\n        if (_mapType == null) {\n            _mapDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType)));\n        } else {\n            // NOTE: if non-default Map type, always consider to be non-standard deser\n            _mapDeserializer = _findCustomDeser(ctxt, _mapType);\n        }\n        _stringDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, stringType));\n        _numberDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructType(Number.class)));\n\n        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n        // their own\n        JavaType unknown = TypeFactory.unknownType();\n        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null, unknown);\n        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null, unknown);\n        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null, unknown);\n        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null, unknown);\n    }\n\n    protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n        throws JsonMappingException\n    {\n        // Since we are calling from `resolve`, we should NOT try to contextualize yet;\n        // contextualization will only occur at a later point\n        return ctxt.findNonContextualValueDeserializer(type);\n    }\n\n    protected JsonDeserializer<Object> _clearIfStdImpl(JsonDeserializer<Object> deser) {\n        return ClassUtil.isJacksonStdImpl(deser) ? null : deser;\n    }\n\n    /**\n     * We only use contextualization for optimizing the case where no customization\n     * occurred; if so, can slip in a more streamlined version.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // 20-Apr-2014, tatu: If nothing custom, let's use \"vanilla\" instance,\n        //     simpler and can avoid some of delegation\n        if ((_stringDeserializer == null) && (_numberDeserializer == null)\n                && (_mapDeserializer == null) && (_listDeserializer == null)\n                &&  getClass() == UntypedObjectDeserializer.class) {\n            return Vanilla.std;\n        }\n        return this;\n    }\n\n    protected JsonDeserializer<?> _withResolved(JsonDeserializer<?> mapDeser,\n            JsonDeserializer<?> listDeser,\n            JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser) {\n        return new UntypedObjectDeserializer(this,\n                mapDeser, listDeser, stringDeser, numberDeser);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializer API\n    /**********************************************************\n     */\n\n    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n     *   sense to also mark this is cachable, since lookup not exactly free, and\n     *   since it's not uncommon to \"read anything\"\n     */\n    @Override\n    public boolean isCachable() {\n        /* 26-Mar-2015, tatu: With respect to [databind#735], there are concerns over\n         *   cachability. It seems like we SHOULD be safe here; but just in case there\n         *   are problems with false sharing, this may need to be revisited.\n         */\n        return true;\n    }\n\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            /* Caller may want to get all integral values returned as {@link java.math.BigInteger},\n             * or {@link java.lang.Long} for consistency\n             */\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); // should be optimal, whatever it is\n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            /* [JACKSON-72]: need to allow overriding the behavior regarding\n             *   which type to use\n             */\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: // should not get this but...\n            return null;\n\n//        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        // First: does it look like we had type id wrapping of some kind?\n        case JsonTokenId.ID_START_ARRAY:\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            /* Output can be as JSON Object, Array or scalar: no way to know\n             * a this point:\n             */\n            return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n            \n        /* Otherwise we probably got a \"native\" type (ones that map\n         * naturally and thus do not need or use type ids)\n         */\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            // May need coercion to \"bigger\" types:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); // should be optimal, whatever it is\n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: // should not get this far really but...\n            return null;\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to map a JSON Array into a Java value.\n     */\n    protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Minor optimization to handle small lists (default size for ArrayList is 10)\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return new ArrayList<Object>(2);\n        }\n        Object value = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            return l;\n        }\n        Object value2 = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            l.add(value2);\n            return l;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        values[ptr++] = value;\n        values[ptr++] = value2;\n        int totalSize = ptr;\n        do {\n            value = deserialize(jp, ctxt);\n            ++totalSize;\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        // let's create full array then\n        ArrayList<Object> result = new ArrayList<Object>(totalSize);\n        buffer.completeAndClearBuffer(values, ptr, result);\n        return result;\n    }\n\n    /**\n     * Method called to map a JSON Object into a Java value.\n     */\n    protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        String key1;\n\n        JsonToken t = p.getCurrentToken();\n        \n        if (t == JsonToken.START_OBJECT) {\n            key1 = p.nextFieldName();\n        } else if (t == JsonToken.FIELD_NAME) {\n            key1 = p.getCurrentName();\n        } else {\n            if (t != JsonToken.END_OBJECT) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key1 = null;\n        }\n        if (key1 == null) {\n            // empty map might work; but caller may want to modify... so better just give small modifiable\n            return new LinkedHashMap<String,Object>(2);\n        }\n        // minor optimization; let's handle 1 and 2 entry cases separately\n        // 24-Mar-2015, tatu: Ideally, could use one of 'nextXxx()' methods, but for\n        //   that we'd need new method(s) in JsonDeserializer. So not quite yet.\n        p.nextToken();\n        Object value1 = deserialize(p, ctxt);\n\n        String key2 = p.nextFieldName();\n        if (key2 == null) { // has to be END_OBJECT, then\n            // single entry; but we want modifiable\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n            result.put(key1, value1);\n            return result;\n        }\n        p.nextToken();\n        Object value2 = deserialize(p, ctxt);\n\n        String key = p.nextFieldName();\n\n        if (key == null) {\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n            result.put(key1, value1);\n            result.put(key2, value2);\n            return result;\n        }\n        // And then the general case; default map size is 16\n        LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n        result.put(key1, value1);\n        result.put(key2, value2);\n\n        do {\n            p.nextToken();\n            result.put(key, deserialize(p, ctxt));\n        } while ((key = p.nextFieldName()) != null);\n        return result;\n    }\n\n    /**\n     * Method called to map a JSON Array into a Java Object array (Object[]).\n     */\n    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Minor optimization to handle small lists (default size for ArrayList is 10)\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return NO_OBJECTS;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        do {\n            Object value = deserialize(jp, ctxt);\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        return buffer.completeAndClearBuffer(values, ptr);\n    }\n\n    /*\n    /**********************************************************\n    /* Separate \"vanilla\" implementation for common case of\n    /* no custom deserializer overrides\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    public static class Vanilla\n        extends StdDeserializer<Object>\n    {\n        private static final long serialVersionUID = 1L;\n\n        public final static Vanilla std = new Vanilla();\n\n        public Vanilla() { super(Object.class); }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_OBJECT:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_OBJECT) {\n                        return new LinkedHashMap<String,Object>(2);\n                    }\n                }\n            case JsonTokenId.ID_FIELD_NAME:\n                return mapObject(p, ctxt);\n            case JsonTokenId.ID_START_ARRAY:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_ARRAY) { // and empty one too\n                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                            return NO_OBJECTS;\n                        }\n                        return new ArrayList<Object>(2);\n                    }\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return p.getEmbeddedObject();\n            case JsonTokenId.ID_STRING:\n                return p.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue(); // should be optimal, whatever it is\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n\n            case JsonTokenId.ID_NULL: // should not get this but...\n                return null;\n\n                // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n                //    if caller has advanced to the first token of Object, but for empty Object\n\n            //case JsonTokenId.ID_END_ARRAY: // invalid\n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException\n        {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_ARRAY:\n            case JsonTokenId.ID_START_OBJECT:\n            case JsonTokenId.ID_FIELD_NAME:\n                return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n\n            case JsonTokenId.ID_STRING:\n                return jp.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                    return jp.getBigIntegerValue();\n                }\n                return jp.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return jp.getDecimalValue();\n                }\n                return Double.valueOf(jp.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return jp.getEmbeddedObject();\n\n            case JsonTokenId.ID_NULL: // should not get this far really but...\n                return null;\n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n        {\n            Object value = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                return l;\n            }\n            Object value2 = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                l.add(value2);\n                return l;\n            }\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            values[ptr++] = value;\n            values[ptr++] = value2;\n            int totalSize = ptr;\n            do {\n                value = deserialize(jp, ctxt);\n                ++totalSize;\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            // let's create full array then\n            ArrayList<Object> result = new ArrayList<Object>(totalSize);\n            buffer.completeAndClearBuffer(values, ptr, result);\n            return result;\n        }\n\n        /**\n         * Method called to map a JSON Object into a Java value.\n         */\n        protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            // will point to FIELD_NAME at this point, guaranteed\n            String key1 = p.getText();\n            p.nextToken();\n            Object value1 = deserialize(p, ctxt);\n\n            String key2 = p.nextFieldName();\n            if (key2 == null) { // single entry; but we want modifiable\n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n                result.put(key1, value1);\n                return result;\n            }\n            p.nextToken();\n            Object value2 = deserialize(p, ctxt);\n\n            String key = p.nextFieldName();\n            if (key == null) {\n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n                result.put(key1, value1);\n                result.put(key2, value2);\n                return result;\n            }\n            // And then the general case; default map size is 16\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n            result.put(key1, value1);\n            result.put(key2, value2);\n            do {\n                p.nextToken();\n                result.put(key, deserialize(p, ctxt));\n            } while ((key = p.nextFieldName()) != null);\n            return result;\n        }\n\n        /**\n         * Method called to map a JSON Array into a Java Object array (Object[]).\n         */\n        protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            do {\n                Object value = deserialize(jp, ctxt);\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            return buffer.completeAndClearBuffer(values, ptr);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.deser.ContextualDeserializer;\nimport com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.ObjectBuffer;\n\n/**\n * Deserializer implementation that is used if it is necessary to bind content of\n * \"unknown\" type; something declared as basic {@link java.lang.Object}\n * (either explicitly, or due to type erasure).\n * If so, \"natural\" mapping is used to convert JSON values to their natural\n * Java object matches: JSON arrays to Java {@link java.util.List}s (or, if configured,\n * Object[]), JSON objects to {@link java.util.Map}s, numbers to\n * {@link java.lang.Number}s, booleans to {@link java.lang.Boolean}s and\n * strings to {@link java.lang.String} (and nulls to nulls).\n */\n@JacksonStdImpl\npublic class UntypedObjectDeserializer\n    extends StdDeserializer<Object>\n    implements ResolvableDeserializer, ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final static Object[] NO_OBJECTS = new Object[0];\n\n    /**\n     * @deprecated Since 2.3, construct a new instance, needs to be resolved\n     */\n    @Deprecated\n    public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer(null, null);\n\n    /*\n    /**********************************************************\n    /* Possible custom deserializer overrides we need to use\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _mapDeserializer;\n\n    protected JsonDeserializer<Object> _listDeserializer;\n\n    protected JsonDeserializer<Object> _stringDeserializer;\n\n    protected JsonDeserializer<Object> _numberDeserializer;\n\n    /**\n     * If {@link java.util.List} has been mapped to non-default implementation,\n     * we'll store type here\n     *\n     * @since 2.6\n     */\n    protected JavaType _listType;\n\n    /**\n     * If {@link java.util.Map} has been mapped to non-default implementation,\n     * we'll store type here\n     *\n     * @since 2.6\n     */\n    protected JavaType _mapType;\n\n    /**\n     * @deprecated Since 2.6 use variant takes type arguments\n     */\n    @Deprecated\n    public UntypedObjectDeserializer() {\n        this(null, null);\n    }\n\n    public UntypedObjectDeserializer(JavaType listType, JavaType mapType) {\n        super(Object.class);\n        _listType = listType;\n        _mapType = mapType;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public UntypedObjectDeserializer(UntypedObjectDeserializer base,\n            JsonDeserializer<?> mapDeser, JsonDeserializer<?> listDeser,\n            JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser)\n    {\n        super(Object.class);\n        _mapDeserializer = (JsonDeserializer<Object>) mapDeser;\n        _listDeserializer = (JsonDeserializer<Object>) listDeser;\n        _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n        _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n        _listType = base._listType;\n        _mapType = base._mapType;\n    }\n\n    /*\n    /**********************************************************\n    /* Initialization\n    /**********************************************************\n     */\n\n    /**\n     * We need to implement this method to properly find things to delegate\n     * to: it can not be done earlier since delegated deserializers almost\n     * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n    {\n        JavaType obType = ctxt.constructType(Object.class);\n        JavaType stringType = ctxt.constructType(String.class);\n        TypeFactory tf = ctxt.getTypeFactory();\n\n        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n         *    should always be called separately, from within \"createContextual()\".\n         *    But this is a very singular deserializer since it operates on `Object`\n         *    (and often for `?` type parameter), and as a result, easily and commonly\n         *    results in cycles, being value deserializer for various Maps and Collections.\n         *    Because of this, we must somehow break the cycles. This is done here by\n         *    forcing pseudo-contextualization with null property.\n         */\n\n        // So: first find possible custom instances\n        if (_listType == null) {\n            _listDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType)));\n        } else {\n            // NOTE: if non-default List type, always consider to be non-standard deser\n            _listDeserializer = _findCustomDeser(ctxt, _listType);\n        }\n        if (_mapType == null) {\n            _mapDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType)));\n        } else {\n            // NOTE: if non-default Map type, always consider to be non-standard deser\n            _mapDeserializer = _findCustomDeser(ctxt, _mapType);\n        }\n        _stringDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, stringType));\n        _numberDeserializer = _clearIfStdImpl(_findCustomDeser(ctxt, tf.constructType(Number.class)));\n\n        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n        // their own\n        JavaType unknown = TypeFactory.unknownType();\n        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null, unknown);\n        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null, unknown);\n        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null, unknown);\n        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null, unknown);\n    }\n\n    protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n        throws JsonMappingException\n    {\n        // Since we are calling from `resolve`, we should NOT try to contextualize yet;\n        // contextualization will only occur at a later point\n        return ctxt.findNonContextualValueDeserializer(type);\n    }\n\n    protected JsonDeserializer<Object> _clearIfStdImpl(JsonDeserializer<Object> deser) {\n        return ClassUtil.isJacksonStdImpl(deser) ? null : deser;\n    }\n\n    /**\n     * We only use contextualization for optimizing the case where no customization\n     * occurred; if so, can slip in a more streamlined version.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // 20-Apr-2014, tatu: If nothing custom, let's use \"vanilla\" instance,\n        //     simpler and can avoid some of delegation\n        if ((_stringDeserializer == null) && (_numberDeserializer == null)\n                && (_mapDeserializer == null) && (_listDeserializer == null)\n                &&  getClass() == UntypedObjectDeserializer.class) {\n            return Vanilla.std;\n        }\n        return this;\n    }\n\n    protected JsonDeserializer<?> _withResolved(JsonDeserializer<?> mapDeser,\n            JsonDeserializer<?> listDeser,\n            JsonDeserializer<?> stringDeser, JsonDeserializer<?> numberDeser) {\n        return new UntypedObjectDeserializer(this,\n                mapDeser, listDeser, stringDeser, numberDeser);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializer API\n    /**********************************************************\n     */\n\n    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n     *   sense to also mark this is cachable, since lookup not exactly free, and\n     *   since it's not uncommon to \"read anything\"\n     */\n    @Override\n    public boolean isCachable() {\n        /* 26-Mar-2015, tatu: With respect to [databind#735], there are concerns over\n         *   cachability. It seems like we SHOULD be safe here; but just in case there\n         *   are problems with false sharing, this may need to be revisited.\n         */\n        return true;\n    }\n\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n        case JsonTokenId.ID_END_OBJECT:\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            /* Caller may want to get all integral values returned as {@link java.math.BigInteger},\n             * or {@link java.lang.Long} for consistency\n             */\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); // should be optimal, whatever it is\n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            /* [JACKSON-72]: need to allow overriding the behavior regarding\n             *   which type to use\n             */\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: // should not get this but...\n            return null;\n\n//        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        // First: does it look like we had type id wrapping of some kind?\n        case JsonTokenId.ID_START_ARRAY:\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            /* Output can be as JSON Object, Array or scalar: no way to know\n             * a this point:\n             */\n            return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n            \n        /* Otherwise we probably got a \"native\" type (ones that map\n         * naturally and thus do not need or use type ids)\n         */\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            // May need coercion to \"bigger\" types:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue(); // should be optimal, whatever it is\n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case JsonTokenId.ID_NULL: // should not get this far really but...\n            return null;\n        default:\n        }\n        throw ctxt.mappingException(Object.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to map a JSON Array into a Java value.\n     */\n    protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Minor optimization to handle small lists (default size for ArrayList is 10)\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return new ArrayList<Object>(2);\n        }\n        Object value = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            return l;\n        }\n        Object value2 = deserialize(jp, ctxt);\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            ArrayList<Object> l = new ArrayList<Object>(2);\n            l.add(value);\n            l.add(value2);\n            return l;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        values[ptr++] = value;\n        values[ptr++] = value2;\n        int totalSize = ptr;\n        do {\n            value = deserialize(jp, ctxt);\n            ++totalSize;\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        // let's create full array then\n        ArrayList<Object> result = new ArrayList<Object>(totalSize);\n        buffer.completeAndClearBuffer(values, ptr, result);\n        return result;\n    }\n\n    /**\n     * Method called to map a JSON Object into a Java value.\n     */\n    protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        String key1;\n\n        JsonToken t = p.getCurrentToken();\n        \n        if (t == JsonToken.START_OBJECT) {\n            key1 = p.nextFieldName();\n        } else if (t == JsonToken.FIELD_NAME) {\n            key1 = p.getCurrentName();\n        } else {\n            if (t != JsonToken.END_OBJECT) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key1 = null;\n        }\n        if (key1 == null) {\n            // empty map might work; but caller may want to modify... so better just give small modifiable\n            return new LinkedHashMap<String,Object>(2);\n        }\n        // minor optimization; let's handle 1 and 2 entry cases separately\n        // 24-Mar-2015, tatu: Ideally, could use one of 'nextXxx()' methods, but for\n        //   that we'd need new method(s) in JsonDeserializer. So not quite yet.\n        p.nextToken();\n        Object value1 = deserialize(p, ctxt);\n\n        String key2 = p.nextFieldName();\n        if (key2 == null) { // has to be END_OBJECT, then\n            // single entry; but we want modifiable\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n            result.put(key1, value1);\n            return result;\n        }\n        p.nextToken();\n        Object value2 = deserialize(p, ctxt);\n\n        String key = p.nextFieldName();\n\n        if (key == null) {\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n            result.put(key1, value1);\n            result.put(key2, value2);\n            return result;\n        }\n        // And then the general case; default map size is 16\n        LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n        result.put(key1, value1);\n        result.put(key2, value2);\n\n        do {\n            p.nextToken();\n            result.put(key, deserialize(p, ctxt));\n        } while ((key = p.nextFieldName()) != null);\n        return result;\n    }\n\n    /**\n     * Method called to map a JSON Array into a Java Object array (Object[]).\n     */\n    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Minor optimization to handle small lists (default size for ArrayList is 10)\n        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n            return NO_OBJECTS;\n        }\n        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n        Object[] values = buffer.resetAndStart();\n        int ptr = 0;\n        do {\n            Object value = deserialize(jp, ctxt);\n            if (ptr >= values.length) {\n                values = buffer.appendCompletedChunk(values);\n                ptr = 0;\n            }\n            values[ptr++] = value;\n        } while (jp.nextToken() != JsonToken.END_ARRAY);\n        return buffer.completeAndClearBuffer(values, ptr);\n    }\n\n    /*\n    /**********************************************************\n    /* Separate \"vanilla\" implementation for common case of\n    /* no custom deserializer overrides\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    public static class Vanilla\n        extends StdDeserializer<Object>\n    {\n        private static final long serialVersionUID = 1L;\n\n        public final static Vanilla std = new Vanilla();\n\n        public Vanilla() { super(Object.class); }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_OBJECT:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_OBJECT) {\n                        return new LinkedHashMap<String,Object>(2);\n                    }\n                }\n            case JsonTokenId.ID_FIELD_NAME:\n                return mapObject(p, ctxt);\n            case JsonTokenId.ID_START_ARRAY:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_ARRAY) { // and empty one too\n                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                            return NO_OBJECTS;\n                        }\n                        return new ArrayList<Object>(2);\n                    }\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return p.getEmbeddedObject();\n            case JsonTokenId.ID_STRING:\n                return p.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue(); // should be optimal, whatever it is\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n\n            case JsonTokenId.ID_NULL: // should not get this but...\n                return null;\n\n            case JsonTokenId.ID_END_OBJECT:\n                // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n                //    if caller has advanced to the first token of Object, but for empty Object\n                return new LinkedHashMap<String,Object>(2);\n\n            //case JsonTokenId.ID_END_ARRAY: // invalid\n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException\n        {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_ARRAY:\n            case JsonTokenId.ID_START_OBJECT:\n            case JsonTokenId.ID_FIELD_NAME:\n                return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n\n            case JsonTokenId.ID_STRING:\n                return jp.getText();\n\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                    return jp.getBigIntegerValue();\n                }\n                return jp.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return jp.getDecimalValue();\n                }\n                return Double.valueOf(jp.getDoubleValue());\n\n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return jp.getEmbeddedObject();\n\n            case JsonTokenId.ID_NULL: // should not get this far really but...\n                return null;\n            default:\n                throw ctxt.mappingException(Object.class);\n            }\n        }\n\n        protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n        {\n            Object value = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                return l;\n            }\n            Object value2 = deserialize(jp, ctxt);\n            if (jp.nextToken()  == JsonToken.END_ARRAY) {\n                ArrayList<Object> l = new ArrayList<Object>(2);\n                l.add(value);\n                l.add(value2);\n                return l;\n            }\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            values[ptr++] = value;\n            values[ptr++] = value2;\n            int totalSize = ptr;\n            do {\n                value = deserialize(jp, ctxt);\n                ++totalSize;\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            // let's create full array then\n            ArrayList<Object> result = new ArrayList<Object>(totalSize);\n            buffer.completeAndClearBuffer(values, ptr, result);\n            return result;\n        }\n\n        /**\n         * Method called to map a JSON Object into a Java value.\n         */\n        protected Object mapObject(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            // will point to FIELD_NAME at this point, guaranteed\n            String key1 = p.getText();\n            p.nextToken();\n            Object value1 = deserialize(p, ctxt);\n\n            String key2 = p.nextFieldName();\n            if (key2 == null) { // single entry; but we want modifiable\n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(2);\n                result.put(key1, value1);\n                return result;\n            }\n            p.nextToken();\n            Object value2 = deserialize(p, ctxt);\n\n            String key = p.nextFieldName();\n            if (key == null) {\n                LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n                result.put(key1, value1);\n                result.put(key2, value2);\n                return result;\n            }\n            // And then the general case; default map size is 16\n            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n            result.put(key1, value1);\n            result.put(key2, value2);\n            do {\n                p.nextToken();\n                result.put(key, deserialize(p, ctxt));\n            } while ((key = p.nextFieldName()) != null);\n            return result;\n        }\n\n        /**\n         * Method called to map a JSON Array into a Java Object array (Object[]).\n         */\n        protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n            Object[] values = buffer.resetAndStart();\n            int ptr = 0;\n            do {\n                Object value = deserialize(jp, ctxt);\n                if (ptr >= values.length) {\n                    values = buffer.appendCompletedChunk(values);\n                    ptr = 0;\n                }\n                values[ptr++] = value;\n            } while (jp.nextToken() != JsonToken.END_ARRAY);\n            return buffer.completeAndClearBuffer(values, ptr);\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 33, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector", "buggy_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.RawSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    public JacksonAnnotationIntrospector() { }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotation properties\n    /**********************************************************\n     */\n\n    /**\n     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n     * are considered bundles.\n     */\n    @Override\n    public boolean isAnnotationBundle(Annotation ann) {\n        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotations\n    /**********************************************************\n     */\n\n    /**\n     * Since 2.6, we have supported use of {@link JsonProperty} for specifying\n     * explicit serialized name\n     */\n    @Override\n    public String findEnumValue(Enum<?> value)\n    {\n        // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n        //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n        //   reasons, including odd representation JVM uses); has to do for now\n        try {\n            // We know that values are actually static fields with matching name so:\n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                if (prop != null) {\n                    String n = prop.value();\n                    if (n != null && !n.isEmpty()) {\n                        return n;\n                    }\n                }\n            }\n        } catch (SecurityException e) {\n            // 17-Sep-2015, tatu: Anything we could/should do here?\n        } catch (NoSuchFieldException e) {\n            // 17-Sep-2015, tatu: should not really happen. But... can we do anything?\n        }\n        return value.name();\n    }\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findRootName(AnnotatedClass ac)\n    {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7 or later\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    @Override // since 2.6\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        if (ignore == null) {\n            return null;\n        }\n        // 13-May-2015, tatu: As per [databind#95], allow read-only/write-only props\n        if (forSerialization) {\n            if (ignore.allowGetters()) {\n                return null;\n            }\n        } else {\n            if (ignore.allowSetters()) {\n                return null;\n            }\n        }\n        return ignore.value();\n    }\n    \n    @Override\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.ignoreUnknown();\n    }\n\n    @Override\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    /**\n     * @deprecated (since 2.3) Use {@link #findFilterId(Annotated)} instead\n     */\n    @Deprecated\n    @Override\n    public Object findFilterId(AnnotatedClass ac) {\n        return _findFilterId(ac);\n    }\n    \n    @Override\n    public Object findFilterId(Annotated a) {\n        return _findFilterId(a);\n    }\n\n    protected final Object _findFilterId(Annotated a)\n    {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            // Empty String is same as not having annotation, to allow overrides\n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNamingStrategy(AnnotatedClass ac)\n    {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    } \n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n    \n    @Override\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n        VisibilityChecker<?> checker)\n    {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String findImplicitPropertyName(AnnotatedMember param) {\n        // not known by default (until JDK8) for creators; default \n        //\n        return null;\n    }\n    \n    @Override\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }\n\n    @Override\n    public Boolean hasRequiredMarker(AnnotatedMember m)\n    {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }\n\n    @Override\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }\n\n    @Override\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }\n\n    @Override\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }\n    \n    @Override\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        // Since annotations do not allow nulls, need to assume empty means \"none\"\n        return str.isEmpty() ? null : str;\n    }\n    \n    @Override\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }\n\n    @Override        \n    public ReferenceProperty findReferenceType(AnnotatedMember member)\n    {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }\n\n    @Override\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n    {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        // if not enabled, just means annotation is not enabled; not necessarily\n        // that unwrapping should not be done (relevant when using chained introspectors)\n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }\n\n    @Override\n    public Object findInjectableValueId(AnnotatedMember m)\n    {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        /* Empty String means that we should use name of declared\n         * value class.\n         */\n        String id = ann.value();\n        if (id.length() == 0) {\n            // slight complication; for setters, type \n            if (!(m instanceof AnnotatedMethod)) {\n                return m.getRawType().getName();\n            }\n            AnnotatedMethod am = (AnnotatedMethod) m;\n            if (am.getParameterCount() == 0) {\n                return m.getRawType().getName();\n            }\n            return am.getRawParameterType(0).getName();\n        }\n        return id;\n    }\n\n    @Override\n    public Class<?>[] findViews(Annotated a)\n    {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic Type handling\n    /**********************************************************\n     */\n\n    @Override\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType)\n    {\n        return _findTypeResolver(config, ac, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        if (baseType.isContainerType()) return null;\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType)\n    {\n        /* First: let's ensure property is a container type: caller should have\n         * verified but just to be sure\n         */\n        if (!containerType.isContainerType()) {\n            throw new IllegalArgumentException(\"Must call method with a container type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }\n    \n    @Override\n    public List<NamedType> findSubtypes(Annotated a)\n    {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }\n\n    @Override        \n    public String findTypeName(AnnotatedClass ac)\n    {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }\n\n    @Override\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        // In future may need to allow passing namespace?\n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }\n\n    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref != null) {\n            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n        }\n        return objectIdInfo;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n    */\n\n    @Override\n    public Object findSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n         *  if we need to get raw indicator from other sources need to add\n         *  separate accessor within {@link AnnotationIntrospector} interface.\n         */\n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            // let's construct instance with nominal type:\n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }\n\n    @Override\n    public Object findKeySerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNullSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include v = inc.value();\n            if (v != JsonInclude.Include.USE_DEFAULTS) {\n                return v;\n            }\n        }\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            JsonSerialize.Inclusion i2 = ann.include();\n            switch (i2) {\n            case ALWAYS:\n                return JsonInclude.Include.ALWAYS;\n            case NON_NULL:\n                return JsonInclude.Include.NON_NULL;\n            case NON_DEFAULT:\n                return JsonInclude.Include.NON_DEFAULT;\n            case NON_EMPTY:\n                return JsonInclude.Include.NON_EMPTY;\n            case DEFAULT_INCLUSION: // since 2.3 -- fall through, use default\n                break;\n            }\n        }\n        return defValue;\n    }\n\n    @Override\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include incl = inc.content();\n            if (incl != JsonInclude.Include.USE_DEFAULTS) {\n                return incl;\n            }\n        }\n        return defValue;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public JsonInclude.Value findPropertyInclusion(Annotated a)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        JsonInclude.Include valueIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.value();\n        if (valueIncl == JsonInclude.Include.USE_DEFAULTS) {\n            JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n            if (ann != null) {\n                JsonSerialize.Inclusion i2 = ann.include();\n                switch (i2) {\n                case ALWAYS:\n                    valueIncl = JsonInclude.Include.ALWAYS;\n                    break;\n                case NON_NULL:\n                    valueIncl = JsonInclude.Include.NON_NULL;\n                    break;\n                case NON_DEFAULT:\n                    valueIncl = JsonInclude.Include.NON_DEFAULT;\n                    break;\n                case NON_EMPTY:\n                    valueIncl = JsonInclude.Include.NON_EMPTY;\n                    break;\n                case DEFAULT_INCLUSION:\n                default:\n                }\n            }\n        }\n        JsonInclude.Include contentIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.content();\n        return JsonInclude.Value.construct(valueIncl, contentIncl);\n    }\n\n    @Override\n    public Class<?> findSerializationType(Annotated am)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n\n    @Override\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n    \n    @Override\n    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }\n\n    @Override\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }\n\n    @Override\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }\n\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        /* 23-Jun-2015, tatu: as per [databind#840], let's only consider\n         *  `true` to have any significance.\n         */\n        if ((order != null) && order.alphabetic()) {\n            return Boolean.TRUE;\n        }\n        return null;\n    }\n\n    @Override\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        // First: any attribute-backed properties?\n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        // Then: general-purpose virtual properties?\n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n    {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        // could add Index, Description in future, if those matter\n        String attrName = attr.value();\n\n        // allow explicit renaming; if none, default to attribute name\n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        // can construct the property writer\n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n            MapperConfig<?> config, AnnotatedClass ac)\n    {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        // one more thing: give it necessary contextual information\n        return bpw.withConfig(config, ac, propDef, type);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n\n    @Override\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        // value of 'false' means disabled...\n        return (ann != null && ann.value());\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    @Override\n    public Object findDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findKeyDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n\n    @Override\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n    {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n\n    @Override\n    public Object findDeserializationConverter(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findDeserializationContentConverter(AnnotatedMember a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: Class annotations\n    /**********************************************************\n     */\n    \n    @Override\n    public Object findValueInstantiator(AnnotatedClass ac)\n    {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        // no 'null' marker yet, so:\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n    {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n    {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated a)\n    {\n        String name;\n\n        // @JsonSetter has precedence over @JsonProperty, being more specific\n        // @JsonDeserialize implies that there is a property, but no name\n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            name = js.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonDeserialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                    name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n    \n    @Override\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }\n\n    @Override\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (handled separately\n         */\n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }\n\n    @Override\n    public boolean hasCreatorAnnotation(Annotated a)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n    }\n\n    @Override\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected boolean _isIgnorable(Annotated a)\n    {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        return (ann != null && ann.value());\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }\n\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }\n\n    /**\n     * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n     * if given annotated element indicates one is needed.\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n            Annotated ann, JavaType baseType)\n    {\n        // First: maybe we have explicit type resolver?\n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            /* let's not try to force access override (would need to pass\n             * settings through if we did, since that's not doable on some\n             * platforms)\n             */\n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { // if not, use standard one, if indicated by annotations\n            if (info == null) {\n                return null;\n            }\n            // bit special; must return 'marker' to block use of default typing:\n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        // Does it define a custom type id resolver?\n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) { // [JACKSON-359]\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        /* 13-Aug-2011, tatu: One complication wrt [JACKSON-453]; external id\n         *   only works for properties; so if declared for a Class, we will need\n         *   to map it to \"PROPERTY\" instead of \"EXTERNAL_PROPERTY\"\n         */\n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n        //   valid use (can not instantiate as default)\n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }\n\n    /**\n     * Helper method for constructing standard {@link TypeResolverBuilder}\n     * implementation.\n     */\n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }\n\n    /**\n     * Helper method for dealing with \"no type info\" marker; can't be null\n     * (as it'd be replaced by default typing)\n     */\n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.introspect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.*;\nimport com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\nimport com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\nimport com.fasterxml.jackson.databind.ser.std.RawSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    public JacksonAnnotationIntrospector() { }\n\n    @Override\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotation properties\n    /**********************************************************\n     */\n\n    /**\n     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n     * are considered bundles.\n     */\n    @Override\n    public boolean isAnnotationBundle(Annotation ann) {\n        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n    }\n\n    /*\n    /**********************************************************\n    /* General annotations\n    /**********************************************************\n     */\n\n    /**\n     * Since 2.6, we have supported use of {@link JsonProperty} for specifying\n     * explicit serialized name\n     */\n    @Override\n    public String findEnumValue(Enum<?> value)\n    {\n        // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n        //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n        //   reasons, including odd representation JVM uses); has to do for now\n        try {\n            // We know that values are actually static fields with matching name so:\n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                if (prop != null) {\n                    String n = prop.value();\n                    if (n != null && !n.isEmpty()) {\n                        return n;\n                    }\n                }\n            }\n        } catch (SecurityException e) {\n            // 17-Sep-2015, tatu: Anything we could/should do here?\n        } catch (NoSuchFieldException e) {\n            // 17-Sep-2015, tatu: should not really happen. But... can we do anything?\n        }\n        return value.name();\n    }\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findRootName(AnnotatedClass ac)\n    {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7 or later\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    @Override // since 2.6\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        if (ignore == null) {\n            return null;\n        }\n        // 13-May-2015, tatu: As per [databind#95], allow read-only/write-only props\n        if (forSerialization) {\n            if (ignore.allowGetters()) {\n                return null;\n            }\n        } else {\n            if (ignore.allowSetters()) {\n                return null;\n            }\n        }\n        return ignore.value();\n    }\n    \n    @Override\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.ignoreUnknown();\n    }\n\n    @Override\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }\n\n    /**\n     * @deprecated (since 2.3) Use {@link #findFilterId(Annotated)} instead\n     */\n    @Deprecated\n    @Override\n    public Object findFilterId(AnnotatedClass ac) {\n        return _findFilterId(ac);\n    }\n    \n    @Override\n    public Object findFilterId(Annotated a) {\n        return _findFilterId(a);\n    }\n\n    protected final Object _findFilterId(Annotated a)\n    {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            // Empty String is same as not having annotation, to allow overrides\n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNamingStrategy(AnnotatedClass ac)\n    {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    } \n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n    \n    @Override\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n        VisibilityChecker<?> checker)\n    {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String findImplicitPropertyName(AnnotatedMember param) {\n        // not known by default (until JDK8) for creators; default \n        //\n        return null;\n    }\n    \n    @Override\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }\n\n    @Override\n    public Boolean hasRequiredMarker(AnnotatedMember m)\n    {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }\n\n    @Override\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }\n\n    @Override\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }\n\n    @Override\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }\n    \n    @Override\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        // Since annotations do not allow nulls, need to assume empty means \"none\"\n        return str.isEmpty() ? null : str;\n    }\n    \n    @Override\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }\n\n    @Override        \n    public ReferenceProperty findReferenceType(AnnotatedMember member)\n    {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }\n\n    @Override\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n    {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        // if not enabled, just means annotation is not enabled; not necessarily\n        // that unwrapping should not be done (relevant when using chained introspectors)\n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }\n\n    @Override\n    public Object findInjectableValueId(AnnotatedMember m)\n    {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        /* Empty String means that we should use name of declared\n         * value class.\n         */\n        String id = ann.value();\n        if (id.length() == 0) {\n            // slight complication; for setters, type \n            if (!(m instanceof AnnotatedMethod)) {\n                return m.getRawType().getName();\n            }\n            AnnotatedMethod am = (AnnotatedMethod) m;\n            if (am.getParameterCount() == 0) {\n                return m.getRawType().getName();\n            }\n            return am.getRawParameterType(0).getName();\n        }\n        return id;\n    }\n\n    @Override\n    public Class<?>[] findViews(Annotated a)\n    {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic Type handling\n    /**********************************************************\n     */\n\n    @Override\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType)\n    {\n        return _findTypeResolver(config, ac, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        if (baseType.isContainerType()) return null;\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }\n\n    @Override\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType)\n    {\n        /* First: let's ensure property is a container type: caller should have\n         * verified but just to be sure\n         */\n        if (!containerType.isContainerType()) {\n            throw new IllegalArgumentException(\"Must call method with a container type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }\n    \n    @Override\n    public List<NamedType> findSubtypes(Annotated a)\n    {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }\n\n    @Override        \n    public String findTypeName(AnnotatedClass ac)\n    {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }\n\n    @Override\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        // In future may need to allow passing namespace?\n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }\n\n    @Override\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref != null) {\n            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n        }\n        return objectIdInfo;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n    */\n\n    @Override\n    public Object findSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n         *  if we need to get raw indicator from other sources need to add\n         *  separate accessor within {@link AnnotationIntrospector} interface.\n         */\n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            // let's construct instance with nominal type:\n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }\n\n    @Override\n    public Object findKeySerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findNullSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include v = inc.value();\n            if (v != JsonInclude.Include.USE_DEFAULTS) {\n                return v;\n            }\n        }\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            JsonSerialize.Inclusion i2 = ann.include();\n            switch (i2) {\n            case ALWAYS:\n                return JsonInclude.Include.ALWAYS;\n            case NON_NULL:\n                return JsonInclude.Include.NON_NULL;\n            case NON_DEFAULT:\n                return JsonInclude.Include.NON_DEFAULT;\n            case NON_EMPTY:\n                return JsonInclude.Include.NON_EMPTY;\n            case DEFAULT_INCLUSION: // since 2.3 -- fall through, use default\n                break;\n            }\n        }\n        return defValue;\n    }\n\n    @Override\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include incl = inc.content();\n            if (incl != JsonInclude.Include.USE_DEFAULTS) {\n                return incl;\n            }\n        }\n        return defValue;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public JsonInclude.Value findPropertyInclusion(Annotated a)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        JsonInclude.Include valueIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.value();\n        if (valueIncl == JsonInclude.Include.USE_DEFAULTS) {\n            JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n            if (ann != null) {\n                JsonSerialize.Inclusion i2 = ann.include();\n                switch (i2) {\n                case ALWAYS:\n                    valueIncl = JsonInclude.Include.ALWAYS;\n                    break;\n                case NON_NULL:\n                    valueIncl = JsonInclude.Include.NON_NULL;\n                    break;\n                case NON_DEFAULT:\n                    valueIncl = JsonInclude.Include.NON_DEFAULT;\n                    break;\n                case NON_EMPTY:\n                    valueIncl = JsonInclude.Include.NON_EMPTY;\n                    break;\n                case DEFAULT_INCLUSION:\n                default:\n                }\n            }\n        }\n        JsonInclude.Include contentIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.content();\n        return JsonInclude.Value.construct(valueIncl, contentIncl);\n    }\n\n    @Override\n    public Class<?> findSerializationType(Annotated am)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n\n    @Override\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n    \n    @Override\n    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }\n\n    @Override\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    @Override\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }\n\n    @Override\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }\n\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        /* 23-Jun-2015, tatu: as per [databind#840], let's only consider\n         *  `true` to have any significance.\n         */\n        if ((order != null) && order.alphabetic()) {\n            return Boolean.TRUE;\n        }\n        return null;\n    }\n\n    @Override\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        // First: any attribute-backed properties?\n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        // Then: general-purpose virtual properties?\n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n    {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        // could add Index, Description in future, if those matter\n        String attrName = attr.value();\n\n        // allow explicit renaming; if none, default to attribute name\n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        // can construct the property writer\n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }\n\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n            MapperConfig<?> config, AnnotatedClass ac)\n    {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        // one more thing: give it necessary contextual information\n        return bpw.withConfig(config, ac, propDef, type);\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class)\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n\n    @Override\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        // value of 'false' means disabled...\n        return (ann != null && ann.value());\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    @Override\n    public Object findDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findKeyDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Object findContentDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }\n\n    @Override\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }\n\n    @Override\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n    {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }\n\n    @Override\n    public Object findDeserializationConverter(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }\n\n    @Override\n    public Object findDeserializationContentConverter(AnnotatedMember a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: Class annotations\n    /**********************************************************\n     */\n    \n    @Override\n    public Object findValueInstantiator(AnnotatedClass ac)\n    {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        // no 'null' marker yet, so:\n        return (ann == null) ? null : ann.value();\n    }\n\n    @Override\n    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n    {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }\n\n    @Override\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n    {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated a)\n    {\n        String name;\n\n        // @JsonSetter has precedence over @JsonProperty, being more specific\n        // @JsonDeserialize implies that there is a property, but no name\n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            name = js.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonDeserialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                    name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n    \n    @Override\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }\n\n    @Override\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (handled separately\n         */\n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }\n\n    @Override\n    public boolean hasCreatorAnnotation(Annotated a)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n    }\n\n    @Override\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected boolean _isIgnorable(Annotated a)\n    {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        return (ann != null && ann.value());\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }\n\n    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }\n\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }\n\n    /**\n     * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n     * if given annotated element indicates one is needed.\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n            Annotated ann, JavaType baseType)\n    {\n        // First: maybe we have explicit type resolver?\n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            /* let's not try to force access override (would need to pass\n             * settings through if we did, since that's not doable on some\n             * platforms)\n             */\n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { // if not, use standard one, if indicated by annotations\n            if (info == null) {\n                return null;\n            }\n            // bit special; must return 'marker' to block use of default typing:\n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        // Does it define a custom type id resolver?\n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) { // [JACKSON-359]\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        /* 13-Aug-2011, tatu: One complication wrt [JACKSON-453]; external id\n         *   only works for properties; so if declared for a Class, we will need\n         *   to map it to \"PROPERTY\" instead of \"EXTERNAL_PROPERTY\"\n         */\n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n        //   valid use (can not instantiate as default)\n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }\n\n    /**\n     * Helper method for constructing standard {@link TypeResolverBuilder}\n     * implementation.\n     */\n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }\n\n    /**\n     * Helper method for dealing with \"no type info\" marker; can't be null\n     * (as it'd be replaced by default typing)\n     */\n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 34, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.std.NumberSerializer", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n\n/**\n * As a fallback, we may need to use this serializer for other\n * types of {@link Number}s: both custom types and \"big\" numbers\n * like {@link BigInteger} and {@link BigDecimal}.\n */\n@JacksonStdImpl\n@SuppressWarnings(\"serial\")\npublic class NumberSerializer\n    extends StdScalarSerializer<Number>\n{\n    /**\n     * Static instance that is only to be used for {@link java.lang.Number}.\n     */\n    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n\n    protected final boolean _isInt;\n\n    /**\n     * @since 2.5\n     */\n    public NumberSerializer(Class<? extends Number> rawType) {\n        super(rawType, false);\n        // since this will NOT be constructed for Integer or Long, only case is:\n        _isInt = (rawType == BigInteger.class);\n    }\n\n    @Override\n    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n\n/**\n * As a fallback, we may need to use this serializer for other\n * types of {@link Number}s: both custom types and \"big\" numbers\n * like {@link BigInteger} and {@link BigDecimal}.\n */\n@JacksonStdImpl\n@SuppressWarnings(\"serial\")\npublic class NumberSerializer\n    extends StdScalarSerializer<Number>\n{\n    /**\n     * Static instance that is only to be used for {@link java.lang.Number}.\n     */\n    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n\n    protected final boolean _isInt;\n\n    /**\n     * @since 2.5\n     */\n    public NumberSerializer(Class<? extends Number> rawType) {\n        super(rawType, false);\n        // since this will NOT be constructed for Integer or Long, only case is:\n        _isInt = (rawType == BigInteger.class);\n    }\n\n    @Override\n    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}"}]}
{"project": "JacksonDatabind", "bug_id": 35, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.jsontype.impl.AsWrapperTypeDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserSequence;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Type deserializer used with {@link As#WRAPPER_OBJECT}\n * inclusion mechanism. Simple since JSON structure used is always\n * the same, regardless of structure used for actual value: wrapping\n * is done using a single-element JSON Object where type id is the key,\n * and actual object data as the value.\n */\npublic class AsWrapperTypeDeserializer\n    extends TypeDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 5345570420394408290L;\n\n    public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n    {\n        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n    }\n\n    protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property) {\n        super(src, property);\n    }\n    \n    @Override\n    public TypeDeserializer forProperty(BeanProperty prop) {\n        return (prop == _property) ? this : new AsWrapperTypeDeserializer(this, prop);\n    }\n    \n    @Override\n    public As getTypeInclusion() { return As.WRAPPER_OBJECT; }\n\n    /**\n     * Deserializing type id enclosed using WRAPPER_OBJECT style is straightforward\n     */\n    @Override\n    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }    \n\n    @Override\n    public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n    \n    /*\n    /***************************************************************\n    /* Internal methods\n    /***************************************************************\n     */\n\n    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        // first, sanity checks\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n            // should always get field name, but just in case...\n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); // recreate START_OBJECT\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        // And then need the closing END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserSequence;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Type deserializer used with {@link As#WRAPPER_OBJECT}\n * inclusion mechanism. Simple since JSON structure used is always\n * the same, regardless of structure used for actual value: wrapping\n * is done using a single-element JSON Object where type id is the key,\n * and actual object data as the value.\n */\npublic class AsWrapperTypeDeserializer\n    extends TypeDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 5345570420394408290L;\n\n    public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n    {\n        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n    }\n\n    protected AsWrapperTypeDeserializer(AsWrapperTypeDeserializer src, BeanProperty property) {\n        super(src, property);\n    }\n    \n    @Override\n    public TypeDeserializer forProperty(BeanProperty prop) {\n        return (prop == _property) ? this : new AsWrapperTypeDeserializer(this, prop);\n    }\n    \n    @Override\n    public As getTypeInclusion() { return As.WRAPPER_OBJECT; }\n\n    /**\n     * Deserializing type id enclosed using WRAPPER_OBJECT style is straightforward\n     */\n    @Override\n    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }    \n\n    @Override\n    public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n\n    @Override\n    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserialize(jp, ctxt);\n    }\n    \n    /*\n    /***************************************************************\n    /* Internal methods\n    /***************************************************************\n     */\n\n    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        // first, sanity checks\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            // should always get field name, but just in case...\n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        } else if (t != JsonToken.FIELD_NAME) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); // recreate START_OBJECT\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        // And then need the closing END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 36, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.util.StdDateFormat", "buggy_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat\n    extends DateFormat\n{\n    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n     * permissive. The two don't mix, need to write a better one.\n     */\n    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n    //   not really robust. But still in use.\n\n    /**\n     * Defines a commonly used date format that conforms\n     * to ISO-8601 date formatting standard, when it includes basic undecorated\n     * timezone definition\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    /**\n     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n     * (or \"UTC\")\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    /**\n     * ISO-8601 with just the Date part, no time\n     */\n    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n\n    /**\n     * This constant defines the date format specified by\n     * RFC 1123 / RFC 822.\n     */\n    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n\n    /**\n     * For error messages we'll also need a list of all formats.\n     */\n    protected final static String[] ALL_FORMATS = new String[] {\n        DATE_FORMAT_STR_ISO8601,\n        DATE_FORMAT_STR_ISO8601_Z,\n        DATE_FORMAT_STR_RFC1123,\n        DATE_FORMAT_STR_PLAIN\n    };\n\n    /**\n     * By default we use UTC for everything, with Jackson 2.7 and later\n     * (2.6 and earlier relied on GMT)\n     */\n    private final static TimeZone DEFAULT_TIMEZONE;\n    static {\n        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7\n    }\n\n    private final static Locale DEFAULT_LOCALE = Locale.US;\n    \n    protected final static DateFormat DATE_FORMAT_RFC1123;\n\n    protected final static DateFormat DATE_FORMAT_ISO8601;\n    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n\n    protected final static DateFormat DATE_FORMAT_PLAIN;\n\n    /* Let's construct \"blueprint\" date format instances: can not be used\n     * as is, due to thread-safety issues, but can be used for constructing\n     * actual instances more cheaply (avoids re-parsing).\n     */\n    static {\n        /* Another important thing: let's force use of default timezone for\n         * baseline DataFormat objects\n         */\n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    /**\n     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n     */\n    public final static StdDateFormat instance = new StdDateFormat();\n    \n    /**\n     * Caller may want to explicitly override timezone to use; if so,\n     * we will have non-null value here.\n     */\n    protected transient TimeZone _timezone;\n\n    protected final Locale _locale;\n\n    /**\n     * Explicit override for leniency, if specified.\n     *<p>\n     * Can not be `final` because {@link #setLenient(boolean)} returns\n     * `void`.\n     *\n     * @since 2.7\n     */\n    protected Boolean _lenient;\n    \n    protected transient DateFormat _formatRFC1123;\n    protected transient DateFormat _formatISO8601;\n    protected transient DateFormat _formatISO8601_z;\n    protected transient DateFormat _formatPlain;\n\n    /*\n    /**********************************************************\n    /* Life cycle, accessing singleton \"standard\" formats\n    /**********************************************************\n     */\n\n    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated // since 2.7\n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    /**\n     * Method used for creating a new instance with specified timezone;\n     * if no timezone specified, defaults to the default timezone (UTC).\n     */\n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        /* Although there is that much state to share, we do need to\n         * orchestrate a bit, mostly since timezones may be changed\n         */\n        return new StdDateFormat(_timezone, _locale, _lenient);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specified timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specific timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, configuration\n    /**********************************************************\n     */\n\n    @Override // since 2.6\n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz)\n    {\n        /* DateFormats are timezone-specific (via Calendar contained),\n         * so need to reset instances if timezone changes:\n         */\n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    /**\n     * Need to override since we need to keep track of leniency locally,\n     * and not via underlying {@link Calendar} instance like base class\n     * does.\n     */\n            // and since leniency settings may have been used:\n\n    @Override // since 2.7\n    public boolean isLenient() {\n        if (_lenient == null) {\n            // default is, I believe, true\n            return true;\n        }\n        return _lenient.booleanValue();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, parsing\n    /**********************************************************\n     */\n\n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n\n        Date dt;\n\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            dt = parseAsISO8601(dateStr, pos, true);\n        } else {\n            // Also consider \"stringified\" simple time stamp\n            int i = dateStr.length();\n            while (--i >= 0) {\n                char ch = dateStr.charAt(i);\n                if (ch < '0' || ch > '9') {\n                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work\n                    if (i > 0 || ch != '-') {\n                        break;\n                    }\n                }\n            }\n            if ((i < 0)\n                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n                dt = new Date(Long.parseLong(dateStr));\n            } else {\n                // Otherwise, fall back to using RFC 1123\n                dt = parseAsRFC1123(dateStr, pos);\n            }\n        }\n        if (dt != null) {\n            return dt;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            try {\n                return parseAsISO8601(dateStr, pos, false);\n            } catch (ParseException e) { // will NOT be thrown due to false but is declared...\n                return null;\n            }\n        }\n        // Also consider \"stringified\" simple time stamp\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { // all digits\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, writing\n    /**********************************************************\n     */\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    /*\n    /**********************************************************\n    /* Std overrides\n    /**********************************************************\n     */\n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used to figure out which of supported\n     * formats is the likeliest match.\n     */\n    protected boolean looksLikeISO8601(String dateStr)\n    {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)\n            throws ParseException\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"UTC\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * UTC, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        String formatStr;\n\n        // Need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n            // may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n                    int offset = len - 5; // insertion offset, before tz-offset\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: // is this legal? (just second fraction marker)\n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: // not legal to have single-digit second\n                        break;\n                    case 6: // probably not legal, but let's allow\n                        sb.insert(offset, \"00.000\");\n                    case 5: // is legal to omit seconds\n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { // missing, or partial\n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        // 22-Dec-2015, tatu: With non-lenient, may get null\n        if (dt == null) {\n            throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                           dateStr, formatStr, _lenient),\n               pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str)\n    {\n        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc, Boolean lenient)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n        _formatISO8601 = null;\n        _formatISO8601_z = null;\n        _formatPlain = null;\n    }\n}\n\n", "fixed_version": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat\n    extends DateFormat\n{\n    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n     * permissive. The two don't mix, need to write a better one.\n     */\n    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n    //   not really robust. But still in use.\n\n    /**\n     * Defines a commonly used date format that conforms\n     * to ISO-8601 date formatting standard, when it includes basic undecorated\n     * timezone definition\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    /**\n     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n     * (or \"UTC\")\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    /**\n     * ISO-8601 with just the Date part, no time\n     */\n    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n\n    /**\n     * This constant defines the date format specified by\n     * RFC 1123 / RFC 822.\n     */\n    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n\n    /**\n     * For error messages we'll also need a list of all formats.\n     */\n    protected final static String[] ALL_FORMATS = new String[] {\n        DATE_FORMAT_STR_ISO8601,\n        DATE_FORMAT_STR_ISO8601_Z,\n        DATE_FORMAT_STR_RFC1123,\n        DATE_FORMAT_STR_PLAIN\n    };\n\n    /**\n     * By default we use UTC for everything, with Jackson 2.7 and later\n     * (2.6 and earlier relied on GMT)\n     */\n    private final static TimeZone DEFAULT_TIMEZONE;\n    static {\n        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"UTC\"); // since 2.7\n    }\n\n    private final static Locale DEFAULT_LOCALE = Locale.US;\n    \n    protected final static DateFormat DATE_FORMAT_RFC1123;\n\n    protected final static DateFormat DATE_FORMAT_ISO8601;\n    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n\n    protected final static DateFormat DATE_FORMAT_PLAIN;\n\n    /* Let's construct \"blueprint\" date format instances: can not be used\n     * as is, due to thread-safety issues, but can be used for constructing\n     * actual instances more cheaply (avoids re-parsing).\n     */\n    static {\n        /* Another important thing: let's force use of default timezone for\n         * baseline DataFormat objects\n         */\n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    /**\n     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n     */\n    public final static StdDateFormat instance = new StdDateFormat();\n    \n    /**\n     * Caller may want to explicitly override timezone to use; if so,\n     * we will have non-null value here.\n     */\n    protected transient TimeZone _timezone;\n\n    protected final Locale _locale;\n\n    /**\n     * Explicit override for leniency, if specified.\n     *<p>\n     * Can not be `final` because {@link #setLenient(boolean)} returns\n     * `void`.\n     *\n     * @since 2.7\n     */\n    protected Boolean _lenient;\n    \n    protected transient DateFormat _formatRFC1123;\n    protected transient DateFormat _formatISO8601;\n    protected transient DateFormat _formatISO8601_z;\n    protected transient DateFormat _formatPlain;\n\n    /*\n    /**********************************************************\n    /* Life cycle, accessing singleton \"standard\" formats\n    /**********************************************************\n     */\n\n    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    @Deprecated // since 2.7\n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {\n        _timezone = tz;\n        _locale = loc;\n        _lenient = lenient;\n    }\n    \n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    /**\n     * Method used for creating a new instance with specified timezone;\n     * if no timezone specified, defaults to the default timezone (UTC).\n     */\n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if ((tz == _timezone) || tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale, _lenient);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc, _lenient);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        /* Although there is that much state to share, we do need to\n         * orchestrate a bit, mostly since timezones may be changed\n         */\n        return new StdDateFormat(_timezone, _locale, _lenient);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specified timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specific timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                tz, loc, null);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, configuration\n    /**********************************************************\n     */\n\n    @Override // since 2.6\n    public TimeZone getTimeZone() {\n        return _timezone;\n    }\n\n    @Override\n    public void setTimeZone(TimeZone tz)\n    {\n        /* DateFormats are timezone-specific (via Calendar contained),\n         * so need to reset instances if timezone changes:\n         */\n        if (!tz.equals(_timezone)) {\n            _clearFormats();\n            _timezone = tz;\n        }\n    }\n\n    /**\n     * Need to override since we need to keep track of leniency locally,\n     * and not via underlying {@link Calendar} instance like base class\n     * does.\n     */\n    @Override // since 2.7\n    public void setLenient(boolean enabled) {\n        Boolean newValue = enabled;\n        if (_lenient != newValue) {\n            _lenient = newValue;\n            // and since leniency settings may have been used:\n            _clearFormats();\n        }\n    }\n\n    @Override // since 2.7\n    public boolean isLenient() {\n        if (_lenient == null) {\n            // default is, I believe, true\n            return true;\n        }\n        return _lenient.booleanValue();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, parsing\n    /**********************************************************\n     */\n\n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n\n        Date dt;\n\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            dt = parseAsISO8601(dateStr, pos, true);\n        } else {\n            // Also consider \"stringified\" simple time stamp\n            int i = dateStr.length();\n            while (--i >= 0) {\n                char ch = dateStr.charAt(i);\n                if (ch < '0' || ch > '9') {\n                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work\n                    if (i > 0 || ch != '-') {\n                        break;\n                    }\n                }\n            }\n            if ((i < 0)\n                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {\n                dt = new Date(Long.parseLong(dateStr));\n            } else {\n                // Otherwise, fall back to using RFC 1123\n                dt = parseAsRFC1123(dateStr, pos);\n            }\n        }\n        if (dt != null) {\n            return dt;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            try {\n                return parseAsISO8601(dateStr, pos, false);\n            } catch (ParseException e) { // will NOT be thrown due to false but is declared...\n                return null;\n            }\n        }\n        // Also consider \"stringified\" simple time stamp\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { // all digits\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, writing\n    /**********************************************************\n     */\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    /*\n    /**********************************************************\n    /* Std overrides\n    /**********************************************************\n     */\n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used to figure out which of supported\n     * formats is the likeliest match.\n     */\n    protected boolean looksLikeISO8601(String dateStr)\n    {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)\n            throws ParseException\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"UTC\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * UTC, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        String formatStr;\n\n        // Need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                        _timezone, _locale, _lenient);\n            }\n            // may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n                    int offset = len - 5; // insertion offset, before tz-offset\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: // is this legal? (just second fraction marker)\n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: // not legal to have single-digit second\n                        break;\n                    case 6: // probably not legal, but let's allow\n                        sb.insert(offset, \"00.000\");\n                    case 5: // is legal to omit seconds\n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { // missing, or partial\n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n                            _timezone, _locale, _lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        // 22-Dec-2015, tatu: With non-lenient, may get null\n        if (dt == null) {\n            throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                           dateStr, formatStr, _lenient),\n               pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,\n                    _timezone, _locale, _lenient);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str)\n    {\n        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc, Boolean lenient)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }\n\n    protected void _clearFormats() {\n        _formatRFC1123 = null;\n        _formatISO8601 = null;\n        _formatISO8601_z = null;\n        _formatPlain = null;\n    }\n}\n\n"}]}
{"project": "JacksonDatabind", "bug_id": 37, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.SimpleType", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by core Jackson databind functionality;\n     * should never be called by application code.\n     *<p>\n     * As with other direct construction that by-passes {@link TypeFactory},\n     * no introspection occurs with respect to super-types; caller must be\n     * aware of consequences if using this method.\n     */\n    protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    /**\n     * Simple copy-constructor, usually used when upgrading/refining a simple type\n     * into more specialized type.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * Pass-through constructor used by {@link ReferenceType}.\n     * \n     * @since 2.6\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    /**\n     * Method used by core Jackson classes: NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance.\n     *<p>\n     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n     * not in same package\n     */\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }\n\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by core Jackson databind functionality;\n     * should never be called by application code.\n     *<p>\n     * As with other direct construction that by-passes {@link TypeFactory},\n     * no introspection occurs with respect to super-types; caller must be\n     * aware of consequences if using this method.\n     */\n    protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    /**\n     * Simple copy-constructor, usually used when upgrading/refining a simple type\n     * into more specialized type.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * Pass-through constructor used by {@link ReferenceType}.\n     * \n     * @since 2.6\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    /**\n     * Method used by core Jackson classes: NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance.\n     *<p>\n     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n     * not in same package\n     */\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }\n\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 38, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.CollectionType", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Type that represents Java Collection types (Lists, Sets).\n */\npublic final class CollectionType\n    extends CollectionLikeType\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private CollectionType(Class<?> collT, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType elemT,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(collT, bindings, superClass, superInts, elemT, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * @since 2.7\n     */\n    protected CollectionType(TypeBase base, JavaType elemT) {\n        super(base, elemT);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType elemT) {\n        return new CollectionType(rawType, bindings, superClass, superInts, elemT,\n                null, null, false);\n    }\n\n    /**\n     * @deprecated Since 2.7, remove from 2.8\n     */\n    @Deprecated // since 2.7\n    public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        return new CollectionType(rawType, null,\n                // !!! TODO: Wrong, does have supertypes, but:\n                _bogusSuperClass(rawType), null, elemT,\n                null, null, false);\n    }\n\n    @Deprecated // since 2.7\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new CollectionType(subclass, _bindings,\n                _superClass, _superInterfaces, _elementType, null, null, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_elementType == contentType) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public CollectionType withTypeHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public CollectionType withContentTypeHandler(Object h)\n    {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public  CollectionType withContentValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new CollectionType(rawType, bindings,\n                superClass, superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return \"[collection type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Type that represents Java Collection types (Lists, Sets).\n */\npublic final class CollectionType\n    extends CollectionLikeType\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private CollectionType(Class<?> collT, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType elemT,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(collT, bindings, superClass, superInts, elemT, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * @since 2.7\n     */\n    protected CollectionType(TypeBase base, JavaType elemT) {\n        super(base, elemT);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType elemT) {\n        return new CollectionType(rawType, bindings, superClass, superInts, elemT,\n                null, null, false);\n    }\n\n    /**\n     * @deprecated Since 2.7, remove from 2.8\n     */\n    @Deprecated // since 2.7\n    public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 1)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, elemT);\n        }\n        return new CollectionType(rawType, bindings,\n                // !!! TODO: Wrong, does have supertypes, but:\n                _bogusSuperClass(rawType), null, elemT,\n                null, null, false);\n    }\n\n    @Deprecated // since 2.7\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new CollectionType(subclass, _bindings,\n                _superClass, _superInterfaces, _elementType, null, null, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_elementType == contentType) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings, _superClass, _superInterfaces,\n                contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public CollectionType withTypeHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public CollectionType withContentTypeHandler(Object h)\n    {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public  CollectionType withContentValueHandler(Object h) {\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public CollectionType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new CollectionType(_class, _bindings,\n                _superClass, _superInterfaces, _elementType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new CollectionType(rawType, bindings,\n                superClass, superInterfaces, _elementType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return \"[collection type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.type.MapType", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Type that represents \"true\" Java Map types.\n */\npublic final class MapType extends MapLikeType\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private MapType(Class<?> mapType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT,\n            Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(mapType, bindings, superClass, superInts,\n                keyT, valueT, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * @since 2.7\n     */\n    protected MapType(TypeBase base, JavaType keyT, JavaType valueT) {\n        super(base, keyT, valueT);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public static MapType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            JavaType keyT, JavaType valueT) {\n        return new MapType(rawType, bindings, superClass, superInts, keyT, valueT, null, null, false);\n    }\n    \n    @Deprecated // since 2.7\n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)\n    {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        // !!! TODO: Wrong, does have supertypes\n        return new MapType(rawType, null, _bogusSuperClass(rawType), null,\n                keyT, valueT, null, null, false);\n    }\n\n    @Deprecated // since 2.7\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new MapType(subclass, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public MapType withContentTypeHandler(Object h)\n    {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withContentValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withStaticTyping(), _valueType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_valueType == contentType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withKeyType(JavaType keyType) {\n        if (keyType == _keyType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new MapType(rawType, bindings,\n                superClass, superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n    \n    @Override\n    public MapType withKeyTypeHandler(Object h)\n    {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withKeyValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return \"[map type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Type that represents \"true\" Java Map types.\n */\npublic final class MapType extends MapLikeType\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private MapType(Class<?> mapType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT,\n            Object valueHandler, Object typeHandler, boolean asStatic) {\n        super(mapType, bindings, superClass, superInts,\n                keyT, valueT, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * @since 2.7\n     */\n    protected MapType(TypeBase base, JavaType keyT, JavaType valueT) {\n        super(base, keyT, valueT);\n    }\n\n    /**\n     * @since 2.7\n     */\n    public static MapType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            JavaType keyT, JavaType valueT) {\n        return new MapType(rawType, bindings, superClass, superInts, keyT, valueT, null, null, false);\n    }\n    \n    @Deprecated // since 2.7\n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)\n    {\n        // First: may need to fabricate TypeBindings (needed for refining into\n        // concrete collection types, as per [databind#1102])\n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        TypeBindings bindings;\n        if ((vars == null) || (vars.length != 2)) {\n            bindings = TypeBindings.emptyBindings();\n        } else {\n            bindings = TypeBindings.create(rawType, keyT, valueT);\n        }\n        // !!! TODO: Wrong, does have supertypes\n        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,\n                keyT, valueT, null, null, false);\n    }\n\n    @Deprecated // since 2.7\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new MapType(subclass, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withTypeHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public MapType withContentTypeHandler(Object h)\n    {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withContentValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withStaticTyping(), _valueType.withStaticTyping(),\n                _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        if (_valueType == contentType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public MapType withKeyType(JavaType keyType) {\n        if (keyType == _keyType) {\n            return this;\n        }\n        return new MapType(_class, _bindings, _superClass, _superInterfaces,\n                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new MapType(rawType, bindings,\n                superClass, superInterfaces, _keyType, _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n    \n    @Override\n    public MapType withKeyTypeHandler(Object h)\n    {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public MapType withKeyValueHandler(Object h) {\n        return new MapType(_class, _bindings,\n                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return \"[map type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.type.SimpleType", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by core Jackson databind functionality;\n     * should never be called by application code.\n     *<p>\n     * As with other direct construction that by-passes {@link TypeFactory},\n     * no introspection occurs with respect to super-types; caller must be\n     * aware of consequences if using this method.\n     */\n    protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    /**\n     * Simple copy-constructor, usually used when upgrading/refining a simple type\n     * into more specialized type.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * Pass-through constructor used by {@link ReferenceType}.\n     * \n     * @since 2.6\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    /**\n     * Method used by core Jackson classes: NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance.\n     *<p>\n     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n     * not in same package\n     */\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }\n\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls, TypeBindings.emptyBindings(),\n                _bogusSuperClass(cls), null, null, null, false);\n    }\n\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method we need to recursively build skeletal representations\n     * of superclasses.\n     * \n     * @since 2.7 -- remove when not needed (2.8?)\n     */\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by core Jackson databind functionality;\n     * should never be called by application code.\n     *<p>\n     * As with other direct construction that by-passes {@link TypeFactory},\n     * no introspection occurs with respect to super-types; caller must be\n     * aware of consequences if using this method.\n     */\n    protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    /**\n     * Simple copy-constructor, usually used when upgrading/refining a simple type\n     * into more specialized type.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * Pass-through constructor used by {@link ReferenceType}.\n     * \n     * @since 2.6\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    /**\n     * Method used by core Jackson classes: NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance.\n     *<p>\n     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n     * not in same package\n     */\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }\n\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        TypeBindings b = TypeBindings.emptyBindings();\n        return new SimpleType(cls, b,\n                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n    }\n\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method we need to recursively build skeletal representations\n     * of superclasses.\n     * \n     * @since 2.7 -- remove when not needed (2.8?)\n     */\n    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)\n    {\n        if (superClass == null) {\n            return null;\n        }\n        if (superClass == Object.class) {\n            return TypeFactory.unknownType();\n        }\n        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n        return new SimpleType(superClass, b,\n                superSuper, null, null, null, false);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 39, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n/**\n * Bogus deserializer that will simply skip all content there is to map\n * and returns Java null reference.\n * \n * @since 2.2\n */\npublic class NullifyingDeserializer\n    extends StdDeserializer<Object>\n{\n    private static final long serialVersionUID = 1L;\n\n    public final static NullifyingDeserializer instance = new NullifyingDeserializer();\n    \n    public NullifyingDeserializer() { super(Object.class); }\n\n    /*\n    /**********************************************************\n    /* Deserializer API\n    /**********************************************************\n     */\n    \n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n        //    special unfortunately\n            p.skipChildren();\n        return null;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer) throws IOException\n    {\n        // Not sure if we need to bother but:\n\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_ARRAY:\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n        default:\n            return null;\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n/**\n * Bogus deserializer that will simply skip all content there is to map\n * and returns Java null reference.\n * \n * @since 2.2\n */\npublic class NullifyingDeserializer\n    extends StdDeserializer<Object>\n{\n    private static final long serialVersionUID = 1L;\n\n    public final static NullifyingDeserializer instance = new NullifyingDeserializer();\n    \n    public NullifyingDeserializer() { super(Object.class); }\n\n    /*\n    /**********************************************************\n    /* Deserializer API\n    /**********************************************************\n     */\n    \n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n        //    special unfortunately\n        if (p.hasToken(JsonToken.FIELD_NAME)) {\n            while (true) {\n                JsonToken t = p.nextToken();\n                if ((t == null) || (t == JsonToken.END_OBJECT)) {\n                    break;\n                }\n                p.skipChildren();\n            }\n        } else {\n            p.skipChildren();\n        }\n        return null;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer) throws IOException\n    {\n        // Not sure if we need to bother but:\n\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_ARRAY:\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n        default:\n            return null;\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 40, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.NumberDeserializers", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.HashSet;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n/**\n * Container class for deserializers that handle core JDK primitive\n * (and matching wrapper) types, as well as standard \"big\" numeric types.\n * Note that this includes types such as {@link java.lang.Boolean}\n * and {@link java.lang.Character} which are not strictly numeric,\n * but are part of primitive/wrapper types.\n */\npublic class NumberDeserializers\n{\n    private final static HashSet<String> _classNames = new HashSet<String>();\n    static {\n        // note: can skip primitive types; other ways to check them:\n        Class<?>[] numberTypes = new Class<?>[] {\n            Boolean.class,\n            Byte.class,\n            Short.class,\n            Character.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            // and more generic ones\n            Number.class, BigDecimal.class, BigInteger.class\n        };\n        for (Class<?> cls : numberTypes) {\n            _classNames.add(cls.getName());\n        }\n    }\n\n    public static JsonDeserializer<?> find(Class<?> rawType, String clsName) {\n        if (rawType.isPrimitive()) {\n            if (rawType == Integer.TYPE) {\n                return IntegerDeserializer.primitiveInstance;\n            }\n            if (rawType == Boolean.TYPE) {\n                return BooleanDeserializer.primitiveInstance;\n            }\n            if (rawType == Long.TYPE) {\n                return LongDeserializer.primitiveInstance;\n            }\n            if (rawType == Double.TYPE) {\n                return DoubleDeserializer.primitiveInstance;\n            }\n            if (rawType == Character.TYPE) {\n                return CharacterDeserializer.primitiveInstance;\n            }\n            if (rawType == Byte.TYPE) {\n                return ByteDeserializer.primitiveInstance;\n            }\n            if (rawType == Short.TYPE) {\n                return ShortDeserializer.primitiveInstance;\n            }\n            if (rawType == Float.TYPE) {\n                return FloatDeserializer.primitiveInstance;\n            }\n        } else if (_classNames.contains(clsName)) {\n            // Start with most common types; int, boolean, long, double\n            if (rawType == Integer.class) {\n                return IntegerDeserializer.wrapperInstance;\n            }\n            if (rawType == Boolean.class) {\n                return BooleanDeserializer.wrapperInstance;\n            }\n            if (rawType == Long.class) {\n                return LongDeserializer.wrapperInstance;\n            }\n            if (rawType == Double.class) {\n                return DoubleDeserializer.wrapperInstance;\n            }\n            if (rawType == Character.class) {\n                return CharacterDeserializer.wrapperInstance;\n            }\n            if (rawType == Byte.class) {\n                return ByteDeserializer.wrapperInstance;\n            }\n            if (rawType == Short.class) {\n                return ShortDeserializer.wrapperInstance;\n            }\n            if (rawType == Float.class) {\n                return FloatDeserializer.wrapperInstance;\n            }\n            if (rawType == Number.class) {\n                return NumberDeserializer.instance;\n            }\n            if (rawType == BigDecimal.class) {\n                return BigDecimalDeserializer.instance;\n            }\n            if (rawType == BigInteger.class) {\n                return BigIntegerDeserializer.instance;\n            }\n        } else {\n            return null;\n        }\n        // should never occur\n        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n    }\n    \n    /*\n    /**********************************************************\n    /* Then one intermediate base class for things that have\n    /* both primitive and wrapper types\n    /**********************************************************\n     */\n\n    protected abstract static class PrimitiveOrWrapperDeserializer<T>\n        extends StdScalarDeserializer<T>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final T _nullValue;\n        protected final boolean _primitive;\n\n        protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl) {\n            super(vc);\n            _nullValue = nvl;\n            _primitive = vc.isPrimitive();\n        }\n\n        @Override\n        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException\n        {\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map JSON null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n\n        @Override\n        @Deprecated // remove in 2.7\n        public final T getNullValue() {\n            return _nullValue;\n        }\n\n            // [databind#1095]: Should not allow coercion from into null from Empty String\n            // either, if `null` not allowed\n    }\n\n    /*\n    /**********************************************************\n    /* Then primitive/wrapper types\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    public final static class BooleanDeserializer\n        extends PrimitiveOrWrapperDeserializer<Boolean>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE);\n        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.class, null);\n\n        public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n        {\n            super(cls, nvl);\n        }\n        \n        @Override\n        public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException\n        {\n            return _parseBoolean(j, ctxt);\n        }\n\n        // Since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n        // (is it an error to even call this version?)\n        @Override\n        public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt,\n                TypeDeserializer typeDeserializer)\n            throws IOException\n        {\n            return _parseBoolean(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ByteDeserializer\n        extends PrimitiveOrWrapperDeserializer<Byte>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n        \n        public ByteDeserializer(Class<Byte> cls, Byte nvl)\n        {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            return _parseByte(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ShortDeserializer\n        extends PrimitiveOrWrapperDeserializer<Short>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.TYPE, Short.valueOf((short)0));\n        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.class, null);\n        \n        public ShortDeserializer(Class<Short> cls, Short nvl)\n        {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Short deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException\n        {\n            return _parseShort(jp, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class CharacterDeserializer\n        extends PrimitiveOrWrapperDeserializer<Character>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.TYPE, '\\0');\n        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.class, null);\n        \n        public CharacterDeserializer(Class<Character> cls, Character nvl)\n        {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Character deserialize(JsonParser p, DeserializationContext ctxt)\n            throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT: // ok iff ascii value\n                int value = p.getIntValue();\n                if (value >= 0 && value <= 0xFFFF) {\n                    return Character.valueOf((char) value);\n                }\n                break;\n            case JsonTokenId.ID_STRING: // this is the usual type\n                // But does it have to be exactly one char?\n                String text = p.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue(ctxt);\n                }               \n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Character C = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return C;\n                }\n            }\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class IntegerDeserializer\n        extends PrimitiveOrWrapperDeserializer<Integer>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.TYPE, Integer.valueOf(0));\n        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.class, null);\n        \n        public IntegerDeserializer(Class<Integer> cls, Integer nvl) {\n            super(cls, nvl);\n        }\n\n        // since 2.6, slightly faster lookups for this very common type\n        @Override\n        public boolean isCachable() { return true; }\n\n        @Override\n        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n\n        // Since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n        // (is it an error to even call this version?)\n        @Override\n        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt,\n                TypeDeserializer typeDeserializer) throws IOException\n        {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class LongDeserializer\n        extends PrimitiveOrWrapperDeserializer<Long>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.TYPE, Long.valueOf(0L));\n        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.class, null);\n        \n        public LongDeserializer(Class<Long> cls, Long nvl) {\n            super(cls, nvl);\n        }\n\n        // since 2.6, slightly faster lookups for this very common type\n        @Override\n        public boolean isCachable() { return true; }\n        \n        @Override\n        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getLongValue();\n            }\n            return _parseLong(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class FloatDeserializer\n        extends PrimitiveOrWrapperDeserializer<Float>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.TYPE, 0.f);\n        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.class, null);\n        \n        public FloatDeserializer(Class<Float> cls, Float nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            return _parseFloat(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class DoubleDeserializer\n        extends PrimitiveOrWrapperDeserializer<Double>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.TYPE, 0.d);\n        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.class, null);\n        \n        public DoubleDeserializer(Class<Double> cls, Double nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return _parseDouble(jp, ctxt);\n        }\n\n        // Since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n        // (is it an error to even call this version?)\n        @Override\n        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n                TypeDeserializer typeDeserializer) throws IOException\n        {\n            return _parseDouble(jp, ctxt);\n        }\n    }\n\n    /**\n     * For type <code>Number.class</code>, we can just rely on type\n     * mappings that plain {@link JsonParser#getNumberValue} returns.\n     *<p>\n     * There is one additional complication: some numeric\n     * types (specifically, int/Integer and double/Double) are \"non-typed\";\n     * meaning that they will NEVER be output with type information.\n     * But other numeric types may need such type information.\n     * This is why {@link #deserializeWithType} must be overridden.\n     */\n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class NumberDeserializer\n        extends StdScalarDeserializer<Object>\n    {\n        public final static NumberDeserializer instance = new NumberDeserializer();\n        \n        public NumberDeserializer() {\n            super(Number.class);\n        }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_STRING:\n                /* Textual values are more difficult... not parsing itself, but figuring\n                 * out 'minimal' type to use \n                 */\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return getEmptyValue(ctxt);\n                }\n                if (_hasTextualNull(text)) {\n                    return getNullValue(ctxt);\n                }\n                if (_isPosInf(text)) {\n                    return Double.POSITIVE_INFINITY;\n                }\n                if (_isNegInf(text)) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n                if (_isNaN(text)) {\n                    return Double.NaN;\n                }\n                try {\n                    if (!_isIntNumber(text)) {\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                            return new BigDecimal(text);\n                        }\n                        return new Double(text);\n                    }\n                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                        return new BigInteger(text);\n                    }\n                    long value = Long.parseLong(text);\n                    if (!ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n                        if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n                            return Integer.valueOf((int) value);\n                        }\n                    }\n                    return Long.valueOf(value);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid number\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Object value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return value;\n                }\n                break;\n            }\n            // Otherwise, no can do:\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n\n        /**\n         * As mentioned in class Javadoc, there is additional complexity in\n         * handling potentially mixed type information here. Because of this,\n         * we must actually check for \"raw\" integers and doubles first, before\n         * calling type deserializer.\n         */\n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n                                          TypeDeserializer typeDeserializer)\n            throws IOException\n        {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n            case JsonTokenId.ID_STRING:\n                // can not point to type information: hence must be non-typed (int/double)\n                return deserialize(jp, ctxt);\n            }\n            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* And then bit more complicated (but non-structured) number\n    /* types\n    /**********************************************************\n     */\n\n    /**\n     * This is bit trickier to implement efficiently, while avoiding\n     * overflow problems.\n     */\n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigIntegerDeserializer\n        extends StdScalarDeserializer<BigInteger>\n    {\n        public final static BigIntegerDeserializer instance = new BigIntegerDeserializer();\n\n        public BigIntegerDeserializer() { super(BigInteger.class); }\n\n        @SuppressWarnings(\"incomplete-switch\")\n        @Override\n        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                switch (p.getNumberType()) {\n                case INT:\n                case LONG:\n                case BIG_INTEGER:\n                    return p.getBigIntegerValue();\n                }\n                break;\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                    _failDoubleToIntCoercion(p, ctxt, \"java.math.BigInteger\");\n                }\n                return p.getDecimalValue().toBigInteger();\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigInteger value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            case JsonTokenId.ID_STRING: // let's do implicit re-parse\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigInteger(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            }\n            // String is ok too, can easily convert; otherwise, no can do:\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigDecimalDeserializer\n        extends StdScalarDeserializer<BigDecimal>\n    {\n        public final static BigDecimalDeserializer instance = new BigDecimalDeserializer();\n \n        public BigDecimalDeserializer() { super(BigDecimal.class); }\n\n        @Override\n        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt)\n            throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return p.getDecimalValue();\n            case JsonTokenId.ID_STRING:\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigDecimal(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigDecimal value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigDecimal' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            }\n            // Otherwise, no can do:\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.HashSet;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n\n/**\n * Container class for deserializers that handle core JDK primitive\n * (and matching wrapper) types, as well as standard \"big\" numeric types.\n * Note that this includes types such as {@link java.lang.Boolean}\n * and {@link java.lang.Character} which are not strictly numeric,\n * but are part of primitive/wrapper types.\n */\npublic class NumberDeserializers\n{\n    private final static HashSet<String> _classNames = new HashSet<String>();\n    static {\n        // note: can skip primitive types; other ways to check them:\n        Class<?>[] numberTypes = new Class<?>[] {\n            Boolean.class,\n            Byte.class,\n            Short.class,\n            Character.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            // and more generic ones\n            Number.class, BigDecimal.class, BigInteger.class\n        };\n        for (Class<?> cls : numberTypes) {\n            _classNames.add(cls.getName());\n        }\n    }\n\n    public static JsonDeserializer<?> find(Class<?> rawType, String clsName) {\n        if (rawType.isPrimitive()) {\n            if (rawType == Integer.TYPE) {\n                return IntegerDeserializer.primitiveInstance;\n            }\n            if (rawType == Boolean.TYPE) {\n                return BooleanDeserializer.primitiveInstance;\n            }\n            if (rawType == Long.TYPE) {\n                return LongDeserializer.primitiveInstance;\n            }\n            if (rawType == Double.TYPE) {\n                return DoubleDeserializer.primitiveInstance;\n            }\n            if (rawType == Character.TYPE) {\n                return CharacterDeserializer.primitiveInstance;\n            }\n            if (rawType == Byte.TYPE) {\n                return ByteDeserializer.primitiveInstance;\n            }\n            if (rawType == Short.TYPE) {\n                return ShortDeserializer.primitiveInstance;\n            }\n            if (rawType == Float.TYPE) {\n                return FloatDeserializer.primitiveInstance;\n            }\n        } else if (_classNames.contains(clsName)) {\n            // Start with most common types; int, boolean, long, double\n            if (rawType == Integer.class) {\n                return IntegerDeserializer.wrapperInstance;\n            }\n            if (rawType == Boolean.class) {\n                return BooleanDeserializer.wrapperInstance;\n            }\n            if (rawType == Long.class) {\n                return LongDeserializer.wrapperInstance;\n            }\n            if (rawType == Double.class) {\n                return DoubleDeserializer.wrapperInstance;\n            }\n            if (rawType == Character.class) {\n                return CharacterDeserializer.wrapperInstance;\n            }\n            if (rawType == Byte.class) {\n                return ByteDeserializer.wrapperInstance;\n            }\n            if (rawType == Short.class) {\n                return ShortDeserializer.wrapperInstance;\n            }\n            if (rawType == Float.class) {\n                return FloatDeserializer.wrapperInstance;\n            }\n            if (rawType == Number.class) {\n                return NumberDeserializer.instance;\n            }\n            if (rawType == BigDecimal.class) {\n                return BigDecimalDeserializer.instance;\n            }\n            if (rawType == BigInteger.class) {\n                return BigIntegerDeserializer.instance;\n            }\n        } else {\n            return null;\n        }\n        // should never occur\n        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n    }\n    \n    /*\n    /**********************************************************\n    /* Then one intermediate base class for things that have\n    /* both primitive and wrapper types\n    /**********************************************************\n     */\n\n    protected abstract static class PrimitiveOrWrapperDeserializer<T>\n        extends StdScalarDeserializer<T>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final T _nullValue;\n        protected final boolean _primitive;\n\n        protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl) {\n            super(vc);\n            _nullValue = nvl;\n            _primitive = vc.isPrimitive();\n        }\n\n        @Override\n        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException\n        {\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map JSON null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n\n        @Override\n        @Deprecated // remove in 2.7\n        public final T getNullValue() {\n            return _nullValue;\n        }\n\n        @Override\n        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n            // [databind#1095]: Should not allow coercion from into null from Empty String\n            // either, if `null` not allowed\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Then primitive/wrapper types\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    public final static class BooleanDeserializer\n        extends PrimitiveOrWrapperDeserializer<Boolean>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE);\n        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.class, null);\n\n        public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n        {\n            super(cls, nvl);\n        }\n        \n        @Override\n        public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException\n        {\n            return _parseBoolean(j, ctxt);\n        }\n\n        // Since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n        // (is it an error to even call this version?)\n        @Override\n        public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt,\n                TypeDeserializer typeDeserializer)\n            throws IOException\n        {\n            return _parseBoolean(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ByteDeserializer\n        extends PrimitiveOrWrapperDeserializer<Byte>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n        \n        public ByteDeserializer(Class<Byte> cls, Byte nvl)\n        {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            return _parseByte(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class ShortDeserializer\n        extends PrimitiveOrWrapperDeserializer<Short>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.TYPE, Short.valueOf((short)0));\n        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.class, null);\n        \n        public ShortDeserializer(Class<Short> cls, Short nvl)\n        {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Short deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException\n        {\n            return _parseShort(jp, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class CharacterDeserializer\n        extends PrimitiveOrWrapperDeserializer<Character>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.TYPE, '\\0');\n        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.class, null);\n        \n        public CharacterDeserializer(Class<Character> cls, Character nvl)\n        {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Character deserialize(JsonParser p, DeserializationContext ctxt)\n            throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT: // ok iff ascii value\n                int value = p.getIntValue();\n                if (value >= 0 && value <= 0xFFFF) {\n                    return Character.valueOf((char) value);\n                }\n                break;\n            case JsonTokenId.ID_STRING: // this is the usual type\n                // But does it have to be exactly one char?\n                String text = p.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue(ctxt);\n                }               \n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Character C = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return C;\n                }\n            }\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class IntegerDeserializer\n        extends PrimitiveOrWrapperDeserializer<Integer>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.TYPE, Integer.valueOf(0));\n        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.class, null);\n        \n        public IntegerDeserializer(Class<Integer> cls, Integer nvl) {\n            super(cls, nvl);\n        }\n\n        // since 2.6, slightly faster lookups for this very common type\n        @Override\n        public boolean isCachable() { return true; }\n\n        @Override\n        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n\n        // Since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n        // (is it an error to even call this version?)\n        @Override\n        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt,\n                TypeDeserializer typeDeserializer) throws IOException\n        {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getIntValue();\n            }\n            return _parseInteger(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public final static class LongDeserializer\n        extends PrimitiveOrWrapperDeserializer<Long>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.TYPE, Long.valueOf(0L));\n        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.class, null);\n        \n        public LongDeserializer(Class<Long> cls, Long nvl) {\n            super(cls, nvl);\n        }\n\n        // since 2.6, slightly faster lookups for this very common type\n        @Override\n        public boolean isCachable() { return true; }\n        \n        @Override\n        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n                return p.getLongValue();\n            }\n            return _parseLong(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class FloatDeserializer\n        extends PrimitiveOrWrapperDeserializer<Float>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.TYPE, 0.f);\n        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.class, null);\n        \n        public FloatDeserializer(Class<Float> cls, Float nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            return _parseFloat(p, ctxt);\n        }\n    }\n\n    @JacksonStdImpl\n    public static class DoubleDeserializer\n        extends PrimitiveOrWrapperDeserializer<Double>\n    {\n        private static final long serialVersionUID = 1L;\n\n        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.TYPE, 0.d);\n        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.class, null);\n        \n        public DoubleDeserializer(Class<Double> cls, Double nvl) {\n            super(cls, nvl);\n        }\n\n        @Override\n        public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return _parseDouble(jp, ctxt);\n        }\n\n        // Since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n        // (is it an error to even call this version?)\n        @Override\n        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n                TypeDeserializer typeDeserializer) throws IOException\n        {\n            return _parseDouble(jp, ctxt);\n        }\n    }\n\n    /**\n     * For type <code>Number.class</code>, we can just rely on type\n     * mappings that plain {@link JsonParser#getNumberValue} returns.\n     *<p>\n     * There is one additional complication: some numeric\n     * types (specifically, int/Integer and double/Double) are \"non-typed\";\n     * meaning that they will NEVER be output with type information.\n     * But other numeric types may need such type information.\n     * This is why {@link #deserializeWithType} must be overridden.\n     */\n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class NumberDeserializer\n        extends StdScalarDeserializer<Object>\n    {\n        public final static NumberDeserializer instance = new NumberDeserializer();\n        \n        public NumberDeserializer() {\n            super(Number.class);\n        }\n\n        @Override\n        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue();\n\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return Double.valueOf(p.getDoubleValue());\n\n            case JsonTokenId.ID_STRING:\n                /* Textual values are more difficult... not parsing itself, but figuring\n                 * out 'minimal' type to use \n                 */\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return getEmptyValue(ctxt);\n                }\n                if (_hasTextualNull(text)) {\n                    return getNullValue(ctxt);\n                }\n                if (_isPosInf(text)) {\n                    return Double.POSITIVE_INFINITY;\n                }\n                if (_isNegInf(text)) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n                if (_isNaN(text)) {\n                    return Double.NaN;\n                }\n                try {\n                    if (!_isIntNumber(text)) {\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                            return new BigDecimal(text);\n                        }\n                        return new Double(text);\n                    }\n                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                        return new BigInteger(text);\n                    }\n                    long value = Long.parseLong(text);\n                    if (!ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n                        if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n                            return Integer.valueOf((int) value);\n                        }\n                    }\n                    return Long.valueOf(value);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid number\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final Object value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\"\n                                );\n                    }\n                    return value;\n                }\n                break;\n            }\n            // Otherwise, no can do:\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n\n        /**\n         * As mentioned in class Javadoc, there is additional complexity in\n         * handling potentially mixed type information here. Because of this,\n         * we must actually check for \"raw\" integers and doubles first, before\n         * calling type deserializer.\n         */\n        @Override\n        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n                                          TypeDeserializer typeDeserializer)\n            throws IOException\n        {\n            switch (jp.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n            case JsonTokenId.ID_STRING:\n                // can not point to type information: hence must be non-typed (int/double)\n                return deserialize(jp, ctxt);\n            }\n            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* And then bit more complicated (but non-structured) number\n    /* types\n    /**********************************************************\n     */\n\n    /**\n     * This is bit trickier to implement efficiently, while avoiding\n     * overflow problems.\n     */\n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigIntegerDeserializer\n        extends StdScalarDeserializer<BigInteger>\n    {\n        public final static BigIntegerDeserializer instance = new BigIntegerDeserializer();\n\n        public BigIntegerDeserializer() { super(BigInteger.class); }\n\n        @SuppressWarnings(\"incomplete-switch\")\n        @Override\n        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                switch (p.getNumberType()) {\n                case INT:\n                case LONG:\n                case BIG_INTEGER:\n                    return p.getBigIntegerValue();\n                }\n                break;\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                    _failDoubleToIntCoercion(p, ctxt, \"java.math.BigInteger\");\n                }\n                return p.getDecimalValue().toBigInteger();\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigInteger value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            case JsonTokenId.ID_STRING: // let's do implicit re-parse\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigInteger(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            }\n            // String is ok too, can easily convert; otherwise, no can do:\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n    \n    @SuppressWarnings(\"serial\")\n    @JacksonStdImpl\n    public static class BigDecimalDeserializer\n        extends StdScalarDeserializer<BigDecimal>\n    {\n        public final static BigDecimalDeserializer instance = new BigDecimalDeserializer();\n \n        public BigDecimalDeserializer() { super(BigDecimal.class); }\n\n        @Override\n        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt)\n            throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return p.getDecimalValue();\n            case JsonTokenId.ID_STRING:\n                String text = p.getText().trim();\n                if (text.length() == 0) {\n                    return null;\n                }\n                try {\n                    return new BigDecimal(text);\n                } catch (IllegalArgumentException iae) {\n                    throw ctxt.weirdStringException(text, _valueClass, \"not a valid representation\");\n                }\n            case JsonTokenId.ID_START_ARRAY:\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final BigDecimal value = deserialize(p, ctxt);\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,\n                            \"Attempted to unwrap single value array for single 'BigDecimal' value but there was more than a single value in the array\"\n                        );\n                    }\n                    return value;\n                }\n                break;\n            }\n            // Otherwise, no can do:\n            throw ctxt.mappingException(_valueClass, p.getCurrentToken());\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 41, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.TypeFactory", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n\n    protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();\n\n    /*\n    /**********************************************************\n    /* Constants for \"well-known\" classes\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n\n    /*\n    /**********************************************************\n    /* Cached pre-constructed JavaType instances\n    /**********************************************************\n     */\n\n    // note: these are primitive, hence no super types\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG);\n\n    // and as to String... well, for now, ignore its super types\n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING);\n\n    // @since 2.7\n    protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);\n\n    /**\n     * Cache {@link Comparable} because it is both parameteric (relatively costly to\n     * resolve) and mostly useless (no special handling), better handle directly\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE);\n\n    /**\n     * Cache {@link Enum} because it is parametric AND self-referential (costly to\n     * resolve) and useless in itself (no special handling).\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM);\n\n    /**\n     * Cache {@link Class} because it is nominally parametric, but has no really\n     * useful information.\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n\n    protected final TypeParser _parser;\n    \n    /**\n     * ClassLoader used by this factory [databind#624].\n     */\n    protected final ClassLoader _classLoader;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        // As per [databind#894] must ensure we have back-linkage from TypeFactory:\n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    /*\n     * Getters\n     */\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Should be able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},\n     * to allow for overriding of lookup functionality in environments like OSGi.\n     *\n     * @since 2.6\n     */\n    public Class<?> findClass(String className) throws ClassNotFoundException\n    {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        // Two-phase lookup: first using context ClassLoader; then default\n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize,\n                                   ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className)\n    {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n        \n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            if (subclass.getTypeParameters().length == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n\n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n            // !!! TODO (as of 28-Jan-2016, at least)\n\n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,\n                        new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,\n                        NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n                // (hopefully passing null Class for root is ok)\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());        \n            }\n        } while (false);\n\n        // except possibly handlers\n//      newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }\n\n    /**\n     * Method similar to {@link #constructSpecializedType}, but that creates a\n     * less-specific type of given type. Usually this is as simple as simply\n     * finding super-type with type erasure of <code>superClass</code>, but\n     * there may be need for some additional work-arounds.\n     *\n     * @param superClass\n     *\n     * @since 2.7\n     */\n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            // Most likely, caller did not verify sub/super-type relationship\n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            // 01-Nov-2015, tatu: Should never happen, but ch\n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n\n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef)\n    {\n        // 19-Oct-2015, tatu: Simpler variant like so should work\n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        // but if not, due to funky sub-classing, type variables, what follows\n        // is a more complete processing a la Java ClassMate.\n\n        /*\n        final Class<?> refdRawType = typeRef.getClass();\n        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);\n        JavaType genType = type.findSuperType(TypeReference.class);\n        if (genType == null) { // sanity check; shouldn't occur\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        TypeBindings b = genType.getBindings();\n        JavaType[] params = b.typeParameterArray();\n        if (params.length == 0) {\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        return params[0];\n        */\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        return constructType(type, constructType(contextClass));\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        return _fromAny(null, type, contextType.getBindings());\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *<p>\n     * NOTE: was briefly deprecated for 2.6.\n     */\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *\n     * @since 2.6\n     *\n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    /**\n     * @since 2.6\n     */\n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)\n    {\n        return ReferenceType.construct(rawType, null, // no bindings\n                null, null, // or super-class, interfaces?\n                referredType);\n    }\n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here\n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param rawType Actual type-erased type\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)\n    {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level factory methods\n    /**********************************************************\n     */\n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        JavaType kt, vt;\n        \n        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake \"correct\" parameter sig\n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            // ok to have no types (\"raw\")\n            switch (typeParams.size()) {\n            case 0: // acceptable?\n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    /**\n     * Factory method to call when no special {@link JavaType} is needed,\n     * no generic parameters are passed. Default implementation may check\n     * pre-constructed values for \"well-known\" types, but if none found\n     * will simply call {@link #_newSimpleType}\n     *\n     * @since 2.7\n     */\n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Factory method that is to create a new {@link SimpleType} with no\n     * checks whatsoever. Default implementation calls the single argument\n     * constructor of {@link SimpleType}.\n     *\n     * @since 2.7\n     */\n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n         *    This may have been due to potential mutability of the instance; but that\n         *    should not be issue any more, and creation is somewhat wasteful. So let's\n         *    try reusing singleton/flyweight instance.\n         */\n        return CORE_TYPE_OBJECT;\n    }\n\n    /**\n     * Helper method called to see if requested, non-generic-parameterized\n     * type is one of common, \"well-known\" types, instances of which are\n     * pre-constructed and do not need dynamic caching.\n     *\n     * @since 2.7\n     */\n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Actual type resolution, traversal\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            // Important: remove possible bindings since this is type-erased thingy\n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { // [databind#116]\n            // no need to modify further if we already had JavaType\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, b, this);\n            }\n        }\n        return resultType;\n    }\n\n    /**\n     * @param bindings Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        // Very first thing: small set of core types we know well:\n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        // Barring that, we may have recently constructed an instance:\n        // !!! TODO 16-Oct-2015, tatu: For now let's only cached non-parameterized; otherwise\n        //     need better cache key\n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType); // ok, cache object is synced\n            if (result != null) {\n                return result;\n            }\n        }\n\n        // 15-Oct-2015, tatu: recursive reference?\n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                // Self-reference: needs special handling, then...\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            // no, but need to update context to allow for proper cycle resolution\n            context = context.child(rawType);\n        }\n\n        // First: do we have an array type?\n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            // If not, need to proceed by first resolving parent type hierarchy\n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                // Note: even Enums can implement interfaces, so can not drop those\n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...\n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            // And then check what flavor of type we got. Start by asking resolved\n            // super-type if refinement is all that is needed?\n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            // if not, perhaps we are now resolving a well-known class or interface?\n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        // but if nothing else, \"simple\" class for now:\n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result); // cache object syncs\n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    /**\n     * Helper class used to check whether exact class for which type is being constructed\n     * is one of well-known base interfaces or classes that indicates alternate\n     * {@link JavaType} implementation.\n     */\n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // Quite simple when we resolving exact class/interface; start with that\n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        // and since 2.6 one referential type\n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        // 01-Nov-2015, tatu: As of 2.7, couple of potential `CollectionLikeType`s (like\n        //    `Iterable`, `Iterator`), and `MapLikeType`s (`Map.Entry`) are not automatically\n        //    detected, related to difficulties in propagating type upwards (Iterable, for\n        //    example, is a weak, tag-on type). They may be detectable in future.\n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // But that's not all: may be possible current type actually implements an\n        // interface type. So...\n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,\n            TypeBindings parentBindings)\n    {\n        // Assumption here is we'll always get Class, not one of other Types\n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of\n        //   couple of not-so-useful parametric types\n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        // First: what is the actual base type? One odd thing is that 'getRawType'\n        // returns Type, not Class<?> as one might expect. But let's assume it is\n        // always of type Class: if not, need to add more code to resolve it to Class.        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)\n    {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)\n    {\n        // ideally should find it via bindings:\n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        // but if not, use bounds... note that approach here is simplistic; not taking\n        // into account possible multiple bounds, nor consider upper bounds.\n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)\n    {\n        /* Similar to challenges with TypeVariable, we may have multiple upper bounds.\n         * But it is also possible that if upper bound defaults to Object, we might\n         * want to consider lower bounds instead.\n         * For now, we won't try anything more advanced; above is just for future reference.\n         */\n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n\n    protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();\n\n    /*\n    /**********************************************************\n    /* Constants for \"well-known\" classes\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n\n    /*\n    /**********************************************************\n    /* Cached pre-constructed JavaType instances\n    /**********************************************************\n     */\n\n    // note: these are primitive, hence no super types\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG);\n\n    // and as to String... well, for now, ignore its super types\n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING);\n\n    // @since 2.7\n    protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);\n\n    /**\n     * Cache {@link Comparable} because it is both parameteric (relatively costly to\n     * resolve) and mostly useless (no special handling), better handle directly\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE);\n\n    /**\n     * Cache {@link Enum} because it is parametric AND self-referential (costly to\n     * resolve) and useless in itself (no special handling).\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM);\n\n    /**\n     * Cache {@link Class} because it is nominally parametric, but has no really\n     * useful information.\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n\n    protected final TypeParser _parser;\n    \n    /**\n     * ClassLoader used by this factory [databind#624].\n     */\n    protected final ClassLoader _classLoader;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        // As per [databind#894] must ensure we have back-linkage from TypeFactory:\n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n    \n    /*\n     * Getters\n     */\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Should be able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},\n     * to allow for overriding of lookup functionality in environments like OSGi.\n     *\n     * @since 2.6\n     */\n    public Class<?> findClass(String className) throws ClassNotFoundException\n    {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        // Two-phase lookup: first using context ClassLoader; then default\n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize,\n                                   ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className)\n    {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n        \n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            if (subclass.getTypeParameters().length == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n\n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n            // !!! TODO (as of 28-Jan-2016, at least)\n\n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,\n                        new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,\n                        NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n                // (hopefully passing null Class for root is ok)\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());        \n            }\n        } while (false);\n\n        // except possibly handlers\n//      newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }\n\n    /**\n     * Method similar to {@link #constructSpecializedType}, but that creates a\n     * less-specific type of given type. Usually this is as simple as simply\n     * finding super-type with type erasure of <code>superClass</code>, but\n     * there may be need for some additional work-arounds.\n     *\n     * @param superClass\n     *\n     * @since 2.7\n     */\n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            // Most likely, caller did not verify sub/super-type relationship\n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            // 01-Nov-2015, tatu: Should never happen, but ch\n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n\n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef)\n    {\n        // 19-Oct-2015, tatu: Simpler variant like so should work\n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        // but if not, due to funky sub-classing, type variables, what follows\n        // is a more complete processing a la Java ClassMate.\n\n        /*\n        final Class<?> refdRawType = typeRef.getClass();\n        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);\n        JavaType genType = type.findSuperType(TypeReference.class);\n        if (genType == null) { // sanity check; shouldn't occur\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        TypeBindings b = genType.getBindings();\n        JavaType[] params = b.typeParameterArray();\n        if (params.length == 0) {\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        return params[0];\n        */\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *<p>\n     * NOTE: was briefly deprecated for 2.6.\n     */\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *\n     * @since 2.6\n     *\n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    /**\n     * @since 2.6\n     */\n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)\n    {\n        return ReferenceType.construct(rawType, null, // no bindings\n                null, null, // or super-class, interfaces?\n                referredType);\n    }\n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here\n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param rawType Actual type-erased type\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)\n    {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level factory methods\n    /**********************************************************\n     */\n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        JavaType kt, vt;\n        \n        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake \"correct\" parameter sig\n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            // ok to have no types (\"raw\")\n            switch (typeParams.size()) {\n            case 0: // acceptable?\n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    /**\n     * Factory method to call when no special {@link JavaType} is needed,\n     * no generic parameters are passed. Default implementation may check\n     * pre-constructed values for \"well-known\" types, but if none found\n     * will simply call {@link #_newSimpleType}\n     *\n     * @since 2.7\n     */\n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Factory method that is to create a new {@link SimpleType} with no\n     * checks whatsoever. Default implementation calls the single argument\n     * constructor of {@link SimpleType}.\n     *\n     * @since 2.7\n     */\n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n         *    This may have been due to potential mutability of the instance; but that\n         *    should not be issue any more, and creation is somewhat wasteful. So let's\n         *    try reusing singleton/flyweight instance.\n         */\n        return CORE_TYPE_OBJECT;\n    }\n\n    /**\n     * Helper method called to see if requested, non-generic-parameterized\n     * type is one of common, \"well-known\" types, instances of which are\n     * pre-constructed and do not need dynamic caching.\n     *\n     * @since 2.7\n     */\n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Actual type resolution, traversal\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            // Important: remove possible bindings since this is type-erased thingy\n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { // [databind#116]\n            // no need to modify further if we already had JavaType\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, b, this);\n            }\n        }\n        return resultType;\n    }\n\n    /**\n     * @param bindings Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        // Very first thing: small set of core types we know well:\n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        // Barring that, we may have recently constructed an instance:\n        // !!! TODO 16-Oct-2015, tatu: For now let's only cached non-parameterized; otherwise\n        //     need better cache key\n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType); // ok, cache object is synced\n            if (result != null) {\n                return result;\n            }\n        }\n\n        // 15-Oct-2015, tatu: recursive reference?\n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                // Self-reference: needs special handling, then...\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            // no, but need to update context to allow for proper cycle resolution\n            context = context.child(rawType);\n        }\n\n        // First: do we have an array type?\n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            // If not, need to proceed by first resolving parent type hierarchy\n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                // Note: even Enums can implement interfaces, so can not drop those\n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...\n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            // And then check what flavor of type we got. Start by asking resolved\n            // super-type if refinement is all that is needed?\n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            // if not, perhaps we are now resolving a well-known class or interface?\n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        // but if nothing else, \"simple\" class for now:\n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result); // cache object syncs\n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    /**\n     * Helper class used to check whether exact class for which type is being constructed\n     * is one of well-known base interfaces or classes that indicates alternate\n     * {@link JavaType} implementation.\n     */\n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // Quite simple when we resolving exact class/interface; start with that\n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        // and since 2.6 one referential type\n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        // 01-Nov-2015, tatu: As of 2.7, couple of potential `CollectionLikeType`s (like\n        //    `Iterable`, `Iterator`), and `MapLikeType`s (`Map.Entry`) are not automatically\n        //    detected, related to difficulties in propagating type upwards (Iterable, for\n        //    example, is a weak, tag-on type). They may be detectable in future.\n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // But that's not all: may be possible current type actually implements an\n        // interface type. So...\n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,\n            TypeBindings parentBindings)\n    {\n        // Assumption here is we'll always get Class, not one of other Types\n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of\n        //   couple of not-so-useful parametric types\n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        // First: what is the actual base type? One odd thing is that 'getRawType'\n        // returns Type, not Class<?> as one might expect. But let's assume it is\n        // always of type Class: if not, need to add more code to resolve it to Class.        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)\n    {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)\n    {\n        // ideally should find it via bindings:\n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        // but if not, use bounds... note that approach here is simplistic; not taking\n        // into account possible multiple bounds, nor consider upper bounds.\n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)\n    {\n        /* Similar to challenges with TypeVariable, we may have multiple upper bounds.\n         * But it is also possible that if upper bound defaults to Object, we might\n         * want to consider lower bounds instead.\n         * For now, we won't try anything more advanced; above is just for future reference.\n         */\n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 42, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.std.FromStringDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Currency;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n    public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n        };\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserializer implementations\n    /**********************************************************\n     */\n    \n    protected FromStringDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    /**\n     * Factory method for trying to find a deserializer for one of supported\n     * types that have simple from-String serialization.\n     */\n    public static Std findDeserializer(Class<?> rawType)\n    {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserializer implementations\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Issue#381\n        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            jp.nextToken();\n            final T value = deserialize(jp, ctxt);\n            if (jp.nextToken() != JsonToken.END_ARRAY) {\n                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n            }\n            return value;\n        }\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = jp.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                T result = _deserialize(text, ctxt);\n                if (result != null) {\n                    return result;\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // nothing to do here, yet? We'll fail anyway\n        }\n        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = jp.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        throw ctxt.mappingException(_valueClass);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n\n    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        // default impl: error out\n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* A general-purpose implementation\n    /**********************************************************\n     */\n\n    /**\n     * \"Chameleon\" deserializer that works on simple types that are deserialized\n     * from a simple String.\n     * \n     * @since 2.4\n     */\n    public static class Std extends FromStringDeserializer<Object>\n    {\n        private static final long serialVersionUID = 1;\n\n        public final static int STD_FILE = 1;\n        public final static int STD_URL = 2;\n        public final static int STD_URI = 3;\n        public final static int STD_CLASS = 4;\n        public final static int STD_JAVA_TYPE = 5;\n        public final static int STD_CURRENCY = 6;\n        public final static int STD_PATTERN = 7;\n        public final static int STD_LOCALE = 8;\n        public final static int STD_CHARSET = 9;\n        public final static int STD_TIME_ZONE = 10;\n        public final static int STD_INET_ADDRESS = 11;\n        public final static int STD_INET_SOCKET_ADDRESS = 12;\n\n        protected final int _kind;\n        \n        protected Std(Class<?> valueType, int kind) {\n            super(valueType);\n            _kind = kind;\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                // will throw IAE if unknown:\n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                // will throw IAE (or its subclass) if malformed\n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = value.indexOf('_');\n                    if (ix < 0) { // single argument\n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = value.indexOf('_');\n                    if (ix < 0) { // two pieces\n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    // bracketed IPv6 (with port number)\n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(\"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        // host:port\n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    // host or unbracketed IPv6, without port number\n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            // As per [databind#398], URI requires special handling\n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            // As per [databind#1123], Locale too\n            return super._deserializeFromEmptyString();\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Currency;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.util.regex.Pattern;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n    public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n        };\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserializer implementations\n    /**********************************************************\n     */\n    \n    protected FromStringDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    /**\n     * Factory method for trying to find a deserializer for one of supported\n     * types that have simple from-String serialization.\n     */\n    public static Std findDeserializer(Class<?> rawType)\n    {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserializer implementations\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Issue#381\n        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            jp.nextToken();\n            final T value = deserialize(jp, ctxt);\n            if (jp.nextToken() != JsonToken.END_ARRAY) {\n                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n            }\n            return value;\n        }\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = jp.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                T result = _deserialize(text, ctxt);\n                if (result != null) {\n                    return result;\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // nothing to do here, yet? We'll fail anyway\n        }\n        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = jp.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        throw ctxt.mappingException(_valueClass);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n\n    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        // default impl: error out\n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* A general-purpose implementation\n    /**********************************************************\n     */\n\n    /**\n     * \"Chameleon\" deserializer that works on simple types that are deserialized\n     * from a simple String.\n     * \n     * @since 2.4\n     */\n    public static class Std extends FromStringDeserializer<Object>\n    {\n        private static final long serialVersionUID = 1;\n\n        public final static int STD_FILE = 1;\n        public final static int STD_URL = 2;\n        public final static int STD_URI = 3;\n        public final static int STD_CLASS = 4;\n        public final static int STD_JAVA_TYPE = 5;\n        public final static int STD_CURRENCY = 6;\n        public final static int STD_PATTERN = 7;\n        public final static int STD_LOCALE = 8;\n        public final static int STD_CHARSET = 9;\n        public final static int STD_TIME_ZONE = 10;\n        public final static int STD_INET_ADDRESS = 11;\n        public final static int STD_INET_SOCKET_ADDRESS = 12;\n\n        protected final int _kind;\n        \n        protected Std(Class<?> valueType, int kind) {\n            super(valueType);\n            _kind = kind;\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                // will throw IAE if unknown:\n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                // will throw IAE (or its subclass) if malformed\n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = value.indexOf('_');\n                    if (ix < 0) { // single argument\n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = value.indexOf('_');\n                    if (ix < 0) { // two pieces\n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    // bracketed IPv6 (with port number)\n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(\"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        // host:port\n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    // host or unbracketed IPv6, without port number\n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            // As per [databind#398], URI requires special handling\n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            // As per [databind#1123], Locale too\n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }\n            return super._deserializeFromEmptyString();\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 43, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty", "buggy_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n\n/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final ObjectIdReader _objectIdReader;\n\n    public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n            PropertyMetadata metadata)\n    {\n        super(objectIdReader.propertyName, objectIdReader.getIdType(), metadata,\n                objectIdReader.getDeserializer());\n        _objectIdReader = objectIdReader;\n    }\n\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, JsonDeserializer<?> deser)\n    {\n        super(src, deser);\n        _objectIdReader = src._objectIdReader;\n    }\n\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, PropertyName newName) {\n        super(src, newName);\n        _objectIdReader = src._objectIdReader;\n    }\n\n    @Override\n    public ObjectIdValueProperty withName(PropertyName newName) {\n        return new ObjectIdValueProperty(this, newName);\n    }\n\n    @Override\n    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        return new ObjectIdValueProperty(this, deser);\n    }\n    \n    // // // BeanProperty impl\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return null;\n    }\n\n    @Override public AnnotatedMember getMember() {  return null; }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods\n    /**********************************************************\n     */\n\n    @Override\n    public void deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object instance) throws IOException\n    {\n        deserializeSetAndReturn(p, ctxt, instance);\n    }\n\n    @Override\n    public Object deserializeSetAndReturn(JsonParser p,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        Object id = _valueDeserializer.deserialize(p, ctxt);\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        if (id == null) {\n            return null;\n        }\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }\n\n    @Override\n    public void set(Object instance, Object value) throws IOException {\n        setAndReturn(instance, value);\n    }\n\n    @Override\n    public Object setAndReturn(Object instance, Object value) throws IOException\n    {\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp == null) {\n            throw new UnsupportedOperationException(\n                    \"Should not call set() on ObjectIdProperty that has no SettableBeanProperty\");\n        }\n        return idProp.setAndReturn(instance, value);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.*;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n\n/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final ObjectIdReader _objectIdReader;\n\n    public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n            PropertyMetadata metadata)\n    {\n        super(objectIdReader.propertyName, objectIdReader.getIdType(), metadata,\n                objectIdReader.getDeserializer());\n        _objectIdReader = objectIdReader;\n    }\n\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, JsonDeserializer<?> deser)\n    {\n        super(src, deser);\n        _objectIdReader = src._objectIdReader;\n    }\n\n    protected ObjectIdValueProperty(ObjectIdValueProperty src, PropertyName newName) {\n        super(src, newName);\n        _objectIdReader = src._objectIdReader;\n    }\n\n    @Override\n    public ObjectIdValueProperty withName(PropertyName newName) {\n        return new ObjectIdValueProperty(this, newName);\n    }\n\n    @Override\n    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {\n        return new ObjectIdValueProperty(this, deser);\n    }\n    \n    // // // BeanProperty impl\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return null;\n    }\n\n    @Override public AnnotatedMember getMember() {  return null; }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods\n    /**********************************************************\n     */\n\n    @Override\n    public void deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object instance) throws IOException\n    {\n        deserializeSetAndReturn(p, ctxt, instance);\n    }\n\n    @Override\n    public Object deserializeSetAndReturn(JsonParser p,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException\n    {\n        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n         *  missing or null id is needed for some cases, such as cases where id\n         *  will be generated externally, at a later point, and is not available\n         *  quite yet. Typical use case is with DB inserts.\n         */\n        // note: no null checks (unlike usually); deserializer should fail if one found\n        if (p.hasToken(JsonToken.VALUE_NULL)) {\n            return null;\n        }\n        Object id = _valueDeserializer.deserialize(p, ctxt);\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(instance);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(instance, id);\n        }\n        return instance;\n    }\n\n    @Override\n    public void set(Object instance, Object value) throws IOException {\n        setAndReturn(instance, value);\n    }\n\n    @Override\n    public Object setAndReturn(Object instance, Object value) throws IOException\n    {\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp == null) {\n            throw new UnsupportedOperationException(\n                    \"Should not call set() on ObjectIdProperty that has no SettableBeanProperty\");\n        }\n        return idProp.setAndReturn(instance, value);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 44, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.SimpleType", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by core Jackson databind functionality;\n     * should never be called by application code.\n     *<p>\n     * As with other direct construction that by-passes {@link TypeFactory},\n     * no introspection occurs with respect to super-types; caller must be\n     * aware of consequences if using this method.\n     */\n    protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    /**\n     * Simple copy-constructor, usually used when upgrading/refining a simple type\n     * into more specialized type.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * Pass-through constructor used by {@link ReferenceType}.\n     * \n     * @since 2.6\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    /**\n     * Method used by core Jackson classes: NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance.\n     *<p>\n     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n     * not in same package\n     */\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }\n\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        TypeBindings b = TypeBindings.emptyBindings();\n        return new SimpleType(cls, b,\n                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n    }\n\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n        // TODO: fix in 2.8\n            /*\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n                    */\n            return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                    _valueHandler, _typeHandler, _asStatic);\n        // Otherwise, stitch together the hierarchy. First, super-class\n        // if not found, try a super-interface\n        // should not get here but...\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method we need to recursively build skeletal representations\n     * of superclasses.\n     * \n     * @since 2.7 -- remove when not needed (2.8?)\n     */\n    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)\n    {\n        if (superClass == null) {\n            return null;\n        }\n        if (superClass == Object.class) {\n            return TypeFactory.unknownType();\n        }\n        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n        return new SimpleType(superClass, b,\n                superSuper, null, null, null, false);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by core Jackson databind functionality;\n     * should never be called by application code.\n     *<p>\n     * As with other direct construction that by-passes {@link TypeFactory},\n     * no introspection occurs with respect to super-types; caller must be\n     * aware of consequences if using this method.\n     */\n    protected SimpleType(Class<?> cls) {\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts) {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    /**\n     * Simple copy-constructor, usually used when upgrading/refining a simple type\n     * into more specialized type.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(TypeBase base) {\n        super(base);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts,\n                0, valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * Pass-through constructor used by {@link ReferenceType}.\n     * \n     * @since 2.6\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, \n                extraHash, valueHandler, typeHandler, asStatic);\n    }\n    \n    /**\n     * Method used by core Jackson classes: NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance.\n     *<p>\n     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n     * not in same package\n     */\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }\n\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        TypeBindings b = TypeBindings.emptyBindings();\n        return new SimpleType(cls, b,\n                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n    }\n\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n        // TODO: fix in 2.8\n        if (!_class.isAssignableFrom(subclass)) {\n            /*\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n                    */\n            return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                    _valueHandler, _typeHandler, _asStatic);\n        }\n        // Otherwise, stitch together the hierarchy. First, super-class\n        Class<?> next = subclass.getSuperclass();\n        if (next == _class) { // straight up parent class? Great.\n            return new SimpleType(subclass, _bindings, this,\n                    _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n        }\n        if ((next != null) && _class.isAssignableFrom(next)) {\n            JavaType superb = _narrow(next);\n            return new SimpleType(subclass, _bindings, superb,\n                    null, _valueHandler, _typeHandler, _asStatic);\n        }\n        // if not found, try a super-interface\n        Class<?>[] nextI = subclass.getInterfaces();\n        for (Class<?> iface : nextI) {\n            if (iface == _class) { // directly implemented\n                return new SimpleType(subclass, _bindings, null,\n                        new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic);\n            }\n            if (_class.isAssignableFrom(iface)) { // indirect, so recurse\n                JavaType superb = _narrow(iface);\n                return new SimpleType(subclass, _bindings, null,\n                        new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic);\n            }\n        }\n        // should not get here but...\n        throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \"\n                +_class.getName());\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }\n    \n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method we need to recursively build skeletal representations\n     * of superclasses.\n     * \n     * @since 2.7 -- remove when not needed (2.8?)\n     */\n    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)\n    {\n        if (superClass == null) {\n            return null;\n        }\n        if (superClass == Object.class) {\n            return TypeFactory.unknownType();\n        }\n        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n        return new SimpleType(superClass, b,\n                superSuper, null, null, null, false);\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 45, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.std.DateTimeSerializerBase", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.*;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\n\n@SuppressWarnings(\"serial\")\npublic abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    /**\n     * Flag that indicates that serialization must be done as the\n     * Java timestamp, regardless of other settings.\n     */\n    protected final Boolean _useTimestamp;\n    \n    /**\n     * Specific format to use, if not default format: non null value\n     * also indicates that serialization is to be done as JSON String,\n     * not numeric timestamp, unless {@link #_useTimestamp} is true.\n     */\n    protected final DateFormat _customFormat;\n\n    protected DateTimeSerializerBase(Class<T> type,\n            Boolean useTimestamp, DateFormat customFormat)\n    {\n        super(type);\n        _useTimestamp = useTimestamp;\n        _customFormat = customFormat;\n    }\n\n    public abstract DateTimeSerializerBase<T> withFormat(Boolean timestamp, DateFormat customFormat);\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n                if (format.getShape() == JsonFormat.Shape.STRING) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    @Deprecated\n    @Override\n    public boolean isEmpty(T value) {\n        // let's assume \"null date\" (timestamp 0) qualifies for empty\n        return (value == null) || (_timestamp(value) == 0L);\n    }\n\n    @Override\n    public boolean isEmpty(SerializerProvider serializers, T value) {\n        // let's assume \"null date\" (timestamp 0) qualifies for empty\n        return (value == null) || (_timestamp(value) == 0L);\n    }\n    \n    protected abstract long _timestamp(T value);\n    \n    @Override\n    public JsonNode getSchema(SerializerProvider serializers, Type typeHint) {\n        //todo: (ryan) add a format for the date in the schema?\n        return createSchemaNode(_asTimestamp(serializers) ? \"number\" : \"string\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        _acceptJsonFormatVisitor(visitor, typeHint, _asTimestamp(visitor.getProvider()));\n    }\n\n    /*\n    /**********************************************************\n    /* Actual serialization\n    /**********************************************************\n     */\n\n    @Override\n    public abstract void serialize(T value, JsonGenerator gen, SerializerProvider serializers)\n        throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected boolean _asTimestamp(SerializerProvider serializers)\n    {\n        if (_useTimestamp != null) {\n            return _useTimestamp.booleanValue();\n        }\n        if (_customFormat == null) {\n            if (serializers != null) {\n                return serializers.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n            }\n            // 12-Jun-2014, tatu: Is it legal not to have provider? Was NPE:ing earlier so leave a check\n            throw new IllegalArgumentException(\"Null SerializerProvider passed for \"+handledType().getName());\n        }\n        return false;\n    }\n\n    protected void _acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint,\n\t\tboolean asNumber) throws JsonMappingException\n    {\n        if (asNumber) {\n            visitIntFormat(visitor, typeHint,\n                    JsonParser.NumberType.LONG, JsonValueFormat.UTC_MILLISEC);\n        } else {\n            visitStringFormat(visitor, typeHint, JsonValueFormat.DATE_TIME);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.jsonFormatVisitors.*;\nimport com.fasterxml.jackson.databind.ser.ContextualSerializer;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\n\n@SuppressWarnings(\"serial\")\npublic abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    /**\n     * Flag that indicates that serialization must be done as the\n     * Java timestamp, regardless of other settings.\n     */\n    protected final Boolean _useTimestamp;\n    \n    /**\n     * Specific format to use, if not default format: non null value\n     * also indicates that serialization is to be done as JSON String,\n     * not numeric timestamp, unless {@link #_useTimestamp} is true.\n     */\n    protected final DateFormat _customFormat;\n\n    protected DateTimeSerializerBase(Class<T> type,\n            Boolean useTimestamp, DateFormat customFormat)\n    {\n        super(type);\n        _useTimestamp = useTimestamp;\n        _customFormat = customFormat;\n    }\n\n    public abstract DateTimeSerializerBase<T> withFormat(Boolean timestamp, DateFormat customFormat);\n\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    @Deprecated\n    @Override\n    public boolean isEmpty(T value) {\n        // let's assume \"null date\" (timestamp 0) qualifies for empty\n        return (value == null) || (_timestamp(value) == 0L);\n    }\n\n    @Override\n    public boolean isEmpty(SerializerProvider serializers, T value) {\n        // let's assume \"null date\" (timestamp 0) qualifies for empty\n        return (value == null) || (_timestamp(value) == 0L);\n    }\n    \n    protected abstract long _timestamp(T value);\n    \n    @Override\n    public JsonNode getSchema(SerializerProvider serializers, Type typeHint) {\n        //todo: (ryan) add a format for the date in the schema?\n        return createSchemaNode(_asTimestamp(serializers) ? \"number\" : \"string\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        _acceptJsonFormatVisitor(visitor, typeHint, _asTimestamp(visitor.getProvider()));\n    }\n\n    /*\n    /**********************************************************\n    /* Actual serialization\n    /**********************************************************\n     */\n\n    @Override\n    public abstract void serialize(T value, JsonGenerator gen, SerializerProvider serializers)\n        throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected boolean _asTimestamp(SerializerProvider serializers)\n    {\n        if (_useTimestamp != null) {\n            return _useTimestamp.booleanValue();\n        }\n        if (_customFormat == null) {\n            if (serializers != null) {\n                return serializers.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n            }\n            // 12-Jun-2014, tatu: Is it legal not to have provider? Was NPE:ing earlier so leave a check\n            throw new IllegalArgumentException(\"Null SerializerProvider passed for \"+handledType().getName());\n        }\n        return false;\n    }\n\n    protected void _acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint,\n\t\tboolean asNumber) throws JsonMappingException\n    {\n        if (asNumber) {\n            visitIntFormat(visitor, typeHint,\n                    JsonParser.NumberType.LONG, JsonValueFormat.UTC_MILLISEC);\n        } else {\n            visitStringFormat(visitor, typeHint, JsonValueFormat.DATE_TIME);\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 46, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.ReferenceType", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Specialized {@link SimpleType} for types that are referential types,\n * that is, values that can be dereferenced to another value (or null),\n * of different type.\n * Referenced type is accessible using {@link #getContentType()}.\n * \n * @since 2.6\n */\npublic class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final JavaType _referencedType;\n\n    protected ReferenceType(Class<?> cls, JavaType refType,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, refType.hashCode(),\n                valueHandler, typeHandler, asStatic);\n        _referencedType = refType;\n    }\n\n    public static ReferenceType construct(Class<?> cls, JavaType refType,\n            Object valueHandler, Object typeHandler)\n    {\n        return new ReferenceType(cls, refType, null, null, false);\n    }                                   \n    \n    @Override\n    public ReferenceType withTypeHandler(Object h)\n    {\n        if (h == _typeHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentTypeHandler(Object h)\n    {\n        if (h == _referencedType.<Object>getTypeHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType, h, _typeHandler,_asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentValueHandler(Object h) {\n        if (h == _referencedType.<Object>getValueHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType.withStaticTyping(),\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Narrow/widen\n    /**********************************************************\n     */\n    \n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Should we check that there is a sub-class relationship?\n        return new ReferenceType(subclass, _referencedType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n    \n    @Override\n    public JavaType getReferencedType() {\n        return _referencedType;\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(';');\n        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Specialized {@link SimpleType} for types that are referential types,\n * that is, values that can be dereferenced to another value (or null),\n * of different type.\n * Referenced type is accessible using {@link #getContentType()}.\n * \n * @since 2.6\n */\npublic class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final JavaType _referencedType;\n\n    protected ReferenceType(Class<?> cls, JavaType refType,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, refType.hashCode(),\n                valueHandler, typeHandler, asStatic);\n        _referencedType = refType;\n    }\n\n    public static ReferenceType construct(Class<?> cls, JavaType refType,\n            Object valueHandler, Object typeHandler)\n    {\n        return new ReferenceType(cls, refType, null, null, false);\n    }                                   \n    \n    @Override\n    public ReferenceType withTypeHandler(Object h)\n    {\n        if (h == _typeHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentTypeHandler(Object h)\n    {\n        if (h == _referencedType.<Object>getTypeHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType.withTypeHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType, h, _typeHandler,_asStatic);\n    }\n\n    @Override\n    public ReferenceType withContentValueHandler(Object h) {\n        if (h == _referencedType.<Object>getValueHandler()) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType.withValueHandler(h),\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _referencedType.withStaticTyping(),\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Narrow/widen\n    /**********************************************************\n     */\n    \n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Should we check that there is a sub-class relationship?\n        return new ReferenceType(subclass, _referencedType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n    \n    @Override\n    public JavaType getReferencedType() {\n        return _referencedType;\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 47, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.AnnotationIntrospector", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.core.Versioned;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.type.MapLikeType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.Converter;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Abstract class that defines API used for introspecting annotation-based\n * configuration for serialization and deserialization. Separated\n * so that different sets of annotations can be supported, and support\n * plugged-in dynamically.\n *<p>\n * Although default implementations are based on using annotations as the only\n * (or at least main) information source, custom implementations are not limited\n * in such a way, and in fact there is no expectation they should be. So the name\n * is bit of misnomer; this is a general configuration introspection facility.\n *<p>\n * NOTE: due to rapid addition of new methods (and changes to existing methods),\n * it is <b>strongly</b> recommended that custom implementations should not directly\n * extend this class, but rather extend {@link NopAnnotationIntrospector}.\n * This way added methods will not break backwards compatibility of custom annotation\n * introspectors.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class AnnotationIntrospector\n    implements Versioned, java.io.Serializable\n{\n    /*\n    /**********************************************************\n    /* Helper types\n    /**********************************************************\n     */\n\n    /**\n     * Value type used with managed and back references; contains type and\n     * logic name, used to link related references\n     */\n    public static class ReferenceProperty\n    {\n        public enum Type {\n            /**\n             * Reference property that Jackson manages and that is serialized normally (by serializing\n             * reference object), but is used for resolving back references during\n             * deserialization.\n             * Usually this can be defined by using\n             * {@link com.fasterxml.jackson.annotation.JsonManagedReference}\n             */\n            MANAGED_REFERENCE\n    \n            /**\n             * Reference property that Jackson manages by suppressing it during serialization,\n             * and reconstructing during deserialization.\n             * Usually this can be defined by using\n             * {@link com.fasterxml.jackson.annotation.JsonBackReference}\n             */\n            ,BACK_REFERENCE\n            ;\n        }\n\n        private final Type _type;\n        private final String _name;\n\n        public ReferenceProperty(Type t, String n) {\n            _type = t;\n            _name = n;\n        }\n\n        public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }\n        public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }\n        \n        public Type getType() { return _type; }\n        public String getName() { return _name; }\n\n        public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }\n        public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method for accessing \"no operation\" implementation\n     * of introspector: instance that will never find any annotation-based\n     * configuration.\n     */\n    public static AnnotationIntrospector nopInstance() {\n        return NopAnnotationIntrospector.instance;\n    }\n\n    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n        return new AnnotationIntrospectorPair(a1, a2);\n    }\n\n    /*\n    /**********************************************************\n    /* Access to possibly chained introspectors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation returns a Singleton list with this introspector\n     * as contents.\n     * This usually works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     */\n    public Collection<AnnotationIntrospector> allIntrospectors() {\n        return Collections.singletonList(this);\n    }\n    \n    /**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation adds this introspector in result; this usually\n     * works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     */\n    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n        result.add(this);\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Default Versioned impl\n    /**********************************************************\n     */\n\n    @Override\n    public abstract Version version();\n    \n    /*\n    /**********************************************************\n    /* Meta-annotations (annotations for annotation types)\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given annotation is considered an\n     * annotation bundle: if so, all meta-annotations it has will\n     * be used instead of annotation (\"bundle\") itself.\n     * \n     * @since 2.0\n     */\n    public boolean isAnnotationBundle(Annotation ann) {\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n    \n    /**\n     * Method for checking whether given annotated thing\n     * (type, or accessor) indicates that values\n     * referenced (values of type of annotated class, or\n     * values referenced by annotated property; latter\n     * having precedence) should include Object Identifier,\n     * and if so, specify details of Object Identity used.\n     * \n     * @since 2.0\n     */\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        return null;\n    }\n\n    /**\n     * Method for figuring out additional properties of an Object Identity reference\n     * \n     * @since 2.1\n     */\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        return objectIdInfo;\n    }\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for locating name used as \"root name\" (for use by\n     * some serializers when outputting root-level object -- mostly\n     * for XML compatibility purposes) for given class, if one\n     * is defined. Returns null if no declaration found; can return\n     * explicit empty String, which is usually ignored as well as null.\n     *<p> \n     * NOTE: method signature changed in 2.1, to return {@link PropertyName}\n     * instead of String.\n     */\n    public PropertyName findRootName(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * Method for finding list of properties to ignore for given class\n     * (null is returned if not specified).\n     * List of property names is applied\n     * after other detection mechanisms, to filter out these specific\n     * properties from being serialized and deserialized.\n     * \n     * @param forSerialization True if requesting properties to ignore for serialization;\n     *   false if for deserialization\n     */\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        return null;\n    }\n\n    /**\n     * @deprecated Since 2.6, use variant that takes second argument.\n     */\n    @Deprecated\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        // Changed in 2.7 to call from old to new; with 2.6 was opposite\n        return findPropertiesToIgnore(ac, true);\n    }\n    \n    /**\n     * Method for checking whether an annotation indicates that all unknown properties\n     */\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method for checking whether properties that have specified type\n     * (class, not generics aware) should be completely ignored for\n     * serialization and deserialization purposes.\n     * \n     * @param ac Type to check\n     * \n     * @return Boolean.TRUE if properties of type should be ignored;\n     *   Boolean.FALSE if they are not to be ignored, null for default\n     *   handling (which is 'do not ignore')\n     */\n    public Boolean isIgnorableType(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method for finding if annotated class has associated filter; and if so,\n     * to return id that is used to locate filter.\n     * \n     * @return Id of the filter to use for filtering properties of annotated\n     *    class, if any; or null if none found.\n     */\n    public Object findFilterId(Annotated ann) { return null; }\n\n    /**\n     * Method for finding {@link PropertyNamingStrategy} for given\n     * class, if any specified by annotations; and if so, either return\n     * a {@link PropertyNamingStrategy} instance, or Class to use for\n     * creating instance\n     * \n     * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one\n     *   is specified for given class; null if not.\n     * \n     * @since 2.1\n     */\n    public Object findNamingStrategy(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method used to check whether specified class defines a human-readable\n     * description to use for documentation.\n     * There are no further definitions for contents; for example, whether\n     * these may be marked up using HTML (or something like wiki format like Markup)\n     * is not defined.\n     * \n     * @return Human-readable description, if any.\n     * \n     * @since 2.7\n     */\n    public String findClassDescription(AnnotatedClass ac) { return null; }\n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking if annotations indicate changes to minimum visibility levels\n     * needed for auto-detecting property elements (fields, methods, constructors).\n     * A baseline checker is given, and introspector is to either return it as is\n     * (if no annotations are found), or build and return a derived instance (using\n     * checker's build methods).\n     */\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        return checker;\n    }\n    \n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic type handling\n    /**********************************************************\n    */\n    \n    /**\n     * Method for checking if given class has annotations that indicate\n     * that specific type resolver is to be used for handling instances.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param ac Annotated class to check for annotations\n     * @param baseType Base java type of value for which resolver is to be found\n     * \n     * @return Type resolver builder for given type, if one found; null if none\n     */\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method for checking if given property entity (field or method) has annotations\n     * that indicate that specific type resolver is to be used for handling instances.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param am Annotated member (field or method) to check for annotations\n     * @param baseType Base java type of property for which resolver is to be found\n     * \n     * @return Type resolver builder for properties of given entity, if one found;\n     *    null if none\n     */\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method for checking if given structured property entity (field or method that\n     * has nominal value of Map, Collection or array type) has annotations\n     * that indicate that specific type resolver is to be used for handling type\n     * information of contained values.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param am Annotated member (field or method) to check for annotations\n     * @param containerType Type of property for which resolver is to be found (must be a container type)\n     * \n     * @return Type resolver builder for values contained in properties of given entity,\n     *    if one found; null if none\n     */    \n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType) {\n        return null;\n    }\n\n    /**\n     * Method for locating annotation-specified subtypes related to annotated\n     * entity (class, method, field). Note that this is only guaranteed to be\n     * a list of directly\n     * declared subtypes, no recursive processing is guarantees (i.e. caller\n     * has to do it if/as necessary)\n     * \n     * @param a Annotated entity (class, field/method) to check for annotations\n     */\n    public List<NamedType> findSubtypes(Annotated a) { return null; }\n\n    /**\n     * Method for checking if specified type has explicit name.\n     * \n     * @param ac Class to check for type name annotations\n     */\n    public String findTypeName(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method for checking whether given accessor claims to represent\n     * type id: if so, its value may be used as an override,\n     * instead of generated type id.\n     */\n    public Boolean isTypeId(AnnotatedMember member) { return null; }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking if given member indicates that it is part\n     * of a reference (parent/child).\n     */\n    public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; }\n\n    /**\n     * Method called to check whether given property is marked to be \"unwrapped\"\n     * when being serialized (and appropriately handled in reverse direction,\n     * i.e. expect unwrapped representation during deserialization).\n     * Return value is the name transformation to use, if wrapping/unwrapping\n     * should  be done, or null if not -- note that transformation may simply\n     * be identity transformation (no changes).\n     */\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; }\n\n    /**\n     * Method called to check whether given property is marked to\n     * be ignored. This is used to determine whether to ignore\n     * properties, on per-property basis, usually combining\n     * annotations from multiple accessors (getters, setters, fields,\n     * constructor parameters).\n     */\n    public boolean hasIgnoreMarker(AnnotatedMember m) { return false; }\n\n    /**\n     * Method called to find out whether given member expectes a value\n     * to be injected, and if so, what is the identifier of the value\n     * to use during injection.\n     * Type if identifier needs to be compatible with provider of\n     * values (of type {@link InjectableValues}); often a simple String\n     * id is used.\n     * \n     * @param m Member to check\n     * \n     * @return Identifier of value to inject, if any; null if no injection\n     *   indicator is found\n     */\n    public Object findInjectableValueId(AnnotatedMember m) { return null; }\n\n    /**\n     * Method that can be called to check whether this member has\n     * an annotation that suggests whether value for matching property\n     * is required or not.\n     * \n     * @since 2.0\n     */\n    public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }\n    \n    /**\n     * Method for checking if annotated property (represented by a field or\n     * getter/setter method) has definitions for views it is to be included in.\n     * If null is returned, no view definitions exist and property is always\n     * included (or always excluded as per default view inclusion configuration);\n     * otherwise it will only be included for views included in returned\n     * array. View matches are checked using class inheritance rules (sub-classes\n     * inherit inclusions of super-classes)\n     * \n     * @param a Annotated property (represented by a method, field or ctor parameter)\n     * @return Array of views (represented by classes) that the property is included in;\n     *    if null, always included (same as returning array containing <code>Object.class</code>)\n     */\n    public Class<?>[] findViews(Annotated a) { return null; }\n\n    /**\n     * Method for finding format annotations for property or class.\n     * Return value is typically used by serializers and/or\n     * deserializers to customize presentation aspects of the\n     * serialized value.\n     * \n     * @since 2.1\n     */\n    public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; }\n\n    /**\n     * Method used to check if specified property has annotation that indicates\n     * that it should be wrapped in an element; and if so, name to use.\n     * Note that not all serializers and deserializers support use this method:\n     * currently (2.1) it is only used by XML-backed handlers.\n     * \n     * @return Wrapper name to use, if any, or {@link PropertyName#USE_DEFAULT}\n     *   to indicate that no wrapper element should be used.\n     * \n     * @since 2.1\n     */\n    public PropertyName findWrapperName(Annotated ann) { return null; }\n\n    /**\n     * Method for finding suggested default value (as simple textual serialization)\n     * for the property. While core databind does not make any use of it, it is exposed\n     * for extension modules to use: an expected use is generation of schema representations\n     * and documentation.\n     *\n     * @since 2.5\n     */\n    public String findPropertyDefaultValue(Annotated ann) { return null; }\n\n    /**\n     * Method used to check whether specified property member (accessor\n     * or mutator) defines human-readable description to use for documentation.\n     * There are no further definitions for contents; for example, whether\n     * these may be marked up using HTML is not defined.\n     * \n     * @return Human-readable description, if any.\n     * \n     * @since 2.3\n     */\n    public String findPropertyDescription(Annotated ann) { return null; }\n\n    /**\n     * Method used to check whether specified property member (accessor\n     * or mutator) defines numeric index, and if so, what is the index value.\n     * Possible use cases for index values included use by underlying data format\n     * (some binary formats mandate use of index instead of name) and ordering\n     * of properties (for documentation, or during serialization).\n     * \n     * @since 2.4\n     * \n     * @return Explicitly specified index for the property, if any\n     */\n    public Integer findPropertyIndex(Annotated ann) { return null; }\n\n    /**\n     * Method for finding implicit name for a property that given annotated\n     * member (field, method, creator parameter) may represent.\n     * This is different from explicit, annotation-based property name, in that\n     * it is \"weak\" and does not either proof that a property exists (for example,\n     * if visibility is not high enough), or override explicit names.\n     * In practice this method is used to introspect optional names for creator\n     * parameters (which may or may not be available and can not be detected\n     * by standard databind); or to provide alternate name mangling for\n     * fields, getters and/or setters.\n     * \n     * @since 2.4\n     */\n    public String findImplicitPropertyName(AnnotatedMember member) { return null; }\n\n    /**\n     * Method for finding optional access definition for a property, annotated\n     * on one of its accessors. If a definition for read-only, write-only\n     * or read-write cases, visibility rules may be modified. Note, however,\n     * that even more specific annotations (like one for ignoring specific accessor)\n     * may further override behavior of the access definition.\n     *\n     * @since 2.6\n     */\n    public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; }\n\n    /**\n     * Method called in cases where a class has two methods eligible to be used\n     * for the same logical property, and default logic is not enough to figure\n     * out clear precedence. Introspector may try to choose one to use; or, if\n     * unable, return `null` to indicate it can not resolve the problem.\n     *\n     * @since 2.7\n     */\n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,\n            AnnotatedMethod setter1, AnnotatedMethod setter2) {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting a serializer definition on specified method\n     * or field. Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findSerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a serializer definition for keys of associated <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findKeySerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a serializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findContentSerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a serializer definition for serializer to use\n     * for nulls (null values) of associated property or type.\n     * \n     * @since 2.3\n     */\n    public Object findNullSerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for accessing declared typing mode annotated (if any).\n     * This is used for type detection, unless more granular settings\n     * (such as actual exact type; or serializer to use which means\n     * no type information is needed) take precedence.\n     *\n     * @return Typing mode to use, if annotation is found; null otherwise\n     */\n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * serialization. If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * This feature is typically used to convert internal values into types\n     * that Jackson can convert.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit serializer is usually better way to handle serialization.\n     * \n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *   \n     * @since 2.2\n     */\n    public Object findSerializationConverter(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * Other notes are same as those for {@link #findSerializationConverter}\n     * \n     * @param a Annotated property (field, method) to check.\n     *   \n     * @since 2.2\n     */\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    /**\n     * Method for checking whether given annotated entity (class, method,\n     * field) defines which Bean/Map properties are to be included in\n     * serialization.\n     * If no annotation is found, method should return given second\n     * argument; otherwise value indicated by the annotation.\n     *<p>\n     * Note that meaning of inclusion value depends on whether it is for\n     * a Class or property (field/method/constructor): in former case,\n     * it is the default for all properties; in latter case it is specific\n     * override for annotated property.\n     *\n     * @return Enumerated value indicating which properties to include\n     *   in serialization\n     * \n     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead\n     */\n    @Deprecated // since 2.7\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    /**\n     * Method for checking whether content (entries) of a {@link java.util.Map} property\n     * are to be included during serialization or not.\n     * NOTE: this is NOT called for POJO properties, or array/Collection elements.\n     * \n     * @since 2.5\n     * \n     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead\n     */\n    @Deprecated // since 2.7\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    /**\n     * Method for checking inclusion criteria for a type (Class) or property (yes, method\n     * name is bit unfortunate -- not just for properties!).\n     * In case of class, acts as the default for properties POJO contains; for properties\n     * acts as override for class defaults and possible global defaults.\n     *\n     * @since 2.6\n     */\n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        return JsonInclude.Value.empty();\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: type refinements\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing annotated type definition that a\n     * method/field can have, to be used as the type for serialization\n     * instead of the runtime type.\n     * Type returned (if any) needs to be widening conversion (super-type).\n     * Declared return type of the method is also considered acceptable.\n     *\n     * @return Class to use instead of runtime type\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationType(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding possible widening type definition that a property\n     * value can have, to define less specific key type to use for serialization.\n     * It should be only be used with {@link java.util.Map} types.\n     * \n     * @return Class specifying more general type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method for finding possible widening type definition that a property\n     * value can have, to define less specific key type to use for serialization.\n     * It should be only used with structured types (arrays, collections, maps).\n     * \n     * @return Class specifying more general type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n                //    static typing this way\n                type = type.withStaticTyping();\n            } else {\n                try {\n                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                    //   may be needed here too in future?\n                        type = tf.constructGeneralizedType(type, serClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                        //   specialize (narrow) type sometimes, even if more commonly opposite\n                        //   is needed.\n                        if (keyClass.isAssignableFrom(currRaw)) { // common case\n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n                   //   specialize (narrow) type sometimes, even if more commonly opposite\n                   //   is needed.\n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { // common case\n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { // shouldn't really happen\n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing defined property serialization order (which may be\n     * partial). May return null if no ordering is defined.\n     */\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * Method for checking whether an annotation indicates that serialized properties\n     * for which no explicit is defined should be alphabetically (lexicograpically)\n     * ordered\n     */\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return null;\n    }\n\n    /**\n     * Method for adding possible virtual properties to be serialized along\n     * with regular properties.\n     * \n     * @since 2.5\n     */\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) { }\n    \n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for serialization.\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     * \n     * @param a Property accessor to check\n     * \n     * @return Name to use if found; null if not.\n     * \n     * @since 2.1\n     */\n    public PropertyName findNameForSerialization(Annotated a) {\n        /*\n        if (name != null) {\n            if (name.length() == 0) { // empty String means 'default'\n                return PropertyName.USE_DEFAULT;\n            }\n            return new PropertyName(name);\n        }\n        */\n        return null;\n    }\n\n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the return value of annotated method\n     * should be used as \"the value\" of the object instance; usually\n     * serialized as a primitive value such as String or number.\n     *\n     * @return True if such annotation is found (and is not disabled);\n     *   false if no enabled annotation is found\n     */\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    // TODO: Deprecate in 2.8?\n    /**\n     * Method for determining the String value to use for serializing\n     * given enumeration entry; used when serializing enumerations\n     * as Strings (the standard method).\n     *\n     * @return Serialized enum value.\n     */\n    public String findEnumValue(Enum<?> value) {\n        return value.name();\n    }\n\n    /**\n     * Method for efficiently figuring out which if given set of <code>Enum</code> values\n     * have explicitly defined name. Method will overwrite entries in incoming <code>names</code>\n     * array with explicit names found, if any, leaving other entries unmodified.\n     *<p>\n     * Default implementation will simply delegate to {@link #findEnumValue}, which is close\n     * enough, although unfortunately NOT 100% equivalent (as it will also consider <code>name()</code>\n     * to give explicit value).\n     *\n     * @since 2.7\n     */\n    public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        for (int i = 0, len = enumValues.length; i < len; ++i) {\n            /* 12-Mar-2016, tatu: This is quite tricky, considering that we should NOT\n             *   overwrite values with default `name`... so for now, let's only delegate\n             *   if no value has been set. Still not optimal but has to do\n             */\n            // TODO: In 2.8, stop delegation?\n            if (names[i] == null) {\n                names[i] = findEnumValue(enumValues[i]);\n            }\n        }\n        return names;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting a deserializer definition on specified method\n     * or field.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findDeserializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a deserializer definition for keys of\n     * associated <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findKeyDeserializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a deserializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or\n     * <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findContentDeserializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * deserialization.\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * This feature is typically used to convert intermediate Jackson types\n     * (that default deserializers can produce) into custom type instances.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit deserializer is usually better way to handle deserialization.\n     * \n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *   \n     * @since 2.2\n     */\n    public Object findDeserializationConverter(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * Other notes are same as those for {@link #findDeserializationConverter}\n     * \n     * @param a Annotated property (field, method) to check.\n     *   \n     * @since 2.2\n     */\n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: type refinements\n    /**********************************************************\n     */\n\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineDeserializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> valueClass = findDeserializationType(a, type);\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findDeserializationContentType(a, contentType);\n           if (contentClass != null) {\n               try {\n                   contentType = tf.constructSpecializedType(contentType, contentClass);\n                   type = type.withContentType(contentType);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(null,\n                           String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n        }\n        return type;\n    }\n    \n    /**\n     * Method for accessing annotated type definition that a\n     * property can have, to be used as the type for deserialization\n     * instead of the static (declared) type.\n     * Type is usually narrowing conversion (i.e.subtype of declared type).\n     * Declared return type of the method is also considered acceptable.\n     *\n     * @param baseType Assumed type before considering annotations\n     *\n     * @return Class to use for deserialization instead of declared type\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }\n    \n    /**\n     * Method for accessing additional narrowing type definition that a\n     * method can have, to define more specific key type to use.\n     * It should be only be used with {@link java.util.Map} types.\n     * \n     * @param baseKeyType Assumed key type before considering annotations\n     *\n     * @return Class specifying more specific type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }\n\n    /**\n     * Method for accessing additional narrowing type definition that a\n     * method can have, to define more specific content type to use;\n     * content refers to Map values and Collection/array elements.\n     * It should be only be used with Map, Collection and array types.\n     * \n     * @param baseContentType Assumed content (value) type before considering annotations\n     *\n     * @return Class specifying more specific type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method getting {@link ValueInstantiator} to use for given\n     * type (class): return value can either be an instance of\n     * instantiator, or class of instantiator to create.\n     */\n    public Object findValueInstantiator(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * Method for finding Builder object to use for constructing\n     * value instance and binding data (sort of combining value\n     * instantiators that can construct, and deserializers\n     * that can bind data).\n     *<p>\n     * Note that unlike accessors for some helper Objects, this\n     * method does not allow returning instances: the reason is\n     * that builders have state, and a separate instance needs\n     * to be created for each deserialization call.\n     * \n     * @since 2.0\n     */\n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * @since 2.0\n     */\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for deserialization (reading JSON into POJOs).\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     * \n     * @param a Property accessor to check\n     * \n     * @return Name to use if found; null if not.\n     * \n     * @since 2.1\n     */\n    public PropertyName findNameForDeserialization(Annotated a) {\n        /*\n        if (name != null) {\n            if (name.length() == 0) { // empty String means 'default'\n                return PropertyName.USE_DEFAULT;\n            }\n            return new PropertyName(name);\n        }\n        */\n        return null;\n    }\n    \n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for setting values of any properties for\n     * which no dedicated setter method is found.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for accessing set of miscellaneous \"extra\"\n     * properties, often bound with matching \"any setter\" method.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n    \n    /**\n     * Method for checking whether given annotated item (method, constructor)\n     * has an annotation\n     * that suggests that the method is a \"creator\" (aka factory)\n     * method to be used for construct new instances of deserialized\n     * values.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasCreatorAnnotation(Annotated a) {\n        return false;\n    }\n\n    /**\n     * Method for finding indication of creator binding mode for\n     * a creator (something for which {@link #hasCreatorAnnotation} returns\n     * true), for cases where there may be ambiguity (currently: single-argument\n     * creator with implicit but no explicit name for the argument).\n     * \n     * @since 2.5\n     */\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable methods: may be used as low-level extension\n    /* points.\n    /**********************************************************\n     */\n\n    /**\n     * Method that should be used by sub-classes for ALL\n     * annotation access;\n     * overridable so \n     * that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change it.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.getAnnotation(annoClass);\n     *</code>\n     * \n     * @since 2.5\n     */\n    protected <A extends Annotation> A _findAnnotation(Annotated annotated,\n            Class<A> annoClass) {\n        return annotated.getAnnotation(annoClass);\n    }\n\n    /**\n     * Method that should be used by sub-classes for ALL\n     * annotation existence access;\n     * overridable so  that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change value seen.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.hasAnnotation(annoClass);\n     *</code>\n     * \n     * @since 2.5\n     */\n    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n        return annotated.hasAnnotation(annoClass);\n    }\n\n    /**\n     * Alternative lookup method that is used to see if annotation has at least one of\n     * annotations of types listed in second argument.\n     *\n     * @since 2.7\n     */\n    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {\n        return annotated.hasOneOf(annoClasses);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.lang.annotation.Annotation;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.core.Versioned;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\nimport com.fasterxml.jackson.databind.type.MapLikeType;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.Converter;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\n\n/**\n * Abstract class that defines API used for introspecting annotation-based\n * configuration for serialization and deserialization. Separated\n * so that different sets of annotations can be supported, and support\n * plugged-in dynamically.\n *<p>\n * Although default implementations are based on using annotations as the only\n * (or at least main) information source, custom implementations are not limited\n * in such a way, and in fact there is no expectation they should be. So the name\n * is bit of misnomer; this is a general configuration introspection facility.\n *<p>\n * NOTE: due to rapid addition of new methods (and changes to existing methods),\n * it is <b>strongly</b> recommended that custom implementations should not directly\n * extend this class, but rather extend {@link NopAnnotationIntrospector}.\n * This way added methods will not break backwards compatibility of custom annotation\n * introspectors.\n */\n@SuppressWarnings(\"serial\")\npublic abstract class AnnotationIntrospector\n    implements Versioned, java.io.Serializable\n{\n    /*\n    /**********************************************************\n    /* Helper types\n    /**********************************************************\n     */\n\n    /**\n     * Value type used with managed and back references; contains type and\n     * logic name, used to link related references\n     */\n    public static class ReferenceProperty\n    {\n        public enum Type {\n            /**\n             * Reference property that Jackson manages and that is serialized normally (by serializing\n             * reference object), but is used for resolving back references during\n             * deserialization.\n             * Usually this can be defined by using\n             * {@link com.fasterxml.jackson.annotation.JsonManagedReference}\n             */\n            MANAGED_REFERENCE\n    \n            /**\n             * Reference property that Jackson manages by suppressing it during serialization,\n             * and reconstructing during deserialization.\n             * Usually this can be defined by using\n             * {@link com.fasterxml.jackson.annotation.JsonBackReference}\n             */\n            ,BACK_REFERENCE\n            ;\n        }\n\n        private final Type _type;\n        private final String _name;\n\n        public ReferenceProperty(Type t, String n) {\n            _type = t;\n            _name = n;\n        }\n\n        public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }\n        public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }\n        \n        public Type getType() { return _type; }\n        public String getName() { return _name; }\n\n        public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }\n        public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method for accessing \"no operation\" implementation\n     * of introspector: instance that will never find any annotation-based\n     * configuration.\n     */\n    public static AnnotationIntrospector nopInstance() {\n        return NopAnnotationIntrospector.instance;\n    }\n\n    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n        return new AnnotationIntrospectorPair(a1, a2);\n    }\n\n    /*\n    /**********************************************************\n    /* Access to possibly chained introspectors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation returns a Singleton list with this introspector\n     * as contents.\n     * This usually works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     */\n    public Collection<AnnotationIntrospector> allIntrospectors() {\n        return Collections.singletonList(this);\n    }\n    \n    /**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation adds this introspector in result; this usually\n     * works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     */\n    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n        result.add(this);\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Default Versioned impl\n    /**********************************************************\n     */\n\n    @Override\n    public abstract Version version();\n    \n    /*\n    /**********************************************************\n    /* Meta-annotations (annotations for annotation types)\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given annotation is considered an\n     * annotation bundle: if so, all meta-annotations it has will\n     * be used instead of annotation (\"bundle\") itself.\n     * \n     * @since 2.0\n     */\n    public boolean isAnnotationBundle(Annotation ann) {\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n    \n    /**\n     * Method for checking whether given annotated thing\n     * (type, or accessor) indicates that values\n     * referenced (values of type of annotated class, or\n     * values referenced by annotated property; latter\n     * having precedence) should include Object Identifier,\n     * and if so, specify details of Object Identity used.\n     * \n     * @since 2.0\n     */\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        return null;\n    }\n\n    /**\n     * Method for figuring out additional properties of an Object Identity reference\n     * \n     * @since 2.1\n     */\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        return objectIdInfo;\n    }\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for locating name used as \"root name\" (for use by\n     * some serializers when outputting root-level object -- mostly\n     * for XML compatibility purposes) for given class, if one\n     * is defined. Returns null if no declaration found; can return\n     * explicit empty String, which is usually ignored as well as null.\n     *<p> \n     * NOTE: method signature changed in 2.1, to return {@link PropertyName}\n     * instead of String.\n     */\n    public PropertyName findRootName(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * Method for finding list of properties to ignore for given class\n     * (null is returned if not specified).\n     * List of property names is applied\n     * after other detection mechanisms, to filter out these specific\n     * properties from being serialized and deserialized.\n     * \n     * @param forSerialization True if requesting properties to ignore for serialization;\n     *   false if for deserialization\n     */\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n        return null;\n    }\n\n    /**\n     * @deprecated Since 2.6, use variant that takes second argument.\n     */\n    @Deprecated\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        // Changed in 2.7 to call from old to new; with 2.6 was opposite\n        return findPropertiesToIgnore(ac, true);\n    }\n    \n    /**\n     * Method for checking whether an annotation indicates that all unknown properties\n     */\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method for checking whether properties that have specified type\n     * (class, not generics aware) should be completely ignored for\n     * serialization and deserialization purposes.\n     * \n     * @param ac Type to check\n     * \n     * @return Boolean.TRUE if properties of type should be ignored;\n     *   Boolean.FALSE if they are not to be ignored, null for default\n     *   handling (which is 'do not ignore')\n     */\n    public Boolean isIgnorableType(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method for finding if annotated class has associated filter; and if so,\n     * to return id that is used to locate filter.\n     * \n     * @return Id of the filter to use for filtering properties of annotated\n     *    class, if any; or null if none found.\n     */\n    public Object findFilterId(Annotated ann) { return null; }\n\n    /**\n     * Method for finding {@link PropertyNamingStrategy} for given\n     * class, if any specified by annotations; and if so, either return\n     * a {@link PropertyNamingStrategy} instance, or Class to use for\n     * creating instance\n     * \n     * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one\n     *   is specified for given class; null if not.\n     * \n     * @since 2.1\n     */\n    public Object findNamingStrategy(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method used to check whether specified class defines a human-readable\n     * description to use for documentation.\n     * There are no further definitions for contents; for example, whether\n     * these may be marked up using HTML (or something like wiki format like Markup)\n     * is not defined.\n     * \n     * @return Human-readable description, if any.\n     * \n     * @since 2.7\n     */\n    public String findClassDescription(AnnotatedClass ac) { return null; }\n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking if annotations indicate changes to minimum visibility levels\n     * needed for auto-detecting property elements (fields, methods, constructors).\n     * A baseline checker is given, and introspector is to either return it as is\n     * (if no annotations are found), or build and return a derived instance (using\n     * checker's build methods).\n     */\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        return checker;\n    }\n    \n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic type handling\n    /**********************************************************\n    */\n    \n    /**\n     * Method for checking if given class has annotations that indicate\n     * that specific type resolver is to be used for handling instances.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param ac Annotated class to check for annotations\n     * @param baseType Base java type of value for which resolver is to be found\n     * \n     * @return Type resolver builder for given type, if one found; null if none\n     */\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method for checking if given property entity (field or method) has annotations\n     * that indicate that specific type resolver is to be used for handling instances.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param am Annotated member (field or method) to check for annotations\n     * @param baseType Base java type of property for which resolver is to be found\n     * \n     * @return Type resolver builder for properties of given entity, if one found;\n     *    null if none\n     */\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method for checking if given structured property entity (field or method that\n     * has nominal value of Map, Collection or array type) has annotations\n     * that indicate that specific type resolver is to be used for handling type\n     * information of contained values.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param am Annotated member (field or method) to check for annotations\n     * @param containerType Type of property for which resolver is to be found (must be a container type)\n     * \n     * @return Type resolver builder for values contained in properties of given entity,\n     *    if one found; null if none\n     */    \n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType) {\n        return null;\n    }\n\n    /**\n     * Method for locating annotation-specified subtypes related to annotated\n     * entity (class, method, field). Note that this is only guaranteed to be\n     * a list of directly\n     * declared subtypes, no recursive processing is guarantees (i.e. caller\n     * has to do it if/as necessary)\n     * \n     * @param a Annotated entity (class, field/method) to check for annotations\n     */\n    public List<NamedType> findSubtypes(Annotated a) { return null; }\n\n    /**\n     * Method for checking if specified type has explicit name.\n     * \n     * @param ac Class to check for type name annotations\n     */\n    public String findTypeName(AnnotatedClass ac) { return null; }\n\n    /**\n     * Method for checking whether given accessor claims to represent\n     * type id: if so, its value may be used as an override,\n     * instead of generated type id.\n     */\n    public Boolean isTypeId(AnnotatedMember member) { return null; }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking if given member indicates that it is part\n     * of a reference (parent/child).\n     */\n    public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; }\n\n    /**\n     * Method called to check whether given property is marked to be \"unwrapped\"\n     * when being serialized (and appropriately handled in reverse direction,\n     * i.e. expect unwrapped representation during deserialization).\n     * Return value is the name transformation to use, if wrapping/unwrapping\n     * should  be done, or null if not -- note that transformation may simply\n     * be identity transformation (no changes).\n     */\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; }\n\n    /**\n     * Method called to check whether given property is marked to\n     * be ignored. This is used to determine whether to ignore\n     * properties, on per-property basis, usually combining\n     * annotations from multiple accessors (getters, setters, fields,\n     * constructor parameters).\n     */\n    public boolean hasIgnoreMarker(AnnotatedMember m) { return false; }\n\n    /**\n     * Method called to find out whether given member expectes a value\n     * to be injected, and if so, what is the identifier of the value\n     * to use during injection.\n     * Type if identifier needs to be compatible with provider of\n     * values (of type {@link InjectableValues}); often a simple String\n     * id is used.\n     * \n     * @param m Member to check\n     * \n     * @return Identifier of value to inject, if any; null if no injection\n     *   indicator is found\n     */\n    public Object findInjectableValueId(AnnotatedMember m) { return null; }\n\n    /**\n     * Method that can be called to check whether this member has\n     * an annotation that suggests whether value for matching property\n     * is required or not.\n     * \n     * @since 2.0\n     */\n    public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }\n    \n    /**\n     * Method for checking if annotated property (represented by a field or\n     * getter/setter method) has definitions for views it is to be included in.\n     * If null is returned, no view definitions exist and property is always\n     * included (or always excluded as per default view inclusion configuration);\n     * otherwise it will only be included for views included in returned\n     * array. View matches are checked using class inheritance rules (sub-classes\n     * inherit inclusions of super-classes)\n     * \n     * @param a Annotated property (represented by a method, field or ctor parameter)\n     * @return Array of views (represented by classes) that the property is included in;\n     *    if null, always included (same as returning array containing <code>Object.class</code>)\n     */\n    public Class<?>[] findViews(Annotated a) { return null; }\n\n    /**\n     * Method for finding format annotations for property or class.\n     * Return value is typically used by serializers and/or\n     * deserializers to customize presentation aspects of the\n     * serialized value.\n     * \n     * @since 2.1\n     */\n    public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; }\n\n    /**\n     * Method used to check if specified property has annotation that indicates\n     * that it should be wrapped in an element; and if so, name to use.\n     * Note that not all serializers and deserializers support use this method:\n     * currently (2.1) it is only used by XML-backed handlers.\n     * \n     * @return Wrapper name to use, if any, or {@link PropertyName#USE_DEFAULT}\n     *   to indicate that no wrapper element should be used.\n     * \n     * @since 2.1\n     */\n    public PropertyName findWrapperName(Annotated ann) { return null; }\n\n    /**\n     * Method for finding suggested default value (as simple textual serialization)\n     * for the property. While core databind does not make any use of it, it is exposed\n     * for extension modules to use: an expected use is generation of schema representations\n     * and documentation.\n     *\n     * @since 2.5\n     */\n    public String findPropertyDefaultValue(Annotated ann) { return null; }\n\n    /**\n     * Method used to check whether specified property member (accessor\n     * or mutator) defines human-readable description to use for documentation.\n     * There are no further definitions for contents; for example, whether\n     * these may be marked up using HTML is not defined.\n     * \n     * @return Human-readable description, if any.\n     * \n     * @since 2.3\n     */\n    public String findPropertyDescription(Annotated ann) { return null; }\n\n    /**\n     * Method used to check whether specified property member (accessor\n     * or mutator) defines numeric index, and if so, what is the index value.\n     * Possible use cases for index values included use by underlying data format\n     * (some binary formats mandate use of index instead of name) and ordering\n     * of properties (for documentation, or during serialization).\n     * \n     * @since 2.4\n     * \n     * @return Explicitly specified index for the property, if any\n     */\n    public Integer findPropertyIndex(Annotated ann) { return null; }\n\n    /**\n     * Method for finding implicit name for a property that given annotated\n     * member (field, method, creator parameter) may represent.\n     * This is different from explicit, annotation-based property name, in that\n     * it is \"weak\" and does not either proof that a property exists (for example,\n     * if visibility is not high enough), or override explicit names.\n     * In practice this method is used to introspect optional names for creator\n     * parameters (which may or may not be available and can not be detected\n     * by standard databind); or to provide alternate name mangling for\n     * fields, getters and/or setters.\n     * \n     * @since 2.4\n     */\n    public String findImplicitPropertyName(AnnotatedMember member) { return null; }\n\n    /**\n     * Method for finding optional access definition for a property, annotated\n     * on one of its accessors. If a definition for read-only, write-only\n     * or read-write cases, visibility rules may be modified. Note, however,\n     * that even more specific annotations (like one for ignoring specific accessor)\n     * may further override behavior of the access definition.\n     *\n     * @since 2.6\n     */\n    public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; }\n\n    /**\n     * Method called in cases where a class has two methods eligible to be used\n     * for the same logical property, and default logic is not enough to figure\n     * out clear precedence. Introspector may try to choose one to use; or, if\n     * unable, return `null` to indicate it can not resolve the problem.\n     *\n     * @since 2.7\n     */\n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,\n            AnnotatedMethod setter1, AnnotatedMethod setter2) {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting a serializer definition on specified method\n     * or field. Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findSerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a serializer definition for keys of associated <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findKeySerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a serializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findContentSerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a serializer definition for serializer to use\n     * for nulls (null values) of associated property or type.\n     * \n     * @since 2.3\n     */\n    public Object findNullSerializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for accessing declared typing mode annotated (if any).\n     * This is used for type detection, unless more granular settings\n     * (such as actual exact type; or serializer to use which means\n     * no type information is needed) take precedence.\n     *\n     * @return Typing mode to use, if annotation is found; null otherwise\n     */\n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * serialization. If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * This feature is typically used to convert internal values into types\n     * that Jackson can convert.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit serializer is usually better way to handle serialization.\n     * \n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *   \n     * @since 2.2\n     */\n    public Object findSerializationConverter(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * Other notes are same as those for {@link #findSerializationConverter}\n     * \n     * @param a Annotated property (field, method) to check.\n     *   \n     * @since 2.2\n     */\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    /**\n     * Method for checking whether given annotated entity (class, method,\n     * field) defines which Bean/Map properties are to be included in\n     * serialization.\n     * If no annotation is found, method should return given second\n     * argument; otherwise value indicated by the annotation.\n     *<p>\n     * Note that meaning of inclusion value depends on whether it is for\n     * a Class or property (field/method/constructor): in former case,\n     * it is the default for all properties; in latter case it is specific\n     * override for annotated property.\n     *\n     * @return Enumerated value indicating which properties to include\n     *   in serialization\n     * \n     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead\n     */\n    @Deprecated // since 2.7\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    /**\n     * Method for checking whether content (entries) of a {@link java.util.Map} property\n     * are to be included during serialization or not.\n     * NOTE: this is NOT called for POJO properties, or array/Collection elements.\n     * \n     * @since 2.5\n     * \n     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead\n     */\n    @Deprecated // since 2.7\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }\n\n    /**\n     * Method for checking inclusion criteria for a type (Class) or property (yes, method\n     * name is bit unfortunate -- not just for properties!).\n     * In case of class, acts as the default for properties POJO contains; for properties\n     * acts as override for class defaults and possible global defaults.\n     *\n     * @since 2.6\n     */\n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n        return JsonInclude.Value.empty();\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: type refinements\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing annotated type definition that a\n     * method/field can have, to be used as the type for serialization\n     * instead of the runtime type.\n     * Type returned (if any) needs to be widening conversion (super-type).\n     * Declared return type of the method is also considered acceptable.\n     *\n     * @return Class to use instead of runtime type\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationType(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding possible widening type definition that a property\n     * value can have, to define less specific key type to use for serialization.\n     * It should be only be used with {@link java.util.Map} types.\n     * \n     * @return Class specifying more general type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method for finding possible widening type definition that a property\n     * value can have, to define less specific key type to use for serialization.\n     * It should be only used with structured types (arrays, collections, maps).\n     * \n     * @return Class specifying more general type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }\n\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n                //    static typing this way\n                type = type.withStaticTyping();\n            } else {\n                Class<?> currRaw = type.getRawClass();\n                try {\n                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                    //   may be needed here too in future?\n                    if (serClass.isAssignableFrom(currRaw)) { // common case\n                        type = tf.constructGeneralizedType(type, serClass);\n                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n                        type = tf.constructSpecializedType(type, serClass);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                        type, serClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                        //   specialize (narrow) type sometimes, even if more commonly opposite\n                        //   is needed.\n                        if (keyClass.isAssignableFrom(currRaw)) { // common case\n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n                   //   specialize (narrow) type sometimes, even if more commonly opposite\n                   //   is needed.\n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { // common case\n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { // shouldn't really happen\n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing defined property serialization order (which may be\n     * partial). May return null if no ordering is defined.\n     */\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * Method for checking whether an annotation indicates that serialized properties\n     * for which no explicit is defined should be alphabetically (lexicograpically)\n     * ordered\n     */\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return null;\n    }\n\n    /**\n     * Method for adding possible virtual properties to be serialized along\n     * with regular properties.\n     * \n     * @since 2.5\n     */\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) { }\n    \n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for serialization.\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     * \n     * @param a Property accessor to check\n     * \n     * @return Name to use if found; null if not.\n     * \n     * @since 2.1\n     */\n    public PropertyName findNameForSerialization(Annotated a) {\n        /*\n        if (name != null) {\n            if (name.length() == 0) { // empty String means 'default'\n                return PropertyName.USE_DEFAULT;\n            }\n            return new PropertyName(name);\n        }\n        */\n        return null;\n    }\n\n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the return value of annotated method\n     * should be used as \"the value\" of the object instance; usually\n     * serialized as a primitive value such as String or number.\n     *\n     * @return True if such annotation is found (and is not disabled);\n     *   false if no enabled annotation is found\n     */\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    // TODO: Deprecate in 2.8?\n    /**\n     * Method for determining the String value to use for serializing\n     * given enumeration entry; used when serializing enumerations\n     * as Strings (the standard method).\n     *\n     * @return Serialized enum value.\n     */\n    public String findEnumValue(Enum<?> value) {\n        return value.name();\n    }\n\n    /**\n     * Method for efficiently figuring out which if given set of <code>Enum</code> values\n     * have explicitly defined name. Method will overwrite entries in incoming <code>names</code>\n     * array with explicit names found, if any, leaving other entries unmodified.\n     *<p>\n     * Default implementation will simply delegate to {@link #findEnumValue}, which is close\n     * enough, although unfortunately NOT 100% equivalent (as it will also consider <code>name()</code>\n     * to give explicit value).\n     *\n     * @since 2.7\n     */\n    public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        for (int i = 0, len = enumValues.length; i < len; ++i) {\n            /* 12-Mar-2016, tatu: This is quite tricky, considering that we should NOT\n             *   overwrite values with default `name`... so for now, let's only delegate\n             *   if no value has been set. Still not optimal but has to do\n             */\n            // TODO: In 2.8, stop delegation?\n            if (names[i] == null) {\n                names[i] = findEnumValue(enumValues[i]);\n            }\n        }\n        return names;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting a deserializer definition on specified method\n     * or field.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findDeserializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a deserializer definition for keys of\n     * associated <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findKeyDeserializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for getting a deserializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or\n     * <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findContentDeserializer(Annotated am) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * deserialization.\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * This feature is typically used to convert intermediate Jackson types\n     * (that default deserializers can produce) into custom type instances.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit deserializer is usually better way to handle deserialization.\n     * \n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *   \n     * @since 2.2\n     */\n    public Object findDeserializationConverter(Annotated a) {\n        return null;\n    }\n\n    /**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * Other notes are same as those for {@link #findDeserializationConverter}\n     * \n     * @param a Annotated property (field, method) to check.\n     *   \n     * @since 2.2\n     */\n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: type refinements\n    /**********************************************************\n     */\n\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineDeserializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> valueClass = findDeserializationType(a, type);\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findDeserializationContentType(a, contentType);\n           if (contentClass != null) {\n               try {\n                   contentType = tf.constructSpecializedType(contentType, contentClass);\n                   type = type.withContentType(contentType);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(null,\n                           String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n        }\n        return type;\n    }\n    \n    /**\n     * Method for accessing annotated type definition that a\n     * property can have, to be used as the type for deserialization\n     * instead of the static (declared) type.\n     * Type is usually narrowing conversion (i.e.subtype of declared type).\n     * Declared return type of the method is also considered acceptable.\n     *\n     * @param baseType Assumed type before considering annotations\n     *\n     * @return Class to use for deserialization instead of declared type\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }\n    \n    /**\n     * Method for accessing additional narrowing type definition that a\n     * method can have, to define more specific key type to use.\n     * It should be only be used with {@link java.util.Map} types.\n     * \n     * @param baseKeyType Assumed key type before considering annotations\n     *\n     * @return Class specifying more specific type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }\n\n    /**\n     * Method for accessing additional narrowing type definition that a\n     * method can have, to define more specific content type to use;\n     * content refers to Map values and Collection/array elements.\n     * It should be only be used with Map, Collection and array types.\n     * \n     * @param baseContentType Assumed content (value) type before considering annotations\n     *\n     * @return Class specifying more specific type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization: class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method getting {@link ValueInstantiator} to use for given\n     * type (class): return value can either be an instance of\n     * instantiator, or class of instantiator to create.\n     */\n    public Object findValueInstantiator(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * Method for finding Builder object to use for constructing\n     * value instance and binding data (sort of combining value\n     * instantiators that can construct, and deserializers\n     * that can bind data).\n     *<p>\n     * Note that unlike accessors for some helper Objects, this\n     * method does not allow returning instances: the reason is\n     * that builders have state, and a separate instance needs\n     * to be created for each deserialization call.\n     * \n     * @since 2.0\n     */\n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n        return null;\n    }\n\n    /**\n     * @since 2.0\n     */\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for deserialization (reading JSON into POJOs).\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     * \n     * @param a Property accessor to check\n     * \n     * @return Name to use if found; null if not.\n     * \n     * @since 2.1\n     */\n    public PropertyName findNameForDeserialization(Annotated a) {\n        /*\n        if (name != null) {\n            if (name.length() == 0) { // empty String means 'default'\n                return PropertyName.USE_DEFAULT;\n            }\n            return new PropertyName(name);\n        }\n        */\n        return null;\n    }\n    \n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for setting values of any properties for\n     * which no dedicated setter method is found.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n\n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for accessing set of miscellaneous \"extra\"\n     * properties, often bound with matching \"any setter\" method.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }\n    \n    /**\n     * Method for checking whether given annotated item (method, constructor)\n     * has an annotation\n     * that suggests that the method is a \"creator\" (aka factory)\n     * method to be used for construct new instances of deserialized\n     * values.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasCreatorAnnotation(Annotated a) {\n        return false;\n    }\n\n    /**\n     * Method for finding indication of creator binding mode for\n     * a creator (something for which {@link #hasCreatorAnnotation} returns\n     * true), for cases where there may be ambiguity (currently: single-argument\n     * creator with implicit but no explicit name for the argument).\n     * \n     * @since 2.5\n     */\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridable methods: may be used as low-level extension\n    /* points.\n    /**********************************************************\n     */\n\n    /**\n     * Method that should be used by sub-classes for ALL\n     * annotation access;\n     * overridable so \n     * that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change it.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.getAnnotation(annoClass);\n     *</code>\n     * \n     * @since 2.5\n     */\n    protected <A extends Annotation> A _findAnnotation(Annotated annotated,\n            Class<A> annoClass) {\n        return annotated.getAnnotation(annoClass);\n    }\n\n    /**\n     * Method that should be used by sub-classes for ALL\n     * annotation existence access;\n     * overridable so  that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change value seen.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.hasAnnotation(annoClass);\n     *</code>\n     * \n     * @since 2.5\n     */\n    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n        return annotated.hasAnnotation(annoClass);\n    }\n\n    /**\n     * Alternative lookup method that is used to see if annotation has at least one of\n     * annotations of types listed in second argument.\n     *\n     * @since 2.7\n     */\n    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {\n        return annotated.hasOneOf(annoClasses);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 48, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.DeserializationConfig", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.text.DateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.cfg.*;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.LinkedNode;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n/**\n * Object that contains baseline configuration for deserialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance to be used for deserialization process.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class DeserializationConfig\n    extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    // since 2.5\n    private static final long serialVersionUID = 1;\n\n    /*\n    /**********************************************************\n    /* Configured helper objects\n    /**********************************************************\n     */\n    \n    /**\n     * Linked list that contains all registered problem handlers.\n     * Implementation as front-added linked list allows for sharing\n     * of the list (tail) without copying the list.\n     */\n    protected final LinkedNode<DeserializationProblemHandler> _problemHandlers;\n    \n    /**\n     * Factory used for constructing {@link com.fasterxml.jackson.databind.JsonNode} instances.\n     */\n    protected final JsonNodeFactory _nodeFactory;\n\n    /*\n    /**********************************************************\n    /* Deserialization features \n    /**********************************************************\n     */\n\n    /**\n     * Set of {@link DeserializationFeature}s enabled.\n     */\n    protected final int _deserFeatures;\n    \n    /*\n    /**********************************************************\n    /* Parser features: generic, format-specific\n    /**********************************************************\n     */\n    \n    /**\n     * States of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable.\n     */\n    protected final int _parserFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable\n     */\n    protected final int _parserFeaturesToChange;\n\n    /**\n     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.\n     *\n     * @since 2.7\n     */\n    protected final int _formatReadFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable\n     *\n     * @since 2.7\n     */\n    protected final int _formatReadFeaturesToChange;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by ObjectMapper to create default configuration object instance.\n     */\n    public DeserializationConfig(BaseSettings base,\n            SubtypeResolver str, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(base, str, mixins, rootNames);\n        _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n        _nodeFactory = JsonNodeFactory.instance;\n        _problemHandlers = null;\n        _parserFeatures = 0;\n        _parserFeaturesToChange = 0;\n        _formatReadFeatures = 0;\n        _formatReadFeaturesToChange = 0;\n    }\n\n    private DeserializationConfig(DeserializationConfig src,\n            int mapperFeatures, int deserFeatures,\n            int parserFeatures, int parserFeatureMask,\n            int formatFeatures, int formatFeatureMask)\n    {\n        super(src, mapperFeatures);\n        _deserFeatures = deserFeatures;\n        _nodeFactory = src._nodeFactory;\n        _problemHandlers = src._problemHandlers;\n        _parserFeatures = parserFeatures;\n        _parserFeaturesToChange = parserFeatureMask;\n        _formatReadFeatures = formatFeatures;\n        _formatReadFeaturesToChange = formatFeatureMask;\n    }\n    \n    /**\n     * Copy constructor used to create a non-shared instance with given mix-in\n     * annotation definitions and subtype resolver.\n     */\n    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str)\n    {\n        super(src, str);\n        _deserFeatures = src._deserFeatures;\n        _nodeFactory = src._nodeFactory;\n        _problemHandlers = src._problemHandlers;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n    {\n        super(src, base);\n        _deserFeatures = src._deserFeatures;\n        _nodeFactory = src._nodeFactory;\n        _problemHandlers = src._problemHandlers;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n    \n    private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n    {\n        super(src);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = f;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src,\n            LinkedNode<DeserializationProblemHandler> problemHandlers)\n    {\n        super(src);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src, PropertyName rootName)\n    {\n        super(src, rootName);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src, Class<?> view)\n    {\n        super(src, view);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    protected DeserializationConfig(DeserializationConfig src, ContextAttributes attrs)\n    {\n        super(src, attrs);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    protected DeserializationConfig(DeserializationConfig src, SimpleMixInResolver mixins)\n    {\n        super(src, mixins);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    /**\n     * Copy-constructor used for making a copy to be used by new {@link ObjectMapper}\n     * or {@link ObjectReader}.\n     *\n     * @since 2.6\n     */\n    protected DeserializationConfig(DeserializationConfig src, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(src, mixins, rootNames);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    // for unit tests only:\n    protected BaseSettings getBaseSettings() { return _base; }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, factory methods from MapperConfig\n    /**********************************************************\n     */\n    \n    @Override\n    public DeserializationConfig with(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n            newMapperFlags |= f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this :\n            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n                    \n    }\n\n    @Override\n    public DeserializationConfig without(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n             newMapperFlags &= ~f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this :\n            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    @Override\n    public DeserializationConfig with(MapperFeature feature, boolean state)\n    {\n        int newMapperFlags;\n        if (state) {\n            newMapperFlags = _mapperFeatures | feature.getMask();\n        } else {\n            newMapperFlags = _mapperFeatures & ~feature.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this :\n            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    @Override\n    public DeserializationConfig with(ClassIntrospector ci) {\n        return _withBase(_base.withClassIntrospector(ci));\n    }\n\n    @Override\n    public DeserializationConfig with(AnnotationIntrospector ai) {\n        return _withBase(_base.withAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public DeserializationConfig with(VisibilityChecker<?> vc) {\n        return _withBase(_base.withVisibilityChecker(vc));\n    }\n\n    @Override\n    public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        return _withBase( _base.withVisibility(forMethod, visibility));\n    }\n    \n    @Override\n    public DeserializationConfig with(TypeResolverBuilder<?> trb) {\n        return _withBase(_base.withTypeResolverBuilder(trb));\n    }\n\n    @Override\n    public DeserializationConfig with(SubtypeResolver str) {\n        return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);\n    }\n    \n    @Override\n    public DeserializationConfig with(PropertyNamingStrategy pns) {\n        return _withBase(_base.withPropertyNamingStrategy(pns));\n    }\n\n    @Override\n    public DeserializationConfig withRootName(PropertyName rootName) {\n        if (rootName == null) {\n            if (_rootName == null) {\n                return this;\n            }\n        } else if (rootName.equals(_rootName)) {\n            return this;\n        }\n        return new DeserializationConfig(this, rootName);\n    }\n\n    @Override\n    public DeserializationConfig with(TypeFactory tf) {\n        return _withBase( _base.withTypeFactory(tf));\n    }\n\n    @Override\n    public DeserializationConfig with(DateFormat df) {\n        return _withBase(_base.withDateFormat(df));\n    }\n    \n    @Override\n    public DeserializationConfig with(HandlerInstantiator hi) {\n        return _withBase(_base.withHandlerInstantiator(hi));\n    }\n\n    @Override\n    public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public DeserializationConfig withView(Class<?> view) {\n        return (_view == view) ? this : new DeserializationConfig(this, view);\n    }\n\n    @Override\n    public DeserializationConfig with(Locale l) {\n        return _withBase(_base.with(l));\n    }\n\n    @Override\n    public DeserializationConfig with(TimeZone tz) {\n        return _withBase(_base.with(tz));\n    }\n\n    @Override\n    public DeserializationConfig with(Base64Variant base64) {\n        return _withBase(_base.with(base64));\n    }\n\n    @Override\n    public DeserializationConfig with(ContextAttributes attrs) {\n        return (attrs == _attributes) ? this : new DeserializationConfig(this, attrs);\n    }\n    \n    private final DeserializationConfig _withBase(BaseSettings newBase) {\n        return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, DeserializationFeature-based factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public DeserializationConfig with(DeserializationFeature feature)\n    {\n        int newDeserFeatures = (_deserFeatures | feature.getMask());\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public DeserializationConfig with(DeserializationFeature first,\n            DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures | first.getMask();\n        for (DeserializationFeature f : features) {\n            newDeserFeatures |= f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public DeserializationConfig withFeatures(DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures;\n        for (DeserializationFeature f : features) {\n            newDeserFeatures |= f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     */\n    public DeserializationConfig without(DeserializationFeature feature)\n    {\n        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public DeserializationConfig without(DeserializationFeature first,\n            DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures & ~first.getMask();\n        for (DeserializationFeature f : features) {\n            newDeserFeatures &= ~f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures;\n        for (DeserializationFeature f : features) {\n            newDeserFeatures &= ~f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, JsonParser.Feature-based factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig with(JsonParser.Feature feature)\n    {\n        int newSet = _parserFeatures | feature.getMask();\n        int newMask = _parserFeaturesToChange | feature.getMask();\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig withFeatures(JsonParser.Feature... features)\n    {\n        int newSet = _parserFeatures;\n        int newMask = _parserFeaturesToChange;\n        for (JsonParser.Feature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig without(JsonParser.Feature feature)\n    {\n        int newSet = _parserFeatures & ~feature.getMask();\n        int newMask = _parserFeaturesToChange | feature.getMask();\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig withoutFeatures(JsonParser.Feature... features)\n    {\n        int newSet = _parserFeatures;\n        int newMask = _parserFeaturesToChange;\n        for (JsonParser.Feature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, JsonParser.FormatFeature-based factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig with(FormatFeature feature)\n    {\n        int newSet = _formatReadFeatures | feature.getMask();\n        int newMask = _formatReadFeaturesToChange | feature.getMask();\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig withFeatures(FormatFeature... features)\n    {\n        int newSet = _formatReadFeatures;\n        int newMask = _formatReadFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig without(FormatFeature feature)\n    {\n        int newSet = _formatReadFeatures & ~feature.getMask();\n        int newMask = _formatReadFeaturesToChange | feature.getMask();\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig withoutFeatures(FormatFeature... features)\n    {\n        int newSet = _formatReadFeatures;\n        int newMask = _formatReadFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }    \n\n    /*\n    /**********************************************************\n    /* Life-cycle, deserialization-specific factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct a new instance with\n     * specified {@link JsonNodeFactory}\n     */\n    public DeserializationConfig with(JsonNodeFactory f) {\n        if (_nodeFactory == f) {\n            return this;\n        }\n        return new DeserializationConfig(this, f);\n    }\n\n    /**\n     * Method that can be used to add a handler that can (try to)\n     * resolve non-fatal deserialization problems.\n     */\n    public DeserializationConfig withHandler(DeserializationProblemHandler h)\n    {\n        // Sanity check: let's prevent adding same handler multiple times\n        if (LinkedNode.contains(_problemHandlers, h)) {\n            return this;\n        }\n        return new DeserializationConfig(this,\n                new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers));\n    }\n\n    /**\n     * Method for removing all configured problem handlers; usually done to replace\n     * existing handler(s) with different one(s)\n     */\n    public DeserializationConfig withNoProblemHandlers() {\n        if (_problemHandlers == null) {\n            return this;\n        }\n        return new DeserializationConfig(this,\n                (LinkedNode<DeserializationProblemHandler>) null);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser initialization\n    /**********************************************************\n     */\n\n    /**\n     * Method called by {@link ObjectMapper} and {@link ObjectReader}\n     * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings\n     * that have been configured via this config instance.\n     * \n     * @since 2.5\n     */\n    public void initialize(JsonParser p) {\n        if (_parserFeaturesToChange != 0) {\n            p.overrideStdFeatures(_parserFeatures, _parserFeaturesToChange);\n        }\n        if (_formatReadFeaturesToChange != 0) {\n            p.overrideFormatFeatures(_formatReadFeatures, _formatReadFeaturesToChange);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* MapperConfig implementation/overrides: introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting {@link AnnotationIntrospector} configured\n     * to introspect annotation values used for configuration.\n     */\n    @Override\n    public AnnotationIntrospector getAnnotationIntrospector()\n    {\n        /* 29-Jul-2009, tatu: it's now possible to disable use of\n         *   annotations; can be done using \"no-op\" introspector\n         */\n        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n            return super.getAnnotationIntrospector();\n        }\n        return NopAnnotationIntrospector.instance;\n    }\n\n    /**\n     * Accessor for getting bean description that only contains class\n     * annotations: useful if no getter/setter/creator information is needed.\n     */\n    @Override\n    public BeanDescription introspectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forClassAnnotations(this, type, this);\n    }\n\n    /**\n     * Accessor for getting bean description that only contains immediate class\n     * annotations: ones from the class, and its direct mix-in, if any, but\n     * not from super types.\n     */\n    @Override\n    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n    }\n\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: default settings with per-type overrides\n    /**********************************************************\n     */\n    \n    // property inclusion not used on deserialization yet (2.7): may be added in future\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion() {\n        return EMPTY_INCLUDE;\n    }\n\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {\n        return EMPTY_INCLUDE;\n    }\n\n    @Override\n    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        // !!! TODO: per-type defaults\n        return EMPTY_FORMAT;\n    }\n\n    /*\n    /**********************************************************\n    /* MapperConfig implementation/overrides: other\n    /**********************************************************\n     */\n\n    @Override\n    public boolean useRootWrapping()\n    {\n        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n            return !_rootName.isEmpty();\n        }\n        return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);\n    }\n\n    public final boolean isEnabled(DeserializationFeature f) {\n        return (_deserFeatures & f.getMask()) != 0;\n    }\n\n    public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {\n        int mask = f.getMask();\n        if ((_parserFeaturesToChange & mask) != 0) {\n            return (_parserFeatures & f.getMask()) != 0;\n        }\n        return factory.isEnabled(f);\n    }\n\n    /**\n     * Bulk access method for checking that all features specified by\n     * mask are enabled.\n     * \n     * @since 2.3\n     */\n    public final boolean hasDeserializationFeatures(int featureMask) {\n        return (_deserFeatures & featureMask) == featureMask;\n    }\n\n    /**\n     * Bulk access method for checking that at least one of features specified by\n     * mask is enabled.\n     * \n     * @since 2.6\n     */\n    public final boolean hasSomeOfFeatures(int featureMask) {\n        return (_deserFeatures & featureMask) != 0;\n    }\n\n    /**\n     * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s\n     * that are enabled.\n     */\n    public final int getDeserializationFeatures() {\n        return _deserFeatures;\n    }\n\n    /*\n    /**********************************************************\n    /* Other configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting head of the problem handler chain. May be null,\n     * if no handlers have been added.\n     */\n    public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n        return _problemHandlers;\n    }\n\n    public final JsonNodeFactory getNodeFactory() {\n        return _nodeFactory;\n    }\n\n    /*\n    /**********************************************************\n    /* Introspection methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that will introspect full bean properties for the purpose\n     * of building a bean deserializer\n     *\n     * @param type Type of class to be introspected\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type) {\n        return (T) getClassIntrospector().forDeserialization(this, type, this);\n    }\n\n    /**\n     * Method that will introspect subset of bean properties needed to\n     * construct bean instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n        return (T) getClassIntrospector().forCreation(this, type, this);\n    }\n\n    /**\n     * @since 2.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspectForBuilder(JavaType type) {\n        return (T) getClassIntrospector().forDeserializationWithBuilder(this, type, this);\n    }\n\n    /*\n    /**********************************************************\n    /* Support for polymorphic type handling\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method that is needed to properly handle polymorphic referenced\n     * types, such as types referenced by {@link java.util.concurrent.atomic.AtomicReference},\n     * or various \"optional\" types.\n     * \n     * @since 2.4\n     */\n    public TypeDeserializer findTypeDeserializer(JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        TypeResolverBuilder<?> b = getAnnotationIntrospector().findTypeResolver(this, ac, baseType);\n\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = getSubtypeResolver().collectAndResolveSubtypesByTypeId(this, ac);\n        }\n        /* 04-May-2014, tatu: When called from DeserializerFactory, additional code like\n         *   this is invoked. But here we do not actually have access to mappings, so not\n         *   quite sure what to do, if anything. May need to revisit if the underlying\n         *   problem re-surfaces...\n         */\n        /*\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        */\n        return b.buildTypeDeserializer(this, baseType, subtypes);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.text.DateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.cfg.*;\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.*;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.LinkedNode;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n/**\n * Object that contains baseline configuration for deserialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance to be used for deserialization process.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class DeserializationConfig\n    extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    // since 2.5\n    private static final long serialVersionUID = 1;\n\n    /*\n    /**********************************************************\n    /* Configured helper objects\n    /**********************************************************\n     */\n    \n    /**\n     * Linked list that contains all registered problem handlers.\n     * Implementation as front-added linked list allows for sharing\n     * of the list (tail) without copying the list.\n     */\n    protected final LinkedNode<DeserializationProblemHandler> _problemHandlers;\n    \n    /**\n     * Factory used for constructing {@link com.fasterxml.jackson.databind.JsonNode} instances.\n     */\n    protected final JsonNodeFactory _nodeFactory;\n\n    /*\n    /**********************************************************\n    /* Deserialization features \n    /**********************************************************\n     */\n\n    /**\n     * Set of {@link DeserializationFeature}s enabled.\n     */\n    protected final int _deserFeatures;\n    \n    /*\n    /**********************************************************\n    /* Parser features: generic, format-specific\n    /**********************************************************\n     */\n    \n    /**\n     * States of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable.\n     */\n    protected final int _parserFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable\n     */\n    protected final int _parserFeaturesToChange;\n\n    /**\n     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.\n     *\n     * @since 2.7\n     */\n    protected final int _formatReadFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable\n     *\n     * @since 2.7\n     */\n    protected final int _formatReadFeaturesToChange;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by ObjectMapper to create default configuration object instance.\n     */\n    public DeserializationConfig(BaseSettings base,\n            SubtypeResolver str, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(base, str, mixins, rootNames);\n        _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n        _nodeFactory = JsonNodeFactory.instance;\n        _problemHandlers = null;\n        _parserFeatures = 0;\n        _parserFeaturesToChange = 0;\n        _formatReadFeatures = 0;\n        _formatReadFeaturesToChange = 0;\n    }\n\n    private DeserializationConfig(DeserializationConfig src,\n            int mapperFeatures, int deserFeatures,\n            int parserFeatures, int parserFeatureMask,\n            int formatFeatures, int formatFeatureMask)\n    {\n        super(src, mapperFeatures);\n        _deserFeatures = deserFeatures;\n        _nodeFactory = src._nodeFactory;\n        _problemHandlers = src._problemHandlers;\n        _parserFeatures = parserFeatures;\n        _parserFeaturesToChange = parserFeatureMask;\n        _formatReadFeatures = formatFeatures;\n        _formatReadFeaturesToChange = formatFeatureMask;\n    }\n    \n    /**\n     * Copy constructor used to create a non-shared instance with given mix-in\n     * annotation definitions and subtype resolver.\n     */\n    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str)\n    {\n        super(src, str);\n        _deserFeatures = src._deserFeatures;\n        _nodeFactory = src._nodeFactory;\n        _problemHandlers = src._problemHandlers;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n    {\n        super(src, base);\n        _deserFeatures = src._deserFeatures;\n        _nodeFactory = src._nodeFactory;\n        _problemHandlers = src._problemHandlers;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n    \n    private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n    {\n        super(src);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = f;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src,\n            LinkedNode<DeserializationProblemHandler> problemHandlers)\n    {\n        super(src);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src, PropertyName rootName)\n    {\n        super(src, rootName);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    private DeserializationConfig(DeserializationConfig src, Class<?> view)\n    {\n        super(src, view);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    protected DeserializationConfig(DeserializationConfig src, ContextAttributes attrs)\n    {\n        super(src, attrs);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    protected DeserializationConfig(DeserializationConfig src, SimpleMixInResolver mixins)\n    {\n        super(src, mixins);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    /**\n     * Copy-constructor used for making a copy to be used by new {@link ObjectMapper}\n     * or {@link ObjectReader}.\n     *\n     * @since 2.6\n     */\n    protected DeserializationConfig(DeserializationConfig src, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(src, mixins, rootNames);\n        _deserFeatures = src._deserFeatures;\n        _problemHandlers = src._problemHandlers;\n        _nodeFactory = src._nodeFactory;\n        _parserFeatures = src._parserFeatures;\n        _parserFeaturesToChange = src._parserFeaturesToChange;\n        _formatReadFeatures = src._formatReadFeatures;\n        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;\n    }\n\n    // for unit tests only:\n    protected BaseSettings getBaseSettings() { return _base; }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, factory methods from MapperConfig\n    /**********************************************************\n     */\n    \n    @Override\n    public DeserializationConfig with(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n            newMapperFlags |= f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this :\n            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n                    \n    }\n\n    @Override\n    public DeserializationConfig without(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n             newMapperFlags &= ~f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this :\n            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    @Override\n    public DeserializationConfig with(MapperFeature feature, boolean state)\n    {\n        int newMapperFlags;\n        if (state) {\n            newMapperFlags = _mapperFeatures | feature.getMask();\n        } else {\n            newMapperFlags = _mapperFeatures & ~feature.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this :\n            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    @Override\n    public DeserializationConfig with(ClassIntrospector ci) {\n        return _withBase(_base.withClassIntrospector(ci));\n    }\n\n    @Override\n    public DeserializationConfig with(AnnotationIntrospector ai) {\n        return _withBase(_base.withAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public DeserializationConfig with(VisibilityChecker<?> vc) {\n        return _withBase(_base.withVisibilityChecker(vc));\n    }\n\n    @Override\n    public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        return _withBase( _base.withVisibility(forMethod, visibility));\n    }\n    \n    @Override\n    public DeserializationConfig with(TypeResolverBuilder<?> trb) {\n        return _withBase(_base.withTypeResolverBuilder(trb));\n    }\n\n    @Override\n    public DeserializationConfig with(SubtypeResolver str) {\n        return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);\n    }\n    \n    @Override\n    public DeserializationConfig with(PropertyNamingStrategy pns) {\n        return _withBase(_base.withPropertyNamingStrategy(pns));\n    }\n\n    @Override\n    public DeserializationConfig withRootName(PropertyName rootName) {\n        if (rootName == null) {\n            if (_rootName == null) {\n                return this;\n            }\n        } else if (rootName.equals(_rootName)) {\n            return this;\n        }\n        return new DeserializationConfig(this, rootName);\n    }\n\n    @Override\n    public DeserializationConfig with(TypeFactory tf) {\n        return _withBase( _base.withTypeFactory(tf));\n    }\n\n    @Override\n    public DeserializationConfig with(DateFormat df) {\n        return _withBase(_base.withDateFormat(df));\n    }\n    \n    @Override\n    public DeserializationConfig with(HandlerInstantiator hi) {\n        return _withBase(_base.withHandlerInstantiator(hi));\n    }\n\n    @Override\n    public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public DeserializationConfig withView(Class<?> view) {\n        return (_view == view) ? this : new DeserializationConfig(this, view);\n    }\n\n    @Override\n    public DeserializationConfig with(Locale l) {\n        return _withBase(_base.with(l));\n    }\n\n    @Override\n    public DeserializationConfig with(TimeZone tz) {\n        return _withBase(_base.with(tz));\n    }\n\n    @Override\n    public DeserializationConfig with(Base64Variant base64) {\n        return _withBase(_base.with(base64));\n    }\n\n    @Override\n    public DeserializationConfig with(ContextAttributes attrs) {\n        return (attrs == _attributes) ? this : new DeserializationConfig(this, attrs);\n    }\n    \n    private final DeserializationConfig _withBase(BaseSettings newBase) {\n        return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, DeserializationFeature-based factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public DeserializationConfig with(DeserializationFeature feature)\n    {\n        int newDeserFeatures = (_deserFeatures | feature.getMask());\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public DeserializationConfig with(DeserializationFeature first,\n            DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures | first.getMask();\n        for (DeserializationFeature f : features) {\n            newDeserFeatures |= f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public DeserializationConfig withFeatures(DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures;\n        for (DeserializationFeature f : features) {\n            newDeserFeatures |= f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     */\n    public DeserializationConfig without(DeserializationFeature feature)\n    {\n        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public DeserializationConfig without(DeserializationFeature first,\n            DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures & ~first.getMask();\n        for (DeserializationFeature f : features) {\n            newDeserFeatures &= ~f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n    {\n        int newDeserFeatures = _deserFeatures;\n        for (DeserializationFeature f : features) {\n            newDeserFeatures &= ~f.getMask();\n        }\n        return (newDeserFeatures == _deserFeatures) ? this :\n            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, JsonParser.Feature-based factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig with(JsonParser.Feature feature)\n    {\n        int newSet = _parserFeatures | feature.getMask();\n        int newMask = _parserFeaturesToChange | feature.getMask();\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig withFeatures(JsonParser.Feature... features)\n    {\n        int newSet = _parserFeatures;\n        int newMask = _parserFeaturesToChange;\n        for (JsonParser.Feature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig without(JsonParser.Feature feature)\n    {\n        int newSet = _parserFeatures & ~feature.getMask();\n        int newMask = _parserFeaturesToChange | feature.getMask();\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.5\n     */\n    public DeserializationConfig withoutFeatures(JsonParser.Feature... features)\n    {\n        int newSet = _parserFeatures;\n        int newMask = _parserFeaturesToChange;\n        for (JsonParser.Feature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    newSet, newMask,\n                    _formatReadFeatures, _formatReadFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, JsonParser.FormatFeature-based factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig with(FormatFeature feature)\n    {\n        int newSet = _formatReadFeatures | feature.getMask();\n        int newMask = _formatReadFeaturesToChange | feature.getMask();\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig withFeatures(FormatFeature... features)\n    {\n        int newSet = _formatReadFeatures;\n        int newMask = _formatReadFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig without(FormatFeature feature)\n    {\n        int newSet = _formatReadFeatures & ~feature.getMask();\n        int newMask = _formatReadFeaturesToChange | feature.getMask();\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.7\n     */\n    public DeserializationConfig withoutFeatures(FormatFeature... features)\n    {\n        int newSet = _formatReadFeatures;\n        int newMask = _formatReadFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :\n            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n                    _parserFeatures, _parserFeaturesToChange,\n                    newSet, newMask);\n    }    \n\n    /*\n    /**********************************************************\n    /* Life-cycle, deserialization-specific factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct a new instance with\n     * specified {@link JsonNodeFactory}\n     */\n    public DeserializationConfig with(JsonNodeFactory f) {\n        if (_nodeFactory == f) {\n            return this;\n        }\n        return new DeserializationConfig(this, f);\n    }\n\n    /**\n     * Method that can be used to add a handler that can (try to)\n     * resolve non-fatal deserialization problems.\n     */\n    public DeserializationConfig withHandler(DeserializationProblemHandler h)\n    {\n        // Sanity check: let's prevent adding same handler multiple times\n        if (LinkedNode.contains(_problemHandlers, h)) {\n            return this;\n        }\n        return new DeserializationConfig(this,\n                new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers));\n    }\n\n    /**\n     * Method for removing all configured problem handlers; usually done to replace\n     * existing handler(s) with different one(s)\n     */\n    public DeserializationConfig withNoProblemHandlers() {\n        if (_problemHandlers == null) {\n            return this;\n        }\n        return new DeserializationConfig(this,\n                (LinkedNode<DeserializationProblemHandler>) null);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser initialization\n    /**********************************************************\n     */\n\n    /**\n     * Method called by {@link ObjectMapper} and {@link ObjectReader}\n     * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings\n     * that have been configured via this config instance.\n     * \n     * @since 2.5\n     */\n    public void initialize(JsonParser p) {\n        if (_parserFeaturesToChange != 0) {\n            p.overrideStdFeatures(_parserFeatures, _parserFeaturesToChange);\n        }\n        if (_formatReadFeaturesToChange != 0) {\n            p.overrideFormatFeatures(_formatReadFeatures, _formatReadFeaturesToChange);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* MapperConfig implementation/overrides: introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting {@link AnnotationIntrospector} configured\n     * to introspect annotation values used for configuration.\n     */\n    @Override\n    public AnnotationIntrospector getAnnotationIntrospector()\n    {\n        /* 29-Jul-2009, tatu: it's now possible to disable use of\n         *   annotations; can be done using \"no-op\" introspector\n         */\n        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n            return super.getAnnotationIntrospector();\n        }\n        return NopAnnotationIntrospector.instance;\n    }\n\n    /**\n     * Accessor for getting bean description that only contains class\n     * annotations: useful if no getter/setter/creator information is needed.\n     */\n    @Override\n    public BeanDescription introspectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forClassAnnotations(this, type, this);\n    }\n\n    /**\n     * Accessor for getting bean description that only contains immediate class\n     * annotations: ones from the class, and its direct mix-in, if any, but\n     * not from super types.\n     */\n    @Override\n    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n    }\n\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: default settings with per-type overrides\n    /**********************************************************\n     */\n    \n    // property inclusion not used on deserialization yet (2.7): may be added in future\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion() {\n        return EMPTY_INCLUDE;\n    }\n\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {\n        return EMPTY_INCLUDE;\n    }\n\n    @Override\n    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        // !!! TODO: per-type defaults\n        return EMPTY_FORMAT;\n    }\n\n    /*\n    /**********************************************************\n    /* MapperConfig implementation/overrides: other\n    /**********************************************************\n     */\n\n    @Override\n    public boolean useRootWrapping()\n    {\n        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n            return !_rootName.isEmpty();\n        }\n        return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);\n    }\n\n    public final boolean isEnabled(DeserializationFeature f) {\n        return (_deserFeatures & f.getMask()) != 0;\n    }\n\n    public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {\n        int mask = f.getMask();\n        if ((_parserFeaturesToChange & mask) != 0) {\n            return (_parserFeatures & f.getMask()) != 0;\n        }\n        return factory.isEnabled(f);\n    }\n\n    /**\n     * Bulk access method for checking that all features specified by\n     * mask are enabled.\n     * \n     * @since 2.3\n     */\n    public final boolean hasDeserializationFeatures(int featureMask) {\n        return (_deserFeatures & featureMask) == featureMask;\n    }\n\n    /**\n     * Bulk access method for checking that at least one of features specified by\n     * mask is enabled.\n     * \n     * @since 2.6\n     */\n    public final boolean hasSomeOfFeatures(int featureMask) {\n        return (_deserFeatures & featureMask) != 0;\n    }\n\n    /**\n     * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s\n     * that are enabled.\n     */\n    public final int getDeserializationFeatures() {\n        return _deserFeatures;\n    }\n\n    /*\n    /**********************************************************\n    /* Other configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting head of the problem handler chain. May be null,\n     * if no handlers have been added.\n     */\n    public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n        return _problemHandlers;\n    }\n\n    public final JsonNodeFactory getNodeFactory() {\n        return _nodeFactory;\n    }\n\n    /*\n    /**********************************************************\n    /* Introspection methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that will introspect full bean properties for the purpose\n     * of building a bean deserializer\n     *\n     * @param type Type of class to be introspected\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type) {\n        return (T) getClassIntrospector().forDeserialization(this, type, this);\n    }\n\n    /**\n     * Method that will introspect subset of bean properties needed to\n     * construct bean instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n        return (T) getClassIntrospector().forCreation(this, type, this);\n    }\n\n    /**\n     * @since 2.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspectForBuilder(JavaType type) {\n        return (T) getClassIntrospector().forDeserializationWithBuilder(this, type, this);\n    }\n\n    /*\n    /**********************************************************\n    /* Support for polymorphic type handling\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method that is needed to properly handle polymorphic referenced\n     * types, such as types referenced by {@link java.util.concurrent.atomic.AtomicReference},\n     * or various \"optional\" types.\n     * \n     * @since 2.4\n     */\n    public TypeDeserializer findTypeDeserializer(JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        TypeResolverBuilder<?> b = getAnnotationIntrospector().findTypeResolver(this, ac, baseType);\n\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = getSubtypeResolver().collectAndResolveSubtypesByTypeId(this, ac);\n        }\n        /* 04-May-2014, tatu: When called from DeserializerFactory, additional code like\n         *   this is invoked. But here we do not actually have access to mappings, so not\n         *   quite sure what to do, if anything. May need to revisit if the underlying\n         *   problem re-surfaces...\n         */\n        /*\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        */\n        return b.buildTypeDeserializer(this, baseType, subtypes);\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.SerializationConfig", "buggy_version": "package com.fasterxml.jackson.databind;\n\nimport java.text.DateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.Instantiatable;\nimport com.fasterxml.jackson.databind.cfg.*;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector;\nimport com.fasterxml.jackson.databind.introspect.SimpleMixInResolver;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.FilterProvider;\nimport com.fasterxml.jackson.databind.ser.SerializerFactory;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n/**\n * Object that contains baseline configuration for serialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance for serialization process to\n * {@link SerializerProvider} and {@link SerializerFactory}\n * (either directly, or through {@link ObjectWriter}.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class SerializationConfig\n    extends MapperConfigBase<SerializationFeature, SerializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    // since 2.5\n    private static final long serialVersionUID = 1;\n\n    // since 2.6\n    protected final static PrettyPrinter DEFAULT_PRETTY_PRINTER = new DefaultPrettyPrinter();\n\n    // since 2.7\n    // Default is \"USE_DEFAULTS, USE_DEFAULTS\"\n    protected final static JsonInclude.Value DEFAULT_INCLUSION = JsonInclude.Value.empty();\n    \n    /*\n    /**********************************************************\n    /* Configured helper objects\n    /**********************************************************\n     */\n    /**\n     * Object used for resolving filter ids to filter instances.\n     * Non-null if explicitly defined; null by default.\n     */\n    protected final FilterProvider _filterProvider;\n\n    /**\n     * If \"default pretty-printing\" is enabled, it will create the instance\n     * from this blueprint object.\n     *\n     * @since 2.6\n     */\n    protected final PrettyPrinter _defaultPrettyPrinter;\n\n    /*\n    /**********************************************************\n    /* Serialization features \n    /**********************************************************\n     */\n\n    /**\n     * Set of {@link SerializationFeature}s enabled.\n     */\n    protected final int _serFeatures;\n\n    /*\n    /**********************************************************\n    /* Generator features: generic, format-specific\n    /**********************************************************\n     */\n    /**\n     * States of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable.\n     */\n    protected final int _generatorFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable\n     */\n    protected final int _generatorFeaturesToChange;\n\n    /**\n     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.\n     *\n     * @since 2.7\n     */\n    protected final int _formatWriteFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable\n     *\n     * @since 2.7\n     */\n    protected final int _formatWriteFeaturesToChange;\n    \n    /*\n    /**********************************************************\n    /* Other configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Which Bean/Map properties are to be included in serialization?\n     * Default settings is to include all regardless of value; can be\n     * changed to only include non-null properties, or properties\n     * with non-default values.\n     *<p>\n     * NOTE: type changed in 2.7, to include both value and content\n     * inclusion options./\n     */\n    protected final JsonInclude.Value _serializationInclusion;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by ObjectMapper to create default configuration object instance.\n     */\n    public SerializationConfig(BaseSettings base,\n            SubtypeResolver str, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(base, str, mixins, rootNames);\n        _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n        _filterProvider = null;\n        _defaultPrettyPrinter = DEFAULT_PRETTY_PRINTER;\n        _generatorFeatures = 0;\n        _generatorFeaturesToChange = 0;\n        _formatWriteFeatures = 0;\n        _formatWriteFeaturesToChange = 0;\n        _serializationInclusion = DEFAULT_INCLUSION;\n    }\n\n    private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n    {\n        super(src, str);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src,\n            int mapperFeatures, int serFeatures,\n            int generatorFeatures, int generatorFeatureMask,\n            int formatFeatures, int formatFeaturesMask)\n    {\n        super(src, mapperFeatures);\n        _serFeatures = serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = generatorFeatures;\n        _generatorFeaturesToChange = generatorFeatureMask;\n        _formatWriteFeatures = formatFeatures;\n        _formatWriteFeaturesToChange = formatFeaturesMask;\n    }\n    \n    private SerializationConfig(SerializationConfig src, BaseSettings base)\n    {\n        super(src, base);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, FilterProvider filters)\n    {\n        super(src);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = filters;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, Class<?> view)\n    {\n        super(src, view);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, JsonInclude.Value incl)\n    {\n        super(src);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = incl;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, PropertyName rootName)\n    {\n        super(src, rootName);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /**\n     * @since 2.1\n     */\n    protected SerializationConfig(SerializationConfig src, ContextAttributes attrs)\n    {\n        super(src, attrs);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /**\n     * @since 2.1\n     */\n    protected SerializationConfig(SerializationConfig src, SimpleMixInResolver mixins)\n    {\n        super(src, mixins);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n    \n    /**\n     * @since 2.6\n     */\n    protected SerializationConfig(SerializationConfig src, PrettyPrinter defaultPP)\n    {\n        super(src);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = defaultPP;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /**\n     * Copy-constructor used for making a copy to be used by new {@link ObjectMapper}\n     * or {@link ObjectReader}.\n     *\n     * @since 2.6\n     */\n    protected SerializationConfig(SerializationConfig src, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(src, mixins, rootNames);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, factory methods from MapperConfig\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    @Override\n    public SerializationConfig with(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n            newMapperFlags |= f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this\n                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    @Override\n    public SerializationConfig without(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n             newMapperFlags &= ~f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this\n                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    @Override\n    public SerializationConfig with(MapperFeature feature, boolean state)\n    {\n        int newMapperFlags;\n        if (state) {\n            newMapperFlags = _mapperFeatures | feature.getMask();\n        } else {\n            newMapperFlags = _mapperFeatures & ~feature.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this\n            : new SerializationConfig(this, newMapperFlags, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n    \n    @Override\n    public SerializationConfig with(AnnotationIntrospector ai) {\n        return _withBase(_base.withAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public SerializationConfig with(ClassIntrospector ci) {\n        return _withBase(_base.withClassIntrospector(ci));\n    }\n\n    /**\n     * In addition to constructing instance with specified date format,\n     * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n     * (enable if format set as null; disable if non-null)\n     */\n    @Override\n    public SerializationConfig with(DateFormat df) {\n        SerializationConfig cfg =  new SerializationConfig(this, _base.withDateFormat(df));\n        // Also need to toggle this feature based on existence of date format:\n        if (df == null) {\n            cfg = cfg.with(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        } else {\n            cfg = cfg.without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        }\n        return cfg;\n    }\n\n    @Override\n    public SerializationConfig with(HandlerInstantiator hi) {\n        return _withBase(_base.withHandlerInstantiator(hi));\n    }\n\n    @Override\n    public SerializationConfig with(PropertyNamingStrategy pns) {\n        return _withBase(_base.withPropertyNamingStrategy(pns));\n    }\n\n    @Override\n    public SerializationConfig withRootName(PropertyName rootName) {\n        if (rootName == null) {\n            if (_rootName == null) {\n                return this;\n            }\n        } else if (rootName.equals(_rootName)) {\n            return this;\n        }\n        return new SerializationConfig(this, rootName);\n    }\n\n    @Override\n    public SerializationConfig with(SubtypeResolver str) {\n        return (str == _subtypeResolver)? this : new SerializationConfig(this, str);\n    }\n\n    @Override\n    public SerializationConfig with(TypeFactory tf) {\n        return _withBase(_base.withTypeFactory(tf));\n    }\n\n    @Override\n    public SerializationConfig with(TypeResolverBuilder<?> trb) {\n        return _withBase(_base.withTypeResolverBuilder(trb));\n    }\n\n    @Override\n    public SerializationConfig withView(Class<?> view) {\n        return (_view == view) ? this : new SerializationConfig(this, view);\n    }\n\n    @Override\n    public SerializationConfig with(VisibilityChecker<?> vc) {\n        return _withBase(_base.withVisibilityChecker(vc));\n    }\n\n    @Override\n    public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        return _withBase(_base.withVisibility(forMethod, visibility));\n    }\n\n    @Override\n    public SerializationConfig with(Locale l) {\n        return _withBase(_base.with(l));\n    }\n\n    @Override\n    public SerializationConfig with(TimeZone tz) {\n        return _withBase(_base.with(tz));\n    }\n\n    @Override\n    public SerializationConfig with(Base64Variant base64) {\n        return _withBase(_base.with(base64));\n    }\n\n    @Override\n    public SerializationConfig with(ContextAttributes attrs) {\n        return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n    }\n\n    private final SerializationConfig _withBase(BaseSettings newBase) {\n        return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods for SerializationFeature\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature enabled.\n     */\n    public SerializationConfig with(SerializationFeature feature)\n    {\n        int newSerFeatures = _serFeatures | feature.getMask();\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public SerializationConfig with(SerializationFeature first, SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures | first.getMask();\n        for (SerializationFeature f : features) {\n            newSerFeatures |= f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public SerializationConfig withFeatures(SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures;\n        for (SerializationFeature f : features) {\n            newSerFeatures |= f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     */\n    public SerializationConfig without(SerializationFeature feature)\n    {\n        int newSerFeatures = _serFeatures & ~feature.getMask();\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public SerializationConfig without(SerializationFeature first, SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures & ~first.getMask();\n        for (SerializationFeature f : features) {\n            newSerFeatures &= ~f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public SerializationConfig withoutFeatures(SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures;\n        for (SerializationFeature f : features) {\n            newSerFeatures &= ~f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods for JsonGenerator.Feature (2.5)\n    /**********************************************************\n     */\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature enabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig with(JsonGenerator.Feature feature)\n    {\n        int newSet = _generatorFeatures | feature.getMask();\n        int newMask = _generatorFeaturesToChange | feature.getMask();\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig withFeatures(JsonGenerator.Feature... features)\n    {\n        int newSet = _generatorFeatures;\n        int newMask = _generatorFeaturesToChange;\n        for (JsonGenerator.Feature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig without(JsonGenerator.Feature feature)\n    {\n        int newSet = _generatorFeatures & ~feature.getMask();\n        int newMask = _generatorFeaturesToChange | feature.getMask();\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig withoutFeatures(JsonGenerator.Feature... features)\n    {\n        int newSet = _generatorFeatures;\n        int newMask = _generatorFeaturesToChange;\n        for (JsonGenerator.Feature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods for FormatFeature (2.7)\n    /**********************************************************\n     */\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature enabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig with(FormatFeature feature)\n    {\n        int newSet = _formatWriteFeatures | feature.getMask();\n        int newMask = _formatWriteFeaturesToChange | feature.getMask();\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig withFeatures(FormatFeature... features)\n    {\n        int newSet = _formatWriteFeatures;\n        int newMask = _formatWriteFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig without(FormatFeature feature)\n    {\n        int newSet = _formatWriteFeatures & ~feature.getMask();\n        int newMask = _formatWriteFeaturesToChange | feature.getMask();\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig withoutFeatures(FormatFeature... features)\n    {\n        int newSet = _formatWriteFeatures;\n        int newMask = _formatWriteFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods, other\n    /**********************************************************\n     */\n\n    public SerializationConfig withFilters(FilterProvider filterProvider) {\n        return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n    }\n\n    /**\n     * @deprecated Since 2.7 use {@link #withPropertyInclusion} instead\n     */\n    @Deprecated\n    public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n        return withPropertyInclusion(DEFAULT_INCLUSION.withValueInclusion(incl));\n    }\n\n    /**\n     * @since 2.7\n     */\n    public SerializationConfig withPropertyInclusion(JsonInclude.Value incl) {\n        if (_serializationInclusion.equals(incl)) {\n            return this;\n        }\n        return new SerializationConfig(this, incl);\n    }\n    \n    /**\n     * @since 2.6\n     */\n    public SerializationConfig withDefaultPrettyPrinter(PrettyPrinter pp) {\n        return (_defaultPrettyPrinter == pp) ? this:  new SerializationConfig(this, pp);\n    }\n\n    /*\n    /**********************************************************\n    /* Factories for objects configured here\n    /**********************************************************\n     */\n\n    public PrettyPrinter constructDefaultPrettyPrinter() {\n        PrettyPrinter pp = _defaultPrettyPrinter;\n        if (pp instanceof Instantiatable<?>) {\n            pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n        }\n        return pp;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonParser initialization\n    /**********************************************************\n     */\n\n    /**\n     * Method called by {@link ObjectMapper} and {@link ObjectWriter}\n     * to modify those {@link com.fasterxml.jackson.core.JsonGenerator.Feature} settings\n     * that have been configured via this config instance.\n     * \n     * @since 2.5\n     */\n    public void initialize(JsonGenerator g)\n    {\n        if (SerializationFeature.INDENT_OUTPUT.enabledIn(_serFeatures)) {\n            // but do not override an explicitly set one\n            if (g.getPrettyPrinter() == null) {\n                PrettyPrinter pp = constructDefaultPrettyPrinter();\n                if (pp != null) {\n                    g.setPrettyPrinter(pp);\n                }\n            }\n        }\n        @SuppressWarnings(\"deprecation\")\n        boolean useBigDec = SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_serFeatures);\n\n        int mask = _generatorFeaturesToChange;\n        if ((mask != 0) || useBigDec) {\n            int newFlags = _generatorFeatures;\n            // although deprecated, needs to be supported for now\n            if (useBigDec) {\n                int f = JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();\n                newFlags |= f;\n                mask |= f;\n            }\n            g.overrideStdFeatures(newFlags, mask);\n        }\n        if (_formatWriteFeaturesToChange != 0) {\n            g.overrideFormatFeatures(_formatWriteFeatures, _formatWriteFeaturesToChange);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* MapperConfig implementation/overrides: introspection\n    /**********************************************************\n     */\n\n    @Override\n    public AnnotationIntrospector getAnnotationIntrospector()\n    {\n        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n            return super.getAnnotationIntrospector();\n        }\n        return AnnotationIntrospector.nopInstance();\n    }\n\n    /**\n     * Accessor for getting bean description that only contains class\n     * annotations: useful if no getter/setter/creator information is needed.\n     */\n    @Override\n    public BeanDescription introspectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forClassAnnotations(this, type, this);\n    }\n\n    /**\n     * Accessor for getting bean description that only contains immediate class\n     * annotations: ones from the class, and its direct mix-in, if any, but\n     * not from super types.\n     */\n    @Override\n    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n    }\n\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        // then global overrides (disabling)\n        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: default settings with per-type overrides\n    /**********************************************************\n     */\n    \n    /**\n     * @deprecated Since 2.7 use {@link #getDefaultPropertyInclusion} instead\n     */\n    @Deprecated\n    public JsonInclude.Include getSerializationInclusion()\n    {\n        JsonInclude.Include incl = _serializationInclusion.getValueInclusion();\n        return (incl == JsonInclude.Include.USE_DEFAULTS) ? JsonInclude.Include.ALWAYS : incl;\n    }\n\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion() {\n        return _serializationInclusion;\n    }\n\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {\n        // !!! TODO: per-type defaults\n        return _serializationInclusion;\n    }\n\n    @Override\n    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        // !!! TODO: per-type defaults\n        return EMPTY_FORMAT;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: other\n    /**********************************************************\n     */\n\n    @Override\n    public boolean useRootWrapping()\n    {\n        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n            return !_rootName.isEmpty();\n        }\n        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n    }\n    \n    public final boolean isEnabled(SerializationFeature f) {\n        return (_serFeatures & f.getMask()) != 0;\n    }\n\n    /**\n     * Accessor method that first checks if we have any overrides\n     * for feature, and only if not, checks state of passed-in\n     * factory.\n     * \n     * @since 2.5\n     */\n    public final boolean isEnabled(JsonGenerator.Feature f, JsonFactory factory) {\n        int mask = f.getMask();\n        if ((_generatorFeaturesToChange & mask) != 0) {\n            return (_generatorFeatures & f.getMask()) != 0;\n        }\n        return factory.isEnabled(f);\n    }\n    \n    /**\n     * \"Bulk\" access method for checking that all features specified by\n     * mask are enabled.\n     * \n     * @since 2.3\n     */\n    public final boolean hasSerializationFeatures(int featureMask) {\n        return (_serFeatures & featureMask) == featureMask;\n    }\n\n    public final int getSerializationFeatures() {\n        return _serFeatures;\n    }\n\n    /**\n     * Method for getting provider used for locating filters given\n     * id (which is usually provided with filter annotations).\n     * Will be null if no provided was set for {@link ObjectWriter}\n     * (or if serialization directly called from {@link ObjectMapper})\n     */\n    public FilterProvider getFilterProvider() {\n        return _filterProvider;\n    }\n\n    /**\n     * Accessor for configured blueprint \"default\" {@link PrettyPrinter} to\n     * use, if default pretty-printing is enabled.\n     *<p>\n     * NOTE: returns the \"blueprint\" instance, and does NOT construct\n     * an instance ready to use; call {@link #constructDefaultPrettyPrinter()} if\n     * actually usable instance is desired.\n     *\n     * @since 2.6\n     */\n    public PrettyPrinter getDefaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }\n\n    /*\n    /**********************************************************\n    /* Introspection methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that will introspect full bean properties for the purpose\n     * of building a bean serializer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type) {\n        return (T) getClassIntrospector().forSerialization(this, type, this);\n    }\n    \n    /*\n    /**********************************************************\n    /* Debug support\n    /**********************************************************\n     */\n\n    @Override\n    public String toString() {\n        return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind;\n\nimport java.text.DateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.Instantiatable;\nimport com.fasterxml.jackson.databind.cfg.*;\nimport com.fasterxml.jackson.databind.introspect.ClassIntrospector;\nimport com.fasterxml.jackson.databind.introspect.SimpleMixInResolver;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\nimport com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\nimport com.fasterxml.jackson.databind.ser.FilterProvider;\nimport com.fasterxml.jackson.databind.ser.SerializerFactory;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.databind.util.RootNameLookup;\n\n/**\n * Object that contains baseline configuration for serialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance for serialization process to\n * {@link SerializerProvider} and {@link SerializerFactory}\n * (either directly, or through {@link ObjectWriter}.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class SerializationConfig\n    extends MapperConfigBase<SerializationFeature, SerializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    // since 2.5\n    private static final long serialVersionUID = 1;\n\n    // since 2.6\n    protected final static PrettyPrinter DEFAULT_PRETTY_PRINTER = new DefaultPrettyPrinter();\n\n    // since 2.7\n    // Default is \"USE_DEFAULTS, USE_DEFAULTS\"\n    protected final static JsonInclude.Value DEFAULT_INCLUSION = JsonInclude.Value.empty();\n    \n    /*\n    /**********************************************************\n    /* Configured helper objects\n    /**********************************************************\n     */\n    /**\n     * Object used for resolving filter ids to filter instances.\n     * Non-null if explicitly defined; null by default.\n     */\n    protected final FilterProvider _filterProvider;\n\n    /**\n     * If \"default pretty-printing\" is enabled, it will create the instance\n     * from this blueprint object.\n     *\n     * @since 2.6\n     */\n    protected final PrettyPrinter _defaultPrettyPrinter;\n\n    /*\n    /**********************************************************\n    /* Serialization features \n    /**********************************************************\n     */\n\n    /**\n     * Set of {@link SerializationFeature}s enabled.\n     */\n    protected final int _serFeatures;\n\n    /*\n    /**********************************************************\n    /* Generator features: generic, format-specific\n    /**********************************************************\n     */\n    /**\n     * States of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable.\n     */\n    protected final int _generatorFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable\n     */\n    protected final int _generatorFeaturesToChange;\n\n    /**\n     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.\n     *\n     * @since 2.7\n     */\n    protected final int _formatWriteFeatures;\n\n    /**\n     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable\n     *\n     * @since 2.7\n     */\n    protected final int _formatWriteFeaturesToChange;\n    \n    /*\n    /**********************************************************\n    /* Other configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Which Bean/Map properties are to be included in serialization?\n     * Default settings is to include all regardless of value; can be\n     * changed to only include non-null properties, or properties\n     * with non-default values.\n     *<p>\n     * NOTE: type changed in 2.7, to include both value and content\n     * inclusion options./\n     */\n    protected final JsonInclude.Value _serializationInclusion;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by ObjectMapper to create default configuration object instance.\n     */\n    public SerializationConfig(BaseSettings base,\n            SubtypeResolver str, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(base, str, mixins, rootNames);\n        _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n        _filterProvider = null;\n        _defaultPrettyPrinter = DEFAULT_PRETTY_PRINTER;\n        _generatorFeatures = 0;\n        _generatorFeaturesToChange = 0;\n        _formatWriteFeatures = 0;\n        _formatWriteFeaturesToChange = 0;\n        _serializationInclusion = DEFAULT_INCLUSION;\n    }\n\n    private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n    {\n        super(src, str);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src,\n            int mapperFeatures, int serFeatures,\n            int generatorFeatures, int generatorFeatureMask,\n            int formatFeatures, int formatFeaturesMask)\n    {\n        super(src, mapperFeatures);\n        _serFeatures = serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = generatorFeatures;\n        _generatorFeaturesToChange = generatorFeatureMask;\n        _formatWriteFeatures = formatFeatures;\n        _formatWriteFeaturesToChange = formatFeaturesMask;\n    }\n    \n    private SerializationConfig(SerializationConfig src, BaseSettings base)\n    {\n        super(src, base);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, FilterProvider filters)\n    {\n        super(src);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = filters;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, Class<?> view)\n    {\n        super(src, view);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, JsonInclude.Value incl)\n    {\n        super(src);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = incl;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    private SerializationConfig(SerializationConfig src, PropertyName rootName)\n    {\n        super(src, rootName);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /**\n     * @since 2.1\n     */\n    protected SerializationConfig(SerializationConfig src, ContextAttributes attrs)\n    {\n        super(src, attrs);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /**\n     * @since 2.1\n     */\n    protected SerializationConfig(SerializationConfig src, SimpleMixInResolver mixins)\n    {\n        super(src, mixins);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n    \n    /**\n     * @since 2.6\n     */\n    protected SerializationConfig(SerializationConfig src, PrettyPrinter defaultPP)\n    {\n        super(src);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = defaultPP;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /**\n     * Copy-constructor used for making a copy to be used by new {@link ObjectMapper}\n     * or {@link ObjectReader}.\n     *\n     * @since 2.6\n     */\n    protected SerializationConfig(SerializationConfig src, SimpleMixInResolver mixins,\n            RootNameLookup rootNames)\n    {\n        super(src, mixins, rootNames);\n        _serFeatures = src._serFeatures;\n        _serializationInclusion = src._serializationInclusion;\n        _filterProvider = src._filterProvider;\n        _defaultPrettyPrinter = src._defaultPrettyPrinter;\n        _generatorFeatures = src._generatorFeatures;\n        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n        _formatWriteFeatures = src._formatWriteFeatures;\n        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, factory methods from MapperConfig\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    @Override\n    public SerializationConfig with(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n            newMapperFlags |= f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this\n                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n    \n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    @Override\n    public SerializationConfig without(MapperFeature... features)\n    {\n        int newMapperFlags = _mapperFeatures;\n        for (MapperFeature f : features) {\n             newMapperFlags &= ~f.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this\n                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    @Override\n    public SerializationConfig with(MapperFeature feature, boolean state)\n    {\n        int newMapperFlags;\n        if (state) {\n            newMapperFlags = _mapperFeatures | feature.getMask();\n        } else {\n            newMapperFlags = _mapperFeatures & ~feature.getMask();\n        }\n        return (newMapperFlags == _mapperFeatures) ? this\n            : new SerializationConfig(this, newMapperFlags, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n    \n    @Override\n    public SerializationConfig with(AnnotationIntrospector ai) {\n        return _withBase(_base.withAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n    }\n\n    @Override\n    public SerializationConfig with(ClassIntrospector ci) {\n        return _withBase(_base.withClassIntrospector(ci));\n    }\n\n    /**\n     * In addition to constructing instance with specified date format,\n     * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n     * (enable if format set as null; disable if non-null)\n     */\n    @Override\n    public SerializationConfig with(DateFormat df) {\n        SerializationConfig cfg =  new SerializationConfig(this, _base.withDateFormat(df));\n        // Also need to toggle this feature based on existence of date format:\n        if (df == null) {\n            cfg = cfg.with(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        } else {\n            cfg = cfg.without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        }\n        return cfg;\n    }\n\n    @Override\n    public SerializationConfig with(HandlerInstantiator hi) {\n        return _withBase(_base.withHandlerInstantiator(hi));\n    }\n\n    @Override\n    public SerializationConfig with(PropertyNamingStrategy pns) {\n        return _withBase(_base.withPropertyNamingStrategy(pns));\n    }\n\n    @Override\n    public SerializationConfig withRootName(PropertyName rootName) {\n        if (rootName == null) {\n            if (_rootName == null) {\n                return this;\n            }\n        } else if (rootName.equals(_rootName)) {\n            return this;\n        }\n        return new SerializationConfig(this, rootName);\n    }\n\n    @Override\n    public SerializationConfig with(SubtypeResolver str) {\n        return (str == _subtypeResolver)? this : new SerializationConfig(this, str);\n    }\n\n    @Override\n    public SerializationConfig with(TypeFactory tf) {\n        return _withBase(_base.withTypeFactory(tf));\n    }\n\n    @Override\n    public SerializationConfig with(TypeResolverBuilder<?> trb) {\n        return _withBase(_base.withTypeResolverBuilder(trb));\n    }\n\n    @Override\n    public SerializationConfig withView(Class<?> view) {\n        return (_view == view) ? this : new SerializationConfig(this, view);\n    }\n\n    @Override\n    public SerializationConfig with(VisibilityChecker<?> vc) {\n        return _withBase(_base.withVisibilityChecker(vc));\n    }\n\n    @Override\n    public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n        return _withBase(_base.withVisibility(forMethod, visibility));\n    }\n\n    @Override\n    public SerializationConfig with(Locale l) {\n        return _withBase(_base.with(l));\n    }\n\n    @Override\n    public SerializationConfig with(TimeZone tz) {\n        return _withBase(_base.with(tz));\n    }\n\n    @Override\n    public SerializationConfig with(Base64Variant base64) {\n        return _withBase(_base.with(base64));\n    }\n\n    @Override\n    public SerializationConfig with(ContextAttributes attrs) {\n        return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n    }\n\n    private final SerializationConfig _withBase(BaseSettings newBase) {\n        return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods for SerializationFeature\n    /**********************************************************\n     */\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature enabled.\n     */\n    public SerializationConfig with(SerializationFeature feature)\n    {\n        int newSerFeatures = _serFeatures | feature.getMask();\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public SerializationConfig with(SerializationFeature first, SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures | first.getMask();\n        for (SerializationFeature f : features) {\n            newSerFeatures |= f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     */\n    public SerializationConfig withFeatures(SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures;\n        for (SerializationFeature f : features) {\n            newSerFeatures |= f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     */\n    public SerializationConfig without(SerializationFeature feature)\n    {\n        int newSerFeatures = _serFeatures & ~feature.getMask();\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public SerializationConfig without(SerializationFeature first, SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures & ~first.getMask();\n        for (SerializationFeature f : features) {\n            newSerFeatures &= ~f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     */\n    public SerializationConfig withoutFeatures(SerializationFeature... features)\n    {\n        int newSerFeatures = _serFeatures;\n        for (SerializationFeature f : features) {\n            newSerFeatures &= ~f.getMask();\n        }\n        return (newSerFeatures == _serFeatures) ? this\n                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n                        _generatorFeatures, _generatorFeaturesToChange,\n                        _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods for JsonGenerator.Feature (2.5)\n    /**********************************************************\n     */\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature enabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig with(JsonGenerator.Feature feature)\n    {\n        int newSet = _generatorFeatures | feature.getMask();\n        int newMask = _generatorFeaturesToChange | feature.getMask();\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig withFeatures(JsonGenerator.Feature... features)\n    {\n        int newSet = _generatorFeatures;\n        int newMask = _generatorFeaturesToChange;\n        for (JsonGenerator.Feature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig without(JsonGenerator.Feature feature)\n    {\n        int newSet = _generatorFeatures & ~feature.getMask();\n        int newMask = _generatorFeaturesToChange | feature.getMask();\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.5\n     */\n    public SerializationConfig withoutFeatures(JsonGenerator.Feature... features)\n    {\n        int newSet = _generatorFeatures;\n        int newMask = _generatorFeaturesToChange;\n        for (JsonGenerator.Feature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    newSet, newMask,\n                    _formatWriteFeatures, _formatWriteFeaturesToChange);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods for FormatFeature (2.7)\n    /**********************************************************\n     */\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature enabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig with(FormatFeature feature)\n    {\n        int newSet = _formatWriteFeatures | feature.getMask();\n        int newMask = _formatWriteFeaturesToChange | feature.getMask();\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig withFeatures(FormatFeature... features)\n    {\n        int newSet = _formatWriteFeatures;\n        int newMask = _formatWriteFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet |= mask;\n            newMask |= mask;\n        }\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified feature disabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig without(FormatFeature feature)\n    {\n        int newSet = _formatWriteFeatures & ~feature.getMask();\n        int newMask = _formatWriteFeaturesToChange | feature.getMask();\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n\n    /**\n     * Fluent factory method that will construct and return a new configuration\n     * object instance with specified features disabled.\n     *\n     * @since 2.7\n     */\n    public SerializationConfig withoutFeatures(FormatFeature... features)\n    {\n        int newSet = _formatWriteFeatures;\n        int newMask = _formatWriteFeaturesToChange;\n        for (FormatFeature f : features) {\n            int mask = f.getMask();\n            newSet &= ~mask;\n            newMask |= mask;\n        }\n        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :\n            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n                    _generatorFeatures, _generatorFeaturesToChange,\n                    newSet, newMask);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods, other\n    /**********************************************************\n     */\n\n    public SerializationConfig withFilters(FilterProvider filterProvider) {\n        return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n    }\n\n    /**\n     * @deprecated Since 2.7 use {@link #withPropertyInclusion} instead\n     */\n    @Deprecated\n    public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n        return withPropertyInclusion(DEFAULT_INCLUSION.withValueInclusion(incl));\n    }\n\n    /**\n     * @since 2.7\n     */\n    public SerializationConfig withPropertyInclusion(JsonInclude.Value incl) {\n        if (_serializationInclusion.equals(incl)) {\n            return this;\n        }\n        return new SerializationConfig(this, incl);\n    }\n    \n    /**\n     * @since 2.6\n     */\n    public SerializationConfig withDefaultPrettyPrinter(PrettyPrinter pp) {\n        return (_defaultPrettyPrinter == pp) ? this:  new SerializationConfig(this, pp);\n    }\n\n    /*\n    /**********************************************************\n    /* Factories for objects configured here\n    /**********************************************************\n     */\n\n    public PrettyPrinter constructDefaultPrettyPrinter() {\n        PrettyPrinter pp = _defaultPrettyPrinter;\n        if (pp instanceof Instantiatable<?>) {\n            pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n        }\n        return pp;\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonParser initialization\n    /**********************************************************\n     */\n\n    /**\n     * Method called by {@link ObjectMapper} and {@link ObjectWriter}\n     * to modify those {@link com.fasterxml.jackson.core.JsonGenerator.Feature} settings\n     * that have been configured via this config instance.\n     * \n     * @since 2.5\n     */\n    public void initialize(JsonGenerator g)\n    {\n        if (SerializationFeature.INDENT_OUTPUT.enabledIn(_serFeatures)) {\n            // but do not override an explicitly set one\n            if (g.getPrettyPrinter() == null) {\n                PrettyPrinter pp = constructDefaultPrettyPrinter();\n                if (pp != null) {\n                    g.setPrettyPrinter(pp);\n                }\n            }\n        }\n        @SuppressWarnings(\"deprecation\")\n        boolean useBigDec = SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_serFeatures);\n\n        int mask = _generatorFeaturesToChange;\n        if ((mask != 0) || useBigDec) {\n            int newFlags = _generatorFeatures;\n            // although deprecated, needs to be supported for now\n            if (useBigDec) {\n                int f = JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();\n                newFlags |= f;\n                mask |= f;\n            }\n            g.overrideStdFeatures(newFlags, mask);\n        }\n        if (_formatWriteFeaturesToChange != 0) {\n            g.overrideFormatFeatures(_formatWriteFeatures, _formatWriteFeaturesToChange);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* MapperConfig implementation/overrides: introspection\n    /**********************************************************\n     */\n\n    @Override\n    public AnnotationIntrospector getAnnotationIntrospector()\n    {\n        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n            return super.getAnnotationIntrospector();\n        }\n        return AnnotationIntrospector.nopInstance();\n    }\n\n    /**\n     * Accessor for getting bean description that only contains class\n     * annotations: useful if no getter/setter/creator information is needed.\n     */\n    @Override\n    public BeanDescription introspectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forClassAnnotations(this, type, this);\n    }\n\n    /**\n     * Accessor for getting bean description that only contains immediate class\n     * annotations: ones from the class, and its direct mix-in, if any, but\n     * not from super types.\n     */\n    @Override\n    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n    }\n\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker()\n    {\n        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n        // then global overrides (disabling)\n        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n        }\n        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n        }\n        return vchecker;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration: default settings with per-type overrides\n    /**********************************************************\n     */\n    \n    /**\n     * @deprecated Since 2.7 use {@link #getDefaultPropertyInclusion} instead\n     */\n    @Deprecated\n    public JsonInclude.Include getSerializationInclusion()\n    {\n        JsonInclude.Include incl = _serializationInclusion.getValueInclusion();\n        return (incl == JsonInclude.Include.USE_DEFAULTS) ? JsonInclude.Include.ALWAYS : incl;\n    }\n\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion() {\n        return _serializationInclusion;\n    }\n\n    @Override\n    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {\n        // !!! TODO: per-type defaults\n        return _serializationInclusion;\n    }\n\n    @Override\n    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {\n        // !!! TODO: per-type defaults\n        return EMPTY_FORMAT;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration: other\n    /**********************************************************\n     */\n\n    @Override\n    public boolean useRootWrapping()\n    {\n        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n            return !_rootName.isEmpty();\n        }\n        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n    }\n    \n    public final boolean isEnabled(SerializationFeature f) {\n        return (_serFeatures & f.getMask()) != 0;\n    }\n\n    /**\n     * Accessor method that first checks if we have any overrides\n     * for feature, and only if not, checks state of passed-in\n     * factory.\n     * \n     * @since 2.5\n     */\n    public final boolean isEnabled(JsonGenerator.Feature f, JsonFactory factory) {\n        int mask = f.getMask();\n        if ((_generatorFeaturesToChange & mask) != 0) {\n            return (_generatorFeatures & f.getMask()) != 0;\n        }\n        return factory.isEnabled(f);\n    }\n    \n    /**\n     * \"Bulk\" access method for checking that all features specified by\n     * mask are enabled.\n     * \n     * @since 2.3\n     */\n    public final boolean hasSerializationFeatures(int featureMask) {\n        return (_serFeatures & featureMask) == featureMask;\n    }\n\n    public final int getSerializationFeatures() {\n        return _serFeatures;\n    }\n\n    /**\n     * Method for getting provider used for locating filters given\n     * id (which is usually provided with filter annotations).\n     * Will be null if no provided was set for {@link ObjectWriter}\n     * (or if serialization directly called from {@link ObjectMapper})\n     */\n    public FilterProvider getFilterProvider() {\n        return _filterProvider;\n    }\n\n    /**\n     * Accessor for configured blueprint \"default\" {@link PrettyPrinter} to\n     * use, if default pretty-printing is enabled.\n     *<p>\n     * NOTE: returns the \"blueprint\" instance, and does NOT construct\n     * an instance ready to use; call {@link #constructDefaultPrettyPrinter()} if\n     * actually usable instance is desired.\n     *\n     * @since 2.6\n     */\n    public PrettyPrinter getDefaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }\n\n    /*\n    /**********************************************************\n    /* Introspection methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that will introspect full bean properties for the purpose\n     * of building a bean serializer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type) {\n        return (T) getClassIntrospector().forSerialization(this, type, this);\n    }\n    \n    /*\n    /**********************************************************\n    /* Debug support\n    /**********************************************************\n     */\n\n    @Override\n    public String toString() {\n        return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 49, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.impl.WritableObjectId", "buggy_version": "package com.fasterxml.jackson.databind.ser.impl;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.SerializableString;\n\nimport com.fasterxml.jackson.databind.SerializerProvider;\n\n/**\n * Simple value container used to keep track of Object Ids during\n * serialization.\n */\npublic final class WritableObjectId\n{\n    public final ObjectIdGenerator<?> generator;\n\n    public Object id;\n\n    /**\n     * Marker to denote whether Object Id value has been written as part of an Object,\n     * to be referencible. Remains false when forward-reference is written.\n     */\n    protected boolean idWritten = false;\n\n    public WritableObjectId(ObjectIdGenerator<?> generator) {\n        this.generator = generator;\n    }\n\n    public boolean writeAsId(JsonGenerator gen, SerializerProvider provider, ObjectIdWriter w) throws IOException\n    {\n        if ((id != null) && (idWritten || w.alwaysAsId)) {\n            // 03-Aug-2013, tatu: Prefer Native Object Ids if available\n            if (gen.canWriteObjectId()) {\n                gen.writeObjectRef(String.valueOf(id));\n            } else {\n                w.serializer.serialize(id, gen, provider);\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n            id = generator.generateId(forPojo);\n        return id;\n    }\n\n    /**\n     * Method called to output Object Id as specified.\n     */\n    public void writeAsField(JsonGenerator gen, SerializerProvider provider,\n            ObjectIdWriter w) throws IOException\n    {\n        idWritten = true;\n\n        // 03-Aug-2013, tatu: Prefer Native Object Ids if available\n        if (gen.canWriteObjectId()) {\n            // Need to assume String(ified) ids, for now... could add 'long' variant?\n            gen.writeObjectId(String.valueOf(id));\n            return;\n        }\n        \n        SerializableString name = w.propertyName;\n        if (name != null) {\n            gen.writeFieldName(name);\n            w.serializer.serialize(id, gen, provider);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.impl;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.SerializableString;\n\nimport com.fasterxml.jackson.databind.SerializerProvider;\n\n/**\n * Simple value container used to keep track of Object Ids during\n * serialization.\n */\npublic final class WritableObjectId\n{\n    public final ObjectIdGenerator<?> generator;\n\n    public Object id;\n\n    /**\n     * Marker to denote whether Object Id value has been written as part of an Object,\n     * to be referencible. Remains false when forward-reference is written.\n     */\n    protected boolean idWritten = false;\n\n    public WritableObjectId(ObjectIdGenerator<?> generator) {\n        this.generator = generator;\n    }\n\n    public boolean writeAsId(JsonGenerator gen, SerializerProvider provider, ObjectIdWriter w) throws IOException\n    {\n        if ((id != null) && (idWritten || w.alwaysAsId)) {\n            // 03-Aug-2013, tatu: Prefer Native Object Ids if available\n            if (gen.canWriteObjectId()) {\n                gen.writeObjectRef(String.valueOf(id));\n            } else {\n                w.serializer.serialize(id, gen, provider);\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n        if (id == null) {\n            id = generator.generateId(forPojo);\n        }\n        return id;\n    }\n\n    /**\n     * Method called to output Object Id as specified.\n     */\n    public void writeAsField(JsonGenerator gen, SerializerProvider provider,\n            ObjectIdWriter w) throws IOException\n    {\n        idWritten = true;\n\n        // 03-Aug-2013, tatu: Prefer Native Object Ids if available\n        if (gen.canWriteObjectId()) {\n            // Need to assume String(ified) ids, for now... could add 'long' variant?\n            gen.writeObjectId(String.valueOf(id));\n            return;\n        }\n        \n        SerializableString name = w.propertyName;\n        if (name != null) {\n            gen.writeFieldName(name);\n            w.serializer.serialize(id, gen, provider);\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 50, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer", "buggy_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.8?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Lazily constructed exception used as root cause if reporting problem\n     * with creator method that returns <code>null</code> (which is not allowed)\n     *\n     * @since 3.8\n     */\n    protected transient Exception _nullFromCreator;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, hasViews);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n        super(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n        super(src, ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n        super(src, unwrapper);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n        super(src, oir);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps) {\n        super(src, ignorableProps);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, BeanPropertyMap props) {\n        super(src, props);\n    }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n        /* bit kludgy but we don't want to accidentally change type; sub-classes\n         * MUST override this method to support unwrapped properties...\n         */\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        /* main thing really is to just enforce ignoring of unknown\n         * properties; since there may be multiple unwrapped values\n         * and properties for all may be interleaved...\n         */\n        return new BeanDeserializer(this, unwrapper);\n    }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(Set<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.getCurrentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n\t    return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, t);\n            }\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }\n\n    /**\n     * @since 2.8\n     */\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }\n\n    /**\n     * Helper method called for rare case of pointing to {@link JsonToken#VALUE_NULL}\n     * token. While this is most often an erroneous condition, there is one specific\n     * case with XML handling where polymorphic type with no properties is exposed\n     * as such, and should be handled same as empty Object.\n     *\n     * @since 2.7\n     */\n    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic\n        //   \"empty\" POJOs deserialized from XML, where empty XML tag synthesizes a\n        //   `VALUE_NULL` token.\n        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tb = new TokenBuffer(p, ctxt);\n            tb.writeEndObject();\n            JsonParser p2 = tb.asParser(p);\n            p2.nextToken(); // to point to END_OBJECT\n            // note: don't have ObjectId to consider at this point, so:\n            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)\n                    : deserializeFromObject(p2, ctxt);\n            p2.close();\n            return ob;\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.getCurrentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        tokens.close();\n                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            /* 24-Nov-2015, tatu: Use of delegating creator needs to have precedence, and basically\n             *   external type id handling just has to be ignored, as they would relate to target\n             *   type and not delegate type. Whether this works as expected is another story, but\n             *   there's no other way to really mix these conflicting features.\n             */\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                            return null;\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }\n\n    /**\n     * Helper method for getting a lazily construct exception to be reported\n     * to {@link DeserializationContext#handleInstantiationProblem(Class, Object, Throwable)}.\n     *\n     * @since 2.8\n     */\n    protected Exception _creatorReturnedNullException() {\n        if (_nullFromCreator == null) {\n            _nullFromCreator = new NullPointerException(\"JSON Creator returned null\");\n        }\n        return _nullFromCreator;\n    }\n\n    /**\n     * @since 2.8\n     */\n\n\n\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.8?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Lazily constructed exception used as root cause if reporting problem\n     * with creator method that returns <code>null</code> (which is not allowed)\n     *\n     * @since 3.8\n     */\n    protected transient Exception _nullFromCreator;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, hasViews);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n        super(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n        super(src, ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n        super(src, unwrapper);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n        super(src, oir);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps) {\n        super(src, ignorableProps);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, BeanPropertyMap props) {\n        super(src, props);\n    }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n        /* bit kludgy but we don't want to accidentally change type; sub-classes\n         * MUST override this method to support unwrapped properties...\n         */\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        /* main thing really is to just enforce ignoring of unknown\n         * properties; since there may be multiple unwrapped values\n         * and properties for all may be interleaved...\n         */\n        return new BeanDeserializer(this, unwrapper);\n    }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(Set<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.getCurrentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n\t    return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, t);\n            }\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        List<BeanReferring> referrings = null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                } catch (UnresolvedForwardReference reference) {\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                    BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference);\n                    if (referrings == null) {\n                        referrings = new ArrayList<BeanReferring>();\n                    }\n                    referrings.add(referring);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (referrings != null) {\n            for (BeanReferring referring : referrings) {\n               referring.setBean(bean);\n            }\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }\n\n    /**\n     * @since 2.8\n     */\n    private BeanReferring handleUnresolvedReference(JsonParser p,\n            SettableBeanProperty prop, PropertyValueBuffer buffer,\n            UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        BeanReferring referring = new BeanReferring(reference, prop.getType().getRawClass(),\n                buffer, prop);\n        reference.getRoid().appendReferring(referring);\n        return referring;\n    }\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }\n\n    /**\n     * Helper method called for rare case of pointing to {@link JsonToken#VALUE_NULL}\n     * token. While this is most often an erroneous condition, there is one specific\n     * case with XML handling where polymorphic type with no properties is exposed\n     * as such, and should be handled same as empty Object.\n     *\n     * @since 2.7\n     */\n    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic\n        //   \"empty\" POJOs deserialized from XML, where empty XML tag synthesizes a\n        //   `VALUE_NULL` token.\n        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tb = new TokenBuffer(p, ctxt);\n            tb.writeEndObject();\n            JsonParser p2 = tb.asParser(p);\n            p2.nextToken(); // to point to END_OBJECT\n            // note: don't have ObjectId to consider at this point, so:\n            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)\n                    : deserializeFromObject(p2, ctxt);\n            p2.close();\n            return ob;\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.getCurrentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        tokens.close();\n                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            /* 24-Nov-2015, tatu: Use of delegating creator needs to have precedence, and basically\n             *   external type id handling just has to be ignored, as they would relate to target\n             *   type and not delegate type. Whether this works as expected is another story, but\n             *   there's no other way to really mix these conflicting features.\n             */\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                            return null;\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }\n\n    /**\n     * Helper method for getting a lazily construct exception to be reported\n     * to {@link DeserializationContext#handleInstantiationProblem(Class, Object, Throwable)}.\n     *\n     * @since 2.8\n     */\n    protected Exception _creatorReturnedNullException() {\n        if (_nullFromCreator == null) {\n            _nullFromCreator = new NullPointerException(\"JSON Creator returned null\");\n        }\n        return _nullFromCreator;\n    }\n\n    /**\n     * @since 2.8\n     */\n    static class BeanReferring extends Referring {\n        private final SettableBeanProperty _prop;\n        private Object _bean;\n\n        public void setBean(Object bean) {\n            _bean = bean;\n        }\n\n        BeanReferring(UnresolvedForwardReference ref,\n                Class<?> valueType, PropertyValueBuffer buffer, SettableBeanProperty prop)\n        {\n            super(ref, valueType);\n            _prop = prop;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _prop.set(_bean, value);\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 51, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase", "buggy_version": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    \n    protected final TypeIdResolver _idResolver;\n    \n    protected final JavaType _baseType;\n\n    /**\n     * Property that contains value for which type information\n     * is included; null if value is a root value.\n     * Note that this value is not assigned during construction\n     * but only when {@link #forProperty} is called to create\n     * a copy.\n     */\n    protected final BeanProperty _property;\n\n    /**\n     * Type to use as the default implementation, if type id is\n     * missing or can not be resolved.\n     */\n    protected final JavaType _defaultImpl;\n\n    /**\n     * Name of type property used; needed for non-property versions too,\n     * in cases where type id is to be exposed as part of JSON.\n     */\n    protected final String _typePropertyName;\n    \n    protected final boolean _typeIdVisible;\n    \n    /**\n     * For efficient operation we will lazily build mappings from type ids\n     * to actual deserializers, once needed.\n     */\n    protected final Map<String,JsonDeserializer<Object>> _deserializers;\n\n    protected JsonDeserializer<Object> _defaultImplDeserializer;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.8\n     */\n    protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, JavaType defaultImpl)\n    {\n        _baseType = baseType;\n        _idResolver = idRes;\n        // 22-Dec-2015, tatu: as per [databind#1055], avoid NPE\n        _typePropertyName = (typePropertyName == null) ? \"\" : typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        // defaults are fine, although shouldn't need much concurrency\n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);\n        _defaultImpl = defaultImpl;\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)\n    {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop);\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n    \n    @Override\n    public abstract JsonTypeInfo.As getTypeInclusion();\n\n    public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { // what should this be taken to mean?\n                        // TODO: try to figure out something better\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException\n    {\n        /* 06-Feb-2013, tatu: As per [databind#148], consider default implementation value of\n         *   {@link java.lang.Void} to mean \"serialize as null\"; as well as DeserializationFeature\n         *   to do swift mapping to null\n         */\n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids. Assumption from there is that only native\n     * type ids are to be used.\n     * \n     * @since 2.3\n     */\n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids, and such type id has been found.\n     * \n     * @since 2.4\n     */\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            /* 04-May-2014, tatu: Should error be obligatory, or should there be another method\n             *   for \"try to deserialize with native tpye id\"?\n             */\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                ctxt.reportMappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n                return null;\n            }\n        } else {\n            String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);\n            deser = _findDeserializer(ctxt, typeIdStr);\n        }\n        return deser.deserialize(jp, ctxt);\n    }\n\n    /**\n     * Helper method called when given type id can not be resolved into \n     * concrete deserializer either directly (using given {@link  TypeIdResolver}),\n     * or using default type.\n     * Default implementation simply throws a {@link com.fasterxml.jackson.databind.JsonMappingException} to\n     * indicate the problem; sub-classes may choose\n     *\n     * @return If it is possible to resolve type id into a {@link JsonDeserializer}\n     *   should return that deserializer; otherwise throw an exception to indicate\n     *   the problem.\n     *\n     * @since 2.8\n     */\n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n            TypeIdResolver idResolver, JavaType baseType)\n        throws IOException\n    {\n        String extraDesc;\n        if (idResolver instanceof TypeIdResolverBase) {\n            extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();\n            if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        return ctxt.handleUnknownTypeId(_baseType, typeId, idResolver, extraDesc);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    \n    protected final TypeIdResolver _idResolver;\n    \n    protected final JavaType _baseType;\n\n    /**\n     * Property that contains value for which type information\n     * is included; null if value is a root value.\n     * Note that this value is not assigned during construction\n     * but only when {@link #forProperty} is called to create\n     * a copy.\n     */\n    protected final BeanProperty _property;\n\n    /**\n     * Type to use as the default implementation, if type id is\n     * missing or can not be resolved.\n     */\n    protected final JavaType _defaultImpl;\n\n    /**\n     * Name of type property used; needed for non-property versions too,\n     * in cases where type id is to be exposed as part of JSON.\n     */\n    protected final String _typePropertyName;\n    \n    protected final boolean _typeIdVisible;\n    \n    /**\n     * For efficient operation we will lazily build mappings from type ids\n     * to actual deserializers, once needed.\n     */\n    protected final Map<String,JsonDeserializer<Object>> _deserializers;\n\n    protected JsonDeserializer<Object> _defaultImplDeserializer;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.8\n     */\n    protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, JavaType defaultImpl)\n    {\n        _baseType = baseType;\n        _idResolver = idRes;\n        // 22-Dec-2015, tatu: as per [databind#1055], avoid NPE\n        _typePropertyName = (typePropertyName == null) ? \"\" : typePropertyName;\n        _typeIdVisible = typeIdVisible;\n        // defaults are fine, although shouldn't need much concurrency\n        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);\n        _defaultImpl = defaultImpl;\n        _property = null;\n    }\n\n    protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property)\n    {\n        _baseType = src._baseType;\n        _idResolver = src._idResolver;\n        _typePropertyName = src._typePropertyName;\n        _typeIdVisible = src._typeIdVisible;\n        _deserializers = src._deserializers;\n        _defaultImpl = src._defaultImpl;\n        _defaultImplDeserializer = src._defaultImplDeserializer;\n        _property = property;\n    }\n\n    @Override\n    public abstract TypeDeserializer forProperty(BeanProperty prop);\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n    \n    @Override\n    public abstract JsonTypeInfo.As getTypeInclusion();\n\n    public String baseTypeName() { return _baseType.getRawClass().getName(); }\n\n    @Override\n    public final String getPropertyName() { return _typePropertyName; }\n    \n    @Override    \n    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n\n    @Override    \n    public Class<?> getDefaultImpl() {\n        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n    }\n    \n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[').append(getClass().getName());\n        sb.append(\"; base-type:\").append(_baseType);\n        sb.append(\"; id-resolver: \").append(_idResolver);\n    \t    sb.append(']');\n    \t    return sb.toString();\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { // what should this be taken to mean?\n                        // TODO: try to figure out something better\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException\n    {\n        /* 06-Feb-2013, tatu: As per [databind#148], consider default implementation value of\n         *   {@link java.lang.Void} to mean \"serialize as null\"; as well as DeserializationFeature\n         *   to do swift mapping to null\n         */\n        if (_defaultImpl == null) {\n            if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n                return NullifyingDeserializer.instance;\n            }\n            return null;\n        }\n        Class<?> raw = _defaultImpl.getRawClass();\n        if (ClassUtil.isBogusClass(raw)) {\n            return NullifyingDeserializer.instance;\n        }\n        \n        synchronized (_defaultImpl) {\n            if (_defaultImplDeserializer == null) {\n                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n                        _defaultImpl, _property);\n            }\n            return _defaultImplDeserializer;\n        }\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids. Assumption from there is that only native\n     * type ids are to be used.\n     * \n     * @since 2.3\n     */\n    @Deprecated\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n        return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());\n    }\n\n    /**\n     * Helper method called when {@link JsonParser} indicates that it can use\n     * so-called native type ids, and such type id has been found.\n     * \n     * @since 2.4\n     */\n    protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser;\n        if (typeId == null) {\n            /* 04-May-2014, tatu: Should error be obligatory, or should there be another method\n             *   for \"try to deserialize with native tpye id\"?\n             */\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                ctxt.reportMappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n                return null;\n            }\n        } else {\n            String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);\n            deser = _findDeserializer(ctxt, typeIdStr);\n        }\n        return deser.deserialize(jp, ctxt);\n    }\n\n    /**\n     * Helper method called when given type id can not be resolved into \n     * concrete deserializer either directly (using given {@link  TypeIdResolver}),\n     * or using default type.\n     * Default implementation simply throws a {@link com.fasterxml.jackson.databind.JsonMappingException} to\n     * indicate the problem; sub-classes may choose\n     *\n     * @return If it is possible to resolve type id into a {@link JsonDeserializer}\n     *   should return that deserializer; otherwise throw an exception to indicate\n     *   the problem.\n     *\n     * @since 2.8\n     */\n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n            TypeIdResolver idResolver, JavaType baseType)\n        throws IOException\n    {\n        String extraDesc;\n        if (idResolver instanceof TypeIdResolverBase) {\n            extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();\n            if (extraDesc == null) {\n                extraDesc = \"known type ids are not statically known\";\n            } else {\n                extraDesc = \"known type ids = \" + extraDesc;\n            }\n        } else {\n            extraDesc = null;\n        }\n        return ctxt.handleUnknownTypeId(_baseType, typeId, idResolver, extraDesc);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 52, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase", "buggy_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.NumberType;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\nimport com.fasterxml.jackson.databind.exc.IgnoredPropertyException;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.ClassKey;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Base class for <code>BeanDeserializer</code>.\n */\npublic abstract class BeanDeserializerBase\n    extends StdDeserializer<Object>\n    implements ContextualDeserializer, ResolvableDeserializer,\n        java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    protected final static PropertyName TEMP_PROPERTY_NAME = new PropertyName(\"#temporary-name\");\n\n    /*\n    /**********************************************************\n    /* Information regarding type being deserialized\n    /**********************************************************\n     */\n\n    /**\n     * Annotations from the bean class: used for accessing\n     * annotations during resolution\n     * (see {@link #resolve}) and\n     * contextualization (see {@link #createContextual})\n     *<p> \n     * Transient since annotations only used during construction.\n     */\n    final private transient Annotations _classAnnotations;\n\n    /**\n     * Declared type of the bean this deserializer handles.\n     */\n    final protected JavaType _beanType;\n\n    /**\n     * Requested shape from bean class annotations.\n     */\n    final protected JsonFormat.Shape _serializationShape;\n    \n    /*\n    /**********************************************************\n    /* Configuration for creating value instance\n    /**********************************************************\n     */\n\n    /**\n     * Object that handles details of constructing initial \n     * bean value (to which bind data to), unless instance\n     * is passed (via updateValue())\n     */\n    protected final ValueInstantiator _valueInstantiator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _delegateDeserializer;\n\n    /**\n     * Deserializer that is used iff array-delegate-based creator\n     * is to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _arrayDelegateDeserializer;\n\n    /**\n     * If the bean needs to be instantiated using constructor\n     * or factory method\n     * that takes one or more named properties as argument(s),\n     * this creator is used for instantiation.\n     * This value gets resolved during general resolution.\n     */\n    protected PropertyBasedCreator _propertyBasedCreator;\n\n    /**\n     * Flag that is set to mark \"non-standard\" cases; where either\n     * we use one of non-default creators, or there are unwrapped\n     * values to consider.\n     */\n    protected boolean _nonStandardCreation;\n\n    /**\n     * Flag that indicates that no \"special features\" whatsoever\n     * are enabled, so the simplest processing is possible.\n     */\n    protected boolean _vanillaProcessing;\n\n    /*\n    /**********************************************************\n    /* Property information, setters\n    /**********************************************************\n     */\n\n    /**\n     * Mapping of property names to properties, built when all properties\n     * to use have been successfully resolved.\n     */\n    final protected BeanPropertyMap _beanProperties;\n\n    /**\n     * List of {@link ValueInjector}s, if any injectable values are\n     * expected by the bean; otherwise null.\n     * This includes injectors used for injecting values via setters\n     * and fields, but not ones passed through constructor parameters.\n     */\n    final protected ValueInjector[] _injectables;\n\n    /**\n     * Fallback setter used for handling any properties that are not\n     * mapped to regular setters. If setter is not null, it will be\n     * called once for each such property.\n     */\n    protected SettableAnyProperty _anySetter;\n\n    /**\n     * In addition to properties that are set, we will also keep\n     * track of recognized but ignorable properties: these will\n     * be skipped without errors or warnings.\n     */\n    final protected Set<String> _ignorableProps;\n\n    /**\n     * Flag that can be set to ignore and skip unknown properties.\n     * If set, will not throw an exception for unknown properties.\n     */\n    final protected boolean _ignoreAllUnknown;\n\n    /**\n     * Flag that indicates that some aspect of deserialization depends\n     * on active view used (if any)\n     */\n    final protected boolean _needViewProcesing;\n    \n    /**\n     * We may also have one or more back reference fields (usually\n     * zero or one).\n     */\n    final protected Map<String, SettableBeanProperty> _backRefs;\n    \n    /*\n    /**********************************************************\n    /* Related handlers\n    /**********************************************************\n     */\n\n    /**\n     * Lazily constructed map used to contain deserializers needed\n     * for polymorphic subtypes.\n     * Note that this is <b>only needed</b> for polymorphic types,\n     * that is, when the actual type is not statically known.\n     * For other types this remains null.\n     */\n    protected transient HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers;\n\n    /**\n     * If one of properties has \"unwrapped\" value, we need separate\n     * helper object\n     */\n    protected UnwrappedPropertyHandler _unwrappedPropertyHandler;\n\n    /**\n     * Handler that we need iff any of properties uses external\n     * type id.\n     */\n    protected ExternalTypeHandler _externalTypeIdHandler;\n\n    /**\n     * If an Object Id is to be used for value handled by this\n     * deserializer, this reader is used for handling.\n     */\n    protected final ObjectIdReader _objectIdReader;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used when initially building a deserializer\n     * instance, given a {@link BeanDeserializerBuilder} that\n     * contains configuration.\n     */\n    protected BeanDeserializerBase(BeanDeserializerBuilder builder,\n            BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            Set<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(beanDesc.getType());\n\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        _classAnnotations = ac.getAnnotations();       \n        _beanType = beanDesc.getType();\n        _valueInstantiator = builder.getValueInstantiator();\n        \n        _beanProperties = properties;\n        _backRefs = backRefs;\n        _ignorableProps = ignorableProps;\n        _ignoreAllUnknown = ignoreAllUnknown;\n\n        _anySetter = builder.getAnySetter();\n        List<ValueInjector> injectables = builder.getInjectables();\n        _injectables = (injectables == null || injectables.isEmpty()) ? null\n                : injectables.toArray(new ValueInjector[injectables.size()]);\n        _objectIdReader = builder.getObjectIdReader();\n        _nonStandardCreation = (_unwrappedPropertyHandler != null)\n            || _valueInstantiator.canCreateUsingDelegate()\n            || _valueInstantiator.canCreateFromObjectWith()\n            || !_valueInstantiator.canCreateUsingDefault()\n            ;\n\n        // Any transformation we may need to apply?\n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        _serializationShape = (format == null) ? null : format.getShape();\n\n        _needViewProcesing = hasViews;\n        _vanillaProcessing = !_nonStandardCreation\n                && (_injectables == null)\n                && !_needViewProcesing\n                // also, may need to reorder stuff if we expect Object Id:\n                && (_objectIdReader == null)\n                ;\n    }\n\n    protected BeanDeserializerBase(BeanDeserializerBase src) {\n        this(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _beanProperties = src._beanProperties;\n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        _objectIdReader = src._objectIdReader;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        _vanillaProcessing = src._vanillaProcessing;\n    }\n \n    protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper)\n    {\n        super(src._beanType);\n\n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n\n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        _objectIdReader = src._objectIdReader;\n\n        _nonStandardCreation = src._nonStandardCreation;\n        UnwrappedPropertyHandler uph = src._unwrappedPropertyHandler;\n\n        if (unwrapper != null) {\n            // delegate further unwraps, if any\n            if (uph != null) { // got handler, delegate\n                uph = uph.renameAll(unwrapper);\n            }\n            // and handle direct unwrapping as well:\n            _beanProperties = src._beanProperties.renameAll(unwrapper);\n        } else {\n            _beanProperties = src._beanProperties;\n        }\n        _unwrappedPropertyHandler = uph;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        // probably adds a twist, so:\n        _vanillaProcessing = false;\n    }\n\n    public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        // then actual changes:\n        _objectIdReader = oir;\n\n        if (oir == null) {\n            _beanProperties = src._beanProperties;\n            _vanillaProcessing = src._vanillaProcessing;\n        } else {\n            /* 18-Nov-2012, tatu: May or may not have annotations for id property;\n             *   but no easy access. But hard to see id property being optional,\n             *   so let's consider required at this point.\n             */\n            ObjectIdValueProperty idProp = new ObjectIdValueProperty(oir, PropertyMetadata.STD_REQUIRED);\n            _beanProperties = src._beanProperties.withProperty(idProp);\n            _vanillaProcessing = false;\n        }\n    }\n\n    public BeanDeserializerBase(BeanDeserializerBase src, Set<String> ignorableProps)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _backRefs = src._backRefs;\n        _ignorableProps = ignorableProps;\n        _ignoreAllUnknown = src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        _vanillaProcessing = src._vanillaProcessing;\n        _objectIdReader = src._objectIdReader;\n\n        // 01-May-2016, tatu: [databind#1217]: Remove properties from mapping,\n        //    to avoid them being deserialized\n        _beanProperties = src._beanProperties.withoutProperties(ignorableProps);\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected BeanDeserializerBase(BeanDeserializerBase src, BeanPropertyMap beanProps)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _beanProperties = beanProps;\n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        _objectIdReader = src._objectIdReader;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        _vanillaProcessing = src._vanillaProcessing;\n    }\n    \n    @Override\n    public abstract JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper);\n\n    public abstract BeanDeserializerBase withObjectIdReader(ObjectIdReader oir);\n\n    public abstract BeanDeserializerBase withIgnorableProperties(Set<String> ignorableProps);\n\n    /**\n     * Mutant factory method that custom sub-classes must override; not left as\n     * abstract to prevent more drastic backwards compatibility problems.\n     *\n     * @since 2.8\n     */\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        throw new UnsupportedOperationException(\"Class \"+getClass().getName()\n                +\" does not override `withBeanProperties()`, needs to\");\n    }\n    \n    /**\n     * Fluent factory for creating a variant that can handle\n     * POJO output as a JSON Array. Implementations may ignore this request\n     * if no such input is possible.\n     * \n     * @since 2.1\n     */\n    protected abstract BeanDeserializerBase asArrayDeserializer();\n\n    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n\n    /**\n     * Method called to finalize setup of this deserializer,\n     * after deserializer itself has been registered.\n     * This is needed to handle recursive and transitive dependencies.\n     */\n    @Override\n    public void resolve(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        ExternalTypeHandler.Builder extTypes = null;\n        // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n        SettableBeanProperty[] creatorProps;\n\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n\n            // 21-Jun-2015, tatu: This resolution was duplicated later on and seems like\n            //    it really should be only done at a later point. So commented out in 2.8.\n            //   However, just in case there was a reason for it, leaving commented out\n            //   here instead of immediately removing.\n\n            /*\n            // also: need to try to resolve 'external' type ids...\n            for (SettableBeanProperty prop : creatorProps) {\n                if (prop.hasValueTypeDeserializer()) {\n                    TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                    if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                        if (extTypes == null) {\n                            extTypes = new ExternalTypeHandler.Builder();\n                        }\n                        extTypes.addExternal(prop, typeDeser);\n                    }\n                }\n            }\n            */\n        } else {\n            creatorProps = null;\n        }\n\n        UnwrappedPropertyHandler unwrapped = null;\n\n        for (SettableBeanProperty origProp : _beanProperties) {\n            SettableBeanProperty prop = origProp;\n\n            // May already have deserializer from annotations, if so, skip:\n            if (!prop.hasValueDeserializer()) {\n                // [databind#125]: allow use of converters\n                JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);\n                if (deser == null) {\n                    deser = findDeserializer(ctxt, prop.getType(), prop);\n                }\n                prop = prop.withValueDeserializer(deser);\n            } else { // may need contextual version\n                JsonDeserializer<Object> deser = prop.getValueDeserializer();\n                /* Important! This is the only place where actually handle \"primary\"\n                 * property deserializers -- call is different from other places.\n                 */\n                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,\n                        prop.getType());\n                if (cd != deser) {\n                    prop = prop.withValueDeserializer(cd);\n                }\n            }\n\n            // Need to link managed references with matching back references\n            prop = _resolveManagedReferenceProperty(ctxt, prop);\n\n            // [databind#351[: need to wrap properties that require object id resolution.\n            if (!(prop instanceof ManagedReferenceProperty)) {\n                prop = _resolvedObjectIdProperty(ctxt, prop);\n            }\n            // Support unwrapped values (via @JsonUnwrapped)\n            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n            if (u != null) {\n                prop = u;\n                if (unwrapped == null) {\n                    unwrapped = new UnwrappedPropertyHandler();\n                }\n                unwrapped.addProperty(prop);\n                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if\n                 *    the original property is left in place. So let's remove it now.\n                 */\n                _beanProperties.remove(prop);\n                continue;\n            }\n            // non-static inner classes too:\n            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n            if (prop != origProp) {\n                _beanProperties.replace(prop);\n                // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync\n                if (creatorProps != null) {\n                    // 18-May-2015, tatu: _Should_ start with consistent set. But can we really\n                    //   fully count on this? May need to revisit in future; seems to hold for now.\n                    for (int i = 0, len = creatorProps.length; i < len; ++i) {\n                        if (creatorProps[i] == origProp) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        // ... as per above, it is possible we'd need to add this as fallback\n                        // if (but only if) identity check fails?\n                        /*\n                        if (creatorProps[i].getName().equals(prop.getName())) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        */\n                    }\n                }\n            }\n            // one more thing: if this property uses \"external property\" type inclusion,\n            // it needs different handling altogether\n            if (prop.hasValueTypeDeserializer()) {\n                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                    if (extTypes == null) {\n                        extTypes = new ExternalTypeHandler.Builder();\n                    }\n                    extTypes.addExternal(prop, typeDeser);\n                    // In fact, remove from list of known properties to simplify later handling\n                    _beanProperties.remove(prop);\n                    continue;\n                }\n            }\n        }\n        // \"any setter\" may also need to be resolved now\n        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n                    _anySetter.getType(), _anySetter.getProperty()));\n        }\n        // as well as delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getDelegateCreator());\n        }\n\n        // and array-delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n            }\n            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getArrayDelegateCreator());\n        }\n\n        // And now that we know CreatorProperty instances are also resolved can finally create the creator:\n        if (creatorProps != null) {\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n\n        if (extTypes != null) {\n            // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,\n            //    so need to pass collected properties\n            _externalTypeIdHandler = extTypes.build();\n            // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n        \n        _unwrappedPropertyHandler = unwrapped;\n        if (unwrapped != null) { // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n\n        // may need to disable vanilla processing, if unwrapped handling was enabled...\n        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n    }\n\n    private JsonDeserializer<Object> _findDelegateDeserializer(DeserializationContext ctxt, JavaType delegateType,\n            AnnotatedWithParams delegateCreator) throws JsonMappingException {\n        // Need to create a temporary property to allow contextual deserializers:\n        BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,\n                delegateType, null, _classAnnotations, delegateCreator,\n                PropertyMetadata.STD_OPTIONAL);\n\n        TypeDeserializer td = delegateType.getTypeHandler();\n        if (td == null) {\n            td = ctxt.getConfig().findTypeDeserializer(delegateType);\n        }\n        JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);\n        if (td != null) {\n            td = td.forProperty(property);\n            return new TypeWrappedDeserializer(td, dd);\n        }\n        return dd;\n    }\n\n\n    /**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */\n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object convDef = intr.findDeserializationConverter(prop.getMember());\n            if (convDef != null) {\n                Converter<Object,Object> conv = ctxt.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n                JsonDeserializer<?> ser = ctxt.findContextualValueDeserializer(delegateType, prop);\n                return new StdDelegatingDeserializer<Object>(conv, delegateType, ser);\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Although most of post-processing is done in resolve(), we only get\n     * access to referring property's annotations here; and this is needed\n     * to support per-property ObjectIds.\n     * We will also consider Shape transformations (read from Array) at this\n     * point, since it may come from either Class definition or property.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        ObjectIdReader oir = _objectIdReader;\n        \n        // First: may have an override for Object Id:\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        if (accessor != null && intr != null) {\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                \n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                // Property-based generator is trickier\n                JavaType idType;\n                SettableBeanProperty idProp;\n                ObjectIdGenerator<?> idGen;\n                ObjectIdResolver resolver = ctxt.objectIdResolverInstance(accessor, objectIdInfo);\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                    PropertyName propName = objectIdInfo.getPropertyName();\n                    idProp = findProperty(propName);\n                    if (idProp == null) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                                +handledType().getName()+\": can not find property with name '\"+propName+\"'\");\n                    }\n                    idType = idProp.getType();\n                    idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n                } else { // other types need to be simpler\n                    JavaType type = ctxt.constructType(implClass);\n                    idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                    idProp = null;\n                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n                }\n                JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n                \t\tidGen, deser, idProp, resolver);\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanDeserializerBase contextual = this;\n        if (oir != null && oir != _objectIdReader) {\n            contextual = contextual.withObjectIdReader(oir);\n        }\n        // And possibly add more properties to ignore\n        if (accessor != null) {\n            JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(accessor);\n            if (ignorals != null) {\n                Set<String> ignored = ignorals.findIgnoredForDeserialization();\n                if (!ignored.isEmpty()) {\n                    Set<String> prev = contextual._ignorableProps;\n                    if ((prev != null) && !prev.isEmpty()) {\n                        ignored = new HashSet<String>(ignored);\n                        ignored.addAll(prev);\n                    }\n                    contextual = contextual.withIgnorableProperties(ignored);\n                }\n            }\n        }\n\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, handledType());\n        JsonFormat.Shape shape = null;\n        if (format != null) {\n            if (format.hasShape()) {\n                shape = format.getShape();\n            }\n            // 16-May-2016, tatu: How about per-property case-insensitivity?\n            Boolean B = format.getFeature(JsonFormat.Feature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n            if (B != null) {\n                // !!! TODO\n                BeanPropertyMap propsOrig = _beanProperties;\n                BeanPropertyMap props = propsOrig.withCaseInsensitivity(B.booleanValue());\n                if (props != propsOrig) {\n                    contextual = contextual.withBeanProperties(props);\n                }\n            }\n        }\n\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArrayDeserializer();\n        }\n        return contextual;\n    }\n\n    /**\n     * Helper method called to see if given property is part of 'managed' property\n     * pair (managed + back reference), and if so, handle resolution details.\n     */\n    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n    {\n        String refName = prop.getManagedReferenceName();\n        if (refName == null) {\n            return prop;\n        }\n        JsonDeserializer<?> valueDeser = prop.getValueDeserializer();\n        SettableBeanProperty backProp = valueDeser.findBackReference(refName);\n        if (backProp == null) {\n            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': no back reference property found from type \"\n                    +prop.getType());\n        }\n        // also: verify that type is compatible\n        JavaType referredType = _beanType;\n        JavaType backRefType = backProp.getType();\n        boolean isContainer = prop.getType().isContainerType();\n        if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) {\n            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': back reference type (\"\n                    +backRefType.getRawClass().getName()+\") not compatible with managed type (\"\n                    +referredType.getRawClass().getName()+\")\");\n        }\n        return new ManagedReferenceProperty(prop, refName, backProp,\n                _classAnnotations, isContainer);\n    }\n\n    /**\n     * Method that wraps given property with {@link ObjectIdReferenceProperty}\n     * in case where object id resolution is required.\n     */\n    protected SettableBeanProperty _resolvedObjectIdProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop) throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = prop.getObjectIdInfo();\n        JsonDeserializer<Object> valueDeser = prop.getValueDeserializer();\n        ObjectIdReader objectIdReader = valueDeser.getObjectIdReader();\n        if (objectIdInfo == null && objectIdReader == null) {\n            return prop;\n        }\n        return new ObjectIdReferenceProperty(prop, objectIdInfo);\n    }\n\n    /**\n     * Helper method called to see if given property might be so-called unwrapped\n     * property: these require special handling.\n     */\n    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n    {\n        AnnotatedMember am = prop.getMember();\n        if (am != null) {\n            NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am);\n            if (unwrapper != null) {\n                JsonDeserializer<Object> orig = prop.getValueDeserializer();\n                JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper);\n                if (unwrapping != orig && unwrapping != null) {\n                    // might be cleaner to create new instance; but difficult to do reliably, so:\n                    return prop.withValueDeserializer(unwrapping);\n                }\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Helper method that will handle gruesome details of dealing with properties\n     * that have non-static inner class as value...\n     */\n    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n    {            \n        /* Should we encounter a property that has non-static inner-class\n         * as value, we need to add some more magic to find the \"hidden\" constructor...\n         */\n        JsonDeserializer<Object> deser = prop.getValueDeserializer();\n        // ideally wouldn't rely on it being BeanDeserializerBase; but for now it'll have to do\n        if (deser instanceof BeanDeserializerBase) {\n            BeanDeserializerBase bd = (BeanDeserializerBase) deser;\n            ValueInstantiator vi = bd.getValueInstantiator();\n            if (!vi.canCreateUsingDefault()) { // no default constructor\n                Class<?> valueClass = prop.getType().getRawClass();\n                Class<?> enclosing = ClassUtil.getOuterClass(valueClass);\n                // and is inner class of the bean class...\n                if (enclosing != null && enclosing == _beanType.getRawClass()) {\n                    for (Constructor<?> ctor : valueClass.getConstructors()) {\n                        Class<?>[] paramTypes = ctor.getParameterTypes();\n                        if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n                            if (ctxt.canOverrideAccessModifiers()) {\n                                ClassUtil.checkAndFixAccess(ctor, ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                            }\n                            return new InnerClassProperty(prop, ctor);\n                        }\n                    }\n                }\n            }\n        }\n        return prop;\n    }\n\n    /*\n    /**********************************************************\n    /* Public accessors\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isCachable() { return true; }\n\n    @Override\n    public Class<?> handledType() {\n        return _beanType.getRawClass();\n    }\n    \n    /**\n     * Overridden to return true for those instances that are\n     * handling value for which Object Identity handling is enabled\n     * (either via value type or referring property).\n     */\n    @Override\n    public ObjectIdReader getObjectIdReader() {\n        return _objectIdReader;\n    }\n    \n    public boolean hasProperty(String propertyName) {\n        return _beanProperties.find(propertyName) != null;\n    }\n\n    public boolean hasViews() {\n        return _needViewProcesing;\n    }\n    \n    /**\n     * Accessor for checking number of deserialized properties.\n     */\n    public int getPropertyCount() { \n        return _beanProperties.size();\n    }\n\n    @Override\n    public Collection<Object> getKnownPropertyNames() {\n        ArrayList<Object> names = new ArrayList<Object>();\n        for (SettableBeanProperty prop : _beanProperties) {\n            names.add(prop.getName());\n        }\n        return names;\n    }\n\n    /**\n     * @deprecated Since 2.3, use {@link #handledType()} instead\n     */\n    @Deprecated\n    public final Class<?> getBeanClass() { return _beanType.getRawClass(); }\n\n    @Override\n    public JavaType getValueType() { return _beanType; }\n\n    /**\n     * Accessor for iterating over properties this deserializer uses; with\n     * the exception that properties passed via Creator methods\n     * (specifically, \"property-based constructor\") are not included,\n     * but can be accessed separate by calling\n     * {@link #creatorProperties}\n     */\n    public Iterator<SettableBeanProperty> properties()\n    {\n        if (_beanProperties == null) {\n            throw new IllegalStateException(\"Can only call after BeanDeserializer has been resolved\");\n        }\n        return _beanProperties.iterator();\n    }\n\n    /**\n     * Accessor for finding properties that represents values to pass\n     * through property-based creator method (constructor or\n     * factory method)\n     * \n     * @since 2.0\n     */\n    public Iterator<SettableBeanProperty> creatorProperties()\n    {\n        if (_propertyBasedCreator == null) {\n            return Collections.<SettableBeanProperty>emptyList().iterator();\n        }\n        return _propertyBasedCreator.properties().iterator();\n    }\n\n    public SettableBeanProperty findProperty(PropertyName propertyName)\n    {\n        // TODO: start matching full name?\n        return findProperty(propertyName.getSimpleName());\n    }\n    \n    /**\n     * Accessor for finding the property with given name, if POJO\n     * has one. Name used is the external name, i.e. name used\n     * in external data representation (JSON).\n     * \n     * @since 2.0\n     */\n    public SettableBeanProperty findProperty(String propertyName)\n    {\n        SettableBeanProperty prop = (_beanProperties == null) ?\n                null : _beanProperties.find(propertyName);\n        if (prop == null && _propertyBasedCreator != null) {\n            prop = _propertyBasedCreator.findCreatorProperty(propertyName);\n        }\n        return prop;\n    }\n\n    /**\n     * Alternate find method that tries to locate a property with given\n     * <code>property index</code>.\n     * Note that access by index is not necessarily faster than by name,\n     * since properties are not directly indexable; however, for most\n     * instances difference is not significant as number of properties\n     * is low.\n     * \n     * @since 2.3\n     */\n    public SettableBeanProperty findProperty(int propertyIndex)\n    {\n        SettableBeanProperty prop = (_beanProperties == null) ?\n                null : _beanProperties.find(propertyIndex);\n        if (prop == null && _propertyBasedCreator != null) {\n            prop = _propertyBasedCreator.findCreatorProperty(propertyIndex);\n        }\n        return prop;\n    }\n    \n    /**\n     * Method needed by {@link BeanDeserializerFactory} to properly link\n     * managed- and back-reference pairs.\n     */\n    @Override\n    public SettableBeanProperty findBackReference(String logicalName)\n    {\n        if (_backRefs == null) {\n            return null;\n        }\n        return _backRefs.get(logicalName);\n    }\n\n    public ValueInstantiator getValueInstantiator() {\n        return _valueInstantiator;\n    }\n\n    /*\n    /**********************************************************\n    /* Mutators\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to replace an existing property with\n     * a modified one.\n     *<p>\n     * NOTE: only ever use this method if you know what you are doing;\n     * incorrect usage can break deserializer.\n     *\n     * @param original Property to replace\n     * @param replacement Property to replace it with\n     * \n     * @since 2.1\n     */\n    public void replaceProperty(SettableBeanProperty original,\n            SettableBeanProperty replacement)\n    {\n        _beanProperties.replace(replacement);\n    }\n\n    /*\n    /**********************************************************\n    /* Partial deserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * General version used when handling needs more advanced\n     * features.\n     */\n    public abstract Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n        if (_objectIdReader != null) {\n            // 05-Aug-2013, tatu: May use native Object Id\n            if (p.canReadObjectId()) {\n                Object id = p.getObjectId();\n                if (id != null) {\n                    Object ob = typeDeserializer.deserializeTypedFromObject(p, ctxt);\n                    return _handleTypedObjectId(p, ctxt, ob, id);\n                }\n            }\n            // or, Object Ids Jackson explicitly sets\n            JsonToken t = p.getCurrentToken();\n            if (t != null) {\n                // Most commonly, a scalar (int id, uuid String, ...)\n                if (t.isScalarValue()) {\n                    return deserializeFromObjectId(p, ctxt);\n                }\n                // but, with 2.5+, a simple Object-wrapped value also legal:\n                if (t == JsonToken.START_OBJECT) {\n                    t = p.nextToken();\n                }\n                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()\n                        && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                    return deserializeFromObjectId(p, ctxt);\n                }\n            }\n        }\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromObject(p, ctxt);\n    }\n\n    /**\n     * Offlined method called to handle \"native\" Object Id that has been read\n     * and known to be associated with given deserialized POJO.\n     *\n     * @since 2.3\n     */\n    protected Object _handleTypedObjectId(JsonParser p, DeserializationContext ctxt,\n            Object pojo, Object rawId)\n        throws IOException\n    {\n        // One more challenge: type of id may not be type of property we are expecting\n        // later on; specifically, numeric ids vs Strings.\n        JsonDeserializer<Object> idDeser = _objectIdReader.getDeserializer();\n        final Object id;\n\n        // Ok, this is bit ridiculous; let's see if conversion is needed:\n        if (idDeser.handledType() == rawId.getClass()) {\n            // nope: already same type\n            id = rawId;\n        } else {\n            id = _convertObjectId(p, ctxt, rawId, idDeser);\n        }\n\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(pojo);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(pojo, id);\n        }\n        return pojo;\n    }\n\n    /**\n     * Helper method we need to do necessary conversion from whatever native object id\n     * type is, into declared type that Jackson internals expect. This may be\n     * simple cast (for String ids), or something more complicated; in latter\n     * case we may need to create bogus content buffer to allow use of\n     * id deserializer.\n     *\n     * @since 2.3\n     */\n    @SuppressWarnings(\"resource\") // TokenBuffers don't need close, nor parser thereof\n    protected Object _convertObjectId(JsonParser p, DeserializationContext ctxt,\n            Object rawId, JsonDeserializer<Object> idDeser) throws IOException\n    {\n        TokenBuffer buf = new TokenBuffer(p, ctxt);\n        if (rawId instanceof String) {\n            buf.writeString((String) rawId);\n        } else if (rawId instanceof Long) {\n            buf.writeNumber(((Long) rawId).longValue());\n        } else if (rawId instanceof Integer) {\n            buf.writeNumber(((Integer) rawId).intValue());\n        } else {\n            // should we worry about UUIDs? They should be fine, right?\n            // 07-Aug-2014, tatu: Maybe, but not necessarily; had issues with\n            //   Smile format; [Smile#19], possibly related.\n            buf.writeObject(rawId);\n        }\n        JsonParser bufParser = buf.asParser();\n        bufParser.nextToken();\n        return idDeser.deserialize(bufParser, ctxt);\n    }\n\n    // NOTE: currently only used by standard BeanDeserializer (not Builder-based)\n    /**\n     * Alternative deserialization method used when we expect to see Object Id;\n     * if so, we will need to ensure that the Id is seen before anything\n     * else, to ensure that it is available for solving references,\n     * even if JSON itself is not ordered that way. This may require\n     * buffering in some cases, but usually just a simple lookup to ensure\n     * that ordering is correct.\n     */\n    protected Object deserializeWithObjectId(JsonParser p, DeserializationContext ctxt) throws IOException {\n        return deserializeFromObject(p, ctxt);\n    }\n\n    /**\n     * Method called in cases where it looks like we got an Object Id\n     * to parse and use as a reference.\n     */\n    protected Object deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        Object id = _objectIdReader.readObjectReference(p, ctxt);\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        // do we have it resolved?\n        Object pojo = roid.resolve();\n        if (pojo == null) { // not yet; should wait...\n            throw new UnresolvedForwardReference(p,\n                    \"Could not resolve Object Id [\"+id+\"] (for \"+_beanType+\").\",\n                    p.getCurrentLocation(), roid);\n        }\n        return pojo;\n    }\n\n    protected Object deserializeFromObjectUsingNonDefault(JsonParser p,\n            DeserializationContext ctxt) throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingPropertyBased(p, ctxt);\n        }\n        // should only occur for abstract types...\n        if (_beanType.isAbstract()) {\n            return ctxt.handleMissingInstantiator(handledType(), p,\n                    \"abstract type (need to add/enable type information?)\");\n        }\n        return ctxt.handleMissingInstantiator(_beanType.getRawClass(), p,\n                \"no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\");\n    }\n\n    protected abstract Object _deserializeUsingPropertyBased(final JsonParser p,\n            final DeserializationContext ctxt)\n        throws IOException, JsonProcessingException;\n\n    @SuppressWarnings(\"incomplete-switch\")\n    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // First things first: id Object Id is used, most likely that's it\n        if (_objectIdReader != null) {\n            return deserializeFromObjectId(p, ctxt);\n        }\n\n        switch (p.getNumberType()) {\n        case INT:\n            if (_delegateDeserializer != null) {\n                if (!_valueInstantiator.canCreateFromInt()) {\n                    Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n                            _delegateDeserializer.deserialize(p, ctxt));\n                    if (_injectables != null) {\n                        injectValues(ctxt, bean);\n                    }\n                    return bean;\n                }\n            }\n            return _valueInstantiator.createFromInt(ctxt, p.getIntValue());\n        case LONG:\n            if (_delegateDeserializer != null) {\n                if (!_valueInstantiator.canCreateFromInt()) {\n                    Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n                            _delegateDeserializer.deserialize(p, ctxt));\n                    if (_injectables != null) {\n                        injectValues(ctxt, bean);\n                    }\n                    return bean;\n                }\n            }\n            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());\n        }\n        // actually, could also be BigInteger, so:\n        if (_delegateDeserializer != null) {\n            Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            return bean;\n        }\n        return ctxt.handleMissingInstantiator(handledType(), p,\n                \"no suitable creator method found to deserialize from Number value (%s)\",\n                p.getNumberValue());\n    }\n\n    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // First things first: id Object Id is used, most likely that's it\n        if (_objectIdReader != null) {\n            return deserializeFromObjectId(p, ctxt);\n        }\n        \n        /* Bit complicated if we have delegating creator; may need to use it,\n         * or might not...\n         */\n        if (_delegateDeserializer != null) {\n            if (!_valueInstantiator.canCreateFromString()) {\n                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            }\n        }\n        return _valueInstantiator.createFromString(ctxt, p.getText());\n    }\n\n    /**\n     * Method called to deserialize POJO value from a JSON floating-point\n     * number.\n     */\n    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        NumberType t = p.getNumberType();\n        // no separate methods for taking float...\n        if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {\n            if (_delegateDeserializer != null) {\n                if (!_valueInstantiator.canCreateFromDouble()) {\n                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                    if (_injectables != null) {\n                        injectValues(ctxt, bean);\n                    }\n                    return bean;\n                }\n            }\n            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n        }\n        // actually, could also be BigDecimal, so:\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        return ctxt.handleMissingInstantiator(handledType(), p,\n                \"no suitable creator method found to deserialize from Number value (%s)\",\n                p.getNumberValue());\n    }\n\n    /**\n     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n     */\n    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            if (!_valueInstantiator.canCreateFromBoolean()) {\n                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            }\n        }\n        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);\n        return _valueInstantiator.createFromBoolean(ctxt, value);\n    }\n\n    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (_arrayDelegateDeserializer != null) {\n            try {\n                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            } catch (Exception e) {\n                return wrapInstantiationProblem(e, ctxt);\n            }\n        }\n        // fallback to non-array delegate\n        if (_delegateDeserializer != null) {\n            try {\n                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            } catch (Exception e) {\n                wrapInstantiationProblem(e, ctxt);\n                return null;\n            }\n        }\n        if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            JsonToken t = p.nextToken();\n            if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                return null;\n            }\n            final Object value = deserialize(p, ctxt);\n            if (p.nextToken() != JsonToken.END_ARRAY) {\n                handleMissingEndArrayForSingle(p, ctxt);\n            }\n            return value;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n            JsonToken t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                return null;\n            }\n            return ctxt.handleUnexpectedToken(handledType(),\n                    JsonToken.START_ARRAY, p, null);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // First things first: id Object Id is used, most likely that's it; specifically,\n        // true for UUIDs when written as binary (with Smile, other binary formats)\n        if (_objectIdReader != null) {\n            return deserializeFromObjectId(p, ctxt);\n        }\n\n        // TODO: maybe add support for ValueInstantiator, embedded?\n        \n        return p.getEmbeddedObject();\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable helper methods\n    /**********************************************************\n     */\n\n    protected void injectValues(DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (ValueInjector injector : _injectables) {\n            injector.inject(ctxt, bean);\n        }\n    }\n    \n    /**\n     * Method called to handle set of one or more unknown properties,\n     * stored in their entirety in given {@link TokenBuffer}\n     * (as field entries, name and value).\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object handleUnknownProperties(DeserializationContext ctxt,\n            Object bean, TokenBuffer unknownTokens)\n        throws IOException\n    {\n        // First: add closing END_OBJECT as marker\n        unknownTokens.writeEndObject();\n\n        // note: buffer does NOT have starting START_OBJECT\n        JsonParser bufferParser = unknownTokens.asParser();\n        while (bufferParser.nextToken() != JsonToken.END_OBJECT) {\n            String propName = bufferParser.getCurrentName();\n            // Unknown: let's call handler method\n            bufferParser.nextToken();\n            handleUnknownProperty(bufferParser, ctxt, bean, propName);\n        }\n        return bean;\n    }\n\n    /**\n     * Helper method called for an unknown property, when using \"vanilla\"\n     * processing.\n     */\n    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,\n            Object bean, String propName)\n        throws IOException\n    {\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, bean, propName);\n        } else if (_anySetter != null) {\n            try {\n               // should we consider return type of any setter?\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        } else {\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);         \n        }\n    }\n\n    /**\n     * Method called when a JSON property is encountered that has not matching\n     * setter, any-setter or field, and thus can not be assigned.\n     */\n    @Override\n    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,\n            Object beanOrClass, String propName)\n        throws IOException\n    {\n        if (_ignoreAllUnknown) {\n            p.skipChildren();\n            return;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, beanOrClass, propName);\n        }\n        // Otherwise use default handling (call handler(s); if not\n        // handled, throw exception or skip depending on settings)\n        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);\n    }\n\n    /**\n     * Method called when an explicitly ignored property (one specified with a\n     * name to match, either by property annotation or class annotation) is encountered.\n     * \n     * @since 2.3\n     */\n    protected void handleIgnoredProperty(JsonParser p, DeserializationContext ctxt,\n            Object beanOrClass, String propName)\n        throws IOException\n    {\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)) {\n            throw IgnoredPropertyException.from(p, beanOrClass, propName, getKnownPropertyNames());\n        }\n        p.skipChildren();\n    }\n    \n    /**\n     * Method called in cases where we may have polymorphic deserialization\n     * case: that is, type of Creator-constructed bean is not the type\n     * of deserializer itself. It should be a sub-class or implementation\n     * class; either way, we may have more specific deserializer to use\n     * for handling it.\n     *\n     * @param p (optional) If not null, parser that has more properties to handle\n     *   (in addition to buffered properties); if null, all properties are passed\n     *   in buffer\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object handlePolymorphic(JsonParser p, DeserializationContext ctxt,                                          \n            Object bean, TokenBuffer unknownTokens)\n        throws IOException\n    {  \n        // First things first: maybe there is a more specific deserializer available?\n        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n        if (subDeser != null) {\n            if (unknownTokens != null) {\n                // need to add END_OBJECT marker first\n                unknownTokens.writeEndObject();\n                JsonParser p2 = unknownTokens.asParser();\n                p2.nextToken(); // to get to first data field\n                bean = subDeser.deserialize(p2, ctxt, bean);\n            }\n            // Original parser may also have some leftovers\n            if (p != null) {\n                bean = subDeser.deserialize(p, ctxt, bean);\n            }\n            return bean;\n        }\n        // nope; need to use this deserializer. Unknowns we've seen so far?\n        if (unknownTokens != null) {\n            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n        }\n        // and/or things left to process via main parser?\n        if (p != null) {\n            bean = deserialize(p, ctxt, bean);\n        }\n        return bean;\n    }\n    \n    /**\n     * Helper method called to (try to) locate deserializer for given sub-type of\n     * type that this deserializer handles.\n     */\n    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt,\n            Object bean, TokenBuffer unknownTokens)\n        throws IOException\n    {  \n        JsonDeserializer<Object> subDeser;\n\n        // First: maybe we have already created sub-type deserializer?\n        synchronized (this) {\n            subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass()));\n        }\n        if (subDeser != null) {\n            return subDeser;\n        }\n        // If not, maybe we can locate one. First, need provider\n        JavaType type = ctxt.constructType(bean.getClass());\n        /* 30-Jan-2012, tatu: Ideally we would be passing referring\n         *   property; which in theory we could keep track of via\n         *   ResolvableDeserializer (if we absolutely must...).\n         *   But for now, let's not bother.\n         */\n//        subDeser = ctxt.findValueDeserializer(type, _property);\n        subDeser = ctxt.findRootValueDeserializer(type);\n        // Also, need to cache it\n        if (subDeser != null) {\n            synchronized (this) {\n                if (_subDeserializers == null) {\n                    _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n                }\n                _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n            }            \n        }\n        return subDeser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for error reporting\n    /**********************************************************\n     */\n\n    /**\n     * Method that will modify caught exception (passed in as argument)\n     * as necessary to include reference information, and to ensure it\n     * is a subtype of {@link IOException}, or an unchecked exception.\n     *<p>\n     * Rules for wrapping and unwrapping are bit complicated; essentially:\n     *<ul>\n     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n     * <li>\"Plain\" IOExceptions (ones that are not of type\n     *   {@link JsonMappingException} are to be passed as is\n     *</ul>\n     */\n    public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)\n        throws IOException\n    {\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, fieldName);\n    }\n\n    @Deprecated // since 2.4, not used by core Jackson; only relevant for arrays/Collections\n    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt) throws IOException {\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, index);\n    }\n\n    private Throwable throwOrReturnThrowable(Throwable t, DeserializationContext ctxt) \n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   often gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap JSON exceptions\n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonProcessingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        return t;\n    }\n\n    protected Object wrapInstantiationProblem(Throwable t, DeserializationContext ctxt)\n        throws IOException\n    {\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        if (t instanceof IOException) {\n            // Since we have no more information to add, let's not actually wrap..\n            throw (IOException) t;\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        return ctxt.handleInstantiationProblem(_beanType.getRawClass(), null, t);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.NumberType;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\nimport com.fasterxml.jackson.databind.exc.IgnoredPropertyException;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.ClassKey;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Base class for <code>BeanDeserializer</code>.\n */\npublic abstract class BeanDeserializerBase\n    extends StdDeserializer<Object>\n    implements ContextualDeserializer, ResolvableDeserializer,\n        java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n\n    protected final static PropertyName TEMP_PROPERTY_NAME = new PropertyName(\"#temporary-name\");\n\n    /*\n    /**********************************************************\n    /* Information regarding type being deserialized\n    /**********************************************************\n     */\n\n    /**\n     * Annotations from the bean class: used for accessing\n     * annotations during resolution\n     * (see {@link #resolve}) and\n     * contextualization (see {@link #createContextual})\n     *<p> \n     * Transient since annotations only used during construction.\n     */\n    final private transient Annotations _classAnnotations;\n\n    /**\n     * Declared type of the bean this deserializer handles.\n     */\n    final protected JavaType _beanType;\n\n    /**\n     * Requested shape from bean class annotations.\n     */\n    final protected JsonFormat.Shape _serializationShape;\n    \n    /*\n    /**********************************************************\n    /* Configuration for creating value instance\n    /**********************************************************\n     */\n\n    /**\n     * Object that handles details of constructing initial \n     * bean value (to which bind data to), unless instance\n     * is passed (via updateValue())\n     */\n    protected final ValueInstantiator _valueInstantiator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _delegateDeserializer;\n\n    /**\n     * Deserializer that is used iff array-delegate-based creator\n     * is to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _arrayDelegateDeserializer;\n\n    /**\n     * If the bean needs to be instantiated using constructor\n     * or factory method\n     * that takes one or more named properties as argument(s),\n     * this creator is used for instantiation.\n     * This value gets resolved during general resolution.\n     */\n    protected PropertyBasedCreator _propertyBasedCreator;\n\n    /**\n     * Flag that is set to mark \"non-standard\" cases; where either\n     * we use one of non-default creators, or there are unwrapped\n     * values to consider.\n     */\n    protected boolean _nonStandardCreation;\n\n    /**\n     * Flag that indicates that no \"special features\" whatsoever\n     * are enabled, so the simplest processing is possible.\n     */\n    protected boolean _vanillaProcessing;\n\n    /*\n    /**********************************************************\n    /* Property information, setters\n    /**********************************************************\n     */\n\n    /**\n     * Mapping of property names to properties, built when all properties\n     * to use have been successfully resolved.\n     */\n    final protected BeanPropertyMap _beanProperties;\n\n    /**\n     * List of {@link ValueInjector}s, if any injectable values are\n     * expected by the bean; otherwise null.\n     * This includes injectors used for injecting values via setters\n     * and fields, but not ones passed through constructor parameters.\n     */\n    final protected ValueInjector[] _injectables;\n\n    /**\n     * Fallback setter used for handling any properties that are not\n     * mapped to regular setters. If setter is not null, it will be\n     * called once for each such property.\n     */\n    protected SettableAnyProperty _anySetter;\n\n    /**\n     * In addition to properties that are set, we will also keep\n     * track of recognized but ignorable properties: these will\n     * be skipped without errors or warnings.\n     */\n    final protected Set<String> _ignorableProps;\n\n    /**\n     * Flag that can be set to ignore and skip unknown properties.\n     * If set, will not throw an exception for unknown properties.\n     */\n    final protected boolean _ignoreAllUnknown;\n\n    /**\n     * Flag that indicates that some aspect of deserialization depends\n     * on active view used (if any)\n     */\n    final protected boolean _needViewProcesing;\n    \n    /**\n     * We may also have one or more back reference fields (usually\n     * zero or one).\n     */\n    final protected Map<String, SettableBeanProperty> _backRefs;\n    \n    /*\n    /**********************************************************\n    /* Related handlers\n    /**********************************************************\n     */\n\n    /**\n     * Lazily constructed map used to contain deserializers needed\n     * for polymorphic subtypes.\n     * Note that this is <b>only needed</b> for polymorphic types,\n     * that is, when the actual type is not statically known.\n     * For other types this remains null.\n     */\n    protected transient HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers;\n\n    /**\n     * If one of properties has \"unwrapped\" value, we need separate\n     * helper object\n     */\n    protected UnwrappedPropertyHandler _unwrappedPropertyHandler;\n\n    /**\n     * Handler that we need iff any of properties uses external\n     * type id.\n     */\n    protected ExternalTypeHandler _externalTypeIdHandler;\n\n    /**\n     * If an Object Id is to be used for value handled by this\n     * deserializer, this reader is used for handling.\n     */\n    protected final ObjectIdReader _objectIdReader;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used when initially building a deserializer\n     * instance, given a {@link BeanDeserializerBuilder} that\n     * contains configuration.\n     */\n    protected BeanDeserializerBase(BeanDeserializerBuilder builder,\n            BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            Set<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(beanDesc.getType());\n\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        _classAnnotations = ac.getAnnotations();       \n        _beanType = beanDesc.getType();\n        _valueInstantiator = builder.getValueInstantiator();\n        \n        _beanProperties = properties;\n        _backRefs = backRefs;\n        _ignorableProps = ignorableProps;\n        _ignoreAllUnknown = ignoreAllUnknown;\n\n        _anySetter = builder.getAnySetter();\n        List<ValueInjector> injectables = builder.getInjectables();\n        _injectables = (injectables == null || injectables.isEmpty()) ? null\n                : injectables.toArray(new ValueInjector[injectables.size()]);\n        _objectIdReader = builder.getObjectIdReader();\n        _nonStandardCreation = (_unwrappedPropertyHandler != null)\n            || _valueInstantiator.canCreateUsingDelegate()\n            || _valueInstantiator.canCreateFromObjectWith()\n            || !_valueInstantiator.canCreateUsingDefault()\n            ;\n\n        // Any transformation we may need to apply?\n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        _serializationShape = (format == null) ? null : format.getShape();\n\n        _needViewProcesing = hasViews;\n        _vanillaProcessing = !_nonStandardCreation\n                && (_injectables == null)\n                && !_needViewProcesing\n                // also, may need to reorder stuff if we expect Object Id:\n                && (_objectIdReader == null)\n                ;\n    }\n\n    protected BeanDeserializerBase(BeanDeserializerBase src) {\n        this(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _beanProperties = src._beanProperties;\n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        _objectIdReader = src._objectIdReader;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        _vanillaProcessing = src._vanillaProcessing;\n    }\n \n    protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper)\n    {\n        super(src._beanType);\n\n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n\n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        _objectIdReader = src._objectIdReader;\n\n        _nonStandardCreation = src._nonStandardCreation;\n        UnwrappedPropertyHandler uph = src._unwrappedPropertyHandler;\n\n        if (unwrapper != null) {\n            // delegate further unwraps, if any\n            if (uph != null) { // got handler, delegate\n                uph = uph.renameAll(unwrapper);\n            }\n            // and handle direct unwrapping as well:\n            _beanProperties = src._beanProperties.renameAll(unwrapper);\n        } else {\n            _beanProperties = src._beanProperties;\n        }\n        _unwrappedPropertyHandler = uph;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        // probably adds a twist, so:\n        _vanillaProcessing = false;\n    }\n\n    public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        // then actual changes:\n        _objectIdReader = oir;\n\n        if (oir == null) {\n            _beanProperties = src._beanProperties;\n            _vanillaProcessing = src._vanillaProcessing;\n        } else {\n            /* 18-Nov-2012, tatu: May or may not have annotations for id property;\n             *   but no easy access. But hard to see id property being optional,\n             *   so let's consider required at this point.\n             */\n            ObjectIdValueProperty idProp = new ObjectIdValueProperty(oir, PropertyMetadata.STD_REQUIRED);\n            _beanProperties = src._beanProperties.withProperty(idProp);\n            _vanillaProcessing = false;\n        }\n    }\n\n    public BeanDeserializerBase(BeanDeserializerBase src, Set<String> ignorableProps)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _backRefs = src._backRefs;\n        _ignorableProps = ignorableProps;\n        _ignoreAllUnknown = src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        _vanillaProcessing = src._vanillaProcessing;\n        _objectIdReader = src._objectIdReader;\n\n        // 01-May-2016, tatu: [databind#1217]: Remove properties from mapping,\n        //    to avoid them being deserialized\n        _beanProperties = src._beanProperties.withoutProperties(ignorableProps);\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected BeanDeserializerBase(BeanDeserializerBase src, BeanPropertyMap beanProps)\n    {\n        super(src._beanType);\n        \n        _classAnnotations = src._classAnnotations;\n        _beanType = src._beanType;\n        \n        _valueInstantiator = src._valueInstantiator;\n        _delegateDeserializer = src._delegateDeserializer;\n        _propertyBasedCreator = src._propertyBasedCreator;\n        \n        _beanProperties = beanProps;\n        _backRefs = src._backRefs;\n        _ignorableProps = src._ignorableProps;\n        _ignoreAllUnknown = src._ignoreAllUnknown;\n        _anySetter = src._anySetter;\n        _injectables = src._injectables;\n        _objectIdReader = src._objectIdReader;\n        \n        _nonStandardCreation = src._nonStandardCreation;\n        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n        _needViewProcesing = src._needViewProcesing;\n        _serializationShape = src._serializationShape;\n\n        _vanillaProcessing = src._vanillaProcessing;\n    }\n    \n    @Override\n    public abstract JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper);\n\n    public abstract BeanDeserializerBase withObjectIdReader(ObjectIdReader oir);\n\n    public abstract BeanDeserializerBase withIgnorableProperties(Set<String> ignorableProps);\n\n    /**\n     * Mutant factory method that custom sub-classes must override; not left as\n     * abstract to prevent more drastic backwards compatibility problems.\n     *\n     * @since 2.8\n     */\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        throw new UnsupportedOperationException(\"Class \"+getClass().getName()\n                +\" does not override `withBeanProperties()`, needs to\");\n    }\n    \n    /**\n     * Fluent factory for creating a variant that can handle\n     * POJO output as a JSON Array. Implementations may ignore this request\n     * if no such input is possible.\n     * \n     * @since 2.1\n     */\n    protected abstract BeanDeserializerBase asArrayDeserializer();\n\n    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n\n    /**\n     * Method called to finalize setup of this deserializer,\n     * after deserializer itself has been registered.\n     * This is needed to handle recursive and transitive dependencies.\n     */\n    @Override\n    public void resolve(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        ExternalTypeHandler.Builder extTypes = null;\n        // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n        SettableBeanProperty[] creatorProps;\n\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n\n            // 21-Jun-2015, tatu: This resolution was duplicated later on and seems like\n            //    it really should be only done at a later point. So commented out in 2.8.\n            //   However, just in case there was a reason for it, leaving commented out\n            //   here instead of immediately removing.\n\n            /*\n            // also: need to try to resolve 'external' type ids...\n            for (SettableBeanProperty prop : creatorProps) {\n                if (prop.hasValueTypeDeserializer()) {\n                    TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                    if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                        if (extTypes == null) {\n                            extTypes = new ExternalTypeHandler.Builder();\n                        }\n                        extTypes.addExternal(prop, typeDeser);\n                    }\n                }\n            }\n            */\n        } else {\n            creatorProps = null;\n        }\n\n        UnwrappedPropertyHandler unwrapped = null;\n\n        for (SettableBeanProperty origProp : _beanProperties) {\n            SettableBeanProperty prop = origProp;\n\n            // May already have deserializer from annotations, if so, skip:\n            if (!prop.hasValueDeserializer()) {\n                // [databind#125]: allow use of converters\n                JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);\n                if (deser == null) {\n                    deser = findDeserializer(ctxt, prop.getType(), prop);\n                }\n                prop = prop.withValueDeserializer(deser);\n            } else { // may need contextual version\n                JsonDeserializer<Object> deser = prop.getValueDeserializer();\n                /* Important! This is the only place where actually handle \"primary\"\n                 * property deserializers -- call is different from other places.\n                 */\n                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,\n                        prop.getType());\n                if (cd != deser) {\n                    prop = prop.withValueDeserializer(cd);\n                }\n            }\n\n            // Need to link managed references with matching back references\n            prop = _resolveManagedReferenceProperty(ctxt, prop);\n\n            // [databind#351[: need to wrap properties that require object id resolution.\n            if (!(prop instanceof ManagedReferenceProperty)) {\n                prop = _resolvedObjectIdProperty(ctxt, prop);\n            }\n            // Support unwrapped values (via @JsonUnwrapped)\n            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n            if (u != null) {\n                prop = u;\n                if (unwrapped == null) {\n                    unwrapped = new UnwrappedPropertyHandler();\n                }\n                unwrapped.addProperty(prop);\n                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if\n                 *    the original property is left in place. So let's remove it now.\n                 */\n                _beanProperties.remove(prop);\n                continue;\n            }\n            // non-static inner classes too:\n            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n            if (prop != origProp) {\n                _beanProperties.replace(prop);\n                // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync\n                if (creatorProps != null) {\n                    // 18-May-2015, tatu: _Should_ start with consistent set. But can we really\n                    //   fully count on this? May need to revisit in future; seems to hold for now.\n                    for (int i = 0, len = creatorProps.length; i < len; ++i) {\n                        if (creatorProps[i] == origProp) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        // ... as per above, it is possible we'd need to add this as fallback\n                        // if (but only if) identity check fails?\n                        /*\n                        if (creatorProps[i].getName().equals(prop.getName())) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        */\n                    }\n                }\n            }\n            // one more thing: if this property uses \"external property\" type inclusion,\n            // it needs different handling altogether\n            if (prop.hasValueTypeDeserializer()) {\n                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                    if (extTypes == null) {\n                        extTypes = new ExternalTypeHandler.Builder();\n                    }\n                    extTypes.addExternal(prop, typeDeser);\n                    // In fact, remove from list of known properties to simplify later handling\n                    _beanProperties.remove(prop);\n                    continue;\n                }\n            }\n        }\n        // \"any setter\" may also need to be resolved now\n        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n                    _anySetter.getType(), _anySetter.getProperty()));\n        }\n        // as well as delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getDelegateCreator());\n        }\n\n        // and array-delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n            }\n            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getArrayDelegateCreator());\n        }\n\n        // And now that we know CreatorProperty instances are also resolved can finally create the creator:\n        if (creatorProps != null) {\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n\n        if (extTypes != null) {\n            // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,\n            //    so need to pass collected properties\n            _externalTypeIdHandler = extTypes.build(_beanProperties);\n            // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n        \n        _unwrappedPropertyHandler = unwrapped;\n        if (unwrapped != null) { // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n\n        // may need to disable vanilla processing, if unwrapped handling was enabled...\n        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n    }\n\n    private JsonDeserializer<Object> _findDelegateDeserializer(DeserializationContext ctxt, JavaType delegateType,\n            AnnotatedWithParams delegateCreator) throws JsonMappingException {\n        // Need to create a temporary property to allow contextual deserializers:\n        BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,\n                delegateType, null, _classAnnotations, delegateCreator,\n                PropertyMetadata.STD_OPTIONAL);\n\n        TypeDeserializer td = delegateType.getTypeHandler();\n        if (td == null) {\n            td = ctxt.getConfig().findTypeDeserializer(delegateType);\n        }\n        JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);\n        if (td != null) {\n            td = td.forProperty(property);\n            return new TypeWrappedDeserializer(td, dd);\n        }\n        return dd;\n    }\n\n\n    /**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */\n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n        throws JsonMappingException\n    {\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object convDef = intr.findDeserializationConverter(prop.getMember());\n            if (convDef != null) {\n                Converter<Object,Object> conv = ctxt.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n                JsonDeserializer<?> ser = ctxt.findContextualValueDeserializer(delegateType, prop);\n                return new StdDelegatingDeserializer<Object>(conv, delegateType, ser);\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Although most of post-processing is done in resolve(), we only get\n     * access to referring property's annotations here; and this is needed\n     * to support per-property ObjectIds.\n     * We will also consider Shape transformations (read from Array) at this\n     * point, since it may come from either Class definition or property.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        ObjectIdReader oir = _objectIdReader;\n        \n        // First: may have an override for Object Id:\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        if (accessor != null && intr != null) {\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                \n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                // Property-based generator is trickier\n                JavaType idType;\n                SettableBeanProperty idProp;\n                ObjectIdGenerator<?> idGen;\n                ObjectIdResolver resolver = ctxt.objectIdResolverInstance(accessor, objectIdInfo);\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                    PropertyName propName = objectIdInfo.getPropertyName();\n                    idProp = findProperty(propName);\n                    if (idProp == null) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                                +handledType().getName()+\": can not find property with name '\"+propName+\"'\");\n                    }\n                    idType = idProp.getType();\n                    idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n                } else { // other types need to be simpler\n                    JavaType type = ctxt.constructType(implClass);\n                    idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                    idProp = null;\n                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n                }\n                JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n                \t\tidGen, deser, idProp, resolver);\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanDeserializerBase contextual = this;\n        if (oir != null && oir != _objectIdReader) {\n            contextual = contextual.withObjectIdReader(oir);\n        }\n        // And possibly add more properties to ignore\n        if (accessor != null) {\n            JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(accessor);\n            if (ignorals != null) {\n                Set<String> ignored = ignorals.findIgnoredForDeserialization();\n                if (!ignored.isEmpty()) {\n                    Set<String> prev = contextual._ignorableProps;\n                    if ((prev != null) && !prev.isEmpty()) {\n                        ignored = new HashSet<String>(ignored);\n                        ignored.addAll(prev);\n                    }\n                    contextual = contextual.withIgnorableProperties(ignored);\n                }\n            }\n        }\n\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, handledType());\n        JsonFormat.Shape shape = null;\n        if (format != null) {\n            if (format.hasShape()) {\n                shape = format.getShape();\n            }\n            // 16-May-2016, tatu: How about per-property case-insensitivity?\n            Boolean B = format.getFeature(JsonFormat.Feature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n            if (B != null) {\n                // !!! TODO\n                BeanPropertyMap propsOrig = _beanProperties;\n                BeanPropertyMap props = propsOrig.withCaseInsensitivity(B.booleanValue());\n                if (props != propsOrig) {\n                    contextual = contextual.withBeanProperties(props);\n                }\n            }\n        }\n\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArrayDeserializer();\n        }\n        return contextual;\n    }\n\n    /**\n     * Helper method called to see if given property is part of 'managed' property\n     * pair (managed + back reference), and if so, handle resolution details.\n     */\n    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n    {\n        String refName = prop.getManagedReferenceName();\n        if (refName == null) {\n            return prop;\n        }\n        JsonDeserializer<?> valueDeser = prop.getValueDeserializer();\n        SettableBeanProperty backProp = valueDeser.findBackReference(refName);\n        if (backProp == null) {\n            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': no back reference property found from type \"\n                    +prop.getType());\n        }\n        // also: verify that type is compatible\n        JavaType referredType = _beanType;\n        JavaType backRefType = backProp.getType();\n        boolean isContainer = prop.getType().isContainerType();\n        if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) {\n            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': back reference type (\"\n                    +backRefType.getRawClass().getName()+\") not compatible with managed type (\"\n                    +referredType.getRawClass().getName()+\")\");\n        }\n        return new ManagedReferenceProperty(prop, refName, backProp,\n                _classAnnotations, isContainer);\n    }\n\n    /**\n     * Method that wraps given property with {@link ObjectIdReferenceProperty}\n     * in case where object id resolution is required.\n     */\n    protected SettableBeanProperty _resolvedObjectIdProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop) throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = prop.getObjectIdInfo();\n        JsonDeserializer<Object> valueDeser = prop.getValueDeserializer();\n        ObjectIdReader objectIdReader = valueDeser.getObjectIdReader();\n        if (objectIdInfo == null && objectIdReader == null) {\n            return prop;\n        }\n        return new ObjectIdReferenceProperty(prop, objectIdInfo);\n    }\n\n    /**\n     * Helper method called to see if given property might be so-called unwrapped\n     * property: these require special handling.\n     */\n    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n    {\n        AnnotatedMember am = prop.getMember();\n        if (am != null) {\n            NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am);\n            if (unwrapper != null) {\n                JsonDeserializer<Object> orig = prop.getValueDeserializer();\n                JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper);\n                if (unwrapping != orig && unwrapping != null) {\n                    // might be cleaner to create new instance; but difficult to do reliably, so:\n                    return prop.withValueDeserializer(unwrapping);\n                }\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Helper method that will handle gruesome details of dealing with properties\n     * that have non-static inner class as value...\n     */\n    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt,\n            SettableBeanProperty prop)\n    {            \n        /* Should we encounter a property that has non-static inner-class\n         * as value, we need to add some more magic to find the \"hidden\" constructor...\n         */\n        JsonDeserializer<Object> deser = prop.getValueDeserializer();\n        // ideally wouldn't rely on it being BeanDeserializerBase; but for now it'll have to do\n        if (deser instanceof BeanDeserializerBase) {\n            BeanDeserializerBase bd = (BeanDeserializerBase) deser;\n            ValueInstantiator vi = bd.getValueInstantiator();\n            if (!vi.canCreateUsingDefault()) { // no default constructor\n                Class<?> valueClass = prop.getType().getRawClass();\n                Class<?> enclosing = ClassUtil.getOuterClass(valueClass);\n                // and is inner class of the bean class...\n                if (enclosing != null && enclosing == _beanType.getRawClass()) {\n                    for (Constructor<?> ctor : valueClass.getConstructors()) {\n                        Class<?>[] paramTypes = ctor.getParameterTypes();\n                        if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n                            if (ctxt.canOverrideAccessModifiers()) {\n                                ClassUtil.checkAndFixAccess(ctor, ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                            }\n                            return new InnerClassProperty(prop, ctor);\n                        }\n                    }\n                }\n            }\n        }\n        return prop;\n    }\n\n    /*\n    /**********************************************************\n    /* Public accessors\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isCachable() { return true; }\n\n    @Override\n    public Class<?> handledType() {\n        return _beanType.getRawClass();\n    }\n    \n    /**\n     * Overridden to return true for those instances that are\n     * handling value for which Object Identity handling is enabled\n     * (either via value type or referring property).\n     */\n    @Override\n    public ObjectIdReader getObjectIdReader() {\n        return _objectIdReader;\n    }\n    \n    public boolean hasProperty(String propertyName) {\n        return _beanProperties.find(propertyName) != null;\n    }\n\n    public boolean hasViews() {\n        return _needViewProcesing;\n    }\n    \n    /**\n     * Accessor for checking number of deserialized properties.\n     */\n    public int getPropertyCount() { \n        return _beanProperties.size();\n    }\n\n    @Override\n    public Collection<Object> getKnownPropertyNames() {\n        ArrayList<Object> names = new ArrayList<Object>();\n        for (SettableBeanProperty prop : _beanProperties) {\n            names.add(prop.getName());\n        }\n        return names;\n    }\n\n    /**\n     * @deprecated Since 2.3, use {@link #handledType()} instead\n     */\n    @Deprecated\n    public final Class<?> getBeanClass() { return _beanType.getRawClass(); }\n\n    @Override\n    public JavaType getValueType() { return _beanType; }\n\n    /**\n     * Accessor for iterating over properties this deserializer uses; with\n     * the exception that properties passed via Creator methods\n     * (specifically, \"property-based constructor\") are not included,\n     * but can be accessed separate by calling\n     * {@link #creatorProperties}\n     */\n    public Iterator<SettableBeanProperty> properties()\n    {\n        if (_beanProperties == null) {\n            throw new IllegalStateException(\"Can only call after BeanDeserializer has been resolved\");\n        }\n        return _beanProperties.iterator();\n    }\n\n    /**\n     * Accessor for finding properties that represents values to pass\n     * through property-based creator method (constructor or\n     * factory method)\n     * \n     * @since 2.0\n     */\n    public Iterator<SettableBeanProperty> creatorProperties()\n    {\n        if (_propertyBasedCreator == null) {\n            return Collections.<SettableBeanProperty>emptyList().iterator();\n        }\n        return _propertyBasedCreator.properties().iterator();\n    }\n\n    public SettableBeanProperty findProperty(PropertyName propertyName)\n    {\n        // TODO: start matching full name?\n        return findProperty(propertyName.getSimpleName());\n    }\n    \n    /**\n     * Accessor for finding the property with given name, if POJO\n     * has one. Name used is the external name, i.e. name used\n     * in external data representation (JSON).\n     * \n     * @since 2.0\n     */\n    public SettableBeanProperty findProperty(String propertyName)\n    {\n        SettableBeanProperty prop = (_beanProperties == null) ?\n                null : _beanProperties.find(propertyName);\n        if (prop == null && _propertyBasedCreator != null) {\n            prop = _propertyBasedCreator.findCreatorProperty(propertyName);\n        }\n        return prop;\n    }\n\n    /**\n     * Alternate find method that tries to locate a property with given\n     * <code>property index</code>.\n     * Note that access by index is not necessarily faster than by name,\n     * since properties are not directly indexable; however, for most\n     * instances difference is not significant as number of properties\n     * is low.\n     * \n     * @since 2.3\n     */\n    public SettableBeanProperty findProperty(int propertyIndex)\n    {\n        SettableBeanProperty prop = (_beanProperties == null) ?\n                null : _beanProperties.find(propertyIndex);\n        if (prop == null && _propertyBasedCreator != null) {\n            prop = _propertyBasedCreator.findCreatorProperty(propertyIndex);\n        }\n        return prop;\n    }\n    \n    /**\n     * Method needed by {@link BeanDeserializerFactory} to properly link\n     * managed- and back-reference pairs.\n     */\n    @Override\n    public SettableBeanProperty findBackReference(String logicalName)\n    {\n        if (_backRefs == null) {\n            return null;\n        }\n        return _backRefs.get(logicalName);\n    }\n\n    public ValueInstantiator getValueInstantiator() {\n        return _valueInstantiator;\n    }\n\n    /*\n    /**********************************************************\n    /* Mutators\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to replace an existing property with\n     * a modified one.\n     *<p>\n     * NOTE: only ever use this method if you know what you are doing;\n     * incorrect usage can break deserializer.\n     *\n     * @param original Property to replace\n     * @param replacement Property to replace it with\n     * \n     * @since 2.1\n     */\n    public void replaceProperty(SettableBeanProperty original,\n            SettableBeanProperty replacement)\n    {\n        _beanProperties.replace(replacement);\n    }\n\n    /*\n    /**********************************************************\n    /* Partial deserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * General version used when handling needs more advanced\n     * features.\n     */\n    public abstract Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n        if (_objectIdReader != null) {\n            // 05-Aug-2013, tatu: May use native Object Id\n            if (p.canReadObjectId()) {\n                Object id = p.getObjectId();\n                if (id != null) {\n                    Object ob = typeDeserializer.deserializeTypedFromObject(p, ctxt);\n                    return _handleTypedObjectId(p, ctxt, ob, id);\n                }\n            }\n            // or, Object Ids Jackson explicitly sets\n            JsonToken t = p.getCurrentToken();\n            if (t != null) {\n                // Most commonly, a scalar (int id, uuid String, ...)\n                if (t.isScalarValue()) {\n                    return deserializeFromObjectId(p, ctxt);\n                }\n                // but, with 2.5+, a simple Object-wrapped value also legal:\n                if (t == JsonToken.START_OBJECT) {\n                    t = p.nextToken();\n                }\n                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()\n                        && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                    return deserializeFromObjectId(p, ctxt);\n                }\n            }\n        }\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromObject(p, ctxt);\n    }\n\n    /**\n     * Offlined method called to handle \"native\" Object Id that has been read\n     * and known to be associated with given deserialized POJO.\n     *\n     * @since 2.3\n     */\n    protected Object _handleTypedObjectId(JsonParser p, DeserializationContext ctxt,\n            Object pojo, Object rawId)\n        throws IOException\n    {\n        // One more challenge: type of id may not be type of property we are expecting\n        // later on; specifically, numeric ids vs Strings.\n        JsonDeserializer<Object> idDeser = _objectIdReader.getDeserializer();\n        final Object id;\n\n        // Ok, this is bit ridiculous; let's see if conversion is needed:\n        if (idDeser.handledType() == rawId.getClass()) {\n            // nope: already same type\n            id = rawId;\n        } else {\n            id = _convertObjectId(p, ctxt, rawId, idDeser);\n        }\n\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        roid.bindItem(pojo);\n        // also: may need to set a property value as well\n        SettableBeanProperty idProp = _objectIdReader.idProperty;\n        if (idProp != null) {\n            return idProp.setAndReturn(pojo, id);\n        }\n        return pojo;\n    }\n\n    /**\n     * Helper method we need to do necessary conversion from whatever native object id\n     * type is, into declared type that Jackson internals expect. This may be\n     * simple cast (for String ids), or something more complicated; in latter\n     * case we may need to create bogus content buffer to allow use of\n     * id deserializer.\n     *\n     * @since 2.3\n     */\n    @SuppressWarnings(\"resource\") // TokenBuffers don't need close, nor parser thereof\n    protected Object _convertObjectId(JsonParser p, DeserializationContext ctxt,\n            Object rawId, JsonDeserializer<Object> idDeser) throws IOException\n    {\n        TokenBuffer buf = new TokenBuffer(p, ctxt);\n        if (rawId instanceof String) {\n            buf.writeString((String) rawId);\n        } else if (rawId instanceof Long) {\n            buf.writeNumber(((Long) rawId).longValue());\n        } else if (rawId instanceof Integer) {\n            buf.writeNumber(((Integer) rawId).intValue());\n        } else {\n            // should we worry about UUIDs? They should be fine, right?\n            // 07-Aug-2014, tatu: Maybe, but not necessarily; had issues with\n            //   Smile format; [Smile#19], possibly related.\n            buf.writeObject(rawId);\n        }\n        JsonParser bufParser = buf.asParser();\n        bufParser.nextToken();\n        return idDeser.deserialize(bufParser, ctxt);\n    }\n\n    // NOTE: currently only used by standard BeanDeserializer (not Builder-based)\n    /**\n     * Alternative deserialization method used when we expect to see Object Id;\n     * if so, we will need to ensure that the Id is seen before anything\n     * else, to ensure that it is available for solving references,\n     * even if JSON itself is not ordered that way. This may require\n     * buffering in some cases, but usually just a simple lookup to ensure\n     * that ordering is correct.\n     */\n    protected Object deserializeWithObjectId(JsonParser p, DeserializationContext ctxt) throws IOException {\n        return deserializeFromObject(p, ctxt);\n    }\n\n    /**\n     * Method called in cases where it looks like we got an Object Id\n     * to parse and use as a reference.\n     */\n    protected Object deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        Object id = _objectIdReader.readObjectReference(p, ctxt);\n        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n        // do we have it resolved?\n        Object pojo = roid.resolve();\n        if (pojo == null) { // not yet; should wait...\n            throw new UnresolvedForwardReference(p,\n                    \"Could not resolve Object Id [\"+id+\"] (for \"+_beanType+\").\",\n                    p.getCurrentLocation(), roid);\n        }\n        return pojo;\n    }\n\n    protected Object deserializeFromObjectUsingNonDefault(JsonParser p,\n            DeserializationContext ctxt) throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingPropertyBased(p, ctxt);\n        }\n        // should only occur for abstract types...\n        if (_beanType.isAbstract()) {\n            return ctxt.handleMissingInstantiator(handledType(), p,\n                    \"abstract type (need to add/enable type information?)\");\n        }\n        return ctxt.handleMissingInstantiator(_beanType.getRawClass(), p,\n                \"no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\");\n    }\n\n    protected abstract Object _deserializeUsingPropertyBased(final JsonParser p,\n            final DeserializationContext ctxt)\n        throws IOException, JsonProcessingException;\n\n    @SuppressWarnings(\"incomplete-switch\")\n    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // First things first: id Object Id is used, most likely that's it\n        if (_objectIdReader != null) {\n            return deserializeFromObjectId(p, ctxt);\n        }\n\n        switch (p.getNumberType()) {\n        case INT:\n            if (_delegateDeserializer != null) {\n                if (!_valueInstantiator.canCreateFromInt()) {\n                    Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n                            _delegateDeserializer.deserialize(p, ctxt));\n                    if (_injectables != null) {\n                        injectValues(ctxt, bean);\n                    }\n                    return bean;\n                }\n            }\n            return _valueInstantiator.createFromInt(ctxt, p.getIntValue());\n        case LONG:\n            if (_delegateDeserializer != null) {\n                if (!_valueInstantiator.canCreateFromInt()) {\n                    Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n                            _delegateDeserializer.deserialize(p, ctxt));\n                    if (_injectables != null) {\n                        injectValues(ctxt, bean);\n                    }\n                    return bean;\n                }\n            }\n            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());\n        }\n        // actually, could also be BigInteger, so:\n        if (_delegateDeserializer != null) {\n            Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            return bean;\n        }\n        return ctxt.handleMissingInstantiator(handledType(), p,\n                \"no suitable creator method found to deserialize from Number value (%s)\",\n                p.getNumberValue());\n    }\n\n    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // First things first: id Object Id is used, most likely that's it\n        if (_objectIdReader != null) {\n            return deserializeFromObjectId(p, ctxt);\n        }\n        \n        /* Bit complicated if we have delegating creator; may need to use it,\n         * or might not...\n         */\n        if (_delegateDeserializer != null) {\n            if (!_valueInstantiator.canCreateFromString()) {\n                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            }\n        }\n        return _valueInstantiator.createFromString(ctxt, p.getText());\n    }\n\n    /**\n     * Method called to deserialize POJO value from a JSON floating-point\n     * number.\n     */\n    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        NumberType t = p.getNumberType();\n        // no separate methods for taking float...\n        if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {\n            if (_delegateDeserializer != null) {\n                if (!_valueInstantiator.canCreateFromDouble()) {\n                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                    if (_injectables != null) {\n                        injectValues(ctxt, bean);\n                    }\n                    return bean;\n                }\n            }\n            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n        }\n        // actually, could also be BigDecimal, so:\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        return ctxt.handleMissingInstantiator(handledType(), p,\n                \"no suitable creator method found to deserialize from Number value (%s)\",\n                p.getNumberValue());\n    }\n\n    /**\n     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n     */\n    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            if (!_valueInstantiator.canCreateFromBoolean()) {\n                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            }\n        }\n        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);\n        return _valueInstantiator.createFromBoolean(ctxt, value);\n    }\n\n    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (_arrayDelegateDeserializer != null) {\n            try {\n                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            } catch (Exception e) {\n                return wrapInstantiationProblem(e, ctxt);\n            }\n        }\n        // fallback to non-array delegate\n        if (_delegateDeserializer != null) {\n            try {\n                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                if (_injectables != null) {\n                    injectValues(ctxt, bean);\n                }\n                return bean;\n            } catch (Exception e) {\n                wrapInstantiationProblem(e, ctxt);\n                return null;\n            }\n        }\n        if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            JsonToken t = p.nextToken();\n            if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                return null;\n            }\n            final Object value = deserialize(p, ctxt);\n            if (p.nextToken() != JsonToken.END_ARRAY) {\n                handleMissingEndArrayForSingle(p, ctxt);\n            }\n            return value;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n            JsonToken t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                return null;\n            }\n            return ctxt.handleUnexpectedToken(handledType(),\n                    JsonToken.START_ARRAY, p, null);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // First things first: id Object Id is used, most likely that's it; specifically,\n        // true for UUIDs when written as binary (with Smile, other binary formats)\n        if (_objectIdReader != null) {\n            return deserializeFromObjectId(p, ctxt);\n        }\n\n        // TODO: maybe add support for ValueInstantiator, embedded?\n        \n        return p.getEmbeddedObject();\n    }\n\n    /*\n    /**********************************************************\n    /* Overridable helper methods\n    /**********************************************************\n     */\n\n    protected void injectValues(DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (ValueInjector injector : _injectables) {\n            injector.inject(ctxt, bean);\n        }\n    }\n    \n    /**\n     * Method called to handle set of one or more unknown properties,\n     * stored in their entirety in given {@link TokenBuffer}\n     * (as field entries, name and value).\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object handleUnknownProperties(DeserializationContext ctxt,\n            Object bean, TokenBuffer unknownTokens)\n        throws IOException\n    {\n        // First: add closing END_OBJECT as marker\n        unknownTokens.writeEndObject();\n\n        // note: buffer does NOT have starting START_OBJECT\n        JsonParser bufferParser = unknownTokens.asParser();\n        while (bufferParser.nextToken() != JsonToken.END_OBJECT) {\n            String propName = bufferParser.getCurrentName();\n            // Unknown: let's call handler method\n            bufferParser.nextToken();\n            handleUnknownProperty(bufferParser, ctxt, bean, propName);\n        }\n        return bean;\n    }\n\n    /**\n     * Helper method called for an unknown property, when using \"vanilla\"\n     * processing.\n     */\n    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,\n            Object bean, String propName)\n        throws IOException\n    {\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, bean, propName);\n        } else if (_anySetter != null) {\n            try {\n               // should we consider return type of any setter?\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        } else {\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);         \n        }\n    }\n\n    /**\n     * Method called when a JSON property is encountered that has not matching\n     * setter, any-setter or field, and thus can not be assigned.\n     */\n    @Override\n    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,\n            Object beanOrClass, String propName)\n        throws IOException\n    {\n        if (_ignoreAllUnknown) {\n            p.skipChildren();\n            return;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, beanOrClass, propName);\n        }\n        // Otherwise use default handling (call handler(s); if not\n        // handled, throw exception or skip depending on settings)\n        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);\n    }\n\n    /**\n     * Method called when an explicitly ignored property (one specified with a\n     * name to match, either by property annotation or class annotation) is encountered.\n     * \n     * @since 2.3\n     */\n    protected void handleIgnoredProperty(JsonParser p, DeserializationContext ctxt,\n            Object beanOrClass, String propName)\n        throws IOException\n    {\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)) {\n            throw IgnoredPropertyException.from(p, beanOrClass, propName, getKnownPropertyNames());\n        }\n        p.skipChildren();\n    }\n    \n    /**\n     * Method called in cases where we may have polymorphic deserialization\n     * case: that is, type of Creator-constructed bean is not the type\n     * of deserializer itself. It should be a sub-class or implementation\n     * class; either way, we may have more specific deserializer to use\n     * for handling it.\n     *\n     * @param p (optional) If not null, parser that has more properties to handle\n     *   (in addition to buffered properties); if null, all properties are passed\n     *   in buffer\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object handlePolymorphic(JsonParser p, DeserializationContext ctxt,                                          \n            Object bean, TokenBuffer unknownTokens)\n        throws IOException\n    {  \n        // First things first: maybe there is a more specific deserializer available?\n        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n        if (subDeser != null) {\n            if (unknownTokens != null) {\n                // need to add END_OBJECT marker first\n                unknownTokens.writeEndObject();\n                JsonParser p2 = unknownTokens.asParser();\n                p2.nextToken(); // to get to first data field\n                bean = subDeser.deserialize(p2, ctxt, bean);\n            }\n            // Original parser may also have some leftovers\n            if (p != null) {\n                bean = subDeser.deserialize(p, ctxt, bean);\n            }\n            return bean;\n        }\n        // nope; need to use this deserializer. Unknowns we've seen so far?\n        if (unknownTokens != null) {\n            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n        }\n        // and/or things left to process via main parser?\n        if (p != null) {\n            bean = deserialize(p, ctxt, bean);\n        }\n        return bean;\n    }\n    \n    /**\n     * Helper method called to (try to) locate deserializer for given sub-type of\n     * type that this deserializer handles.\n     */\n    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt,\n            Object bean, TokenBuffer unknownTokens)\n        throws IOException\n    {  \n        JsonDeserializer<Object> subDeser;\n\n        // First: maybe we have already created sub-type deserializer?\n        synchronized (this) {\n            subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass()));\n        }\n        if (subDeser != null) {\n            return subDeser;\n        }\n        // If not, maybe we can locate one. First, need provider\n        JavaType type = ctxt.constructType(bean.getClass());\n        /* 30-Jan-2012, tatu: Ideally we would be passing referring\n         *   property; which in theory we could keep track of via\n         *   ResolvableDeserializer (if we absolutely must...).\n         *   But for now, let's not bother.\n         */\n//        subDeser = ctxt.findValueDeserializer(type, _property);\n        subDeser = ctxt.findRootValueDeserializer(type);\n        // Also, need to cache it\n        if (subDeser != null) {\n            synchronized (this) {\n                if (_subDeserializers == null) {\n                    _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n                }\n                _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n            }            \n        }\n        return subDeser;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for error reporting\n    /**********************************************************\n     */\n\n    /**\n     * Method that will modify caught exception (passed in as argument)\n     * as necessary to include reference information, and to ensure it\n     * is a subtype of {@link IOException}, or an unchecked exception.\n     *<p>\n     * Rules for wrapping and unwrapping are bit complicated; essentially:\n     *<ul>\n     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n     * <li>\"Plain\" IOExceptions (ones that are not of type\n     *   {@link JsonMappingException} are to be passed as is\n     *</ul>\n     */\n    public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)\n        throws IOException\n    {\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, fieldName);\n    }\n\n    @Deprecated // since 2.4, not used by core Jackson; only relevant for arrays/Collections\n    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt) throws IOException {\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, index);\n    }\n\n    private Throwable throwOrReturnThrowable(Throwable t, DeserializationContext ctxt) \n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   often gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap JSON exceptions\n        if (t instanceof IOException) {\n            if (!wrap || !(t instanceof JsonProcessingException)) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        return t;\n    }\n\n    protected Object wrapInstantiationProblem(Throwable t, DeserializationContext ctxt)\n        throws IOException\n    {\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        if (t instanceof IOException) {\n            // Since we have no more information to add, let's not actually wrap..\n            throw (IOException) t;\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        return ctxt.handleInstantiationProblem(_beanType.getRawClass(), null, t);\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler", "buggy_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n\n    protected ExternalTypeHandler(ExtTypedProperty[] properties,\n            HashMap<String, Integer> nameToPropertyIndex,\n            String[] typeIds, TokenBuffer[] tokens)\n    {\n        _properties = properties;\n        _nameToPropertyIndex = nameToPropertyIndex;\n        _typeIds = typeIds;\n        _tokens = tokens;\n    }\n\n    protected ExternalTypeHandler(ExternalTypeHandler h)\n    {\n        _properties = h._properties;\n        _nameToPropertyIndex = h._nameToPropertyIndex;\n        int len = _properties.length;\n        _typeIds = new String[len];\n        _tokens = new TokenBuffer[len];\n    }\n\n    /**\n     * Method called to start collection process by creating non-blueprint\n     * instances.\n     */\n    public ExternalTypeHandler start() {\n        return new ExternalTypeHandler(this);\n    }\n\n    /**\n     * Method called to see if given property/value pair is an external type\n     * id; and if so handle it. This is <b>only</b> to be called in case\n     * containing POJO has similarly named property as the external type id;\n     * otherwise {@link #handlePropertyValue} should be called instead.\n     */\n    public boolean handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean)\n        throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        if (!prop.hasTypePropertyName(propName)) {\n            return false;\n        }\n        String typeId = p.getText();\n        // note: can NOT skip child values (should always be String anyway)\n        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n        // Minor optimization: deserialize properties as soon as we have all we need:\n        if (canDeserialize) {\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            // clear stored data, to avoid deserializing+setting twice:\n            _tokens[index] = null;\n        } else {\n            _typeIds[index] = typeId;\n        }\n        return true;\n    }\n\n    /**\n     * Method called to ask handler to handle value of given property,\n     * at point where parser points to the first token of the value.\n     * Handling can mean either resolving type id it contains (if it matches type\n     * property name), or by buffering the value for further use.\n     * \n     * @return True, if the given property was properly handled\n     */\n    public boolean handlePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean) throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        boolean canDeserialize;\n        if (prop.hasTypePropertyName(propName)) {\n            _typeIds[index] = p.getText();\n            p.skipChildren();\n            canDeserialize = (bean != null) && (_tokens[index] != null);\n        } else {\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tokens = new TokenBuffer(p, ctxt);\n            tokens.copyCurrentStructure(p);\n            _tokens[index] = tokens;\n            canDeserialize = (bean != null) && (_typeIds[index] != null);\n        }\n        /* Minor optimization: let's deserialize properties as soon as\n         * we have all pertinent information:\n         */\n        if (canDeserialize) {\n            String typeId = _typeIds[index];\n            // clear stored data, to avoid deserializing+setting twice:\n            _typeIds[index] = null;\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            _tokens[index] = null;\n        }\n        return true;\n    }\n\n    /**\n     * Method called after JSON Object closes, and has to ensure that all external\n     * type ids have been handled.\n     */\n    @SuppressWarnings(\"resource\")\n    public Object complete(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (int i = 0, len = _properties.length; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                TokenBuffer tokens = _tokens[i];\n                // let's allow missing both type and property (may already have been set, too)\n                // but not just one\n                if (tokens == null) {\n                    continue;\n                }\n                // [databind#118]: Need to mind natural types, for which no type id\n                // will be included.\n                JsonToken t = tokens.firstToken();\n                if (t != null && t.isScalarValue()) {\n                    JsonParser buffered = tokens.asParser(p);\n                    buffered.nextToken();\n                    SettableBeanProperty extProp = _properties[i].getProperty();\n                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n                    if (result != null) {\n                        extProp.set(bean, result);\n                        continue;\n                    }\n                    // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                    if (!_properties[i].hasDefaultType()) {\n                        ctxt.reportMappingException(\"Missing external type id property '%s'\",\n                                _properties[i].getTypePropertyName());                                \n                    } else  {\n                        typeId = _properties[i].getDefaultTypeId();\n                    }\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n                ctxt.reportMappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            _deserializeAndSet(p, ctxt, bean, i, typeId);\n        }\n        return bean;\n    }\n\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportMappingException(\"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportMappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        return _properties[index].getProperty().deserialize(mp, ctxt);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, int index, String typeId) throws IOException\n    {\n        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n         * style to ensure we can handle all kinds of JSON constructs.\n         */\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            _properties[index].getProperty().set(bean, null);\n            return;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n    \n    public static class Builder\n    {\n        private final ArrayList<ExtTypedProperty> _properties = new ArrayList<ExtTypedProperty>();\n        private final HashMap<String, Integer> _nameToPropertyIndex = new HashMap<String, Integer>();\n\n        public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            Integer index = _properties.size();\n            _properties.add(new ExtTypedProperty(property, typeDeser));\n            _nameToPropertyIndex.put(property.getName(), index);\n            _nameToPropertyIndex.put(typeDeser.getPropertyName(), index);\n        }\n\n        /**\n         * Method called after all external properties have been assigned, to further\n         * link property with polymorphic value with possible property for type id\n         * itself. This is needed to support type ids as Creator properties.\n         *\n         * @since 2.8\n         */\n            // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also\n\n        @Deprecated // since 2.8; may be removed as early as 2.9\n        public ExternalTypeHandler build() {\n            return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]),\n                    _nameToPropertyIndex, null, null);\n        }\n    }\n\n    private final static class ExtTypedProperty\n    {\n        private final SettableBeanProperty _property;\n        private final TypeDeserializer _typeDeserializer;\n        private final String _typePropertyName;\n\n        /**\n         * @since 2.8\n         */\n        private SettableBeanProperty _typeProperty;\n\n        public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            _property = property;\n            _typeDeserializer = typeDeser;\n            _typePropertyName = typeDeser.getPropertyName();\n        }\n\n        /**\n         * @since 2.8\n         */\n        public void linkTypeProperty(SettableBeanProperty p) {\n            _typeProperty = p;\n        }\n\n        public boolean hasTypePropertyName(String n) {\n            return n.equals(_typePropertyName);\n        }\n\n        public boolean hasDefaultType() {\n            return _typeDeserializer.getDefaultImpl() != null;\n        }\n\n        /**\n         * Specialized called when we need to expose type id of `defaultImpl` when\n         * serializing: we may need to expose it for assignment to a property, or\n         * it may be requested as visible for some other reason.\n         */\n        public String getDefaultTypeId() {\n            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n            if (defaultType == null) {\n                return null;\n            }\n            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n        }\n\n        public String getTypePropertyName() { return _typePropertyName; }\n\n        public SettableBeanProperty getProperty() {\n            return _property;\n        }\n\n        /**\n         * @since 2.8\n         */\n        public SettableBeanProperty getTypeProperty() {\n            return _typeProperty;\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.deser.impl;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n\n    protected ExternalTypeHandler(ExtTypedProperty[] properties,\n            HashMap<String, Integer> nameToPropertyIndex,\n            String[] typeIds, TokenBuffer[] tokens)\n    {\n        _properties = properties;\n        _nameToPropertyIndex = nameToPropertyIndex;\n        _typeIds = typeIds;\n        _tokens = tokens;\n    }\n\n    protected ExternalTypeHandler(ExternalTypeHandler h)\n    {\n        _properties = h._properties;\n        _nameToPropertyIndex = h._nameToPropertyIndex;\n        int len = _properties.length;\n        _typeIds = new String[len];\n        _tokens = new TokenBuffer[len];\n    }\n\n    /**\n     * Method called to start collection process by creating non-blueprint\n     * instances.\n     */\n    public ExternalTypeHandler start() {\n        return new ExternalTypeHandler(this);\n    }\n\n    /**\n     * Method called to see if given property/value pair is an external type\n     * id; and if so handle it. This is <b>only</b> to be called in case\n     * containing POJO has similarly named property as the external type id;\n     * otherwise {@link #handlePropertyValue} should be called instead.\n     */\n    public boolean handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean)\n        throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        if (!prop.hasTypePropertyName(propName)) {\n            return false;\n        }\n        String typeId = p.getText();\n        // note: can NOT skip child values (should always be String anyway)\n        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n        // Minor optimization: deserialize properties as soon as we have all we need:\n        if (canDeserialize) {\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            // clear stored data, to avoid deserializing+setting twice:\n            _tokens[index] = null;\n        } else {\n            _typeIds[index] = typeId;\n        }\n        return true;\n    }\n\n    /**\n     * Method called to ask handler to handle value of given property,\n     * at point where parser points to the first token of the value.\n     * Handling can mean either resolving type id it contains (if it matches type\n     * property name), or by buffering the value for further use.\n     * \n     * @return True, if the given property was properly handled\n     */\n    public boolean handlePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean) throws IOException\n    {\n        Integer I = _nameToPropertyIndex.get(propName);\n        if (I == null) {\n            return false;\n        }\n        int index = I.intValue();\n        ExtTypedProperty prop = _properties[index];\n        boolean canDeserialize;\n        if (prop.hasTypePropertyName(propName)) {\n            _typeIds[index] = p.getText();\n            p.skipChildren();\n            canDeserialize = (bean != null) && (_tokens[index] != null);\n        } else {\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tokens = new TokenBuffer(p, ctxt);\n            tokens.copyCurrentStructure(p);\n            _tokens[index] = tokens;\n            canDeserialize = (bean != null) && (_typeIds[index] != null);\n        }\n        /* Minor optimization: let's deserialize properties as soon as\n         * we have all pertinent information:\n         */\n        if (canDeserialize) {\n            String typeId = _typeIds[index];\n            // clear stored data, to avoid deserializing+setting twice:\n            _typeIds[index] = null;\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            _tokens[index] = null;\n        }\n        return true;\n    }\n\n    /**\n     * Method called after JSON Object closes, and has to ensure that all external\n     * type ids have been handled.\n     */\n    @SuppressWarnings(\"resource\")\n    public Object complete(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (int i = 0, len = _properties.length; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                TokenBuffer tokens = _tokens[i];\n                // let's allow missing both type and property (may already have been set, too)\n                // but not just one\n                if (tokens == null) {\n                    continue;\n                }\n                // [databind#118]: Need to mind natural types, for which no type id\n                // will be included.\n                JsonToken t = tokens.firstToken();\n                if (t != null && t.isScalarValue()) {\n                    JsonParser buffered = tokens.asParser(p);\n                    buffered.nextToken();\n                    SettableBeanProperty extProp = _properties[i].getProperty();\n                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n                    if (result != null) {\n                        extProp.set(bean, result);\n                        continue;\n                    }\n                    // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                    if (!_properties[i].hasDefaultType()) {\n                        ctxt.reportMappingException(\"Missing external type id property '%s'\",\n                                _properties[i].getTypePropertyName());                                \n                    } else  {\n                        typeId = _properties[i].getDefaultTypeId();\n                    }\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n                ctxt.reportMappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            _deserializeAndSet(p, ctxt, bean, i, typeId);\n        }\n        return bean;\n    }\n\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportMappingException(\"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportMappingException(\"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        return _properties[index].getProperty().deserialize(mp, ctxt);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, int index, String typeId) throws IOException\n    {\n        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n         * style to ensure we can handle all kinds of JSON constructs.\n         */\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            _properties[index].getProperty().set(bean, null);\n            return;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n    \n    public static class Builder\n    {\n        private final ArrayList<ExtTypedProperty> _properties = new ArrayList<ExtTypedProperty>();\n        private final HashMap<String, Integer> _nameToPropertyIndex = new HashMap<String, Integer>();\n\n        public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            Integer index = _properties.size();\n            _properties.add(new ExtTypedProperty(property, typeDeser));\n            _nameToPropertyIndex.put(property.getName(), index);\n            _nameToPropertyIndex.put(typeDeser.getPropertyName(), index);\n        }\n\n        /**\n         * Method called after all external properties have been assigned, to further\n         * link property with polymorphic value with possible property for type id\n         * itself. This is needed to support type ids as Creator properties.\n         *\n         * @since 2.8\n         */\n        public ExternalTypeHandler build(BeanPropertyMap otherProps) {\n            // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also\n            final int len = _properties.size();\n            ExtTypedProperty[] extProps = new ExtTypedProperty[len];\n            for (int i = 0; i < len; ++i) {\n                ExtTypedProperty extProp = _properties.get(i);\n                String typePropId = extProp.getTypePropertyName();\n                SettableBeanProperty typeProp = otherProps.find(typePropId);\n                if (typeProp != null) {\n                    extProp.linkTypeProperty(typeProp);\n                }\n                extProps[i] = extProp;\n            }\n            return new ExternalTypeHandler(extProps, _nameToPropertyIndex, null, null);\n        }\n\n        @Deprecated // since 2.8; may be removed as early as 2.9\n        public ExternalTypeHandler build() {\n            return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]),\n                    _nameToPropertyIndex, null, null);\n        }\n    }\n\n    private final static class ExtTypedProperty\n    {\n        private final SettableBeanProperty _property;\n        private final TypeDeserializer _typeDeserializer;\n        private final String _typePropertyName;\n\n        /**\n         * @since 2.8\n         */\n        private SettableBeanProperty _typeProperty;\n\n        public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            _property = property;\n            _typeDeserializer = typeDeser;\n            _typePropertyName = typeDeser.getPropertyName();\n        }\n\n        /**\n         * @since 2.8\n         */\n        public void linkTypeProperty(SettableBeanProperty p) {\n            _typeProperty = p;\n        }\n\n        public boolean hasTypePropertyName(String n) {\n            return n.equals(_typePropertyName);\n        }\n\n        public boolean hasDefaultType() {\n            return _typeDeserializer.getDefaultImpl() != null;\n        }\n\n        /**\n         * Specialized called when we need to expose type id of `defaultImpl` when\n         * serializing: we may need to expose it for assignment to a property, or\n         * it may be requested as visible for some other reason.\n         */\n        public String getDefaultTypeId() {\n            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n            if (defaultType == null) {\n                return null;\n            }\n            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n        }\n\n        public String getTypePropertyName() { return _typePropertyName; }\n\n        public SettableBeanProperty getProperty() {\n            return _property;\n        }\n\n        /**\n         * @since 2.8\n         */\n        public SettableBeanProperty getTypeProperty() {\n            return _typeProperty;\n        }\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 53, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.type.TypeBindings", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Helper class used for resolving type parameters for given class\n */\npublic class TypeBindings\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static String[] NO_STRINGS = new String[0];\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null);\n\n    // // // Pre-resolved instances for minor optimizations\n\n    // // // Actual member information\n    \n    /**\n     * Array of type (type variable) names.\n     */\n    private final String[] _names;\n\n    /**\n     * Types matching names\n     */\n    private final JavaType[] _types;\n\n    /**\n     * Names of potentially unresolved type variables.\n     *\n     * @since 2.3\n     */\n    private final String[] _unboundVariables;\n    \n    private final int _hashCode;\n    \n    /*\n    /**********************************************************************\n    /* Construction\n    /**********************************************************************\n     */\n    \n    private TypeBindings(String[] names, JavaType[] types, String[] uvars)\n    {\n        _names = (names == null) ? NO_STRINGS : names;\n        _types = (types == null) ? NO_TYPES : types;\n        if (_names.length != _types.length) {\n            throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\");\n        }\n        int h = 1;\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            h += _types[i].hashCode();\n        }\n        _unboundVariables = uvars;\n        _hashCode = h;\n    }\n\n    public static TypeBindings emptyBindings() {\n        return EMPTY;\n    }\n\n    // Let's just canonicalize serialized EMPTY back to static instance, if need be\n    protected Object readResolve() {\n        if ((_names == null) || (_names.length == 0)) {\n            return EMPTY;\n        }\n        return this;\n    }\n\n    /**\n     * Factory method for constructing bindings for given class using specified type\n     * parameters.\n     */\n    public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList)\n    {\n        JavaType[] types = (typeList == null || typeList.isEmpty()) ?\n                NO_TYPES : typeList.toArray(new JavaType[typeList.size()]);\n        return create(erasedType, types);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType[] types)\n    {\n        if (types == null) {\n            types = NO_TYPES;\n        } else switch (types.length) {\n        case 1:\n            return create(erasedType, types[0]);\n        case 2:\n            return create(erasedType, types[0], types[1]);\n        }\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        String[] names;\n        if (vars == null || vars.length == 0) {\n            names = NO_STRINGS;\n        } else {\n            int len = vars.length;\n            names = new String[len];\n            for (int i = 0; i < len; ++i) {\n                names[i] = vars[i].getName();\n            }\n        }\n        // Check here to give better error message\n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1)\n    {\n        // 30-Oct-2015, tatu: Minor optimization for relatively common cases\n        TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2)\n    {\n        // 30-Oct-2015, tatu: Minor optimization for relatively common cases\n        TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 2) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 2 type parameters: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() },\n                new JavaType[] { typeArg1, typeArg2 }, null);\n    }\n    \n    /**\n     * Alternate factory method that may be called if it is possible that type\n     * does or does not require type parameters; this is mostly useful for\n     * collection- and map-like types.\n     */\n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1)\n    {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen == 0) {\n            return EMPTY;\n        }\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n    \n    /**\n     * Alternate factory method that may be called if it is possible that type\n     * does or does not require type parameters; this is mostly useful for\n     * collection- and map-like types.\n     */\n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types)\n    {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        if (vars == null || vars.length == 0) {\n            return EMPTY;\n        }\n        if (types == null) {\n            types = NO_TYPES;\n        }\n        int len = vars.length;\n        String[] names = new String[len];\n        for (int i = 0; i < len; ++i) {\n            names[i] = vars[i].getName();\n        }\n        // Check here to give better error message\n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n    \n    /**\n     * Method for creating an instance that has same bindings as this object,\n     * plus an indicator for additional type variable that may be unbound within\n     * this context; this is needed to resolve recursive self-references.\n     */\n    public TypeBindings withUnboundVariable(String name)\n    {\n        int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;\n        String[] names =  (len == 0)\n                ? new String[1] : Arrays.copyOf(_unboundVariables, len+1);\n        names[len] = name;\n        return new TypeBindings(_names, _types, names);\n    }\n\n    /*\n    /**********************************************************************\n    /* Accessors\n    /**********************************************************************\n     */\n\n    /**\n     * Find type bound to specified name, if there is one; returns bound type if so, null if not.\n     */\n    public JavaType findBoundType(String name)\n    {\n        for (int i = 0, len = _names.length; i < len; ++i) {\n            if (name.equals(_names[i])) {\n                JavaType t = _types[i];\n                if (t instanceof ResolvedRecursiveType) {\n                    ResolvedRecursiveType rrt = (ResolvedRecursiveType) t;\n                    JavaType t2 = rrt.getSelfReferencedType();\n                    if (t2 != null) {\n                        t = t2;\n                    } else {\n                        /* 25-Feb-2016, tatu: Looks like a potential problem, but alas\n                         *   we have a test where this should NOT fail and things... seem\n                         *   to work. So be it.\n                         */\n/*\n                        throw new IllegalStateException(String.format\n(\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\",\nname, i, t.getRawClass()));\n*/\n                    }\n                }\n                return t;\n            }\n        }\n        return null;\n    }\n\n    public boolean isEmpty() {\n        return (_types.length == 0);\n    }\n    \n    /**\n     * Returns number of bindings contained\n     */\n    public int size() { \n        return _types.length;\n    }\n\n    public String getBoundName(int index)\n    {\n        if (index < 0 || index >= _names.length) {\n            return null;\n        }\n        return _names[index];\n    }\n\n    public JavaType getBoundType(int index)\n    {\n        if (index < 0 || index >= _types.length) {\n            return null;\n        }\n        return _types[index];\n    }\n\n    /**\n     * Accessor for getting bound types in declaration order\n     */\n    public List<JavaType> getTypeParameters()\n    {\n        if (_types.length == 0) {\n            return Collections.emptyList();\n        }\n        return Arrays.asList(_types);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public boolean hasUnbound(String name) {\n        if (_unboundVariables != null) {\n            for (int i = _unboundVariables.length; --i >= 0; ) {\n                if (name.equals(_unboundVariables[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Factory method that will create an object that can be used as a key for\n     * caching purposes by {@link TypeFactory}\n     *\n     * @since 2.8\n     */\n        // safe to pass _types array without copy since it is not exposed via\n        // any access, nor modified by this class\n\n    /*\n    /**********************************************************************\n    /* Standard methods\n    /**********************************************************************\n     */\n    \n    @Override public String toString()\n    {\n        if (_types.length == 0) {\n            return \"<>\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append('<');\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            if (i > 0) {\n                sb.append(',');\n            }\n//            sb = _types[i].appendBriefDescription(sb);\n            String sig = _types[i].getGenericSignature();\n            sb.append(sig);\n        }\n        sb.append('>');\n        return sb.toString();\n    }\n\n    @Override public int hashCode() { return _hashCode; }\n\n    @Override public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null || o.getClass() != getClass()) return false;\n        TypeBindings other = (TypeBindings) o;\n        int len = _types.length;\n        if (len != other.size()) {\n            return false;\n        }\n        JavaType[] otherTypes = other._types;\n        for (int i = 0; i < len; ++i) {\n            if (!otherTypes[i].equals(_types[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Package accessible methods\n    /**********************************************************************\n     */\n\n    protected JavaType[] typeParameterArray() {\n        return _types;\n    }\n\n    /*\n    /**********************************************************************\n    /* Helper classes\n    /**********************************************************************\n     */\n\n    // 30-Oct-2015, tatu: Surprising, but looks like type parameters access can be bit of\n    //    a hot spot. So avoid for a small number of common generic types. Note that we do\n    //    need both common abstract types and concrete ones; latter for specialization\n\n    /**\n     * Helper class that contains simple logic for avoiding repeated lookups via\n     * {@link Class#getTypeParameters()} as that can be a performance issue for\n     * some use cases (wasteful, usually one-off or not reusing mapper).\n     * Partly isolated to avoid initialization for cases where no generic types are\n     * used.\n     */\n    static class TypeParamStash {\n        private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters();\n\n        private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters();\n\n        public static TypeVariable<?>[] paramsFor1(Class<?> erasedType)\n        {\n            if (erasedType == Collection.class) {\n                return VARS_COLLECTION;\n            }\n            if (erasedType == List.class) {\n                return VARS_LIST;\n            }\n            if (erasedType == ArrayList.class) {\n                return VARS_ARRAY_LIST;\n            }\n            if (erasedType == AbstractList.class) {\n                return VARS_ABSTRACT_LIST;\n            }\n            if (erasedType == Iterable.class) {\n                return VARS_ITERABLE;\n            }\n            return erasedType.getTypeParameters();\n        }    \n\n        public static TypeVariable<?>[] paramsFor2(Class<?> erasedType)\n        {\n            if (erasedType == Map.class) {\n                return VARS_MAP;\n            }\n            if (erasedType == HashMap.class) {\n                return VARS_HASH_MAP;\n            }\n            if (erasedType == LinkedHashMap.class) {\n                return VARS_LINKED_HASH_MAP;\n            }\n            return erasedType.getTypeParameters();\n        }    \n    }\n\n    /**\n     * Helper type used to allow caching of generic types\n     *\n     * @since 2.8\n     */\n\n\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Helper class used for resolving type parameters for given class\n */\npublic class TypeBindings\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static String[] NO_STRINGS = new String[0];\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null);\n\n    // // // Pre-resolved instances for minor optimizations\n\n    // // // Actual member information\n    \n    /**\n     * Array of type (type variable) names.\n     */\n    private final String[] _names;\n\n    /**\n     * Types matching names\n     */\n    private final JavaType[] _types;\n\n    /**\n     * Names of potentially unresolved type variables.\n     *\n     * @since 2.3\n     */\n    private final String[] _unboundVariables;\n    \n    private final int _hashCode;\n    \n    /*\n    /**********************************************************************\n    /* Construction\n    /**********************************************************************\n     */\n    \n    private TypeBindings(String[] names, JavaType[] types, String[] uvars)\n    {\n        _names = (names == null) ? NO_STRINGS : names;\n        _types = (types == null) ? NO_TYPES : types;\n        if (_names.length != _types.length) {\n            throw new IllegalArgumentException(\"Mismatching names (\"+_names.length+\"), types (\"+_types.length+\")\");\n        }\n        int h = 1;\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            h += _types[i].hashCode();\n        }\n        _unboundVariables = uvars;\n        _hashCode = h;\n    }\n\n    public static TypeBindings emptyBindings() {\n        return EMPTY;\n    }\n\n    // Let's just canonicalize serialized EMPTY back to static instance, if need be\n    protected Object readResolve() {\n        if ((_names == null) || (_names.length == 0)) {\n            return EMPTY;\n        }\n        return this;\n    }\n\n    /**\n     * Factory method for constructing bindings for given class using specified type\n     * parameters.\n     */\n    public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList)\n    {\n        JavaType[] types = (typeList == null || typeList.isEmpty()) ?\n                NO_TYPES : typeList.toArray(new JavaType[typeList.size()]);\n        return create(erasedType, types);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType[] types)\n    {\n        if (types == null) {\n            types = NO_TYPES;\n        } else switch (types.length) {\n        case 1:\n            return create(erasedType, types[0]);\n        case 2:\n            return create(erasedType, types[0], types[1]);\n        }\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        String[] names;\n        if (vars == null || vars.length == 0) {\n            names = NO_STRINGS;\n        } else {\n            int len = vars.length;\n            names = new String[len];\n            for (int i = 0; i < len; ++i) {\n                names[i] = vars[i].getName();\n            }\n        }\n        // Check here to give better error message\n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1)\n    {\n        // 30-Oct-2015, tatu: Minor optimization for relatively common cases\n        TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n\n    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2)\n    {\n        // 30-Oct-2015, tatu: Minor optimization for relatively common cases\n        TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen != 2) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 2 type parameters: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() },\n                new JavaType[] { typeArg1, typeArg2 }, null);\n    }\n    \n    /**\n     * Alternate factory method that may be called if it is possible that type\n     * does or does not require type parameters; this is mostly useful for\n     * collection- and map-like types.\n     */\n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1)\n    {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen == 0) {\n            return EMPTY;\n        }\n        if (varLen != 1) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                    +\" with 1 type parameter: class expects \"+varLen);\n        }\n        return new TypeBindings(new String[] { vars[0].getName() },\n                new JavaType[] { typeArg1 }, null);\n    }\n    \n    /**\n     * Alternate factory method that may be called if it is possible that type\n     * does or does not require type parameters; this is mostly useful for\n     * collection- and map-like types.\n     */\n    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types)\n    {\n        TypeVariable<?>[] vars = erasedType.getTypeParameters();\n        if (vars == null || vars.length == 0) {\n            return EMPTY;\n        }\n        if (types == null) {\n            types = NO_TYPES;\n        }\n        int len = vars.length;\n        String[] names = new String[len];\n        for (int i = 0; i < len; ++i) {\n            names[i] = vars[i].getName();\n        }\n        // Check here to give better error message\n        if (names.length != types.length) {\n            throw new IllegalArgumentException(\"Can not create TypeBindings for class \"+erasedType.getName()\n                   +\" with \"+types.length+\" type parameter\"\n                   +((types.length == 1) ? \"\" : \"s\")+\": class expects \"+names.length);\n        }\n        return new TypeBindings(names, types, null);\n    }\n    \n    /**\n     * Method for creating an instance that has same bindings as this object,\n     * plus an indicator for additional type variable that may be unbound within\n     * this context; this is needed to resolve recursive self-references.\n     */\n    public TypeBindings withUnboundVariable(String name)\n    {\n        int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;\n        String[] names =  (len == 0)\n                ? new String[1] : Arrays.copyOf(_unboundVariables, len+1);\n        names[len] = name;\n        return new TypeBindings(_names, _types, names);\n    }\n\n    /*\n    /**********************************************************************\n    /* Accessors\n    /**********************************************************************\n     */\n\n    /**\n     * Find type bound to specified name, if there is one; returns bound type if so, null if not.\n     */\n    public JavaType findBoundType(String name)\n    {\n        for (int i = 0, len = _names.length; i < len; ++i) {\n            if (name.equals(_names[i])) {\n                JavaType t = _types[i];\n                if (t instanceof ResolvedRecursiveType) {\n                    ResolvedRecursiveType rrt = (ResolvedRecursiveType) t;\n                    JavaType t2 = rrt.getSelfReferencedType();\n                    if (t2 != null) {\n                        t = t2;\n                    } else {\n                        /* 25-Feb-2016, tatu: Looks like a potential problem, but alas\n                         *   we have a test where this should NOT fail and things... seem\n                         *   to work. So be it.\n                         */\n/*\n                        throw new IllegalStateException(String.format\n(\"Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)\",\nname, i, t.getRawClass()));\n*/\n                    }\n                }\n                return t;\n            }\n        }\n        return null;\n    }\n\n    public boolean isEmpty() {\n        return (_types.length == 0);\n    }\n    \n    /**\n     * Returns number of bindings contained\n     */\n    public int size() { \n        return _types.length;\n    }\n\n    public String getBoundName(int index)\n    {\n        if (index < 0 || index >= _names.length) {\n            return null;\n        }\n        return _names[index];\n    }\n\n    public JavaType getBoundType(int index)\n    {\n        if (index < 0 || index >= _types.length) {\n            return null;\n        }\n        return _types[index];\n    }\n\n    /**\n     * Accessor for getting bound types in declaration order\n     */\n    public List<JavaType> getTypeParameters()\n    {\n        if (_types.length == 0) {\n            return Collections.emptyList();\n        }\n        return Arrays.asList(_types);\n    }\n\n    /**\n     * @since 2.3\n     */\n    public boolean hasUnbound(String name) {\n        if (_unboundVariables != null) {\n            for (int i = _unboundVariables.length; --i >= 0; ) {\n                if (name.equals(_unboundVariables[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Factory method that will create an object that can be used as a key for\n     * caching purposes by {@link TypeFactory}\n     *\n     * @since 2.8\n     */\n    public Object asKey(Class<?> rawBase) {\n        // safe to pass _types array without copy since it is not exposed via\n        // any access, nor modified by this class\n        return new AsKey(rawBase, _types, _hashCode);\n    }\n\n    /*\n    /**********************************************************************\n    /* Standard methods\n    /**********************************************************************\n     */\n    \n    @Override public String toString()\n    {\n        if (_types.length == 0) {\n            return \"<>\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append('<');\n        for (int i = 0, len = _types.length; i < len; ++i) {\n            if (i > 0) {\n                sb.append(',');\n            }\n//            sb = _types[i].appendBriefDescription(sb);\n            String sig = _types[i].getGenericSignature();\n            sb.append(sig);\n        }\n        sb.append('>');\n        return sb.toString();\n    }\n\n    @Override public int hashCode() { return _hashCode; }\n\n    @Override public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null || o.getClass() != getClass()) return false;\n        TypeBindings other = (TypeBindings) o;\n        int len = _types.length;\n        if (len != other.size()) {\n            return false;\n        }\n        JavaType[] otherTypes = other._types;\n        for (int i = 0; i < len; ++i) {\n            if (!otherTypes[i].equals(_types[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Package accessible methods\n    /**********************************************************************\n     */\n\n    protected JavaType[] typeParameterArray() {\n        return _types;\n    }\n\n    /*\n    /**********************************************************************\n    /* Helper classes\n    /**********************************************************************\n     */\n\n    // 30-Oct-2015, tatu: Surprising, but looks like type parameters access can be bit of\n    //    a hot spot. So avoid for a small number of common generic types. Note that we do\n    //    need both common abstract types and concrete ones; latter for specialization\n\n    /**\n     * Helper class that contains simple logic for avoiding repeated lookups via\n     * {@link Class#getTypeParameters()} as that can be a performance issue for\n     * some use cases (wasteful, usually one-off or not reusing mapper).\n     * Partly isolated to avoid initialization for cases where no generic types are\n     * used.\n     */\n    static class TypeParamStash {\n        private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters();\n\n        private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters();\n        private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters();\n\n        public static TypeVariable<?>[] paramsFor1(Class<?> erasedType)\n        {\n            if (erasedType == Collection.class) {\n                return VARS_COLLECTION;\n            }\n            if (erasedType == List.class) {\n                return VARS_LIST;\n            }\n            if (erasedType == ArrayList.class) {\n                return VARS_ARRAY_LIST;\n            }\n            if (erasedType == AbstractList.class) {\n                return VARS_ABSTRACT_LIST;\n            }\n            if (erasedType == Iterable.class) {\n                return VARS_ITERABLE;\n            }\n            return erasedType.getTypeParameters();\n        }    \n\n        public static TypeVariable<?>[] paramsFor2(Class<?> erasedType)\n        {\n            if (erasedType == Map.class) {\n                return VARS_MAP;\n            }\n            if (erasedType == HashMap.class) {\n                return VARS_HASH_MAP;\n            }\n            if (erasedType == LinkedHashMap.class) {\n                return VARS_LINKED_HASH_MAP;\n            }\n            return erasedType.getTypeParameters();\n        }    \n    }\n\n    /**\n     * Helper type used to allow caching of generic types\n     *\n     * @since 2.8\n     */\n    final static class AsKey {\n        private final Class<?> _raw;\n        private final JavaType[] _params;\n        private final int _hash;\n\n        public AsKey(Class<?> raw, JavaType[] params, int hash) {\n            _raw = raw ;\n            _params = params;\n            _hash = hash;\n        }\n\n        @Override\n        public int hashCode() { return _hash; }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o == this) return true;\n            if (o == null) return false;\n            if (o.getClass() != getClass()) return false;\n            AsKey other = (AsKey) o;\n\n            if ((_hash == other._hash) && (_raw == other._raw)) {\n                final JavaType[] otherParams = other._params;\n                final int len = _params.length;\n\n                if (len == otherParams.length) {\n                    for (int i = 0; i < len; ++i) {\n                        if (!_params[i].equals(otherParams[i])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return _raw.getName()+\"<>\";\n        }\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.databind.type.TypeFactory", "buggy_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n\n    protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();\n\n    /*\n    /**********************************************************\n    /* Constants for \"well-known\" classes\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n\n    /*\n    /**********************************************************\n    /* Cached pre-constructed JavaType instances\n    /**********************************************************\n     */\n\n    // note: these are primitive, hence no super types\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG);\n\n    // and as to String... well, for now, ignore its super types\n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING);\n\n    // @since 2.7\n    protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);\n\n    /**\n     * Cache {@link Comparable} because it is both parameteric (relatively costly to\n     * resolve) and mostly useless (no special handling), better handle directly\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE);\n\n    /**\n     * Cache {@link Enum} because it is parametric AND self-referential (costly to\n     * resolve) and useless in itself (no special handling).\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM);\n\n    /**\n     * Cache {@link Class} because it is nominally parametric, but has no really\n     * useful information.\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n\n    protected final TypeParser _parser;\n    \n    /**\n     * ClassLoader used by this factory [databind#624].\n     */\n    protected final ClassLoader _classLoader;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        // As per [databind#894] must ensure we have back-linkage from TypeFactory:\n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Should be able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},\n     * to allow for overriding of lookup functionality in environments like OSGi.\n     *\n     * @since 2.6\n     */\n    public Class<?> findClass(String className) throws ClassNotFoundException\n    {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        // Two-phase lookup: first using context ClassLoader; then default\n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize,\n                                   ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className)\n    {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n            // !!! TODO (as of 28-Jan-2016, at least)\n            \n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n            //  for a case where this code does get invoked: not ideal\n            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n            //  not certain it would reliably work... but let's hope for best for now\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                TypeBindings tb = null;\n                if (baseType.containedTypeCount() == typeParamCount) {\n                    if (typeParamCount == 1) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0));\n                    } else if (typeParamCount == 2) {\n                        tb = TypeBindings.create(subclass, baseType.containedType(0),\n                                baseType.containedType(1));\n                    }\n                }\n                newType = _fromClass(null, subclass,\n                        (tb == null) ? TypeBindings.emptyBindings() : tb);\n            }\n        } while (false);\n\n        // except possibly handlers\n//      newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }\n\n        // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n        // (hopefully passing null Class for root is ok)\n        // Otherwise, two choices: match N first, or empty. Do latter, for now\n\n    /**\n     * Method similar to {@link #constructSpecializedType}, but that creates a\n     * less-specific type of given type. Usually this is as simple as simply\n     * finding super-type with type erasure of <code>superClass</code>, but\n     * there may be need for some additional work-arounds.\n     *\n     * @param superClass\n     *\n     * @since 2.7\n     */\n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            // Most likely, caller did not verify sub/super-type relationship\n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            // 01-Nov-2015, tatu: Should never happen, but ch\n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n\n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef)\n    {\n        // 19-Oct-2015, tatu: Simpler variant like so should work\n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        // but if not, due to funky sub-classing, type variables, what follows\n        // is a more complete processing a la Java ClassMate.\n\n        /*\n        final Class<?> refdRawType = typeRef.getClass();\n        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);\n        JavaType genType = type.findSuperType(TypeReference.class);\n        if (genType == null) { // sanity check; shouldn't occur\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        TypeBindings b = genType.getBindings();\n        JavaType[] params = b.typeParameterArray();\n        if (params.length == 0) {\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        return params[0];\n        */\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *<p>\n     * NOTE: was briefly deprecated for 2.6.\n     */\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *\n     * @since 2.6\n     *\n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    /**\n     * @since 2.6\n     */\n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)\n    {\n        return ReferenceType.construct(rawType, null, // no bindings\n                null, null, // or super-class, interfaces?\n                referredType);\n    }\n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here\n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param rawType Actual type-erased type\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)\n    {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level factory methods\n    /**********************************************************\n     */\n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        JavaType kt, vt;\n        \n        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake \"correct\" parameter sig\n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            // ok to have no types (\"raw\")\n            switch (typeParams.size()) {\n            case 0: // acceptable?\n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    /**\n     * Factory method to call when no special {@link JavaType} is needed,\n     * no generic parameters are passed. Default implementation may check\n     * pre-constructed values for \"well-known\" types, but if none found\n     * will simply call {@link #_newSimpleType}\n     *\n     * @since 2.7\n     */\n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Factory method that is to create a new {@link SimpleType} with no\n     * checks whatsoever. Default implementation calls the single argument\n     * constructor of {@link SimpleType}.\n     *\n     * @since 2.7\n     */\n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n         *    This may have been due to potential mutability of the instance; but that\n         *    should not be issue any more, and creation is somewhat wasteful. So let's\n         *    try reusing singleton/flyweight instance.\n         */\n        return CORE_TYPE_OBJECT;\n    }\n\n    /**\n     * Helper method called to see if requested, non-generic-parameterized\n     * type is one of common, \"well-known\" types, instances of which are\n     * pre-constructed and do not need dynamic caching.\n     *\n     * @since 2.7\n     */\n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Actual type resolution, traversal\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            // Important: remove possible bindings since this is type-erased thingy\n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { // [databind#116]\n            // no need to modify further if we already had JavaType\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* 21-Feb-2016, nateB/tatu: as per [databind#1129] (applied for 2.7.2),\n         *   we do need to let all kinds of types to be refined, esp. for Scala module.\n         */\n        if (_modifiers != null) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(resultType, type, b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), resultType));\n                }\n                resultType = t;\n            }\n        }\n        return resultType;\n    }\n\n    /**\n     * @param bindings Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        // Very first thing: small set of core types we know well:\n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        // Barring that, we may have recently constructed an instance\n        boolean cachable = (bindings == null) || bindings.isEmpty();\n        if (cachable) {\n            result = _typeCache.get(rawType);\n        if (result != null) {\n            return result;\n            }\n        }\n\n        // 15-Oct-2015, tatu: recursive reference?\n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                // Self-reference: needs special handling, then...\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            // no, but need to update context to allow for proper cycle resolution\n            context = context.child(rawType);\n        }\n\n        // First: do we have an array type?\n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            // If not, need to proceed by first resolving parent type hierarchy\n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                // Note: even Enums can implement interfaces, so can not drop those\n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...\n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            // And then check what flavor of type we got. Start by asking resolved\n            // super-type if refinement is all that is needed?\n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            // if not, perhaps we are now resolving a well-known class or interface?\n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        // but if nothing else, \"simple\" class for now:\n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        if (cachable) {\n            _typeCache.putIfAbsent(rawType, result);\n        }\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    /**\n     * Helper class used to check whether exact class for which type is being constructed\n     * is one of well-known base interfaces or classes that indicates alternate\n     * {@link JavaType} implementation.\n     */\n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // Quite simple when we resolving exact class/interface; start with that\n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        // and since 2.6 one referential type\n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        // 01-Nov-2015, tatu: As of 2.7, couple of potential `CollectionLikeType`s (like\n        //    `Iterable`, `Iterator`), and `MapLikeType`s (`Map.Entry`) are not automatically\n        //    detected, related to difficulties in propagating type upwards (Iterable, for\n        //    example, is a weak, tag-on type). They may be detectable in future.\n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // But that's not all: may be possible current type actually implements an\n        // interface type. So...\n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,\n            TypeBindings parentBindings)\n    {\n        // Assumption here is we'll always get Class, not one of other Types\n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of\n        //   couple of not-so-useful parametric types\n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        // First: what is the actual base type? One odd thing is that 'getRawType'\n        // returns Type, not Class<?> as one might expect. But let's assume it is\n        // always of type Class: if not, need to add more code to resolve it to Class.        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)\n    {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)\n    {\n        // ideally should find it via bindings:\n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        // but if not, use bounds... note that approach here is simplistic; not taking\n        // into account possible multiple bounds, nor consider upper bounds.\n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)\n    {\n        /* Similar to challenges with TypeVariable, we may have multiple upper bounds.\n         * But it is also possible that if upper bound defaults to Object, we might\n         * want to consider lower bounds instead.\n         * For now, we won't try anything more advanced; above is just for future reference.\n         */\n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.lang.reflect.*;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ArrayBuilders;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\n@SuppressWarnings({\"rawtypes\" })\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n\n    protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();\n\n    /*\n    /**********************************************************\n    /* Constants for \"well-known\" classes\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n\n    /*\n    /**********************************************************\n    /* Cached pre-constructed JavaType instances\n    /**********************************************************\n     */\n\n    // note: these are primitive, hence no super types\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG);\n\n    // and as to String... well, for now, ignore its super types\n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING);\n\n    // @since 2.7\n    protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);\n\n    /**\n     * Cache {@link Comparable} because it is both parameteric (relatively costly to\n     * resolve) and mostly useless (no special handling), better handle directly\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE);\n\n    /**\n     * Cache {@link Enum} because it is parametric AND self-referential (costly to\n     * resolve) and useless in itself (no special handling).\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM);\n\n    /**\n     * Cache {@link Class} because it is nominally parametric, but has no really\n     * useful information.\n     *\n     * @since 2.7\n     */\n    protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100);\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n\n    protected final TypeParser _parser;\n    \n    /**\n     * ClassLoader used by this factory [databind#624].\n     */\n    protected final ClassLoader _classLoader;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n        _parser = new TypeParser(this);\n        _modifiers = null;\n        _classLoader = null;\n    }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n        this(p, mods, null);\n    }\n    \n    protected TypeFactory(TypeParser p, TypeModifier[] mods, ClassLoader classLoader) {\n        // As per [databind#894] must ensure we have back-linkage from TypeFactory:\n        _parser = p.withFactory(this);\n        _modifiers = mods;\n        _classLoader = classLoader;\n    }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers, _classLoader);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);\n    }\n    \n    public TypeFactory withClassLoader(ClassLoader classLoader) {\n        return new TypeFactory(_parser, _modifiers, classLoader);\n    }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() { return instance; }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n        _typeCache.clear();\n    }\n\n    public ClassLoader getClassLoader() {\n        return _classLoader;\n    }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Should be able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},\n     * to allow for overriding of lookup functionality in environments like OSGi.\n     *\n     * @since 2.6\n     */\n    public Class<?> findClass(String className) throws ClassNotFoundException\n    {\n        if (className.indexOf('.') < 0) {\n            Class<?> prim = _findPrimitive(className);\n            if (prim != null) {\n                return prim;\n            }\n        }\n        // Two-phase lookup: first using context ClassLoader; then default\n        Throwable prob = null;\n        ClassLoader loader = this.getClassLoader();\n        if (loader == null) {\n          loader = \tThread.currentThread().getContextClassLoader();\n        }\n        if (loader != null) {\n            try {\n                return classForName(className, true, loader);\n            } catch (Exception e) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        try {\n            return classForName(className);\n        } catch (Exception e) {\n            if (prob == null) {\n                prob = ClassUtil.getRootCause(e);\n            }\n        }\n        if (prob instanceof RuntimeException) {\n            throw (RuntimeException) prob;\n        }\n        throw new ClassNotFoundException(prob.getMessage(), prob);\n    }\n    \n    protected Class<?> classForName(String name, boolean initialize,\n                                   ClassLoader loader) throws ClassNotFoundException {\n    \treturn Class.forName(name, true, loader);\n    }\n    \n    protected Class<?> classForName(String name) throws ClassNotFoundException {\n        return Class.forName(name);\n    }\n\n    protected Class<?> _findPrimitive(String className)\n    {\n        if (\"int\".equals(className)) return Integer.TYPE;\n        if (\"long\".equals(className)) return Long.TYPE;\n        if (\"float\".equals(className)) return Float.TYPE;\n        if (\"double\".equals(className)) return Double.TYPE;\n        if (\"boolean\".equals(className)) return Boolean.TYPE;\n        if (\"byte\".equals(className)) return Byte.TYPE;\n        if (\"char\".equals(className)) return Character.TYPE;\n        if (\"short\".equals(className)) return Short.TYPE;\n        if (\"void\".equals(className)) return Void.TYPE;\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            \n            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n            // !!! TODO (as of 28-Jan-2016, at least)\n            \n            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n            //    a way to fully resolve and merge hierarchies; but that gets expensive\n            //    so let's, for now, try to create close-enough approximation that\n            //    is not 100% same, structurally, but has equivalent information for\n            //    our specific neeeds.\n            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n            //  for a case where this code does get invoked: not ideal\n            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n            //  not certain it would reliably work... but let's hope for best for now\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            if (baseType.isInterface()) {\n                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n            } else {\n                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n            }\n            // Only SimpleType returns null, but if so just resolve regularly\n            if (newType == null) {\n                newType = _fromClass(null, subclass, tb);\n            }\n        } while (false);\n\n        // except possibly handlers\n//      newType = newType.withHandlersFrom(baseType);\n        return newType;\n\n        // 20-Oct-2015, tatu: Old simplistic approach\n        \n        /*\n        // Currently mostly SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // But there is the need for special case for arrays too, it seems\n        if (baseType instanceof ArrayType) {\n            if (subclass.isArray()) {\n                // actually see if it might be a no-op first:\n                ArrayType at = (ArrayType) baseType;\n                Class<?> rawComp = subclass.getComponentType();\n                if (at.getContentType().getRawClass() == rawComp) {\n                    return baseType;\n                }\n                JavaType componentType = _fromAny(null, rawComp, null);\n                return ((ArrayType) baseType).withComponentType(componentType);\n            }\n        }\n\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n        */\n    }\n\n    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)\n    {\n        // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n        // (hopefully passing null Class for root is ok)\n        int baseCount = baseType.containedTypeCount();\n        if (baseCount == typeParamCount) {\n            if (typeParamCount == 1) {\n                return TypeBindings.create(subclass, baseType.containedType(0));\n            }\n            if (typeParamCount == 2) {\n                return TypeBindings.create(subclass, baseType.containedType(0),\n                        baseType.containedType(1));\n            }\n            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n            for (int i = 0; i < baseCount; ++i) {\n                types.add(baseType.containedType(i));\n            }\n            return TypeBindings.create(subclass, types);\n        }\n        // Otherwise, two choices: match N first, or empty. Do latter, for now\n        return TypeBindings.emptyBindings();\n    }\n\n    /**\n     * Method similar to {@link #constructSpecializedType}, but that creates a\n     * less-specific type of given type. Usually this is as simple as simply\n     * finding super-type with type erasure of <code>superClass</code>, but\n     * there may be need for some additional work-arounds.\n     *\n     * @param superClass\n     *\n     * @since 2.7\n     */\n    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == superClass) {\n            return baseType;\n        }\n        JavaType superType = baseType.findSuperType(superClass);\n        if (superType == null) {\n            // Most likely, caller did not verify sub/super-type relationship\n            if (!superClass.isAssignableFrom(rawBase)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not a super-type of %s\", superClass.getName(), baseType));\n            }\n            // 01-Nov-2015, tatu: Should never happen, but ch\n            throw new IllegalArgumentException(String.format(\n                    \"Internal error: class %s not included as super-type for %s\",\n                    superClass.getName(), baseType));\n        }\n        return superType;\n    }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n\n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        JavaType match = type.findSuperType(expType);\n        if (match == null) {\n            return NO_TYPES;\n        }\n        return match.getBindings().typeParameterArray();\n    }\n\n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n        return findTypeParameters(constructType(clz, bindings), expType);\n    }\n    \n    /**\n     * @deprecated Since 2.7 resolve raw type first, then find type parameters\n     */\n    @Deprecated // since 2.7    \n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n        return findTypeParameters(constructType(clz), expType);\n    }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _fromAny(null, type, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _fromAny(null, type, bindings);\n    }\n    \n    public JavaType constructType(TypeReference<?> typeRef)\n    {\n        // 19-Oct-2015, tatu: Simpler variant like so should work\n        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);\n\n        // but if not, due to funky sub-classing, type variables, what follows\n        // is a more complete processing a la Java ClassMate.\n\n        /*\n        final Class<?> refdRawType = typeRef.getClass();\n        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);\n        JavaType genType = type.findSuperType(TypeReference.class);\n        if (genType == null) { // sanity check; shouldn't occur\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        TypeBindings b = genType.getBindings();\n        JavaType[] params = b.typeParameterArray();\n        if (params.length == 0) {\n            throw new IllegalArgumentException(\"Unparameterized GenericType instance (\"+refdRawType.getName()+\")\");\n        }\n        return params[0];\n        */\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass) {\n        TypeBindings bindings = (contextClass == null)\n                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType) {\n        TypeBindings bindings = (contextType == null)\n                ? TypeBindings.emptyBindings() : contextType.getBindings();\n        return _fromAny(null, type, bindings);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_fromAny(null, elementType, null), null);\n    }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        return (CollectionType) _fromClass(null, collectionClass,\n                TypeBindings.create(collectionClass, elementType));\n    }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _fromClass(null, elementClass, EMPTY_BINDINGS));\n    }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromClass(null, collectionClass,\n                TypeBindings.createIfNeeded(collectionClass, elementType));\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt, vt;\n        if (mapClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);\n            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);\n        }\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return (MapType) _fromClass(null, mapClass,\n                TypeBindings.create(mapClass, new JavaType[] {\n                        keyType, valueType\n                }));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return constructMapLikeType(mapClass,\n                _fromClass(null, keyClass, EMPTY_BINDINGS),\n                _fromClass(null, valueClass, EMPTY_BINDINGS));\n    }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be\n        //    a valid use case here\n        JavaType type = _fromClass(null, mapClass,\n                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *<p>\n     * NOTE: was briefly deprecated for 2.6.\n     */\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * Method for constructing a type instance with specified parameterization.\n     *\n     * @since 2.6\n     *\n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        return constructSimpleType(rawType, parameterTypes);\n    } \n\n    /**\n     * @since 2.6\n     */\n    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)\n    {\n        return ReferenceType.construct(rawType, null, // no bindings\n                null, null, // or super-class, interfaces?\n                referredType);\n    }\n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here\n        return _constructSimple(cls, EMPTY_BINDINGS, null, null);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param rawType Actual type-erased type\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)\n    {\n        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        return constructParametricType(parametrized, parameterTypes);\n    }\n\n    /**\n     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        return constructParametricType(parametrized, parameterClasses);\n    }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level factory methods\n    /**********************************************************\n     */\n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        JavaType kt, vt;\n        \n        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake \"correct\" parameter sig\n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            // ok to have no types (\"raw\")\n            switch (typeParams.size()) {\n            case 0: // acceptable?\n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    /**\n     * Factory method to call when no special {@link JavaType} is needed,\n     * no generic parameters are passed. Default implementation may check\n     * pre-constructed values for \"well-known\" types, but if none found\n     * will simply call {@link #_newSimpleType}\n     *\n     * @since 2.7\n     */\n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Factory method that is to create a new {@link SimpleType} with no\n     * checks whatsoever. Default implementation calls the single argument\n     * constructor of {@link SimpleType}.\n     *\n     * @since 2.7\n     */\n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n         *    This may have been due to potential mutability of the instance; but that\n         *    should not be issue any more, and creation is somewhat wasteful. So let's\n         *    try reusing singleton/flyweight instance.\n         */\n        return CORE_TYPE_OBJECT;\n    }\n\n    /**\n     * Helper method called to see if requested, non-generic-parameterized\n     * type is one of common, \"well-known\" types, instances of which are\n     * pre-constructed and do not need dynamic caching.\n     *\n     * @since 2.7\n     */\n    protected JavaType _findWellKnownSimple(Class<?> clz) {\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Actual type resolution, traversal\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            // Important: remove possible bindings since this is type-erased thingy\n            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n        }\n        else if (type instanceof JavaType) { // [databind#116]\n            // no need to modify further if we already had JavaType\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(context, (WildcardType) type, bindings);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* 21-Feb-2016, nateB/tatu: as per [databind#1129] (applied for 2.7.2),\n         *   we do need to let all kinds of types to be refined, esp. for Scala module.\n         */\n        if (_modifiers != null) {\n            TypeBindings b = resultType.getBindings();\n            if (b == null) {\n                b = EMPTY_BINDINGS;\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(resultType, type, b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), resultType));\n                }\n                resultType = t;\n            }\n        }\n        return resultType;\n    }\n\n    /**\n     * @param bindings Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        // Very first thing: small set of core types we know well:\n        JavaType result = _findWellKnownSimple(rawType);\n        if (result != null) {\n            return result;\n        }\n        // Barring that, we may have recently constructed an instance\n        final Object key;\n        if ((bindings == null) || bindings.isEmpty()) {\n            key = rawType;\n            result = _typeCache.get(key); // ok, cache object is synced\n        } else {\n            key = bindings.asKey(rawType);\n        }\n        result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // 15-Oct-2015, tatu: recursive reference?\n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                // Self-reference: needs special handling, then...\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            // no, but need to update context to allow for proper cycle resolution\n            context = context.child(rawType);\n        }\n\n        // First: do we have an array type?\n        if (rawType.isArray()) {\n            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),\n                    bindings);\n        } else {\n            // If not, need to proceed by first resolving parent type hierarchy\n            \n            JavaType superClass;\n            JavaType[] superInterfaces;\n\n            if (rawType.isInterface()) {\n                superClass = null;\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            } else {\n                // Note: even Enums can implement interfaces, so can not drop those\n                superClass = _resolveSuperClass(context, rawType, bindings);\n                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n            }\n\n            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...\n            if (rawType == Properties.class) {\n                result = MapType.construct(rawType, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            }\n            // And then check what flavor of type we got. Start by asking resolved\n            // super-type if refinement is all that is needed?\n            else if (superClass != null) {\n                result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n            }\n            // if not, perhaps we are now resolving a well-known class or interface?\n            if (result == null) {\n                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); \n                if (result == null) {\n                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                    if (result == null) {\n                        // but if nothing else, \"simple\" class for now:\n                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                    }\n                }\n            }\n        }\n        context.resolveSelfReferences(result);\n        _typeCache.putIfAbsent(key, result); // cache object syncs\n        return result;\n    }\n\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type parent = ClassUtil.getGenericSuperclass(rawType);\n        if (parent == null) {\n            return null;\n        }\n        return _fromAny(context, parent, parentBindings);\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)\n    {\n        Type[] types = ClassUtil.getGenericInterfaces(rawType);\n        if (types == null || types.length == 0) {\n            return NO_TYPES;\n        }\n        int len = types.length;\n        JavaType[] resolved = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            Type type = types[i];\n            resolved[i] = _fromAny(context, type, parentBindings);\n        }\n        return resolved;\n    }\n\n    /**\n     * Helper class used to check whether exact class for which type is being constructed\n     * is one of well-known base interfaces or classes that indicates alternate\n     * {@link JavaType} implementation.\n     */\n    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // Quite simple when we resolving exact class/interface; start with that\n        if (rawType == Map.class) {\n            return _mapType(rawType, bindings, superClass, superInterfaces);\n        }\n        if (rawType == Collection.class) {\n            return _collectionType(rawType, bindings, superClass, superInterfaces);\n        }\n        // and since 2.6 one referential type\n        if (rawType == AtomicReference.class) {\n            return _referenceType(rawType, bindings, superClass, superInterfaces);\n        }\n        // 01-Nov-2015, tatu: As of 2.7, couple of potential `CollectionLikeType`s (like\n        //    `Iterable`, `Iterator`), and `MapLikeType`s (`Map.Entry`) are not automatically\n        //    detected, related to difficulties in propagating type upwards (Iterable, for\n        //    example, is a weak, tag-on type). They may be detectable in future.\n        return null;\n    }\n\n    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        // But that's not all: may be possible current type actually implements an\n        // interface type. So...\n        final int intCount = superInterfaces.length;\n\n        for (int i = 0; i < intCount; ++i) {\n            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,\n            TypeBindings parentBindings)\n    {\n        // Assumption here is we'll always get Class, not one of other Types\n        Class<?> rawType = (Class<?>) ptype.getRawType();\n\n        // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of\n        //   couple of not-so-useful parametric types\n        if (rawType == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (rawType == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (rawType == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n\n        // First: what is the actual base type? One odd thing is that 'getRawType'\n        // returns Type, not Class<?> as one might expect. But let's assume it is\n        // always of type Class: if not, need to add more code to resolve it to Class.        \n        Type[] args = ptype.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n        JavaType[] pt;\n        TypeBindings newBindings;        \n\n        if (paramCount == 0) {\n            newBindings = EMPTY_BINDINGS;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _fromAny(context, args[i], parentBindings);\n            }\n            newBindings = TypeBindings.create(rawType, pt);\n        }\n        return _fromClass(context, rawType, newBindings);\n    }\n\n    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)\n    {\n        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);\n        return ArrayType.construct(elementType, bindings);\n    }\n\n    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)\n    {\n        // ideally should find it via bindings:\n        final String name = var.getName();\n        JavaType type = bindings.findBoundType(name);\n        if (type != null) {\n            return type;\n        }\n        // but if not, use bounds... note that approach here is simplistic; not taking\n        // into account possible multiple bounds, nor consider upper bounds.\n        if (bindings.hasUnbound(name)) {\n            return CORE_TYPE_OBJECT;\n        }\n        bindings = bindings.withUnboundVariable(name);\n\n        Type[] bounds = var.getBounds();\n        return _fromAny(context, bounds[0], bindings);\n    }\n\n    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)\n    {\n        /* Similar to challenges with TypeVariable, we may have multiple upper bounds.\n         * But it is also possible that if upper bound defaults to Object, we might\n         * want to consider lower bounds instead.\n         * For now, we won't try anything more advanced; above is just for future reference.\n         */\n        return _fromAny(context, type.getUpperBounds()[0], bindings);\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 54, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder", "buggy_version": "package com.fasterxml.jackson.databind.ser;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    // @since 2.7\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    \n    final protected SerializationConfig _config;\n    final protected BeanDescription _beanDesc;\n\n    /**\n     * Default inclusion mode for properties of the POJO for which\n     * properties are collected; possibly overridden on\n     * per-property basis.\n     */\n    final protected JsonInclude.Value _defaultInclusion;\n\n    final protected AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * If a property has serialization inclusion value of\n     * {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT},\n     * we may need to know the default value of the bean, to know if property value\n     * equals default one.\n     *<p>\n     * NOTE: only used if enclosing class defines NON_DEFAULT, but NOT if it is the\n     * global default OR per-property override.\n     */\n    protected Object _defaultBean;\n\n    public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc)\n    {\n        _config = config;\n        _beanDesc = beanDesc;\n        _defaultInclusion = beanDesc.findPropertyInclusion(\n                config.getDefaultPropertyInclusion(beanDesc.getBeanClass()));\n        _annotationIntrospector = _config.getAnnotationIntrospector();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        \n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (declaredType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (declaredType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods; annotation access\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to determine statically defined type of property\n     * being serialized, based on annotations (for overrides), and alternatively\n     * declared type (if static typing for serialization is enabled).\n     * If neither can be used (no annotations, dynamic typing), returns null.\n     */\n    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType)\n        throws JsonMappingException\n    {\n        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);\n        // 11-Oct-2015, tatu: As of 2.7, not 100% sure following checks are needed. But keeping\n        //    for now, just in case\n        if (secondary != declaredType) {\n            Class<?> serClass = secondary.getRawClass();\n            // Must be a super type to be usable\n            Class<?> rawDeclared = declaredType.getRawClass();\n            if (serClass.isAssignableFrom(rawDeclared)) {\n                ; // fine as is\n            } else {\n                /* 18-Nov-2010, tatu: Related to fixing [JACKSON-416], an issue with such\n                 *   check is that for deserialization more specific type makes sense;\n                 *   and for serialization more generic. But alas JAXB uses but a single\n                 *   annotation to do both... Hence, we must just discard type, as long as\n                 *   types are related\n                 */\n                if (!rawDeclared.isAssignableFrom(serClass)) {\n                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n                }\n                /* 03-Dec-2010, tatu: Actually, ugh, we may need to further relax this\n                 *   and actually accept subtypes too for serialization. Bit dangerous in theory\n                 *   but need to trust user here...\n                 */\n            }\n            useStaticTyping = true;\n            declaredType = secondary;\n        }\n        // If using static typing, declared type is known to be the type...\n        JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {\n            useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n        }\n        if (useStaticTyping) {\n            // 11-Oct-2015, tatu: Make sure JavaType also \"knows\" static-ness...\n            return declaredType.withStaticTyping();\n            \n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for default value handling\n    /**********************************************************\n     */\n\n    protected Object getDefaultBean()\n    {\n        Object def = _defaultBean;\n        if (def == null) {\n            /* If we can fix access rights, we should; otherwise non-public\n             * classes or default constructor will prevent instantiation\n             */\n            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n            if (def == null) {\n                // 06-Nov-2015, tatu: As per [databind#998], do not fail.\n                /*\n                Class<?> cls = _beanDesc.getClassInfo().getAnnotated();\n                throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation\");\n                 */\n\n                // And use a marker\n                def = NO_DEFAULT_MARKER;\n            }\n            _defaultBean = def;\n        }\n        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;\n    }\n\n    /**\n     * Accessor used to find out \"default value\" for given property, to use for\n     * comparing values to serialize, to determine whether to exclude value from serialization with\n     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY}.\n     * This method is called when we specifically want to know default value within context\n     * of a POJO, when annotation is within containing class, and not for property or\n     * defined as global baseline.\n     *<p>\n     * Note that returning of pseudo-type \n     *\n     * @since 2.7\n     */\n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member,\n            JavaType type)\n    {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n    /**\n     * Accessor used to find out \"default value\" to use for comparing values to\n     * serialize, to determine whether to exclude value from serialization with\n     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.\n     *<p>\n     * Default logic is such that for primitives and wrapper types for primitives, expected\n     * defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,\n     * and for structured (Maps, Collections, arrays) and reference types, criteria\n     * {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}\n     * is used.\n     *\n     * @since 2.7\n     */\n    protected Object getDefaultValue(JavaType type)\n    {\n        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special\n        //   handling for primitives since they are never passed as nulls.\n        Class<?> cls = type.getRawClass();\n\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for exception handling\n    /**********************************************************\n     */\n    \n    protected Object _throwWrapped(Exception e, String propName, Object defaultBean)\n    {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        if (t instanceof Error) throw (Error) t;\n        if (t instanceof RuntimeException) throw (RuntimeException) t;\n        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.*;\nimport com.fasterxml.jackson.databind.jsontype.TypeSerializer;\nimport com.fasterxml.jackson.databind.util.*;\n\n/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    // @since 2.7\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    \n    final protected SerializationConfig _config;\n    final protected BeanDescription _beanDesc;\n\n    /**\n     * Default inclusion mode for properties of the POJO for which\n     * properties are collected; possibly overridden on\n     * per-property basis.\n     */\n    final protected JsonInclude.Value _defaultInclusion;\n\n    final protected AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * If a property has serialization inclusion value of\n     * {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT},\n     * we may need to know the default value of the bean, to know if property value\n     * equals default one.\n     *<p>\n     * NOTE: only used if enclosing class defines NON_DEFAULT, but NOT if it is the\n     * global default OR per-property override.\n     */\n    protected Object _defaultBean;\n\n    public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc)\n    {\n        _config = config;\n        _beanDesc = beanDesc;\n        _defaultInclusion = beanDesc.findPropertyInclusion(\n                config.getDefaultPropertyInclusion(beanDesc.getBeanClass()));\n        _annotationIntrospector = _config.getAnnotationIntrospector();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public Annotations getClassAnnotations() {\n        return _beanDesc.getClassAnnotations();\n    }\n\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        \n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods; annotation access\n    /**********************************************************\n     */\n\n    /**\n     * Method that will try to determine statically defined type of property\n     * being serialized, based on annotations (for overrides), and alternatively\n     * declared type (if static typing for serialization is enabled).\n     * If neither can be used (no annotations, dynamic typing), returns null.\n     */\n    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType)\n        throws JsonMappingException\n    {\n        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);\n        // 11-Oct-2015, tatu: As of 2.7, not 100% sure following checks are needed. But keeping\n        //    for now, just in case\n        if (secondary != declaredType) {\n            Class<?> serClass = secondary.getRawClass();\n            // Must be a super type to be usable\n            Class<?> rawDeclared = declaredType.getRawClass();\n            if (serClass.isAssignableFrom(rawDeclared)) {\n                ; // fine as is\n            } else {\n                /* 18-Nov-2010, tatu: Related to fixing [JACKSON-416], an issue with such\n                 *   check is that for deserialization more specific type makes sense;\n                 *   and for serialization more generic. But alas JAXB uses but a single\n                 *   annotation to do both... Hence, we must just discard type, as long as\n                 *   types are related\n                 */\n                if (!rawDeclared.isAssignableFrom(serClass)) {\n                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n                }\n                /* 03-Dec-2010, tatu: Actually, ugh, we may need to further relax this\n                 *   and actually accept subtypes too for serialization. Bit dangerous in theory\n                 *   but need to trust user here...\n                 */\n            }\n            useStaticTyping = true;\n            declaredType = secondary;\n        }\n        // If using static typing, declared type is known to be the type...\n        JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {\n            useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n        }\n        if (useStaticTyping) {\n            // 11-Oct-2015, tatu: Make sure JavaType also \"knows\" static-ness...\n            return declaredType.withStaticTyping();\n            \n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for default value handling\n    /**********************************************************\n     */\n\n    protected Object getDefaultBean()\n    {\n        Object def = _defaultBean;\n        if (def == null) {\n            /* If we can fix access rights, we should; otherwise non-public\n             * classes or default constructor will prevent instantiation\n             */\n            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n            if (def == null) {\n                // 06-Nov-2015, tatu: As per [databind#998], do not fail.\n                /*\n                Class<?> cls = _beanDesc.getClassInfo().getAnnotated();\n                throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation\");\n                 */\n\n                // And use a marker\n                def = NO_DEFAULT_MARKER;\n            }\n            _defaultBean = def;\n        }\n        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;\n    }\n\n    /**\n     * Accessor used to find out \"default value\" for given property, to use for\n     * comparing values to serialize, to determine whether to exclude value from serialization with\n     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY}.\n     * This method is called when we specifically want to know default value within context\n     * of a POJO, when annotation is within containing class, and not for property or\n     * defined as global baseline.\n     *<p>\n     * Note that returning of pseudo-type \n     *\n     * @since 2.7\n     */\n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member,\n            JavaType type)\n    {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n    /**\n     * Accessor used to find out \"default value\" to use for comparing values to\n     * serialize, to determine whether to exclude value from serialization with\n     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.\n     *<p>\n     * Default logic is such that for primitives and wrapper types for primitives, expected\n     * defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,\n     * and for structured (Maps, Collections, arrays) and reference types, criteria\n     * {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}\n     * is used.\n     *\n     * @since 2.7\n     */\n    protected Object getDefaultValue(JavaType type)\n    {\n        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special\n        //   handling for primitives since they are never passed as nulls.\n        Class<?> cls = type.getRawClass();\n\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for exception handling\n    /**********************************************************\n     */\n    \n    protected Object _throwWrapped(Exception e, String propName, Object defaultBean)\n    {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        if (t instanceof Error) throw (Error) t;\n        if (t instanceof RuntimeException) throw (RuntimeException) t;\n        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n    }\n}\n"}]}
{"project": "JacksonDatabind", "bug_id": 55, "classes_modified": [{"class_name": "com.fasterxml.jackson.databind.ser.std.StdKeySerializers", "buggy_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n\n@SuppressWarnings(\"serial\")\npublic class StdKeySerializers\n{\n    protected final static JsonSerializer<Object> DEFAULT_KEY_SERIALIZER = new StdKeySerializer();\n\n    protected final static JsonSerializer<Object> DEFAULT_STRING_SERIALIZER = new StringKeySerializer();\n\n    private StdKeySerializers() { }\n\n    /**\n     * @param config Serialization configuration in use, may be needed in choosing\n     *    serializer to use\n     * @param rawKeyType Type of key values to serialize\n     * @param useDefault If no match is found, should we return fallback deserializer\n     *    (true), or null (false)?\n     */\n    public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType, boolean useDefault)\n    {\n        // 24-Sep-2015, tatu: Important -- should ONLY consider types for which `@JsonValue`\n        //    can not be used, since caller has not yet checked for that annotation\n        //    This is why Enum types are not handled here quite yet\n\n        // [databind#943: Use a dynamic key serializer if we are not given actual\n        // type declaration\n        if ((rawKeyType == null) || (rawKeyType == Object.class)) {\n            return new Dynamic();\n        }\n        if (rawKeyType == String.class) {\n            return DEFAULT_STRING_SERIALIZER;\n        }\n        if (rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) {\n            return DEFAULT_KEY_SERIALIZER;\n        }\n        if (rawKeyType == Class.class) {\n            return new Default(Default.TYPE_CLASS, rawKeyType);\n        }\n        if (Date.class.isAssignableFrom(rawKeyType)) {\n            return new Default(Default.TYPE_DATE, rawKeyType);\n        }\n        if (Calendar.class.isAssignableFrom(rawKeyType)) {\n            return new Default(Default.TYPE_CALENDAR, rawKeyType);\n        }\n        // other JDK types we know convert properly with 'toString()'?\n        if (rawKeyType == java.util.UUID.class) {\n            return new Default(Default.TYPE_TO_STRING, rawKeyType);\n        }\n        return useDefault ? DEFAULT_KEY_SERIALIZER : null;\n    }\n\n    /**\n     * Method called if no specified key serializer was located; will return a\n     * \"default\" key serializer.\n     *\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType)\n    {\n        if (rawKeyType != null) {\n            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure\n            //   if that is a bug or feature. Regardless, it seems to require dynamic handling\n            //   (compared to getting actual fully typed Enum).\n            //  Note that this might even work from the earlier point, but let's play it safe for now\n            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because\n            //    then there is no static type\n            if (rawKeyType == Enum.class) {\n                return new Dynamic();\n            }\n            if (rawKeyType.isEnum()) {\n                return new Default(Default.TYPE_ENUM, rawKeyType);\n            }\n        }\n        return DEFAULT_KEY_SERIALIZER;\n    }\n\n    /**\n     * @deprecated since 2.7\n     */\n    @Deprecated\n    public static JsonSerializer<Object> getDefault() {\n        return DEFAULT_KEY_SERIALIZER;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard implementations used\n    /**********************************************************\n     */\n\n    /**\n     * This is a \"chameleon\" style multi-type key serializer for simple\n     * standard JDK types.\n     *<p>\n     * TODO: Should (but does not yet) support re-configuring format used for\n     * {@link java.util.Date} and {@link java.util.Calendar} key serializers,\n     * as well as alternative configuration of Enum key serializers.\n     */\n    public static class Default extends StdSerializer<Object> {\n        final static int TYPE_DATE = 1;\n        final static int TYPE_CALENDAR = 2;\n        final static int TYPE_CLASS = 3;\n        final static int TYPE_ENUM = 4;\n        final static int TYPE_TO_STRING = 5;\n\n        protected final int _typeId;\n        \n        public Default(int typeId, Class<?> type) {\n            super(type, false);\n            _typeId = typeId;\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException {\n            switch (_typeId) {\n            case TYPE_DATE:\n                provider.defaultSerializeDateKey((Date)value, g);\n                break;\n            case TYPE_CALENDAR:\n                provider.defaultSerializeDateKey(((Calendar) value).getTimeInMillis(), g);\n                break;\n            case TYPE_CLASS:\n                g.writeFieldName(((Class<?>)value).getName());\n                break;\n            case TYPE_ENUM:\n                {\n                    String str = provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n                            ? value.toString() : ((Enum<?>) value).name();\n                    g.writeFieldName(str);\n                }\n                break;\n            case TYPE_TO_STRING:\n            default:\n                g.writeFieldName(value.toString());\n            }\n        }\n    }\n\n    /**\n     * Key serializer used when key type is not known statically, and actual key\n     * serializer needs to be dynamically located.\n     */\n    public static class Dynamic extends StdSerializer<Object>\n    {\n        // Important: MUST be transient, to allow serialization of key serializer itself\n        protected transient PropertySerializerMap _dynamicSerializers;\n        \n        public Dynamic() {\n            super(String.class, false);\n            _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n        }\n\n        Object readResolve() {\n            // Since it's transient, and since JDK serialization by-passes ctor, need this:\n            _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n            return this;\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider provider)\n                throws IOException\n        {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap m = _dynamicSerializers;\n            JsonSerializer<Object> ser = m.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(m, cls, provider);\n            }\n            ser.serialize(value, g, provider);\n        }\n\n        protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n                Class<?> type, SerializerProvider provider) throws JsonMappingException\n        {\n            PropertySerializerMap.SerializerAndMapResult result =\n                    // null -> for now we won't keep ref or pass BeanProperty; could change\n                    map.findAndAddKeySerializer(type, provider, null);\n            // did we get a new map of serializers? If so, start using it\n            if (map != result.map) {\n                _dynamicSerializers = result.map;\n            }\n            return result.serializer;\n        }\n    }\n\n    /**\n     * Simple and fast key serializer when keys are Strings.\n     */\n    public static class StringKeySerializer extends StdSerializer<Object>\n    {\n        public StringKeySerializer() { super(String.class, false); }\n\n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException {\n            g.writeFieldName((String) value);\n        }\n    }\n\n    /**\n     * Specialized instance to use for Enum keys, as per [databind#1322]\n     *\n     * @since 2.8\n     */\n\n\n        \n}\n", "fixed_version": "package com.fasterxml.jackson.databind.ser.std;\n\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\nimport com.fasterxml.jackson.databind.util.EnumValues;\n\n@SuppressWarnings(\"serial\")\npublic class StdKeySerializers\n{\n    protected final static JsonSerializer<Object> DEFAULT_KEY_SERIALIZER = new StdKeySerializer();\n\n    protected final static JsonSerializer<Object> DEFAULT_STRING_SERIALIZER = new StringKeySerializer();\n\n    private StdKeySerializers() { }\n\n    /**\n     * @param config Serialization configuration in use, may be needed in choosing\n     *    serializer to use\n     * @param rawKeyType Type of key values to serialize\n     * @param useDefault If no match is found, should we return fallback deserializer\n     *    (true), or null (false)?\n     */\n    public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType, boolean useDefault)\n    {\n        // 24-Sep-2015, tatu: Important -- should ONLY consider types for which `@JsonValue`\n        //    can not be used, since caller has not yet checked for that annotation\n        //    This is why Enum types are not handled here quite yet\n\n        // [databind#943: Use a dynamic key serializer if we are not given actual\n        // type declaration\n        if ((rawKeyType == null) || (rawKeyType == Object.class)) {\n            return new Dynamic();\n        }\n        if (rawKeyType == String.class) {\n            return DEFAULT_STRING_SERIALIZER;\n        }\n        if (rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) {\n            return DEFAULT_KEY_SERIALIZER;\n        }\n        if (rawKeyType == Class.class) {\n            return new Default(Default.TYPE_CLASS, rawKeyType);\n        }\n        if (Date.class.isAssignableFrom(rawKeyType)) {\n            return new Default(Default.TYPE_DATE, rawKeyType);\n        }\n        if (Calendar.class.isAssignableFrom(rawKeyType)) {\n            return new Default(Default.TYPE_CALENDAR, rawKeyType);\n        }\n        // other JDK types we know convert properly with 'toString()'?\n        if (rawKeyType == java.util.UUID.class) {\n            return new Default(Default.TYPE_TO_STRING, rawKeyType);\n        }\n        return useDefault ? DEFAULT_KEY_SERIALIZER : null;\n    }\n\n    /**\n     * Method called if no specified key serializer was located; will return a\n     * \"default\" key serializer.\n     *\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType)\n    {\n        if (rawKeyType != null) {\n            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure\n            //   if that is a bug or feature. Regardless, it seems to require dynamic handling\n            //   (compared to getting actual fully typed Enum).\n            //  Note that this might even work from the earlier point, but let's play it safe for now\n            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because\n            //    then there is no static type\n            if (rawKeyType == Enum.class) {\n                return new Dynamic();\n            }\n            if (rawKeyType.isEnum()) {\n                return EnumKeySerializer.construct(rawKeyType,\n                        EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType));\n            }\n        }\n        return DEFAULT_KEY_SERIALIZER;\n    }\n\n    /**\n     * @deprecated since 2.7\n     */\n    @Deprecated\n    public static JsonSerializer<Object> getDefault() {\n        return DEFAULT_KEY_SERIALIZER;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard implementations used\n    /**********************************************************\n     */\n\n    /**\n     * This is a \"chameleon\" style multi-type key serializer for simple\n     * standard JDK types.\n     *<p>\n     * TODO: Should (but does not yet) support re-configuring format used for\n     * {@link java.util.Date} and {@link java.util.Calendar} key serializers,\n     * as well as alternative configuration of Enum key serializers.\n     */\n    public static class Default extends StdSerializer<Object> {\n        final static int TYPE_DATE = 1;\n        final static int TYPE_CALENDAR = 2;\n        final static int TYPE_CLASS = 3;\n        final static int TYPE_ENUM = 4;\n        final static int TYPE_TO_STRING = 5;\n\n        protected final int _typeId;\n        \n        public Default(int typeId, Class<?> type) {\n            super(type, false);\n            _typeId = typeId;\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException {\n            switch (_typeId) {\n            case TYPE_DATE:\n                provider.defaultSerializeDateKey((Date)value, g);\n                break;\n            case TYPE_CALENDAR:\n                provider.defaultSerializeDateKey(((Calendar) value).getTimeInMillis(), g);\n                break;\n            case TYPE_CLASS:\n                g.writeFieldName(((Class<?>)value).getName());\n                break;\n            case TYPE_ENUM:\n                {\n                    String str = provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n                            ? value.toString() : ((Enum<?>) value).name();\n                    g.writeFieldName(str);\n                }\n                break;\n            case TYPE_TO_STRING:\n            default:\n                g.writeFieldName(value.toString());\n            }\n        }\n    }\n\n    /**\n     * Key serializer used when key type is not known statically, and actual key\n     * serializer needs to be dynamically located.\n     */\n    public static class Dynamic extends StdSerializer<Object>\n    {\n        // Important: MUST be transient, to allow serialization of key serializer itself\n        protected transient PropertySerializerMap _dynamicSerializers;\n        \n        public Dynamic() {\n            super(String.class, false);\n            _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n        }\n\n        Object readResolve() {\n            // Since it's transient, and since JDK serialization by-passes ctor, need this:\n            _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n            return this;\n        }\n\n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider provider)\n                throws IOException\n        {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap m = _dynamicSerializers;\n            JsonSerializer<Object> ser = m.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(m, cls, provider);\n            }\n            ser.serialize(value, g, provider);\n        }\n\n        protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n                Class<?> type, SerializerProvider provider) throws JsonMappingException\n        {\n            PropertySerializerMap.SerializerAndMapResult result =\n                    // null -> for now we won't keep ref or pass BeanProperty; could change\n                    map.findAndAddKeySerializer(type, provider, null);\n            // did we get a new map of serializers? If so, start using it\n            if (map != result.map) {\n                _dynamicSerializers = result.map;\n            }\n            return result.serializer;\n        }\n    }\n\n    /**\n     * Simple and fast key serializer when keys are Strings.\n     */\n    public static class StringKeySerializer extends StdSerializer<Object>\n    {\n        public StringKeySerializer() { super(String.class, false); }\n\n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException {\n            g.writeFieldName((String) value);\n        }\n    }\n\n    /**\n     * Specialized instance to use for Enum keys, as per [databind#1322]\n     *\n     * @since 2.8\n     */\n    public static class EnumKeySerializer extends StdSerializer<Object>\n    {\n        protected final EnumValues _values;\n\n        protected EnumKeySerializer(Class<?> enumType, EnumValues values) {\n            super(enumType, false);\n            _values = values;\n        }\n\n        public static EnumKeySerializer construct(Class<?> enumType,\n                EnumValues enumValues)\n        {\n            return new EnumKeySerializer(enumType, enumValues);\n        }\n        \n        @Override\n        public void serialize(Object value, JsonGenerator g, SerializerProvider serializers)\n                throws IOException\n        {\n            if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {\n                g.writeFieldName(value.toString());\n                return;\n            }\n            Enum<?> en = (Enum<?>) value;\n            g.writeFieldName(_values.serializedValueFor(en));\n        }\n    }\n}\n"}]}
