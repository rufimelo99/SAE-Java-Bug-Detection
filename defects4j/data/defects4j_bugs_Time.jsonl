{"project": "Time", "bug_id": 1, "classes_modified": [{"class_name": "org.joda.time.field.UnsupportedDurationField", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n/**\n * A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic final class UnsupportedDurationField extends DurationField implements Serializable {\n\n    /** Serialization lock. */\n    private static final long serialVersionUID = -6390301302770925357L;\n\n    /** The cache of unsupported duration field instances */\n    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n\n    /**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */\n    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    /** The name of the field */\n    private final DurationFieldType iType;\n\n    /**\n     * Constructor.\n     * \n     * @param type  the type to use\n     */\n    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    //-----------------------------------------------------------------------\n    // Design note: Simple Accessors return a suitable value, but methods\n    // intended to perform calculations throw an UnsupportedOperationException.\n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    /**\n     * This field is not supported.\n     *\n     * @return false always\n     */\n    public boolean isSupported() {\n        return false;\n    }\n\n    /**\n     * This field is precise.\n     * \n     * @return true always\n     */\n    public boolean isPrecise() {\n        return true;\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always returns zero.\n     *\n     * @return zero always\n     */\n    public long getUnitMillis() {\n        return 0;\n    }\n\n    /**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */\n    public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n        return 0;\n    }\n\n    //------------------------------------------------------------------------\n    /**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */\n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    /**\n     * Ensure proper singleton serialization\n     */\n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n/**\n * A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic final class UnsupportedDurationField extends DurationField implements Serializable {\n\n    /** Serialization lock. */\n    private static final long serialVersionUID = -6390301302770925357L;\n\n    /** The cache of unsupported duration field instances */\n    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n\n    /**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */\n    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    /** The name of the field */\n    private final DurationFieldType iType;\n\n    /**\n     * Constructor.\n     * \n     * @param type  the type to use\n     */\n    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    //-----------------------------------------------------------------------\n    // Design note: Simple Accessors return a suitable value, but methods\n    // intended to perform calculations throw an UnsupportedOperationException.\n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    /**\n     * This field is not supported.\n     *\n     * @return false always\n     */\n    public boolean isSupported() {\n        return false;\n    }\n\n    /**\n     * This field is precise.\n     * \n     * @return true always\n     */\n    public boolean isPrecise() {\n        return true;\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always returns zero.\n     *\n     * @return zero always\n     */\n    public long getUnitMillis() {\n        return 0;\n    }\n\n    /**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */\n    public int compareTo(DurationField durationField) {\n        return 0;\n    }\n\n    //------------------------------------------------------------------------\n    /**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */\n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    /**\n     * Ensure proper singleton serialization\n     */\n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n"}, {"class_name": "org.joda.time.Partial", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1\n */\npublic final class Partial\n        extends AbstractPartial\n        implements ReadablePartial, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 12324121189002L;\n\n    /** The chronology in use. */\n    private final Chronology iChronology;\n    /** The set of field types. */\n    private final DateTimeFieldType[] iTypes;\n    /** The values of each field in this partial. */\n    private final int[] iValues;\n    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n    private transient DateTimeFormatter[] iFormatter;\n\n    // Constructors\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */\n    public Partial() {\n        this((Chronology) null);\n    }\n\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */\n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    /**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */\n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    /**\n     * Constructs a Partial with the specified values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param partial  the partial to copy\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    /**\n     * Constructs a Partial with the specified chronology, fields and values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param chronology  the chronology\n     * @param types  the types to create the partial from\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */\n    public int size() {\n        return iTypes.length;\n    }\n\n    /**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * \n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    /**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    /**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Does this partial match the specified instant.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified instant.\n     *\n     * @param instant  an instant to check against, null means now in default zone\n     * @return true if this partial matches the specified instant\n     */\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */\n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date in an appropriate ISO8601 format.\n     * <p>\n     * This method will output the partial in one of two ways.\n     * If {@link #getFormatter()}\n     * <p>\n     * If there is no appropriate ISO format a dump of the fields is output\n     * via {@link #toStringList()}.\n     * \n     * @return ISO8601 formatted string\n     */\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    /**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1\n     */\n    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 53278362873888L;\n\n        /** The partial */\n        private final Partial iPartial;\n        /** The field index */\n        private final int iFieldIndex;\n\n        /**\n         * Constructs a property.\n         * \n         * @param partial  the partial instance\n         * @param fieldIndex  the index in the partial\n         */\n        Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        /**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        /**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1\n */\npublic final class Partial\n        extends AbstractPartial\n        implements ReadablePartial, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 12324121189002L;\n\n    /** The chronology in use. */\n    private final Chronology iChronology;\n    /** The set of field types. */\n    private final DateTimeFieldType[] iTypes;\n    /** The values of each field in this partial. */\n    private final int[] iValues;\n    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n    private transient DateTimeFormatter[] iFormatter;\n\n    // Constructors\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */\n    public Partial() {\n        this((Chronology) null);\n    }\n\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */\n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                if (loopUnitField.isSupported() == false) {\n                    if (lastUnitField.isSupported()) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                        types[i - 1].getName() + \" < \" + loopType.getName());\n                    } else {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    /**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */\n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    /**\n     * Constructs a Partial with the specified values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param partial  the partial to copy\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    /**\n     * Constructs a Partial with the specified chronology, fields and values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param chronology  the chronology\n     * @param types  the types to create the partial from\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */\n    public int size() {\n        return iTypes.length;\n    }\n\n    /**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * \n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    /**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    /**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Does this partial match the specified instant.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified instant.\n     *\n     * @param instant  an instant to check against, null means now in default zone\n     * @return true if this partial matches the specified instant\n     */\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */\n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date in an appropriate ISO8601 format.\n     * <p>\n     * This method will output the partial in one of two ways.\n     * If {@link #getFormatter()}\n     * <p>\n     * If there is no appropriate ISO format a dump of the fields is output\n     * via {@link #toStringList()}.\n     * \n     * @return ISO8601 formatted string\n     */\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    /**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1\n     */\n    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 53278362873888L;\n\n        /** The partial */\n        private final Partial iPartial;\n        /** The field index */\n        private final int iFieldIndex;\n\n        /**\n         * Constructs a property.\n         * \n         * @param partial  the partial instance\n         * @param fieldIndex  the index in the partial\n         */\n        Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        /**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        /**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 2, "classes_modified": [{"class_name": "org.joda.time.field.UnsupportedDurationField", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n/**\n * A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic final class UnsupportedDurationField extends DurationField implements Serializable {\n\n    /** Serialization lock. */\n    private static final long serialVersionUID = -6390301302770925357L;\n\n    /** The cache of unsupported duration field instances */\n    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n\n    /**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */\n    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    /** The name of the field */\n    private final DurationFieldType iType;\n\n    /**\n     * Constructor.\n     * \n     * @param type  the type to use\n     */\n    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    //-----------------------------------------------------------------------\n    // Design note: Simple Accessors return a suitable value, but methods\n    // intended to perform calculations throw an UnsupportedOperationException.\n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    /**\n     * This field is not supported.\n     *\n     * @return false always\n     */\n    public boolean isSupported() {\n        return false;\n    }\n\n    /**\n     * This field is precise.\n     * \n     * @return true always\n     */\n    public boolean isPrecise() {\n        return true;\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always returns zero.\n     *\n     * @return zero always\n     */\n    public long getUnitMillis() {\n        return 0;\n    }\n\n    /**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */\n    public int compareTo(DurationField durationField) {\n        return 0;\n    }\n\n    //------------------------------------------------------------------------\n    /**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */\n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    /**\n     * Ensure proper singleton serialization\n     */\n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n/**\n * A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic final class UnsupportedDurationField extends DurationField implements Serializable {\n\n    /** Serialization lock. */\n    private static final long serialVersionUID = -6390301302770925357L;\n\n    /** The cache of unsupported duration field instances */\n    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n\n    /**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */\n    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    /** The name of the field */\n    private final DurationFieldType iType;\n\n    /**\n     * Constructor.\n     * \n     * @param type  the type to use\n     */\n    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    //-----------------------------------------------------------------------\n    // Design note: Simple Accessors return a suitable value, but methods\n    // intended to perform calculations throw an UnsupportedOperationException.\n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    /**\n     * This field is not supported.\n     *\n     * @return false always\n     */\n    public boolean isSupported() {\n        return false;\n    }\n\n    /**\n     * This field is precise.\n     * \n     * @return true always\n     */\n    public boolean isPrecise() {\n        return true;\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always returns zero.\n     *\n     * @return zero always\n     */\n    public long getUnitMillis() {\n        return 0;\n    }\n\n    /**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */\n    public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n        return 0;\n    }\n\n    //------------------------------------------------------------------------\n    /**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */\n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    /**\n     * Ensure proper singleton serialization\n     */\n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n"}, {"class_name": "org.joda.time.Partial", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1\n */\npublic final class Partial\n        extends AbstractPartial\n        implements ReadablePartial, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 12324121189002L;\n\n    /** The chronology in use. */\n    private final Chronology iChronology;\n    /** The set of field types. */\n    private final DateTimeFieldType[] iTypes;\n    /** The values of each field in this partial. */\n    private final int[] iValues;\n    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n    private transient DateTimeFormatter[] iFormatter;\n\n    // Constructors\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */\n    public Partial() {\n        this((Chronology) null);\n    }\n\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */\n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    /**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */\n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    /**\n     * Constructs a Partial with the specified values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param partial  the partial to copy\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    /**\n     * Constructs a Partial with the specified chronology, fields and values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param chronology  the chronology\n     * @param types  the types to create the partial from\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */\n    public int size() {\n        return iTypes.length;\n    }\n\n    /**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * \n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    /**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    /**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Does this partial match the specified instant.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified instant.\n     *\n     * @param instant  an instant to check against, null means now in default zone\n     * @return true if this partial matches the specified instant\n     */\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */\n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date in an appropriate ISO8601 format.\n     * <p>\n     * This method will output the partial in one of two ways.\n     * If {@link #getFormatter()}\n     * <p>\n     * If there is no appropriate ISO format a dump of the fields is output\n     * via {@link #toStringList()}.\n     * \n     * @return ISO8601 formatted string\n     */\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    /**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1\n     */\n    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 53278362873888L;\n\n        /** The partial */\n        private final Partial iPartial;\n        /** The field index */\n        private final int iFieldIndex;\n\n        /**\n         * Constructs a property.\n         * \n         * @param partial  the partial instance\n         * @param fieldIndex  the index in the partial\n         */\n        Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        /**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        /**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1\n */\npublic final class Partial\n        extends AbstractPartial\n        implements ReadablePartial, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 12324121189002L;\n\n    /** The chronology in use. */\n    private final Chronology iChronology;\n    /** The set of field types. */\n    private final DateTimeFieldType[] iTypes;\n    /** The values of each field in this partial. */\n    private final int[] iValues;\n    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n    private transient DateTimeFormatter[] iFormatter;\n\n    // Constructors\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */\n    public Partial() {\n        this((Chronology) null);\n    }\n\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */\n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    /**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */\n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    /**\n     * Constructs a Partial with the specified values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param partial  the partial to copy\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    /**\n     * Constructs a Partial with the specified chronology, fields and values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param chronology  the chronology\n     * @param types  the types to create the partial from\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */\n    public int size() {\n        return iTypes.length;\n    }\n\n    /**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * \n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    /**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    /**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Does this partial match the specified instant.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified instant.\n     *\n     * @param instant  an instant to check against, null means now in default zone\n     * @return true if this partial matches the specified instant\n     */\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */\n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date in an appropriate ISO8601 format.\n     * <p>\n     * This method will output the partial in one of two ways.\n     * If {@link #getFormatter()}\n     * <p>\n     * If there is no appropriate ISO format a dump of the fields is output\n     * via {@link #toStringList()}.\n     * \n     * @return ISO8601 formatted string\n     */\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    /**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1\n     */\n    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 53278362873888L;\n\n        /** The partial */\n        private final Partial iPartial;\n        /** The field index */\n        private final int iFieldIndex;\n\n        /**\n         * Constructs a property.\n         * \n         * @param partial  the partial instance\n         * @param fieldIndex  the index in the partial\n         */\n        Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        /**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        /**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 3, "classes_modified": [{"class_name": "org.joda.time.MutableDateTime", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Locale;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseDateTime;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * MutableDateTime is the standard implementation of a modifiable datetime class.\n * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n * <p>\n * This class uses a Chronology internally. The Chronology determines how the\n * millisecond instant value is converted into the date time fields.\n * The default Chronology is <code>ISOChronology</code> which is the agreed\n * international standard and compatible with the modern Gregorian calendar.\n * <p>\n * Each individual field can be accessed in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>get numeric value\n * <li>set numeric value\n * <li>add to numeric value\n * <li>add to numeric value wrapping with the field\n * <li>get text value\n * <li>get short text value\n * <li>set text value\n * <li>field maximum value\n * <li>field minimum value\n * </ul>\n *\n * <p>\n * MutableDateTime is mutable and not thread-safe, unless concurrent threads\n * are not invoking mutator methods.\n *\n * @author Guy Allard\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Mike Schrag\n * @since 1.0\n * @see DateTime\n */\npublic class MutableDateTime\n        extends BaseDateTime\n        implements ReadWritableDateTime, Cloneable, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2852608688135209575L;\n\n    /** Rounding is disabled */\n    public static final int ROUND_NONE = 0;\n    /** Rounding mode as described by {@link DateTimeField#roundFloor} */\n    public static final int ROUND_FLOOR = 1;\n    /** Rounding mode as described by {@link DateTimeField#roundCeiling} */\n    public static final int ROUND_CEILING = 2;\n    /** Rounding mode as described by {@link DateTimeField#roundHalfFloor} */\n    public static final int ROUND_HALF_FLOOR = 3;\n    /** Rounding mode as described by {@link DateTimeField#roundHalfCeiling} */\n    public static final int ROUND_HALF_CEILING = 4;\n    /** Rounding mode as described by {@link DateTimeField#roundHalfEven} */\n    public static final int ROUND_HALF_EVEN = 5;\n\n    /** The field to round on */\n    private DateTimeField iRoundingField;\n    /** The mode of rounding */\n    private int iRoundingMode;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static MutableDateTime now() {\n        return new MutableDateTime();\n    }\n\n    /**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     *\n     * @param zone  the time zone, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static MutableDateTime now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new MutableDateTime(zone);\n    }\n\n    /**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static MutableDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new MutableDateTime(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code MutableDateTime} from the specified string.\n     * <p>\n     * This uses {@link ISODateTimeFormat#dateTimeParser()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static MutableDateTime parse(String str) {\n        return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());\n    }\n\n    /**\n     * Parses a {@code MutableDateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static MutableDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseDateTime(str).toMutableDateTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @see #now()\n     */\n    public MutableDateTime() {\n        super();\n    }\n\n    /**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */\n    public MutableDateTime(DateTimeZone zone) {\n        super(zone);\n    }\n\n    /**\n     * Constructs an instance set to the current system millisecond time\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */\n    public MutableDateTime(Chronology chronology) {\n        super(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */\n    public MutableDateTime(long instant) {\n        super(instant);\n    }\n\n    /**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */\n    public MutableDateTime(long instant, DateTimeZone zone) {\n        super(instant, zone);\n    }\n\n    /**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public MutableDateTime(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used. Otherwise, ISO default is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public MutableDateTime(Object instant) {\n        super(instant, (Chronology) null);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used, but with the time zone adjusted.\n     * Otherwise, ISO is used in the specified time zone.\n     * If the specified time zone is null, the default zone is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @param zone  the time zone, null means default time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public MutableDateTime(Object instant, DateTimeZone zone) {\n        super(instant, zone);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Any chronology implied by the object (such as GregorianCalendar does)\n     * is ignored.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public MutableDateTime(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     */\n    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond) {\n        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n\n    /**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param zone  the time zone, null means default time zone\n     */\n    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            DateTimeZone zone) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n    }\n\n    /**\n     * Constructs an instance from datetime field values\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the field used for rounding this instant, returning null if rounding\n     * is not enabled.\n     * \n     * @return the rounding field\n     */\n    public DateTimeField getRoundingField() {\n        return iRoundingField;\n    }\n\n    /**\n     * Gets the rounding mode for this instant, returning ROUND_NONE if rounding\n     * is not enabled.\n     * \n     * @return the rounding mode constant\n     */\n    public int getRoundingMode() {\n        return iRoundingMode;\n    }\n\n    /**\n     * Sets the status of rounding to use the specified field and ROUND_FLOOR mode.\n     * A null field will disable rounding.\n     * Once set, the instant is then rounded using the new field and mode.\n     * <p>\n     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n     * to be rounded. This can be used to control the precision of the instant,\n     * for example by setting a rounding field of minuteOfDay, the seconds and\n     * milliseconds will always be zero.\n     *\n     * @param field rounding field or null to disable\n     */\n    public void setRounding(DateTimeField field) {\n        setRounding(field, MutableDateTime.ROUND_FLOOR);\n    }\n\n    /**\n     * Sets the status of rounding to use the specified field and mode.\n     * A null field or mode of ROUND_NONE will disable rounding.\n     * Once set, the instant is then rounded using the new field and mode.\n     * <p>\n     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n     * to be rounded. This can be used to control the precision of the instant,\n     * for example by setting a rounding field of minuteOfDay, the seconds and\n     * milliseconds will always be zero.\n     *\n     * @param field  rounding field or null to disable\n     * @param mode  rounding mode or ROUND_NONE to disable\n     * @throws IllegalArgumentException if mode is unknown, no exception if field is null\n     */\n    public void setRounding(DateTimeField field, int mode) {\n        if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {\n            throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);\n        }\n        iRoundingField = (mode == ROUND_NONE ? null : field);\n        iRoundingMode = (field == null ? ROUND_NONE : mode);\n        setMillis(getMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the milliseconds of the datetime.\n     * <p>\n     * All changes to the millisecond field occurs via this method.\n     *\n     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n     * datetime to\n     */\n    public void setMillis(long instant) {\n        switch (iRoundingMode) {\n            case ROUND_NONE:\n                break;\n            case ROUND_FLOOR:\n                instant = iRoundingField.roundFloor(instant);\n                break;\n            case ROUND_CEILING:\n                instant = iRoundingField.roundCeiling(instant);\n                break;\n            case ROUND_HALF_FLOOR:\n                instant = iRoundingField.roundHalfFloor(instant);\n                break;\n            case ROUND_HALF_CEILING:\n                instant = iRoundingField.roundHalfCeiling(instant);\n                break;\n            case ROUND_HALF_EVEN:\n                instant = iRoundingField.roundHalfEven(instant);\n                break;\n        }\n        super.setMillis(instant);\n    }\n\n    /**\n     * Sets the millisecond instant of this instant from another.\n     * <p>\n     * This method does not change the chronology of this instant, just the\n     * millisecond instant.\n     * \n     * @param instant  the instant to use, null means now\n     */\n    public void setMillis(ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        setMillis(instantMillis);  // set via this class not super\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add an amount of time to the datetime.\n     * \n     * @param duration  the millis to add\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(long duration) {\n        setMillis(FieldUtils.safeAdd(getMillis(), duration));  // set via this class not super\n    }\n\n    /**\n     * Adds a duration to this instant.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param duration  the duration to add, null means add zero\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadableDuration duration) {\n        add(duration, 1);\n    }\n\n    /**\n     * Adds a duration to this instant specifying how many times to add.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param duration  the duration to add, null means add zero\n     * @param scalar  direction and amount to add, which may be negative\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadableDuration duration, int scalar) {\n        if (duration != null) {\n            add(FieldUtils.safeMultiply(duration.getMillis(), scalar));\n        }\n    }\n\n    /**\n     * Adds a period to this instant.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param period  the period to add, null means add zero\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadablePeriod period) {\n        add(period, 1);\n    }\n\n    /**\n     * Adds a period to this instant specifying how many times to add.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param period  the period to add, null means add zero\n     * @param scalar  direction and amount to add, which may be negative\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadablePeriod period, int scalar) {\n        if (period != null) {\n            setMillis(getChronology().add(period, getMillis(), scalar));  // set via this class not super\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the chronology of the datetime.\n     * <p>\n     * All changes to the chronology occur via this method.\n     * \n     * @param chronology  the chronology to use, null means ISOChronology in default zone\n     */\n    public void setChronology(Chronology chronology) {\n        super.setChronology(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the time zone of the datetime, changing the chronology and field values.\n     * <p>\n     * Changing the zone using this method retains the millisecond instant.\n     * The millisecond instant is adjusted in the new zone to compensate.\n     * \n     * chronology. Setting the time zone does not affect the millisecond value\n     * of this instant.\n     * <p>\n     * If the chronology already has this time zone, no change occurs.\n     *\n     * @param newZone  the time zone to use, null means default zone\n     * @see #setZoneRetainFields\n     */\n    public void setZone(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        Chronology chrono = getChronology();\n        if (chrono.getZone() != newZone) {\n            setChronology(chrono.withZone(newZone));  // set via this class not super\n        }\n    }\n\n    /**\n     * Sets the time zone of the datetime, changing the chronology and millisecond.\n     * <p>\n     * Changing the zone using this method retains the field values.\n     * The millisecond instant is adjusted in the new zone to compensate.\n     * <p>\n     * If the chronology already has this time zone, no change occurs.\n     *\n     * @param newZone  the time zone to use, null means default zone\n     * @see #setZone\n     */\n    public void setZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        setChronology(getChronology().withZone(newZone));  // set via this class not super\n        setMillis(millis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of one of the fields of the instant, such as hourOfDay.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @param value  the value to set the field to\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public void set(DateTimeFieldType type, int value) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        setMillis(type.getField(getChronology()).set(getMillis(), value));\n    }\n\n    /**\n     * Adds to the instant specifying the duration and multiple to add.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @param amount  the amount to add of this duration\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(DurationFieldType type, int amount) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n            setMillis(type.getField(getChronology()).add(getMillis(), amount));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the year to the specified value.\n     *\n     * @param year  the year\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setYear(final int year) {\n        setMillis(getChronology().year().set(getMillis(), year));\n    }\n\n    /**\n     * Add a number of years to the date.\n     *\n     * @param years  the years to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addYears(final int years) {\n            setMillis(getChronology().years().add(getMillis(), years));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the weekyear to the specified value.\n     *\n     * @param weekyear  the weekyear\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setWeekyear(final int weekyear) {\n        setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }\n\n    /**\n     * Add a number of weekyears to the date.\n     *\n     * @param weekyears  the weekyears to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addWeekyears(final int weekyears) {\n            setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the month of the year to the specified value.\n     *\n     * @param monthOfYear  the month of the year\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMonthOfYear(final int monthOfYear) {\n        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }\n\n    /**\n     * Add a number of months to the date.\n     *\n     * @param months  the months to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addMonths(final int months) {\n            setMillis(getChronology().months().add(getMillis(), months));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the week of weekyear to the specified value.\n     *\n     * @param weekOfWeekyear the week of the weekyear\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setWeekOfWeekyear(final int weekOfWeekyear) {\n        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }\n\n    /**\n     * Add a number of weeks to the date.\n     *\n     * @param weeks  the weeks to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addWeeks(final int weeks) {\n            setMillis(getChronology().weeks().add(getMillis(), weeks));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the day of year to the specified value.\n     *\n     * @param dayOfYear the day of the year\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDayOfYear(final int dayOfYear) {\n        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }\n\n    /**\n     * Set the day of the month to the specified value.\n     *\n     * @param dayOfMonth  the day of the month\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDayOfMonth(final int dayOfMonth) {\n        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }\n\n    /**\n     * Set the day of week to the specified value.\n     *\n     * @param dayOfWeek  the day of the week\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDayOfWeek(final int dayOfWeek) {\n        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }\n\n    /**\n     * Add a number of days to the date.\n     *\n     * @param days  the days to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addDays(final int days) {\n            setMillis(getChronology().days().add(getMillis(), days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the hour of the day to the specified value.\n     *\n     * @param hourOfDay  the hour of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setHourOfDay(final int hourOfDay) {\n        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n    }\n\n    /**\n     * Add a number of hours to the date.\n     *\n     * @param hours  the hours to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addHours(final int hours) {\n            setMillis(getChronology().hours().add(getMillis(), hours));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Set the minute of the day to the specified value.\n     *\n     * @param minuteOfDay  the minute of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMinuteOfDay(final int minuteOfDay) {\n        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n    }\n\n    /**\n     * Set the minute of the hour to the specified value.\n     *\n     * @param minuteOfHour  the minute of hour\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMinuteOfHour(final int minuteOfHour) {\n        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n    }\n\n    /**\n     * Add a number of minutes to the date.\n     *\n     * @param minutes  the minutes to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addMinutes(final int minutes) {\n            setMillis(getChronology().minutes().add(getMillis(), minutes));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the second of the day to the specified value.\n     *\n     * @param secondOfDay  the second of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setSecondOfDay(final int secondOfDay) {\n        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n    }\n\n    /**\n     * Set the second of the minute to the specified value.\n     *\n     * @param secondOfMinute  the second of minute\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setSecondOfMinute(final int secondOfMinute) {\n        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n    }\n\n    /**\n     * Add a number of seconds to the date.\n     *\n     * @param seconds  the seconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addSeconds(final int seconds) {\n            setMillis(getChronology().seconds().add(getMillis(), seconds));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the millis of the day to the specified value.\n     *\n     * @param millisOfDay  the millis of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMillisOfDay(final int millisOfDay) {\n        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n    }\n\n    /**\n     * Set the millis of the second to the specified value.\n     *\n     * @param millisOfSecond  the millis of second\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMillisOfSecond(final int millisOfSecond) {\n        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n    }\n\n    /**\n     * Add a number of milliseconds to the date. The implementation of this\n     * method differs from the {@link #add(long)} method in that a\n     * DateTimeField performs the addition.\n     *\n     * @param millis  the milliseconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addMillis(final int millis) {\n            setMillis(getChronology().millis().add(getMillis(), millis));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the date from milliseconds.\n     * The time part of this object will be unaffected.\n     *\n     * @param instant  an instant to copy the date from, time part ignored\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDate(final long instant) {\n        setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));\n    }\n\n    /**\n     * Set the date from another instant.\n     * The time part of this object will be unaffected.\n     * <p>\n     * If the input is a {@code ReadableDateTime} then it is converted to the\n     * same time-zone as this object before using the instant millis.\n     *\n     * @param instant  an instant to copy the date from, time part ignored\n     * @throws IllegalArgumentException if the object is invalid\n     */\n    public void setDate(final ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        if (instant instanceof ReadableDateTime) {\n            ReadableDateTime rdt = (ReadableDateTime) instant;\n            Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology());\n            DateTimeZone zone = instantChrono.getZone();\n            if (zone != null) {\n                instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis);\n            }\n        }\n        setDate(instantMillis);\n    }\n\n    /**\n     * Set the date from fields.\n     * The time part of this object will be unaffected.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDate(\n            final int year,\n            final int monthOfYear,\n            final int dayOfMonth) {\n        Chronology c = getChronology();\n        long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        setDate(instantMidnight);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the time from milliseconds.\n     * The date part of this object will be unaffected.\n     *\n     * @param millis  an instant to copy the time from, date part ignored\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setTime(final long millis) {\n        int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);\n        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n    }\n\n    /**\n     * Set the time from another instant.\n     * The date part of this object will be unaffected.\n     *\n     * @param instant  an instant to copy the time from, date part ignored\n     * @throws IllegalArgumentException if the object is invalid\n     */\n    public void setTime(final ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);\n        DateTimeZone zone = instantChrono.getZone();\n        if (zone != null) {\n            instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);\n        }\n        setTime(instantMillis);\n    }\n\n    /**\n     * Set the time from fields.\n     * The date part of this object will be unaffected.\n     *\n     * @param hour  the hour\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setTime(\n            final int hour,\n            final int minuteOfHour,\n            final int secondOfMinute,\n            final int millisOfSecond) {\n        long instant = getChronology().getDateTimeMillis(\n            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n        setMillis(instant);\n    }\n\n    /**\n     * Set the date and time from fields.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDateTime(\n            final int year,\n            final int monthOfYear,\n            final int dayOfMonth,\n            final int hourOfDay,\n            final int minuteOfHour,\n            final int secondOfMinute,\n            final int millisOfSecond) {\n        long instant = getChronology().getDateTimeMillis(\n            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        setMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains many useful methods.\n     *\n     * @param type  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @since 1.2\n     */\n    public Property property(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (field.isSupported() == false) {\n            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n        }\n        return new Property(this, field);\n    }\n\n    /**\n     * Get the era property.\n     * \n     * @return the era property\n     */\n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    /**\n     * Get the century of era property.\n     * \n     * @return the year of era property\n     */\n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    /**\n     * Get the year of century property.\n     * \n     * @return the year of era property\n     */\n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    /**\n     * Get the year of era property.\n     * \n     * @return the year of era property\n     */\n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    /**\n     * Get the year property.\n     * \n     * @return the year property\n     */\n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    /**\n     * Get the year of a week based year property.\n     * \n     * @return the year of a week based year property\n     */\n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    /**\n     * Get the month of year property.\n     * \n     * @return the month of year property\n     */\n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    /**\n     * Get the week of a week based year property.\n     * \n     * @return the week of a week based year property\n     */\n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    /**\n     * Get the day of year property.\n     * \n     * @return the day of year property\n     */\n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    /**\n     * Get the day of month property.\n     * <p>\n     * The values for day of month are defined in {@link DateTimeConstants}.\n     * \n     * @return the day of month property\n     */\n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    /**\n     * Get the day of week property.\n     * <p>\n     * The values for day of week are defined in {@link DateTimeConstants}.\n     * \n     * @return the day of week property\n     */\n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the hour of day field property\n     * \n     * @return the hour of day property\n     */\n    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }\n\n    /**\n     * Get the minute of day property\n     * \n     * @return the minute of day property\n     */\n    public Property minuteOfDay() {\n        return new Property(this, getChronology().minuteOfDay());\n    }\n\n    /**\n     * Get the minute of hour field property\n     * \n     * @return the minute of hour property\n     */\n    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }\n\n    /**\n     * Get the second of day property\n     * \n     * @return the second of day property\n     */\n    public Property secondOfDay() {\n        return new Property(this, getChronology().secondOfDay());\n    }\n\n    /**\n     * Get the second of minute field property\n     * \n     * @return the second of minute property\n     */\n    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }\n\n    /**\n     * Get the millis of day property\n     * \n     * @return the millis of day property\n     */\n    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }\n\n    /**\n     * Get the millis of second property\n     * \n     * @return the millis of second property\n     */\n    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */\n    public MutableDateTime copy() {\n        return (MutableDateTime) clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clone this object.\n     *\n     * @return a clone of this object.\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"Clone error\");\n        }\n    }\n\n    /**\n     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).\n     * \n     * @return ISO8601 time formatted string.\n     */\n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n\n    /**\n     * MutableDateTime.Property binds a MutableDateTime to a\n     * DateTimeField allowing powerful datetime functionality to be easily\n     * accessed.\n     * <p>\n     * The example below shows how to use the property to change the value of a\n     * MutableDateTime object.\n     * <pre>\n     * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 13, 32, 19, 123);\n     * dt.year().add(20);\n     * dt.second().roundFloor().minute().set(10);\n     * </pre>\n     * <p>\n     * MutableDateTime.Propery itself is thread-safe and immutable, but the\n     * MutableDateTime being operated on is not.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.0\n     */\n    public static final class Property extends AbstractReadableInstantFieldProperty {\n        \n        /** Serialization version */\n        private static final long serialVersionUID = -4481126543819298617L;\n        \n        /** The instant this property is working against */\n        private MutableDateTime iInstant;\n        /** The field this property is working against */\n        private DateTimeField iField;\n        \n        /**\n         * Constructor.\n         * \n         * @param instant  the instant to set\n         * @param field  the field to use\n         */\n        Property(MutableDateTime instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        /**\n         * Writes the property in a safe serialization format.\n         */\n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        /**\n         * Reads the property from a safe serialization format.\n         */\n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (MutableDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the field being used.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        /**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */\n        protected long getMillis() {\n            return iInstant.getMillis();\n        }\n        \n        /**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */\n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        /**\n         * Gets the mutable datetime being used.\n         * \n         * @return the mutable datetime\n         */\n        public MutableDateTime getMutableDateTime() {\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,int)\n         */\n        public MutableDateTime add(int value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        /**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,long)\n         */\n        public MutableDateTime add(long value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        /**\n         * Adds a value, possibly wrapped, to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#addWrapField\n         */\n        public MutableDateTime addWrapField(int value) {\n            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Sets a value.\n         * \n         * @param value  the value to set.\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#set(long,int)\n         */\n        public MutableDateTime set(int value) {\n            iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        /**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n         */\n        public MutableDateTime set(String text, Locale locale) {\n            iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n            return iInstant;\n        }\n        \n        /**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String)\n         */\n        public MutableDateTime set(String text) {\n            set(text, null);\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Round to the lowest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundFloor\n         */\n        public MutableDateTime roundFloor() {\n            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n            return iInstant;\n        }\n\n        /**\n         * Round to the highest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundCeiling\n         */\n        public MutableDateTime roundCeiling() {\n            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n            return iInstant;\n        }\n        \n        /**\n         * Round to the nearest whole unit of this field, favoring the floor if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfFloor\n         */\n        public MutableDateTime roundHalfFloor() {\n            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n            return iInstant;\n        }\n        \n        /**\n         * Round to the nearest whole unit of this field, favoring the ceiling if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfCeiling\n         */\n        public MutableDateTime roundHalfCeiling() {\n            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n            return iInstant;\n        }\n\n        /**\n         * Round to the nearest whole unit of this field. If halfway, the ceiling\n         * is favored over the floor only if it makes this field's value even.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfEven\n         */\n        public MutableDateTime roundHalfEven() {\n            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n            return iInstant;\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Locale;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseDateTime;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * MutableDateTime is the standard implementation of a modifiable datetime class.\n * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n * <p>\n * This class uses a Chronology internally. The Chronology determines how the\n * millisecond instant value is converted into the date time fields.\n * The default Chronology is <code>ISOChronology</code> which is the agreed\n * international standard and compatible with the modern Gregorian calendar.\n * <p>\n * Each individual field can be accessed in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>get numeric value\n * <li>set numeric value\n * <li>add to numeric value\n * <li>add to numeric value wrapping with the field\n * <li>get text value\n * <li>get short text value\n * <li>set text value\n * <li>field maximum value\n * <li>field minimum value\n * </ul>\n *\n * <p>\n * MutableDateTime is mutable and not thread-safe, unless concurrent threads\n * are not invoking mutator methods.\n *\n * @author Guy Allard\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Mike Schrag\n * @since 1.0\n * @see DateTime\n */\npublic class MutableDateTime\n        extends BaseDateTime\n        implements ReadWritableDateTime, Cloneable, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2852608688135209575L;\n\n    /** Rounding is disabled */\n    public static final int ROUND_NONE = 0;\n    /** Rounding mode as described by {@link DateTimeField#roundFloor} */\n    public static final int ROUND_FLOOR = 1;\n    /** Rounding mode as described by {@link DateTimeField#roundCeiling} */\n    public static final int ROUND_CEILING = 2;\n    /** Rounding mode as described by {@link DateTimeField#roundHalfFloor} */\n    public static final int ROUND_HALF_FLOOR = 3;\n    /** Rounding mode as described by {@link DateTimeField#roundHalfCeiling} */\n    public static final int ROUND_HALF_CEILING = 4;\n    /** Rounding mode as described by {@link DateTimeField#roundHalfEven} */\n    public static final int ROUND_HALF_EVEN = 5;\n\n    /** The field to round on */\n    private DateTimeField iRoundingField;\n    /** The mode of rounding */\n    private int iRoundingMode;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static MutableDateTime now() {\n        return new MutableDateTime();\n    }\n\n    /**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     *\n     * @param zone  the time zone, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static MutableDateTime now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new MutableDateTime(zone);\n    }\n\n    /**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static MutableDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new MutableDateTime(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code MutableDateTime} from the specified string.\n     * <p>\n     * This uses {@link ISODateTimeFormat#dateTimeParser()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static MutableDateTime parse(String str) {\n        return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());\n    }\n\n    /**\n     * Parses a {@code MutableDateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static MutableDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseDateTime(str).toMutableDateTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @see #now()\n     */\n    public MutableDateTime() {\n        super();\n    }\n\n    /**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */\n    public MutableDateTime(DateTimeZone zone) {\n        super(zone);\n    }\n\n    /**\n     * Constructs an instance set to the current system millisecond time\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */\n    public MutableDateTime(Chronology chronology) {\n        super(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */\n    public MutableDateTime(long instant) {\n        super(instant);\n    }\n\n    /**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */\n    public MutableDateTime(long instant, DateTimeZone zone) {\n        super(instant, zone);\n    }\n\n    /**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public MutableDateTime(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used. Otherwise, ISO default is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public MutableDateTime(Object instant) {\n        super(instant, (Chronology) null);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used, but with the time zone adjusted.\n     * Otherwise, ISO is used in the specified time zone.\n     * If the specified time zone is null, the default zone is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @param zone  the time zone, null means default time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public MutableDateTime(Object instant, DateTimeZone zone) {\n        super(instant, zone);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Any chronology implied by the object (such as GregorianCalendar does)\n     * is ignored.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public MutableDateTime(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     */\n    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond) {\n        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n\n    /**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param zone  the time zone, null means default time zone\n     */\n    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            DateTimeZone zone) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n    }\n\n    /**\n     * Constructs an instance from datetime field values\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the field used for rounding this instant, returning null if rounding\n     * is not enabled.\n     * \n     * @return the rounding field\n     */\n    public DateTimeField getRoundingField() {\n        return iRoundingField;\n    }\n\n    /**\n     * Gets the rounding mode for this instant, returning ROUND_NONE if rounding\n     * is not enabled.\n     * \n     * @return the rounding mode constant\n     */\n    public int getRoundingMode() {\n        return iRoundingMode;\n    }\n\n    /**\n     * Sets the status of rounding to use the specified field and ROUND_FLOOR mode.\n     * A null field will disable rounding.\n     * Once set, the instant is then rounded using the new field and mode.\n     * <p>\n     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n     * to be rounded. This can be used to control the precision of the instant,\n     * for example by setting a rounding field of minuteOfDay, the seconds and\n     * milliseconds will always be zero.\n     *\n     * @param field rounding field or null to disable\n     */\n    public void setRounding(DateTimeField field) {\n        setRounding(field, MutableDateTime.ROUND_FLOOR);\n    }\n\n    /**\n     * Sets the status of rounding to use the specified field and mode.\n     * A null field or mode of ROUND_NONE will disable rounding.\n     * Once set, the instant is then rounded using the new field and mode.\n     * <p>\n     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n     * to be rounded. This can be used to control the precision of the instant,\n     * for example by setting a rounding field of minuteOfDay, the seconds and\n     * milliseconds will always be zero.\n     *\n     * @param field  rounding field or null to disable\n     * @param mode  rounding mode or ROUND_NONE to disable\n     * @throws IllegalArgumentException if mode is unknown, no exception if field is null\n     */\n    public void setRounding(DateTimeField field, int mode) {\n        if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {\n            throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);\n        }\n        iRoundingField = (mode == ROUND_NONE ? null : field);\n        iRoundingMode = (field == null ? ROUND_NONE : mode);\n        setMillis(getMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the milliseconds of the datetime.\n     * <p>\n     * All changes to the millisecond field occurs via this method.\n     *\n     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n     * datetime to\n     */\n    public void setMillis(long instant) {\n        switch (iRoundingMode) {\n            case ROUND_NONE:\n                break;\n            case ROUND_FLOOR:\n                instant = iRoundingField.roundFloor(instant);\n                break;\n            case ROUND_CEILING:\n                instant = iRoundingField.roundCeiling(instant);\n                break;\n            case ROUND_HALF_FLOOR:\n                instant = iRoundingField.roundHalfFloor(instant);\n                break;\n            case ROUND_HALF_CEILING:\n                instant = iRoundingField.roundHalfCeiling(instant);\n                break;\n            case ROUND_HALF_EVEN:\n                instant = iRoundingField.roundHalfEven(instant);\n                break;\n        }\n        super.setMillis(instant);\n    }\n\n    /**\n     * Sets the millisecond instant of this instant from another.\n     * <p>\n     * This method does not change the chronology of this instant, just the\n     * millisecond instant.\n     * \n     * @param instant  the instant to use, null means now\n     */\n    public void setMillis(ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        setMillis(instantMillis);  // set via this class not super\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add an amount of time to the datetime.\n     * \n     * @param duration  the millis to add\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(long duration) {\n        setMillis(FieldUtils.safeAdd(getMillis(), duration));  // set via this class not super\n    }\n\n    /**\n     * Adds a duration to this instant.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param duration  the duration to add, null means add zero\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadableDuration duration) {\n        add(duration, 1);\n    }\n\n    /**\n     * Adds a duration to this instant specifying how many times to add.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param duration  the duration to add, null means add zero\n     * @param scalar  direction and amount to add, which may be negative\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadableDuration duration, int scalar) {\n        if (duration != null) {\n            add(FieldUtils.safeMultiply(duration.getMillis(), scalar));\n        }\n    }\n\n    /**\n     * Adds a period to this instant.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param period  the period to add, null means add zero\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadablePeriod period) {\n        add(period, 1);\n    }\n\n    /**\n     * Adds a period to this instant specifying how many times to add.\n     * <p>\n     * This will typically change the value of most fields.\n     *\n     * @param period  the period to add, null means add zero\n     * @param scalar  direction and amount to add, which may be negative\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(ReadablePeriod period, int scalar) {\n        if (period != null) {\n            setMillis(getChronology().add(period, getMillis(), scalar));  // set via this class not super\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the chronology of the datetime.\n     * <p>\n     * All changes to the chronology occur via this method.\n     * \n     * @param chronology  the chronology to use, null means ISOChronology in default zone\n     */\n    public void setChronology(Chronology chronology) {\n        super.setChronology(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the time zone of the datetime, changing the chronology and field values.\n     * <p>\n     * Changing the zone using this method retains the millisecond instant.\n     * The millisecond instant is adjusted in the new zone to compensate.\n     * \n     * chronology. Setting the time zone does not affect the millisecond value\n     * of this instant.\n     * <p>\n     * If the chronology already has this time zone, no change occurs.\n     *\n     * @param newZone  the time zone to use, null means default zone\n     * @see #setZoneRetainFields\n     */\n    public void setZone(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        Chronology chrono = getChronology();\n        if (chrono.getZone() != newZone) {\n            setChronology(chrono.withZone(newZone));  // set via this class not super\n        }\n    }\n\n    /**\n     * Sets the time zone of the datetime, changing the chronology and millisecond.\n     * <p>\n     * Changing the zone using this method retains the field values.\n     * The millisecond instant is adjusted in the new zone to compensate.\n     * <p>\n     * If the chronology already has this time zone, no change occurs.\n     *\n     * @param newZone  the time zone to use, null means default zone\n     * @see #setZone\n     */\n    public void setZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        setChronology(getChronology().withZone(newZone));  // set via this class not super\n        setMillis(millis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of one of the fields of the instant, such as hourOfDay.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @param value  the value to set the field to\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public void set(DateTimeFieldType type, int value) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        setMillis(type.getField(getChronology()).set(getMillis(), value));\n    }\n\n    /**\n     * Adds to the instant specifying the duration and multiple to add.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @param amount  the amount to add of this duration\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public void add(DurationFieldType type, int amount) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (amount != 0) {\n            setMillis(type.getField(getChronology()).add(getMillis(), amount));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the year to the specified value.\n     *\n     * @param year  the year\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setYear(final int year) {\n        setMillis(getChronology().year().set(getMillis(), year));\n    }\n\n    /**\n     * Add a number of years to the date.\n     *\n     * @param years  the years to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addYears(final int years) {\n        if (years != 0) {\n            setMillis(getChronology().years().add(getMillis(), years));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the weekyear to the specified value.\n     *\n     * @param weekyear  the weekyear\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setWeekyear(final int weekyear) {\n        setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }\n\n    /**\n     * Add a number of weekyears to the date.\n     *\n     * @param weekyears  the weekyears to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addWeekyears(final int weekyears) {\n        if (weekyears != 0) {\n            setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the month of the year to the specified value.\n     *\n     * @param monthOfYear  the month of the year\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMonthOfYear(final int monthOfYear) {\n        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }\n\n    /**\n     * Add a number of months to the date.\n     *\n     * @param months  the months to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addMonths(final int months) {\n        if (months != 0) {\n            setMillis(getChronology().months().add(getMillis(), months));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the week of weekyear to the specified value.\n     *\n     * @param weekOfWeekyear the week of the weekyear\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setWeekOfWeekyear(final int weekOfWeekyear) {\n        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }\n\n    /**\n     * Add a number of weeks to the date.\n     *\n     * @param weeks  the weeks to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addWeeks(final int weeks) {\n        if (weeks != 0) {\n            setMillis(getChronology().weeks().add(getMillis(), weeks));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the day of year to the specified value.\n     *\n     * @param dayOfYear the day of the year\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDayOfYear(final int dayOfYear) {\n        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }\n\n    /**\n     * Set the day of the month to the specified value.\n     *\n     * @param dayOfMonth  the day of the month\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDayOfMonth(final int dayOfMonth) {\n        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }\n\n    /**\n     * Set the day of week to the specified value.\n     *\n     * @param dayOfWeek  the day of the week\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDayOfWeek(final int dayOfWeek) {\n        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }\n\n    /**\n     * Add a number of days to the date.\n     *\n     * @param days  the days to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addDays(final int days) {\n        if (days != 0) {\n            setMillis(getChronology().days().add(getMillis(), days));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the hour of the day to the specified value.\n     *\n     * @param hourOfDay  the hour of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setHourOfDay(final int hourOfDay) {\n        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n    }\n\n    /**\n     * Add a number of hours to the date.\n     *\n     * @param hours  the hours to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addHours(final int hours) {\n        if (hours != 0) {\n            setMillis(getChronology().hours().add(getMillis(), hours));\n        }\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Set the minute of the day to the specified value.\n     *\n     * @param minuteOfDay  the minute of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMinuteOfDay(final int minuteOfDay) {\n        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n    }\n\n    /**\n     * Set the minute of the hour to the specified value.\n     *\n     * @param minuteOfHour  the minute of hour\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMinuteOfHour(final int minuteOfHour) {\n        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n    }\n\n    /**\n     * Add a number of minutes to the date.\n     *\n     * @param minutes  the minutes to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addMinutes(final int minutes) {\n        if (minutes != 0) {\n            setMillis(getChronology().minutes().add(getMillis(), minutes));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the second of the day to the specified value.\n     *\n     * @param secondOfDay  the second of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setSecondOfDay(final int secondOfDay) {\n        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n    }\n\n    /**\n     * Set the second of the minute to the specified value.\n     *\n     * @param secondOfMinute  the second of minute\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setSecondOfMinute(final int secondOfMinute) {\n        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n    }\n\n    /**\n     * Add a number of seconds to the date.\n     *\n     * @param seconds  the seconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addSeconds(final int seconds) {\n        if (seconds != 0) {\n            setMillis(getChronology().seconds().add(getMillis(), seconds));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the millis of the day to the specified value.\n     *\n     * @param millisOfDay  the millis of day\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMillisOfDay(final int millisOfDay) {\n        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n    }\n\n    /**\n     * Set the millis of the second to the specified value.\n     *\n     * @param millisOfSecond  the millis of second\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setMillisOfSecond(final int millisOfSecond) {\n        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n    }\n\n    /**\n     * Add a number of milliseconds to the date. The implementation of this\n     * method differs from the {@link #add(long)} method in that a\n     * DateTimeField performs the addition.\n     *\n     * @param millis  the milliseconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void addMillis(final int millis) {\n        if (millis != 0) {\n            setMillis(getChronology().millis().add(getMillis(), millis));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the date from milliseconds.\n     * The time part of this object will be unaffected.\n     *\n     * @param instant  an instant to copy the date from, time part ignored\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDate(final long instant) {\n        setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));\n    }\n\n    /**\n     * Set the date from another instant.\n     * The time part of this object will be unaffected.\n     * <p>\n     * If the input is a {@code ReadableDateTime} then it is converted to the\n     * same time-zone as this object before using the instant millis.\n     *\n     * @param instant  an instant to copy the date from, time part ignored\n     * @throws IllegalArgumentException if the object is invalid\n     */\n    public void setDate(final ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        if (instant instanceof ReadableDateTime) {\n            ReadableDateTime rdt = (ReadableDateTime) instant;\n            Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology());\n            DateTimeZone zone = instantChrono.getZone();\n            if (zone != null) {\n                instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis);\n            }\n        }\n        setDate(instantMillis);\n    }\n\n    /**\n     * Set the date from fields.\n     * The time part of this object will be unaffected.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDate(\n            final int year,\n            final int monthOfYear,\n            final int dayOfMonth) {\n        Chronology c = getChronology();\n        long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        setDate(instantMidnight);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the time from milliseconds.\n     * The date part of this object will be unaffected.\n     *\n     * @param millis  an instant to copy the time from, date part ignored\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setTime(final long millis) {\n        int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);\n        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n    }\n\n    /**\n     * Set the time from another instant.\n     * The date part of this object will be unaffected.\n     *\n     * @param instant  an instant to copy the time from, date part ignored\n     * @throws IllegalArgumentException if the object is invalid\n     */\n    public void setTime(final ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);\n        DateTimeZone zone = instantChrono.getZone();\n        if (zone != null) {\n            instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);\n        }\n        setTime(instantMillis);\n    }\n\n    /**\n     * Set the time from fields.\n     * The date part of this object will be unaffected.\n     *\n     * @param hour  the hour\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setTime(\n            final int hour,\n            final int minuteOfHour,\n            final int secondOfMinute,\n            final int millisOfSecond) {\n        long instant = getChronology().getDateTimeMillis(\n            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n        setMillis(instant);\n    }\n\n    /**\n     * Set the date and time from fields.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public void setDateTime(\n            final int year,\n            final int monthOfYear,\n            final int dayOfMonth,\n            final int hourOfDay,\n            final int minuteOfHour,\n            final int secondOfMinute,\n            final int millisOfSecond) {\n        long instant = getChronology().getDateTimeMillis(\n            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        setMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains many useful methods.\n     *\n     * @param type  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @since 1.2\n     */\n    public Property property(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (field.isSupported() == false) {\n            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n        }\n        return new Property(this, field);\n    }\n\n    /**\n     * Get the era property.\n     * \n     * @return the era property\n     */\n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    /**\n     * Get the century of era property.\n     * \n     * @return the year of era property\n     */\n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    /**\n     * Get the year of century property.\n     * \n     * @return the year of era property\n     */\n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    /**\n     * Get the year of era property.\n     * \n     * @return the year of era property\n     */\n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    /**\n     * Get the year property.\n     * \n     * @return the year property\n     */\n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    /**\n     * Get the year of a week based year property.\n     * \n     * @return the year of a week based year property\n     */\n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    /**\n     * Get the month of year property.\n     * \n     * @return the month of year property\n     */\n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    /**\n     * Get the week of a week based year property.\n     * \n     * @return the week of a week based year property\n     */\n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    /**\n     * Get the day of year property.\n     * \n     * @return the day of year property\n     */\n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    /**\n     * Get the day of month property.\n     * <p>\n     * The values for day of month are defined in {@link DateTimeConstants}.\n     * \n     * @return the day of month property\n     */\n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    /**\n     * Get the day of week property.\n     * <p>\n     * The values for day of week are defined in {@link DateTimeConstants}.\n     * \n     * @return the day of week property\n     */\n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the hour of day field property\n     * \n     * @return the hour of day property\n     */\n    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }\n\n    /**\n     * Get the minute of day property\n     * \n     * @return the minute of day property\n     */\n    public Property minuteOfDay() {\n        return new Property(this, getChronology().minuteOfDay());\n    }\n\n    /**\n     * Get the minute of hour field property\n     * \n     * @return the minute of hour property\n     */\n    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }\n\n    /**\n     * Get the second of day property\n     * \n     * @return the second of day property\n     */\n    public Property secondOfDay() {\n        return new Property(this, getChronology().secondOfDay());\n    }\n\n    /**\n     * Get the second of minute field property\n     * \n     * @return the second of minute property\n     */\n    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }\n\n    /**\n     * Get the millis of day property\n     * \n     * @return the millis of day property\n     */\n    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }\n\n    /**\n     * Get the millis of second property\n     * \n     * @return the millis of second property\n     */\n    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */\n    public MutableDateTime copy() {\n        return (MutableDateTime) clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clone this object.\n     *\n     * @return a clone of this object.\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"Clone error\");\n        }\n    }\n\n    /**\n     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).\n     * \n     * @return ISO8601 time formatted string.\n     */\n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n\n    /**\n     * MutableDateTime.Property binds a MutableDateTime to a\n     * DateTimeField allowing powerful datetime functionality to be easily\n     * accessed.\n     * <p>\n     * The example below shows how to use the property to change the value of a\n     * MutableDateTime object.\n     * <pre>\n     * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 13, 32, 19, 123);\n     * dt.year().add(20);\n     * dt.second().roundFloor().minute().set(10);\n     * </pre>\n     * <p>\n     * MutableDateTime.Propery itself is thread-safe and immutable, but the\n     * MutableDateTime being operated on is not.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.0\n     */\n    public static final class Property extends AbstractReadableInstantFieldProperty {\n        \n        /** Serialization version */\n        private static final long serialVersionUID = -4481126543819298617L;\n        \n        /** The instant this property is working against */\n        private MutableDateTime iInstant;\n        /** The field this property is working against */\n        private DateTimeField iField;\n        \n        /**\n         * Constructor.\n         * \n         * @param instant  the instant to set\n         * @param field  the field to use\n         */\n        Property(MutableDateTime instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        /**\n         * Writes the property in a safe serialization format.\n         */\n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        /**\n         * Reads the property from a safe serialization format.\n         */\n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (MutableDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the field being used.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        /**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */\n        protected long getMillis() {\n            return iInstant.getMillis();\n        }\n        \n        /**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */\n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        /**\n         * Gets the mutable datetime being used.\n         * \n         * @return the mutable datetime\n         */\n        public MutableDateTime getMutableDateTime() {\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,int)\n         */\n        public MutableDateTime add(int value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        /**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,long)\n         */\n        public MutableDateTime add(long value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        /**\n         * Adds a value, possibly wrapped, to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#addWrapField\n         */\n        public MutableDateTime addWrapField(int value) {\n            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Sets a value.\n         * \n         * @param value  the value to set.\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#set(long,int)\n         */\n        public MutableDateTime set(int value) {\n            iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n            return iInstant;\n        }\n        \n        /**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n         */\n        public MutableDateTime set(String text, Locale locale) {\n            iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n            return iInstant;\n        }\n        \n        /**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String)\n         */\n        public MutableDateTime set(String text) {\n            set(text, null);\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Round to the lowest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundFloor\n         */\n        public MutableDateTime roundFloor() {\n            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n            return iInstant;\n        }\n\n        /**\n         * Round to the highest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundCeiling\n         */\n        public MutableDateTime roundCeiling() {\n            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n            return iInstant;\n        }\n        \n        /**\n         * Round to the nearest whole unit of this field, favoring the floor if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfFloor\n         */\n        public MutableDateTime roundHalfFloor() {\n            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n            return iInstant;\n        }\n        \n        /**\n         * Round to the nearest whole unit of this field, favoring the ceiling if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfCeiling\n         */\n        public MutableDateTime roundHalfCeiling() {\n            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n            return iInstant;\n        }\n\n        /**\n         * Round to the nearest whole unit of this field. If halfway, the ceiling\n         * is favored over the floor only if it makes this field's value even.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfEven\n         */\n        public MutableDateTime roundHalfEven() {\n            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n            return iInstant;\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 4, "classes_modified": [{"class_name": "org.joda.time.Partial", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1\n */\npublic final class Partial\n        extends AbstractPartial\n        implements ReadablePartial, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 12324121189002L;\n\n    /** The chronology in use. */\n    private final Chronology iChronology;\n    /** The set of field types. */\n    private final DateTimeFieldType[] iTypes;\n    /** The values of each field in this partial. */\n    private final int[] iValues;\n    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n    private transient DateTimeFormatter[] iFormatter;\n\n    // Constructors\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */\n    public Partial() {\n        this((Chronology) null);\n    }\n\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */\n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    /**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */\n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    /**\n     * Constructs a Partial with the specified values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param partial  the partial to copy\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    /**\n     * Constructs a Partial with the specified chronology, fields and values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param chronology  the chronology\n     * @param types  the types to create the partial from\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */\n    public int size() {\n        return iTypes.length;\n    }\n\n    /**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * \n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    /**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    /**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Does this partial match the specified instant.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified instant.\n     *\n     * @param instant  an instant to check against, null means now in default zone\n     * @return true if this partial matches the specified instant\n     */\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */\n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date in an appropriate ISO8601 format.\n     * <p>\n     * This method will output the partial in one of two ways.\n     * If {@link #getFormatter()}\n     * <p>\n     * If there is no appropriate ISO format a dump of the fields is output\n     * via {@link #toStringList()}.\n     * \n     * @return ISO8601 formatted string\n     */\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    /**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1\n     */\n    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 53278362873888L;\n\n        /** The partial */\n        private final Partial iPartial;\n        /** The field index */\n        private final int iFieldIndex;\n\n        /**\n         * Constructs a property.\n         * \n         * @param partial  the partial instance\n         * @param fieldIndex  the index in the partial\n         */\n        Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        /**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        /**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.joda.time.base.AbstractPartial;\nimport org.joda.time.field.AbstractPartialFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1\n */\npublic final class Partial\n        extends AbstractPartial\n        implements ReadablePartial, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 12324121189002L;\n\n    /** The chronology in use. */\n    private final Chronology iChronology;\n    /** The set of field types. */\n    private final DateTimeFieldType[] iTypes;\n    /** The values of each field in this partial. */\n    private final int[] iValues;\n    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n    private transient DateTimeFormatter[] iFormatter;\n\n    // Constructors\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */\n    public Partial() {\n        this((Chronology) null);\n    }\n\n    /**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */\n    public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */\n    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }\n\n    /**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n    /**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */\n    public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }\n\n    /**\n     * Constructs a Partial with the specified values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param partial  the partial to copy\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Partial partial, int[] values) {\n        super();\n        iChronology = partial.iChronology;\n        iTypes = partial.iTypes;\n        iValues = values;\n    }\n\n    /**\n     * Constructs a Partial with the specified chronology, fields and values.\n     * This constructor assigns and performs no validation.\n     * \n     * @param chronology  the chronology\n     * @param types  the types to create the partial from\n     * @param values  the values to store\n     * @throws IllegalArgumentException if the types or values are invalid\n     */\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */\n    public int size() {\n        return iTypes.length;\n    }\n\n    /**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * \n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n\n    /**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    /**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    /**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Does this partial match the specified instant.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified instant.\n     *\n     * @param instant  an instant to check against, null means now in default zone\n     * @return true if this partial matches the specified instant\n     */\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */\n    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date in an appropriate ISO8601 format.\n     * <p>\n     * This method will output the partial in one of two ways.\n     * If {@link #getFormatter()}\n     * <p>\n     * If there is no appropriate ISO format a dump of the fields is output\n     * via {@link #toStringList()}.\n     * \n     * @return ISO8601 formatted string\n     */\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }\n\n    /**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1\n     */\n    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 53278362873888L;\n\n        /** The partial */\n        private final Partial iPartial;\n        /** The field index */\n        private final int iFieldIndex;\n\n        /**\n         * Constructs a property.\n         * \n         * @param partial  the partial instance\n         * @param fieldIndex  the index in the partial\n         */\n        Property(Partial partial, int fieldIndex) {\n            super();\n            iPartial = partial;\n            iFieldIndex = fieldIndex;\n        }\n\n        /**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */\n        public Partial getPartial() {\n            return iPartial;\n        }\n\n        /**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }\n\n        /**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n\n        /**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 5, "classes_modified": [{"class_name": "org.joda.time.Period", "buggy_version": "/*\n *  Copyright 2001-2010 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\n\nimport org.joda.convert.FromString;\nimport org.joda.time.base.BasePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.ISOPeriodFormat;\nimport org.joda.time.format.PeriodFormatter;\n\n/**\n * An immutable time period specifying a set of duration field values.\n * <p>\n * A time period is divided into a number of fields, such as hours and seconds.\n * Which fields are supported is defined by the PeriodType class.\n * The default is the standard period type, which supports years, months, weeks, days,\n * hours, minutes, seconds and millis.\n * <p>\n * When this time period is added to an instant, the effect is of adding each field in turn.\n * As a result, this takes into account daylight savings time.\n * Adding a time period of 1 day to the day before daylight savings starts will only add\n * 23 hours rather than 24 to ensure that the time remains the same.\n * If this is not the behaviour you want, then see {@link Duration}.\n * <p>\n * The definition of a period also affects the equals method. A period of 1\n * day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes.\n * This is because periods represent an abstracted definition of a time period\n * (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight\n * savings boundary). To compare the actual duration of two periods, convert\n * both to durations using toDuration, an operation that emphasises that the\n * result may differ according to the date you choose.\n * <p>\n * Period is thread-safe and immutable, provided that the PeriodType is as well.\n * All standard PeriodType classes supplied are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see MutablePeriod\n */\npublic final class Period\n        extends BasePeriod\n        implements ReadablePeriod, Serializable {\n\n    /**\n     * A period of zero length and standard period type.\n     * @since 1.4\n     */\n    public static final Period ZERO = new Period();\n\n    /** Serialization version */\n    private static final long serialVersionUID = 741052353876488155L;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code Period} from the specified string.\n     * <p>\n     * This uses {@link ISOPeriodFormat#standard()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static Period parse(String str) {\n        return parse(str, ISOPeriodFormat.standard());\n    }\n\n    /**\n     * Parses a {@code Period} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static Period parse(String str, PeriodFormatter formatter) {\n        return formatter.parsePeriod(str);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Create a period with a specified number of years.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.years(2).withMonths(6);</code>\n     * <p>\n     * If you want a year-based period that cannot have other fields added,\n     * then you should consider using {@link Years}.\n     *\n     * @param years  the amount of years in this period\n     * @return the period\n     */\n    public static Period years(int years) {\n        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of months.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as years or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.months(2).withDays(6);</code>\n     * <p>\n     * If you want a month-based period that cannot have other fields added,\n     * then you should consider using {@link Months}.\n     *\n     * @param months  the amount of months in this period\n     * @return the period\n     */\n    public static Period months(int months) {\n        return new Period(new int[] {0, months, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of weeks.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.weeks(2).withDays(6);</code>\n     * <p>\n     * If you want a week-based period that cannot have other fields added,\n     * then you should consider using {@link Weeks}.\n     *\n     * @param weeks  the amount of weeks in this period\n     * @return the period\n     */\n    public static Period weeks(int weeks) {\n        return new Period(new int[] {0, 0, weeks, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of days.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or weeks using the <code>withXxx()</code> methods.\n     * For example, <code>Period.days(2).withHours(6);</code>\n     * <p>\n     * If you want a day-based period that cannot have other fields added,\n     * then you should consider using {@link Days}.\n     *\n     * @param days  the amount of days in this period\n     * @return the period\n     */\n    public static Period days(int days) {\n        return new Period(new int[] {0, 0, 0, days, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of hours.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.hours(2).withMinutes(30);</code>\n     * <p>\n     * If you want a hour-based period that cannot have other fields added,\n     * then you should consider using {@link Hours}.\n     *\n     * @param hours  the amount of hours in this period\n     * @return the period\n     */\n    public static Period hours(int hours) {\n        return new Period(new int[] {0, 0, 0, 0, hours, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of minutes.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.minutes(2).withSeconds(30);</code>\n     * <p>\n     * If you want a minute-based period that cannot have other fields added,\n     * then you should consider using {@link Minutes}.\n     *\n     * @param minutes  the amount of minutes in this period\n     * @return the period\n     */\n    public static Period minutes(int minutes) {\n        return new Period(new int[] {0, 0, 0, 0, 0, minutes, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of seconds.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.seconds(2).withMillis(30);</code>\n     * <p>\n     * If you want a second-based period that cannot have other fields added,\n     * then you should consider using {@link Seconds}.\n     *\n     * @param seconds  the amount of seconds in this period\n     * @return the period\n     */\n    public static Period seconds(int seconds) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of millis.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.millis(20).withSeconds(30);</code>\n     *\n     * @param millis  the amount of millis in this period\n     * @return the period\n     */\n    public static Period millis(int millis) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a period from two partially specified times, calculating\n     * by field difference.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each. Also, the partial may not contain overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     * <p>\n     * Calculation by field difference works by extracting the difference\n     * one field at a time and not wrapping into other fields.\n     * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.\n     * <p>\n     * For example, you have an event that always runs from the 27th of\n     * each month to the 2nd of the next month. If you calculate this\n     * period using a standard constructor, then you will get between\n     * P3D and P6D depending on the month. If you use this method, then\n     * you will get P1M-25D. This field-difference based period can\n     * be successfully applied to each month of the year to obtain the\n     * correct end date for a given start date.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            if (i > 0 && types[i - 1] == types[i]) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return new Period(values, PeriodType.forFields(types));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new empty period with the standard set of fields.\n     * <p>\n     * One way to initialise a period is as follows:\n     * <pre>\n     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);\n     * </pre>\n     * Bear in mind that this creates four period instances in total, three of\n     * which are immediately discarded.\n     * The alterative is more efficient, but less readable:\n     * <pre>\n     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);\n     * </pre>\n     * The following is also slightly less wasteful:\n     * <pre>\n     * Period = Period.years(6).withMonths(3).withSeconds(23);\n     * </pre>\n     */\n    public Period() {\n        super(0L, null, null);\n    }\n\n    /**\n     * Create a period from a set of field values using the standard set of fields.\n     * Note that the parameters specify the time fields hours, minutes,\n     * seconds and millis, not the date fields.\n     *\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */\n    public Period(int hours, int minutes, int seconds, int millis) {\n        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n    }\n\n    /**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param years  amount of years in this period\n     * @param months  amount of months in this period\n     * @param weeks  amount of weeks in this period\n     * @param days  amount of days in this period\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */\n    public Period(int years, int months, int weeks, int days,\n                  int hours, int minutes, int seconds, int millis) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n    }\n\n    /**\n     * Create a period from a set of field values.\n     * <p>\n     * There is usually little need to use this constructor.\n     * The period type is used primarily to define how to split an interval into a period.\n     * As this constructor already is split, the period type does no real work.\n     *\n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @param type  which set of fields this period supports, null means AllType\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    public Period(int years, int months, int weeks, int days,\n                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * For the standard period type this is the time fields only.\n     * Thus the year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available precise field, hours in this case.\n     * <p>\n     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n     * ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you have two options:\n     * <ul>\n     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n     * <li>specify a period type that contains precise definitions of the day and larger\n     * fields, such as UTC\n     * </ul>\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    public Period(long duration) {\n        super(duration);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(long duration, PeriodType type) {\n        super(duration, type, null);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */\n    public Period(long duration, Chronology chronology) {\n        super(duration, null, chronology);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */\n    public Period(long duration, PeriodType type, Chronology chronology) {\n        super(duration, type, chronology);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     */\n    public Period(long startInstant, long endInstant) {\n        super(startInstant, endInstant, null, null);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(long startInstant, long endInstant, PeriodType type) {\n        super(startInstant, endInstant, type, null);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */\n    public Period(long startInstant, long endInstant, Chronology chrono) {\n        super(startInstant, endInstant, null, chrono);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */\n    public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super(startInstant, endInstant, type, chrono);\n    }\n\n    /**\n     * Creates a period between the given instants using the standard set of fields.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days\n     * (exposed as 4 weeks and 2 days).\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     */\n    public Period(ReadableInstant startInstant, ReadableInstant endInstant) {\n        super(startInstant, endInstant, null);\n    }\n\n    /**\n     * Creates a period between the given instants.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super(startInstant, endInstant, type);\n    }\n\n    /**\n     * Creates a period from two partially specified times.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days\n     * (exposed as 4 weeks and 2 days).\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     * <p>\n     * An alternative way of constructing a Period from two Partials\n     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n     * That method handles all kinds of partials.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    public Period(ReadablePartial start, ReadablePartial end) {\n        super(start, end, null);\n    }\n\n    /**\n     * Creates a period from two partially specified times.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     * <p>\n     * An alternative way of constructing a Period from two Partials\n     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n     * That method handles all kinds of partials.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    public Period(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super(start, end, type);\n    }\n\n    /**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     */\n    public Period(ReadableInstant startInstant, ReadableDuration duration) {\n        super(startInstant, duration, null);\n    }\n\n    /**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super(startInstant, duration, type);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     */\n    public Period(ReadableDuration duration, ReadableInstant endInstant) {\n        super(duration, endInstant, null);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super(duration, endInstant, type);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period) {\n        super(period, null, null);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period, PeriodType type) {\n        super(period, type, null);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period, Chronology chrono) {\n        super(period, null, chrono);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period, PeriodType type, Chronology chrono) {\n        super(period, type, chrono);\n    }\n\n    /**\n     * Constructor used when we trust ourselves.\n     *\n     * @param values  the values to use, not null, not cloned\n     * @param type  which set of fields this period supports, not null\n     */\n    private Period(int[] values, PeriodType type) {\n        super(values, type);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get this period as an immutable <code>Period</code> object\n     * by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */\n    public Period toPeriod() {\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the years field part of the period.\n     * \n     * @return the number of years in the period, zero if unsupported\n     */\n    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n\n    /**\n     * Gets the months field part of the period.\n     * \n     * @return the number of months in the period, zero if unsupported\n     */\n    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n\n    /**\n     * Gets the weeks field part of the period.\n     * \n     * @return the number of weeks in the period, zero if unsupported\n     */\n    public int getWeeks() {\n        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }\n\n    /**\n     * Gets the days field part of the period.\n     * \n     * @return the number of days in the period, zero if unsupported\n     */\n    public int getDays() {\n        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hours field part of the period.\n     * \n     * @return the number of hours in the period, zero if unsupported\n     */\n    public int getHours() {\n        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }\n\n    /**\n     * Gets the minutes field part of the period.\n     * \n     * @return the number of minutes in the period, zero if unsupported\n     */\n    public int getMinutes() {\n        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }\n\n    /**\n     * Gets the seconds field part of the period.\n     * \n     * @return the number of seconds in the period, zero if unsupported\n     */\n    public int getSeconds() {\n        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }\n\n    /**\n     * Gets the millis field part of the period.\n     * \n     * @return the number of millis in the period, zero if unsupported\n     */\n    public int getMillis() {\n        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Period instance with the same field values but\n     * different PeriodType.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param type  the period type to use, null means standard\n     * @return the new period instance\n     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n     */\n    public Period withPeriodType(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        if (type.equals(getPeriodType())) {\n            return this;\n        }\n        return new Period(this, type);\n    }\n\n    /**\n     * Creates a new Period instance with the fields from the specified period\n     * copied on top of those from this period.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param period  the period to copy from, null ignored\n     * @return the new period instance\n     * @throws IllegalArgumentException if a field type is unsupported\n     */\n    public Period withFields(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] newValues = getValues();  // cloned\n        newValues = super.mergePeriodInto(newValues, period);\n        return new Period(newValues, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Period instance with the specified field set to a new value.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to set to\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */\n    public Period withField(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        int[] newValues = getValues();  // cloned\n        super.setFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }\n\n    /**\n     * Creates a new Period instance with the valueToAdd added to the specified field.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to add\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */\n    public Period withFieldAdded(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (value == 0) {\n            return this;\n        }\n        int[] newValues = getValues();  // cloned\n        super.addFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified number of years.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withYears(int years) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of months.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period with the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withMonths(int months) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of weeks.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period with the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withWeeks(int weeks) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of days.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period with the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withDays(int days) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of hours.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period with the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withHours(int hours) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of minutes.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period with the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withMinutes(int minutes) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of seconds.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period with the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withSeconds(int seconds) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of millis.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period with the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withMillis(int millis) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified period added.\n     * <p>\n     * Each field of the period is added separately. Thus a period of\n     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */\n    public Period plus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified number of years added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of months added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period plus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of weeks added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period plus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of days added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period plus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of hours added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period plus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of minutes added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period plus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of seconds added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period plus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of millis added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period plus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified period subtracted.\n     * <p>\n     * Each field of the period is subtracted separately. Thus a period of\n     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */\n    public Period minus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified number of years taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusYears(int years) {\n        return plusYears(-years);\n    }\n\n    /**\n     * Returns a new period minus the specified number of months taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative\n     * @return the new period minus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusMonths(int months) {\n        return plusMonths(-months);\n    }\n\n    /**\n     * Returns a new period minus the specified number of weeks taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative\n     * @return the new period minus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusWeeks(int weeks) {\n        return plusWeeks(-weeks);\n    }\n\n    /**\n     * Returns a new period minus the specified number of days taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative\n     * @return the new period minus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusDays(int days) {\n        return plusDays(-days);\n    }\n\n    /**\n     * Returns a new period minus the specified number of hours taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative\n     * @return the new period minus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusHours(int hours) {\n        return plusHours(-hours);\n    }\n\n    /**\n     * Returns a new period minus the specified number of minutes taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative\n     * @return the new period minus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusMinutes(int minutes) {\n        return plusMinutes(-minutes);\n    }\n\n    /**\n     * Returns a new period minus the specified number of seconds taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative\n     * @return the new period minus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusSeconds(int seconds) {\n        return plusSeconds(-seconds);\n    }\n\n    /**\n     * Returns a new period minus the specified number of millis taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to take away, may be negative\n     * @return the new period minus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusMillis(int millis) {\n        return plusMillis(-millis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * @param scalar  the scalar to multiply by, not null\n     * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null\n     * @throws ArithmeticException if the capacity of any field is exceeded\n     * @since 2.1\n     */\n    public Period multipliedBy(int scalar) {\n        if (this == ZERO || scalar == 1) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        for (int i = 0; i < values.length; i++) {\n            values[i] = FieldUtils.safeMultiply(values[i], scalar);\n        }\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return a {@code Period} based on this period with the amounts negated, never null\n     * @throws ArithmeticException if any field has the minimum value\n     * @since 2.1\n     */\n    public Period negated() {\n        return multipliedBy(-1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this period to a period in weeks assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard weeks in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of weeks is too large to be represented\n     * @since 1.5\n     */\n    public Weeks toStandardWeeks() {\n        checkYearsAndMonths(\"Weeks\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n        long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n        return Weeks.weeks(FieldUtils.safeToInt(weeks));\n    }\n\n    /**\n     * Converts this period to a period in days assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard days in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of days is too large to be represented\n     * @since 1.5\n     */\n    public Days toStandardDays() {\n        checkYearsAndMonths(\"Days\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n        days = FieldUtils.safeAdd(days, getDays());\n        days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n        return Days.days(FieldUtils.safeToInt(days));\n    }\n\n    /**\n     * Converts this period to a period in hours assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard hours in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of hours is too large to be represented\n     * @since 1.5\n     */\n    public Hours toStandardHours() {\n        checkYearsAndMonths(\"Hours\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n        hours = FieldUtils.safeAdd(hours, getHours());\n        hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n        hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n        return Hours.hours(FieldUtils.safeToInt(hours));\n    }\n\n    /**\n     * Converts this period to a period in minutes assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard minutes in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     * @since 1.5\n     */\n    public Minutes toStandardMinutes() {\n        checkYearsAndMonths(\"Minutes\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n        minutes = FieldUtils.safeAdd(minutes, getMinutes());\n        minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n        minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n        minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n    }\n\n    /**\n     * Converts this period to a period in seconds assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard seconds in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     * @since 1.5\n     */\n    public Seconds toStandardSeconds() {\n        checkYearsAndMonths(\"Seconds\");\n        long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n        seconds = FieldUtils.safeAdd(seconds, getSeconds());\n        seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this period to a duration assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a duration equivalent to this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @since 1.5\n     */\n    public Duration toStandardDuration() {\n        checkYearsAndMonths(\"Duration\");\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        return new Duration(millis);\n    }\n\n    /**\n     * Check that there are no years or months in the period.\n     * \n     * @param destintionType  the destination type, not null\n     * @throws UnsupportedOperationException if the period contains years or months\n     */\n    private void checkYearsAndMonths(String destintionType) {\n        if (getMonths() != 0) {\n            throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains months and months vary in length\");\n        }\n        if (getYears() != 0) {\n            throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains years and years vary in length\");\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The result will always have a <code>PeriodType</code> of standard, thus\n     * days will be grouped into weeks.\n     * \n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @since 1.5\n     */\n    public Period normalizedStandard() {\n        return normalizedStandard(PeriodType.standard());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            if (years != 0) {\n                result = result.withYears(years);\n            }\n            if (months != 0) {\n                result = result.withMonths(months);\n            }\n        }\n        return result;\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2010 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.Serializable;\n\nimport org.joda.convert.FromString;\nimport org.joda.time.base.BasePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.ISOPeriodFormat;\nimport org.joda.time.format.PeriodFormatter;\n\n/**\n * An immutable time period specifying a set of duration field values.\n * <p>\n * A time period is divided into a number of fields, such as hours and seconds.\n * Which fields are supported is defined by the PeriodType class.\n * The default is the standard period type, which supports years, months, weeks, days,\n * hours, minutes, seconds and millis.\n * <p>\n * When this time period is added to an instant, the effect is of adding each field in turn.\n * As a result, this takes into account daylight savings time.\n * Adding a time period of 1 day to the day before daylight savings starts will only add\n * 23 hours rather than 24 to ensure that the time remains the same.\n * If this is not the behaviour you want, then see {@link Duration}.\n * <p>\n * The definition of a period also affects the equals method. A period of 1\n * day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes.\n * This is because periods represent an abstracted definition of a time period\n * (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight\n * savings boundary). To compare the actual duration of two periods, convert\n * both to durations using toDuration, an operation that emphasises that the\n * result may differ according to the date you choose.\n * <p>\n * Period is thread-safe and immutable, provided that the PeriodType is as well.\n * All standard PeriodType classes supplied are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see MutablePeriod\n */\npublic final class Period\n        extends BasePeriod\n        implements ReadablePeriod, Serializable {\n\n    /**\n     * A period of zero length and standard period type.\n     * @since 1.4\n     */\n    public static final Period ZERO = new Period();\n\n    /** Serialization version */\n    private static final long serialVersionUID = 741052353876488155L;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code Period} from the specified string.\n     * <p>\n     * This uses {@link ISOPeriodFormat#standard()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static Period parse(String str) {\n        return parse(str, ISOPeriodFormat.standard());\n    }\n\n    /**\n     * Parses a {@code Period} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static Period parse(String str, PeriodFormatter formatter) {\n        return formatter.parsePeriod(str);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Create a period with a specified number of years.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.years(2).withMonths(6);</code>\n     * <p>\n     * If you want a year-based period that cannot have other fields added,\n     * then you should consider using {@link Years}.\n     *\n     * @param years  the amount of years in this period\n     * @return the period\n     */\n    public static Period years(int years) {\n        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of months.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as years or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.months(2).withDays(6);</code>\n     * <p>\n     * If you want a month-based period that cannot have other fields added,\n     * then you should consider using {@link Months}.\n     *\n     * @param months  the amount of months in this period\n     * @return the period\n     */\n    public static Period months(int months) {\n        return new Period(new int[] {0, months, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of weeks.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.weeks(2).withDays(6);</code>\n     * <p>\n     * If you want a week-based period that cannot have other fields added,\n     * then you should consider using {@link Weeks}.\n     *\n     * @param weeks  the amount of weeks in this period\n     * @return the period\n     */\n    public static Period weeks(int weeks) {\n        return new Period(new int[] {0, 0, weeks, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of days.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or weeks using the <code>withXxx()</code> methods.\n     * For example, <code>Period.days(2).withHours(6);</code>\n     * <p>\n     * If you want a day-based period that cannot have other fields added,\n     * then you should consider using {@link Days}.\n     *\n     * @param days  the amount of days in this period\n     * @return the period\n     */\n    public static Period days(int days) {\n        return new Period(new int[] {0, 0, 0, days, 0, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of hours.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.hours(2).withMinutes(30);</code>\n     * <p>\n     * If you want a hour-based period that cannot have other fields added,\n     * then you should consider using {@link Hours}.\n     *\n     * @param hours  the amount of hours in this period\n     * @return the period\n     */\n    public static Period hours(int hours) {\n        return new Period(new int[] {0, 0, 0, 0, hours, 0, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of minutes.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.minutes(2).withSeconds(30);</code>\n     * <p>\n     * If you want a minute-based period that cannot have other fields added,\n     * then you should consider using {@link Minutes}.\n     *\n     * @param minutes  the amount of minutes in this period\n     * @return the period\n     */\n    public static Period minutes(int minutes) {\n        return new Period(new int[] {0, 0, 0, 0, 0, minutes, 0, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of seconds.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.seconds(2).withMillis(30);</code>\n     * <p>\n     * If you want a second-based period that cannot have other fields added,\n     * then you should consider using {@link Seconds}.\n     *\n     * @param seconds  the amount of seconds in this period\n     * @return the period\n     */\n    public static Period seconds(int seconds) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n    }\n\n    /**\n     * Create a period with a specified number of millis.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.millis(20).withSeconds(30);</code>\n     *\n     * @param millis  the amount of millis in this period\n     * @return the period\n     */\n    public static Period millis(int millis) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a period from two partially specified times, calculating\n     * by field difference.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each. Also, the partial may not contain overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     * <p>\n     * Calculation by field difference works by extracting the difference\n     * one field at a time and not wrapping into other fields.\n     * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.\n     * <p>\n     * For example, you have an event that always runs from the 27th of\n     * each month to the 2nd of the next month. If you calculate this\n     * period using a standard constructor, then you will get between\n     * P3D and P6D depending on the month. If you use this method, then\n     * you will get P1M-25D. This field-difference based period can\n     * be successfully applied to each month of the year to obtain the\n     * correct end date for a given start date.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            if (i > 0 && types[i - 1] == types[i]) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return new Period(values, PeriodType.forFields(types));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new empty period with the standard set of fields.\n     * <p>\n     * One way to initialise a period is as follows:\n     * <pre>\n     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);\n     * </pre>\n     * Bear in mind that this creates four period instances in total, three of\n     * which are immediately discarded.\n     * The alterative is more efficient, but less readable:\n     * <pre>\n     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);\n     * </pre>\n     * The following is also slightly less wasteful:\n     * <pre>\n     * Period = Period.years(6).withMonths(3).withSeconds(23);\n     * </pre>\n     */\n    public Period() {\n        super(0L, null, null);\n    }\n\n    /**\n     * Create a period from a set of field values using the standard set of fields.\n     * Note that the parameters specify the time fields hours, minutes,\n     * seconds and millis, not the date fields.\n     *\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */\n    public Period(int hours, int minutes, int seconds, int millis) {\n        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n    }\n\n    /**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param years  amount of years in this period\n     * @param months  amount of months in this period\n     * @param weeks  amount of weeks in this period\n     * @param days  amount of days in this period\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */\n    public Period(int years, int months, int weeks, int days,\n                  int hours, int minutes, int seconds, int millis) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n    }\n\n    /**\n     * Create a period from a set of field values.\n     * <p>\n     * There is usually little need to use this constructor.\n     * The period type is used primarily to define how to split an interval into a period.\n     * As this constructor already is split, the period type does no real work.\n     *\n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @param type  which set of fields this period supports, null means AllType\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    public Period(int years, int months, int weeks, int days,\n                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * For the standard period type this is the time fields only.\n     * Thus the year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available precise field, hours in this case.\n     * <p>\n     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n     * ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you have two options:\n     * <ul>\n     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n     * <li>specify a period type that contains precise definitions of the day and larger\n     * fields, such as UTC\n     * </ul>\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    public Period(long duration) {\n        super(duration);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(long duration, PeriodType type) {\n        super(duration, type, null);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */\n    public Period(long duration, Chronology chronology) {\n        super(duration, null, chronology);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */\n    public Period(long duration, PeriodType type, Chronology chronology) {\n        super(duration, type, chronology);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     */\n    public Period(long startInstant, long endInstant) {\n        super(startInstant, endInstant, null, null);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(long startInstant, long endInstant, PeriodType type) {\n        super(startInstant, endInstant, type, null);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */\n    public Period(long startInstant, long endInstant, Chronology chrono) {\n        super(startInstant, endInstant, null, chrono);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */\n    public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super(startInstant, endInstant, type, chrono);\n    }\n\n    /**\n     * Creates a period between the given instants using the standard set of fields.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days\n     * (exposed as 4 weeks and 2 days).\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     */\n    public Period(ReadableInstant startInstant, ReadableInstant endInstant) {\n        super(startInstant, endInstant, null);\n    }\n\n    /**\n     * Creates a period between the given instants.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super(startInstant, endInstant, type);\n    }\n\n    /**\n     * Creates a period from two partially specified times.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days\n     * (exposed as 4 weeks and 2 days).\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     * <p>\n     * An alternative way of constructing a Period from two Partials\n     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n     * That method handles all kinds of partials.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    public Period(ReadablePartial start, ReadablePartial end) {\n        super(start, end, null);\n    }\n\n    /**\n     * Creates a period from two partially specified times.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     * <p>\n     * An alternative way of constructing a Period from two Partials\n     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n     * That method handles all kinds of partials.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    public Period(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super(start, end, type);\n    }\n\n    /**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     */\n    public Period(ReadableInstant startInstant, ReadableDuration duration) {\n        super(startInstant, duration, null);\n    }\n\n    /**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super(startInstant, duration, type);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     */\n    public Period(ReadableDuration duration, ReadableInstant endInstant) {\n        super(duration, endInstant, null);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super(duration, endInstant, type);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period) {\n        super(period, null, null);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period, PeriodType type) {\n        super(period, type, null);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period, Chronology chrono) {\n        super(period, null, chrono);\n    }\n\n    /**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */\n    public Period(Object period, PeriodType type, Chronology chrono) {\n        super(period, type, chrono);\n    }\n\n    /**\n     * Constructor used when we trust ourselves.\n     *\n     * @param values  the values to use, not null, not cloned\n     * @param type  which set of fields this period supports, not null\n     */\n    private Period(int[] values, PeriodType type) {\n        super(values, type);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get this period as an immutable <code>Period</code> object\n     * by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */\n    public Period toPeriod() {\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the years field part of the period.\n     * \n     * @return the number of years in the period, zero if unsupported\n     */\n    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n\n    /**\n     * Gets the months field part of the period.\n     * \n     * @return the number of months in the period, zero if unsupported\n     */\n    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n\n    /**\n     * Gets the weeks field part of the period.\n     * \n     * @return the number of weeks in the period, zero if unsupported\n     */\n    public int getWeeks() {\n        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }\n\n    /**\n     * Gets the days field part of the period.\n     * \n     * @return the number of days in the period, zero if unsupported\n     */\n    public int getDays() {\n        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hours field part of the period.\n     * \n     * @return the number of hours in the period, zero if unsupported\n     */\n    public int getHours() {\n        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }\n\n    /**\n     * Gets the minutes field part of the period.\n     * \n     * @return the number of minutes in the period, zero if unsupported\n     */\n    public int getMinutes() {\n        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }\n\n    /**\n     * Gets the seconds field part of the period.\n     * \n     * @return the number of seconds in the period, zero if unsupported\n     */\n    public int getSeconds() {\n        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }\n\n    /**\n     * Gets the millis field part of the period.\n     * \n     * @return the number of millis in the period, zero if unsupported\n     */\n    public int getMillis() {\n        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Period instance with the same field values but\n     * different PeriodType.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param type  the period type to use, null means standard\n     * @return the new period instance\n     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n     */\n    public Period withPeriodType(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        if (type.equals(getPeriodType())) {\n            return this;\n        }\n        return new Period(this, type);\n    }\n\n    /**\n     * Creates a new Period instance with the fields from the specified period\n     * copied on top of those from this period.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param period  the period to copy from, null ignored\n     * @return the new period instance\n     * @throws IllegalArgumentException if a field type is unsupported\n     */\n    public Period withFields(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] newValues = getValues();  // cloned\n        newValues = super.mergePeriodInto(newValues, period);\n        return new Period(newValues, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new Period instance with the specified field set to a new value.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to set to\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */\n    public Period withField(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        int[] newValues = getValues();  // cloned\n        super.setFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }\n\n    /**\n     * Creates a new Period instance with the valueToAdd added to the specified field.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to add\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */\n    public Period withFieldAdded(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (value == 0) {\n            return this;\n        }\n        int[] newValues = getValues();  // cloned\n        super.addFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified number of years.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withYears(int years) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of months.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period with the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withMonths(int months) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of weeks.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period with the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withWeeks(int weeks) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of days.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period with the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withDays(int days) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of hours.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period with the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withHours(int hours) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of minutes.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period with the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withMinutes(int minutes) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of seconds.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period with the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withSeconds(int seconds) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period with the specified number of millis.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period with the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period withMillis(int millis) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified period added.\n     * <p>\n     * Each field of the period is added separately. Thus a period of\n     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */\n    public Period plus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified number of years added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of months added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period plus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of weeks added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period plus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of days added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period plus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of hours added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period plus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of minutes added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period plus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of seconds added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period plus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new period plus the specified number of millis added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period plus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified period subtracted.\n     * <p>\n     * Each field of the period is subtracted separately. Thus a period of\n     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */\n    public Period minus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new period with the specified number of years taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusYears(int years) {\n        return plusYears(-years);\n    }\n\n    /**\n     * Returns a new period minus the specified number of months taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative\n     * @return the new period minus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusMonths(int months) {\n        return plusMonths(-months);\n    }\n\n    /**\n     * Returns a new period minus the specified number of weeks taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative\n     * @return the new period minus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusWeeks(int weeks) {\n        return plusWeeks(-weeks);\n    }\n\n    /**\n     * Returns a new period minus the specified number of days taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative\n     * @return the new period minus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusDays(int days) {\n        return plusDays(-days);\n    }\n\n    /**\n     * Returns a new period minus the specified number of hours taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative\n     * @return the new period minus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusHours(int hours) {\n        return plusHours(-hours);\n    }\n\n    /**\n     * Returns a new period minus the specified number of minutes taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative\n     * @return the new period minus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusMinutes(int minutes) {\n        return plusMinutes(-minutes);\n    }\n\n    /**\n     * Returns a new period minus the specified number of seconds taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative\n     * @return the new period minus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusSeconds(int seconds) {\n        return plusSeconds(-seconds);\n    }\n\n    /**\n     * Returns a new period minus the specified number of millis taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to take away, may be negative\n     * @return the new period minus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */\n    public Period minusMillis(int millis) {\n        return plusMillis(-millis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * @param scalar  the scalar to multiply by, not null\n     * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null\n     * @throws ArithmeticException if the capacity of any field is exceeded\n     * @since 2.1\n     */\n    public Period multipliedBy(int scalar) {\n        if (this == ZERO || scalar == 1) {\n            return this;\n        }\n        int[] values = getValues();  // cloned\n        for (int i = 0; i < values.length; i++) {\n            values[i] = FieldUtils.safeMultiply(values[i], scalar);\n        }\n        return new Period(values, getPeriodType());\n    }\n\n    /**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return a {@code Period} based on this period with the amounts negated, never null\n     * @throws ArithmeticException if any field has the minimum value\n     * @since 2.1\n     */\n    public Period negated() {\n        return multipliedBy(-1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this period to a period in weeks assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard weeks in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of weeks is too large to be represented\n     * @since 1.5\n     */\n    public Weeks toStandardWeeks() {\n        checkYearsAndMonths(\"Weeks\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n        long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n        return Weeks.weeks(FieldUtils.safeToInt(weeks));\n    }\n\n    /**\n     * Converts this period to a period in days assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard days in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of days is too large to be represented\n     * @since 1.5\n     */\n    public Days toStandardDays() {\n        checkYearsAndMonths(\"Days\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n        days = FieldUtils.safeAdd(days, getDays());\n        days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n        return Days.days(FieldUtils.safeToInt(days));\n    }\n\n    /**\n     * Converts this period to a period in hours assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard hours in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of hours is too large to be represented\n     * @since 1.5\n     */\n    public Hours toStandardHours() {\n        checkYearsAndMonths(\"Hours\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n        hours = FieldUtils.safeAdd(hours, getHours());\n        hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n        hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n        return Hours.hours(FieldUtils.safeToInt(hours));\n    }\n\n    /**\n     * Converts this period to a period in minutes assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard minutes in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     * @since 1.5\n     */\n    public Minutes toStandardMinutes() {\n        checkYearsAndMonths(\"Minutes\");\n        long millis = getMillis();  // assign to a long\n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n        minutes = FieldUtils.safeAdd(minutes, getMinutes());\n        minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n        minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n        minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n    }\n\n    /**\n     * Converts this period to a period in seconds assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard seconds in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     * @since 1.5\n     */\n    public Seconds toStandardSeconds() {\n        checkYearsAndMonths(\"Seconds\");\n        long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n        seconds = FieldUtils.safeAdd(seconds, getSeconds());\n        seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this period to a duration assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a duration equivalent to this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @since 1.5\n     */\n    public Duration toStandardDuration() {\n        checkYearsAndMonths(\"Duration\");\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        return new Duration(millis);\n    }\n\n    /**\n     * Check that there are no years or months in the period.\n     * \n     * @param destintionType  the destination type, not null\n     * @throws UnsupportedOperationException if the period contains years or months\n     */\n    private void checkYearsAndMonths(String destintionType) {\n        if (getMonths() != 0) {\n            throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains months and months vary in length\");\n        }\n        if (getYears() != 0) {\n            throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains years and years vary in length\");\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The result will always have a <code>PeriodType</code> of standard, thus\n     * days will be grouped into weeks.\n     * \n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @since 1.5\n     */\n    public Period normalizedStandard() {\n        return normalizedStandard(PeriodType.standard());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            long totalMonths = years * 12L + months;\n            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n                result = result.withYears(normalizedYears);\n                totalMonths = totalMonths - (normalizedYears * 12);\n            }\n            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n                result = result.withMonths(normalizedMonths);\n                totalMonths = totalMonths - normalizedMonths;\n            }\n            if (totalMonths != 0) {\n                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n            }\n        }\n        return result;\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 6, "classes_modified": [{"class_name": "org.joda.time.chrono.GJChronology", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.LocalDate;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.DecoratedDurationField;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Implements the Gregorian/Julian calendar system which is the calendar system\n * used in most of the world. Wherever possible, it is recommended to use the\n * {@link ISOChronology} instead.\n * <p>\n * The Gregorian calendar replaced the Julian calendar, and the point in time\n * when this chronology switches can be controlled using the second parameter\n * of the getInstance method. By default this cutover is set to the date the\n * Gregorian calendar was first instituted, October 15, 1582.\n * <p>\n * Before this date, this chronology uses the proleptic Julian calendar\n * (proleptic means extending indefinitely). The Julian calendar has leap years\n * every four years, whereas the Gregorian has special rules for 100 and 400\n * years. A meaningful result will thus be obtained for all input values.\n * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n * there was no Julian calendar.\n * <p>\n * This chronology differs from\n * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n * The yearOfEra field produces results compatible with GregorianCalendar.\n * <p>\n * The Julian calendar does not have a year zero, and so year -1 is followed by\n * year 1. If the Gregorian cutover date is specified at or before year -1\n * (Julian), year zero is defined. In other words, the proleptic Gregorian\n * chronology used by this class has a year zero.\n * <p>\n * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n * and to create a pure proleptic Gregorian chronology, use\n * {@link GregorianChronology}.\n * <p>\n * GJChronology is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic final class GJChronology extends AssembledChronology {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -2545574827706931671L;\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }\n\n    /**\n     * The default GregorianJulian cutover point.\n     */\n    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n\n    /** Cache of zone to chronology list */\n    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The time zone of the returned instance is UTC.\n     */\n    public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The returned chronology is in the default time zone.\n     */\n    public static GJChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. This uses\n     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n     * (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     */\n    public static GJChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n    \n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            long gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    private JulianChronology iJulianChronology;\n    private GregorianChronology iGregorianChronology;\n    private Instant iCutoverInstant;\n\n    private long iCutoverMillis;\n    private long iGapDuration;\n\n    /**\n     * @param julian chronology used before the cutover instant\n     * @param gregorian chronology used at and after the cutover instant\n     * @param cutoverInstant instant when the gregorian chronology began\n     */\n    private GJChronology(JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Called when applying a time zone.\n     */\n    private GJChronology(Chronology base,\n                         JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n\n    // Conversion\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */\n    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int millisOfDay)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        // Assume date is Gregorian.\n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth, millisOfDay);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth, millisOfDay);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n        try {\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalFieldValueException ex) {\n            if (monthOfYear != 2 || dayOfMonth != 29) {\n                throw ex;\n            }\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, 28,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw ex;\n            }\n        }\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    /**\n     * Gets the cutover instant between Gregorian and Julian chronologies.\n     * @return the cutover instant\n     */\n    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n\n    /**\n     * Gets the minimum days needed for a week to be the first week in a year.\n     * \n     * @return the minimum days\n     */\n    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof GJChronology) {\n            GJChronology chrono = (GJChronology) obj;\n            return iCutoverMillis == chrono.iCutoverMillis &&\n                    getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() &&\n                    getZone().equals(chrono.getZone());\n        }\n        return false;\n    }\n\n    /**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */\n    public int hashCode() {\n        return \"GJ\".hashCode() * 11 + getZone().hashCode() +\n                getMinimumDaysInFirstWeek() + iCutoverInstant.hashCode();\n    }\n\n    // Output\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"GJChronology\");\n        sb.append('[');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\",cutover=\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\",mdfw=\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append(']');\n        \n        return sb.toString();\n    }\n\n    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n\n    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n     * assumes that calls to add and addWrapField are unaffected by the cutover.\n     */\n    private class CutoverField extends BaseDateTimeField {\n        private static final long serialVersionUID = 3528501219481026402L;\n\n        final DateTimeField iJulianField;\n        final DateTimeField iGregorianField;\n        final long iCutover;\n        final boolean iConvertByWeekyear;\n\n        protected DurationField iDurationField;\n        protected DurationField iRangeDurationField;\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         * @param convertByWeekyear\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            // Although average length of Julian and Gregorian years differ,\n            // use the Gregorian duration field because it is more accurate.\n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n\n        public boolean isLenient() {\n            return false;\n        }\n\n        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsText(instant, locale);\n            } else {\n                return iJulianField.getAsText(instant, locale);\n            }\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsShortText(instant, locale);\n            } else {\n                return iJulianField.getAsShortText(instant, locale);\n            }\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n            // overridden as superclass algorithm can't handle\n            // 2004-02-29 + 48 months -> 2008-02-29 type dates\n            if (valueToAdd == 0) {\n                return values;\n            }\n            if (DateTimeUtils.isContiguous(partial)) {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return GJChronology.this.get(partial, instant);\n            } else {\n                return super.add(partial, fieldIndex, values, valueToAdd);\n            }\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n\n        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            }\n            return instant;\n        }\n\n        public DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.isLeap(instant);\n            } else {\n                return iJulianField.isLeap(instant);\n            }\n        }\n\n        public int getLeapAmount(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getLeapAmount(instant);\n            } else {\n                return iJulianField.getLeapAmount(instant);\n            }\n        }\n\n        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n\n\n        public int getMinimumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical. Choose Julian to tighten up the year limits.\n            return iJulianField.getMinimumValue();\n        }\n\n        public int getMinimumValue(ReadablePartial partial) {\n            return iJulianField.getMinimumValue(partial);\n        }\n\n        public int getMinimumValue(ReadablePartial partial, int[] values) {\n            return iJulianField.getMinimumValue(partial, values);\n        }\n\n        public int getMinimumValue(long instant) {\n            if (instant < iCutover) {\n                return iJulianField.getMinimumValue(instant);\n            }\n\n            int min = iGregorianField.getMinimumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the minimum by setting it.\n            instant = iGregorianField.set(instant, min);\n            if (instant < iCutover) {\n                min = iGregorianField.get(iCutover);\n            }\n\n            return min;\n        }\n\n        public int getMaximumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical.\n            return iGregorianField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            }\n\n            int max = iJulianField.getMaximumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the maximum by setting it.\n            instant = iJulianField.set(instant, max);\n            if (instant >= iCutover) {\n                max = iJulianField.get(iJulianField.add(iCutover, -1));\n            }\n\n            return max;\n        }\n\n        public int getMaximumValue(ReadablePartial partial) {\n            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n            return getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial partial, int[] values) {\n            Chronology chrono = GJChronology.getInstanceUTC();\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeField field = partial.getFieldType(i).getField(chrono);\n                if (values[i] <= field.getMaximumValue(instant)) {\n                    instant = field.set(instant, values[i]);\n                }\n            }\n            return getMaximumValue(instant);\n        }\n\n        public long roundFloor(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundFloor(instant);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.roundFloor(instant);\n            }\n            return instant;\n        }\n\n        public long roundCeiling(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundCeiling(instant);\n            } else {\n                instant = iJulianField.roundCeiling(instant);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumTextLength(locale),\n                            iGregorianField.getMaximumTextLength(locale));\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n                            iGregorianField.getMaximumShortTextLength(locale));\n        }\n\n        protected long julianToGregorian(long instant) {\n            if (iConvertByWeekyear) {\n                return julianToGregorianByWeekyear(instant);\n            } else {\n                return julianToGregorianByYear(instant);\n            }\n        }\n\n        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Cutover field for variable length fields. These fields internally call\n     * set whenever add is called. As a result, the same correction applied to\n     * set must be applied to add and addWrapField. Knowing when to use this\n     * field requires specific knowledge of how the GJ fields are implemented.\n     */\n    private final class ImpreciseCutoverField extends CutoverField {\n        private static final long serialVersionUID = 3410248757173576441L;\n\n        /**\n         * Creates a duration field that links back to this.\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n\n        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n        \n        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        // Since the imprecise fields have durations longer than the gap\n        // duration, keep these methods simple. The inherited implementations\n        // produce incorrect results.\n        //\n        // Degenerate case: If this field is a month, and the cutover is set\n        // far into the future, then the gap duration may be so large as to\n        // reduce the number of months in a year. If the missing month(s) are\n        // at the beginning or end of the year, then the minimum and maximum\n        // values are not 1 and 12. I don't expect this case to ever occur.\n\n        public int getMinimumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMinimumValue(instant);\n            } else {\n                return iJulianField.getMinimumValue(instant);\n            }\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            } else {\n                return iJulianField.getMaximumValue(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Links the duration back to a ImpreciseCutoverField.\n     */\n    private static class LinkedDurationField extends DecoratedDurationField {\n        private static final long serialVersionUID = 4097975388007713084L;\n\n        private final ImpreciseCutoverField iField;\n\n        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n\n        public long add(long instant, int value) {\n            return iField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.LocalDate;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.DecoratedDurationField;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Implements the Gregorian/Julian calendar system which is the calendar system\n * used in most of the world. Wherever possible, it is recommended to use the\n * {@link ISOChronology} instead.\n * <p>\n * The Gregorian calendar replaced the Julian calendar, and the point in time\n * when this chronology switches can be controlled using the second parameter\n * of the getInstance method. By default this cutover is set to the date the\n * Gregorian calendar was first instituted, October 15, 1582.\n * <p>\n * Before this date, this chronology uses the proleptic Julian calendar\n * (proleptic means extending indefinitely). The Julian calendar has leap years\n * every four years, whereas the Gregorian has special rules for 100 and 400\n * years. A meaningful result will thus be obtained for all input values.\n * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n * there was no Julian calendar.\n * <p>\n * This chronology differs from\n * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n * The yearOfEra field produces results compatible with GregorianCalendar.\n * <p>\n * The Julian calendar does not have a year zero, and so year -1 is followed by\n * year 1. If the Gregorian cutover date is specified at or before year -1\n * (Julian), year zero is defined. In other words, the proleptic Gregorian\n * chronology used by this class has a year zero.\n * <p>\n * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n * and to create a pure proleptic Gregorian chronology, use\n * {@link GregorianChronology}.\n * <p>\n * GJChronology is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic final class GJChronology extends AssembledChronology {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -2545574827706931671L;\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }\n\n    /**\n     * The default GregorianJulian cutover point.\n     */\n    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n\n    /** Cache of zone to chronology list */\n    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The time zone of the returned instance is UTC.\n     */\n    public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The returned chronology is in the default time zone.\n     */\n    public static GJChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. This uses\n     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n     * (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     */\n    public static GJChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n    \n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n            if (cutoverDate.getYear() <= 0) {\n                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n            }\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            long gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    private JulianChronology iJulianChronology;\n    private GregorianChronology iGregorianChronology;\n    private Instant iCutoverInstant;\n\n    private long iCutoverMillis;\n    private long iGapDuration;\n\n    /**\n     * @param julian chronology used before the cutover instant\n     * @param gregorian chronology used at and after the cutover instant\n     * @param cutoverInstant instant when the gregorian chronology began\n     */\n    private GJChronology(JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Called when applying a time zone.\n     */\n    private GJChronology(Chronology base,\n                         JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n\n    // Conversion\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */\n    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int millisOfDay)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        // Assume date is Gregorian.\n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth, millisOfDay);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth, millisOfDay);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n        try {\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalFieldValueException ex) {\n            if (monthOfYear != 2 || dayOfMonth != 29) {\n                throw ex;\n            }\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, 28,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw ex;\n            }\n        }\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    /**\n     * Gets the cutover instant between Gregorian and Julian chronologies.\n     * @return the cutover instant\n     */\n    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n\n    /**\n     * Gets the minimum days needed for a week to be the first week in a year.\n     * \n     * @return the minimum days\n     */\n    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof GJChronology) {\n            GJChronology chrono = (GJChronology) obj;\n            return iCutoverMillis == chrono.iCutoverMillis &&\n                    getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() &&\n                    getZone().equals(chrono.getZone());\n        }\n        return false;\n    }\n\n    /**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */\n    public int hashCode() {\n        return \"GJ\".hashCode() * 11 + getZone().hashCode() +\n                getMinimumDaysInFirstWeek() + iCutoverInstant.hashCode();\n    }\n\n    // Output\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"GJChronology\");\n        sb.append('[');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\",cutover=\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\",mdfw=\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append(']');\n        \n        return sb.toString();\n    }\n\n    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n\n    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n     * assumes that calls to add and addWrapField are unaffected by the cutover.\n     */\n    private class CutoverField extends BaseDateTimeField {\n        private static final long serialVersionUID = 3528501219481026402L;\n\n        final DateTimeField iJulianField;\n        final DateTimeField iGregorianField;\n        final long iCutover;\n        final boolean iConvertByWeekyear;\n\n        protected DurationField iDurationField;\n        protected DurationField iRangeDurationField;\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         * @param convertByWeekyear\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            // Although average length of Julian and Gregorian years differ,\n            // use the Gregorian duration field because it is more accurate.\n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n\n        public boolean isLenient() {\n            return false;\n        }\n\n        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsText(instant, locale);\n            } else {\n                return iJulianField.getAsText(instant, locale);\n            }\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsShortText(instant, locale);\n            } else {\n                return iJulianField.getAsShortText(instant, locale);\n            }\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n            // overridden as superclass algorithm can't handle\n            // 2004-02-29 + 48 months -> 2008-02-29 type dates\n            if (valueToAdd == 0) {\n                return values;\n            }\n            if (DateTimeUtils.isContiguous(partial)) {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return GJChronology.this.get(partial, instant);\n            } else {\n                return super.add(partial, fieldIndex, values, valueToAdd);\n            }\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n\n        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            }\n            return instant;\n        }\n\n        public DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.isLeap(instant);\n            } else {\n                return iJulianField.isLeap(instant);\n            }\n        }\n\n        public int getLeapAmount(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getLeapAmount(instant);\n            } else {\n                return iJulianField.getLeapAmount(instant);\n            }\n        }\n\n        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n\n\n        public int getMinimumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical. Choose Julian to tighten up the year limits.\n            return iJulianField.getMinimumValue();\n        }\n\n        public int getMinimumValue(ReadablePartial partial) {\n            return iJulianField.getMinimumValue(partial);\n        }\n\n        public int getMinimumValue(ReadablePartial partial, int[] values) {\n            return iJulianField.getMinimumValue(partial, values);\n        }\n\n        public int getMinimumValue(long instant) {\n            if (instant < iCutover) {\n                return iJulianField.getMinimumValue(instant);\n            }\n\n            int min = iGregorianField.getMinimumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the minimum by setting it.\n            instant = iGregorianField.set(instant, min);\n            if (instant < iCutover) {\n                min = iGregorianField.get(iCutover);\n            }\n\n            return min;\n        }\n\n        public int getMaximumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical.\n            return iGregorianField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            }\n\n            int max = iJulianField.getMaximumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the maximum by setting it.\n            instant = iJulianField.set(instant, max);\n            if (instant >= iCutover) {\n                max = iJulianField.get(iJulianField.add(iCutover, -1));\n            }\n\n            return max;\n        }\n\n        public int getMaximumValue(ReadablePartial partial) {\n            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n            return getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial partial, int[] values) {\n            Chronology chrono = GJChronology.getInstanceUTC();\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeField field = partial.getFieldType(i).getField(chrono);\n                if (values[i] <= field.getMaximumValue(instant)) {\n                    instant = field.set(instant, values[i]);\n                }\n            }\n            return getMaximumValue(instant);\n        }\n\n        public long roundFloor(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundFloor(instant);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.roundFloor(instant);\n            }\n            return instant;\n        }\n\n        public long roundCeiling(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundCeiling(instant);\n            } else {\n                instant = iJulianField.roundCeiling(instant);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumTextLength(locale),\n                            iGregorianField.getMaximumTextLength(locale));\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n                            iGregorianField.getMaximumShortTextLength(locale));\n        }\n\n        protected long julianToGregorian(long instant) {\n            if (iConvertByWeekyear) {\n                return julianToGregorianByWeekyear(instant);\n            } else {\n                return julianToGregorianByYear(instant);\n            }\n        }\n\n        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Cutover field for variable length fields. These fields internally call\n     * set whenever add is called. As a result, the same correction applied to\n     * set must be applied to add and addWrapField. Knowing when to use this\n     * field requires specific knowledge of how the GJ fields are implemented.\n     */\n    private final class ImpreciseCutoverField extends CutoverField {\n        private static final long serialVersionUID = 3410248757173576441L;\n\n        /**\n         * Creates a duration field that links back to this.\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n\n        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        if (iConvertByWeekyear) {\n                            int wyear = iGregorianChronology.weekyear().get(instant);\n                            if (wyear <= 0) {\n                                instant = iGregorianChronology.weekyear().add(instant, -1);\n                            }\n                        } else {\n                            int year = iGregorianChronology.year().get(instant);\n                            if (year <= 0) {\n                                instant = iGregorianChronology.year().add(instant, -1);\n                            }\n                        }\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n        \n        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        if (iConvertByWeekyear) {\n                            int wyear = iGregorianChronology.weekyear().get(instant);\n                            if (wyear <= 0) {\n                                instant = iGregorianChronology.weekyear().add(instant, -1);\n                            }\n                        } else {\n                            int year = iGregorianChronology.year().get(instant);\n                            if (year <= 0) {\n                                instant = iGregorianChronology.year().add(instant, -1);\n                            }\n                        }\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        // Since the imprecise fields have durations longer than the gap\n        // duration, keep these methods simple. The inherited implementations\n        // produce incorrect results.\n        //\n        // Degenerate case: If this field is a month, and the cutover is set\n        // far into the future, then the gap duration may be so large as to\n        // reduce the number of months in a year. If the missing month(s) are\n        // at the beginning or end of the year, then the minimum and maximum\n        // values are not 1 and 12. I don't expect this case to ever occur.\n\n        public int getMinimumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMinimumValue(instant);\n            } else {\n                return iJulianField.getMinimumValue(instant);\n            }\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            } else {\n                return iJulianField.getMaximumValue(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Links the duration back to a ImpreciseCutoverField.\n     */\n    private static class LinkedDurationField extends DecoratedDurationField {\n        private static final long serialVersionUID = 4097975388007713084L;\n\n        private final ImpreciseCutoverField iField;\n\n        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n\n        public long add(long instant, int value) {\n            return iField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 7, "classes_modified": [{"class_name": "org.joda.time.format.DateTimeFormatter", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.Instant;\nimport org.joda.time.LocalDate;\nimport org.joda.time.LocalDateTime;\nimport org.joda.time.LocalTime;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadWritableInstant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\n\n/**\n * Controls the printing and parsing of a datetime to and from a string.\n * <p>\n * This class is the main API for printing and parsing used by most applications.\n * Instances of this class are created via one of three factory classes:\n * <ul>\n * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n * </ul>\n * <p>\n * An instance of this class holds a reference internally to one printer and\n * one parser. It is possible that one of these may be null, in which case the\n * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n * and {@link #isParser()} methods.\n * <p>\n * The underlying printer/parser can be altered to behave exactly as required\n * by using one of the decorator modifiers:\n * <ul>\n * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n * <li>{@link #withPivotYear(int)} - returns a new formatter with the specified pivot year</li>\n * <li>{@link #withDefaultYear(int)} - returns a new formatter with the specified default year</li>\n * </ul>\n * Each of these returns a new formatter (instances of this class are immutable).\n * <p>\n * The main methods of the class are the <code>printXxx</code> and\n * <code>parseXxx</code> methods. These are used as follows:\n * <pre>\n * // print using the defaults (default locale, chronology/zone of the datetime)\n * String dateStr = formatter.print(dt);\n * // print using the French locale\n * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n * // print using the UTC zone\n * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n * \n * // parse using the Paris zone\n * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n * </pre>\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeFormatter {\n\n    /** The internal printer used to output the datetime. */\n    private final DateTimePrinter iPrinter;\n    /** The internal parser used to output the datetime. */\n    private final DateTimeParser iParser;\n    /** The locale to use for printing and parsing. */\n    private final Locale iLocale;\n    /** Whether the offset is parsed. */\n    private final boolean iOffsetParsed;\n    /** The chronology to use as an override. */\n    private final Chronology iChrono;\n    /** The zone to use as an override. */\n    private final DateTimeZone iZone;\n    /** The pivot year to use for two-digit year parsing. */\n    private final Integer iPivotYear;\n    /** The default year for parsing month/day without year. */\n    private final int iDefaultYear;\n\n    /**\n     * Creates a new formatter, however you will normally use the factory\n     * or the builder.\n     * \n     * @param printer  the internal printer, null if cannot print\n     * @param parser  the internal parser, null if cannot parse\n     */\n    public DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n\n    /**\n     * Constructor.\n     */\n    private DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser,\n            Locale locale, boolean offsetParsed,\n            Chronology chrono, DateTimeZone zone,\n            Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is this formatter capable of printing.\n     * \n     * @return true if this is a printer\n     */\n    public boolean isPrinter() {\n        return (iPrinter != null);\n    }\n\n    /**\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer; is null if printing not supported\n     */\n    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n\n    /**\n     * Is this formatter capable of parsing.\n     * \n     * @return true if this is a parser\n     */\n    public boolean isParser() {\n        return (iParser != null);\n    }\n\n    /**\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser; is null if parsing not supported\n     */\n    public DateTimeParser getParser() {\n        return iParser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use; if null, formatter uses default locale at\n     * invocation time\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will create a datetime with a time zone\n     * equal to that of the offset of the parsed string.\n     * <p>\n     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n     * savings rules). If the parsed string represents a local time (no zone\n     * offset) the parsed datetime will be in the default zone.\n     * <p>\n     * Calling this method sets the override zone to null.\n     * Calling the override zone method sets this flag off.\n     * \n     * @return the new formatter\n     */\n    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Checks whether the offset from the string is used as the zone of\n     * the parsed datetime.\n     * \n     * @return true if the offset from the string is used as the zone\n     */\n    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified chronology in\n     * preference to that of the printed object, or ISO on a parse.\n     * <p>\n     * When printing, this chronolgy will be used in preference to the chronology\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this chronology will be set on the parsed datetime.\n     * <p>\n     * A null chronology means no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param chrono  the chronology to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     * @deprecated Use the method with the correct spelling\n     */\n    @Deprecated\n    public Chronology getChronolgy() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the UTC zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, UTC will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, UTC will be set on the parsed datetime.\n     * <p>\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @return the new formatter, never null\n     * @since 2.0\n     */\n    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, this zone will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this zone will be set on the parsed datetime.\n     * <p>\n     * A null zone means of no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param zone  the zone to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the zone to use as an override.\n     * \n     * @return the zone to use as an override\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used. Null means no-override.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }\n\n    /**\n     * Gets the pivot year to use as an override.\n     *\n     * @return the pivot year to use as an override\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n      return iPivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     */\n    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n\n    /**\n     * Gets the default year for parsing months and days.\n     *\n     * @return the default year for parsing months and days\n     * @since 2.0\n     */\n    public int getDefaultYear() {\n      return iDefaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(out, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(StringBuffer buf, long instant) {\n        printTo(buf, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(Writer out, long instant) throws IOException {\n        printTo(out, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, long instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param buf  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(StringBuffer buf, ReadablePartial partial) {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(buf, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param out  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(out, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param partial  partial to format\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n        appendable.append(print(partial));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the chronology and zone of the instant.\n     *\n     * @param instant  instant to format, null means now\n     * @return the printed result\n     */\n    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a millisecond instant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the ISO chronology and default zone.\n     *\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @return the printed result\n     */\n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */\n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    /**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    /**\n     * Parses only the local time from the given text, returning a new LocalTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    /**\n     * Parses only the local date-time from the given text, returning a new LocalDateTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determines the correct chronology to use.\n     *\n     * @param chrono  the proposed chronology\n     * @return the actual chronology\n     */\n    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.Instant;\nimport org.joda.time.LocalDate;\nimport org.joda.time.LocalDateTime;\nimport org.joda.time.LocalTime;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadWritableInstant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\n\n/**\n * Controls the printing and parsing of a datetime to and from a string.\n * <p>\n * This class is the main API for printing and parsing used by most applications.\n * Instances of this class are created via one of three factory classes:\n * <ul>\n * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n * </ul>\n * <p>\n * An instance of this class holds a reference internally to one printer and\n * one parser. It is possible that one of these may be null, in which case the\n * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n * and {@link #isParser()} methods.\n * <p>\n * The underlying printer/parser can be altered to behave exactly as required\n * by using one of the decorator modifiers:\n * <ul>\n * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n * <li>{@link #withPivotYear(int)} - returns a new formatter with the specified pivot year</li>\n * <li>{@link #withDefaultYear(int)} - returns a new formatter with the specified default year</li>\n * </ul>\n * Each of these returns a new formatter (instances of this class are immutable).\n * <p>\n * The main methods of the class are the <code>printXxx</code> and\n * <code>parseXxx</code> methods. These are used as follows:\n * <pre>\n * // print using the defaults (default locale, chronology/zone of the datetime)\n * String dateStr = formatter.print(dt);\n * // print using the French locale\n * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n * // print using the UTC zone\n * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n * \n * // parse using the Paris zone\n * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n * </pre>\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeFormatter {\n\n    /** The internal printer used to output the datetime. */\n    private final DateTimePrinter iPrinter;\n    /** The internal parser used to output the datetime. */\n    private final DateTimeParser iParser;\n    /** The locale to use for printing and parsing. */\n    private final Locale iLocale;\n    /** Whether the offset is parsed. */\n    private final boolean iOffsetParsed;\n    /** The chronology to use as an override. */\n    private final Chronology iChrono;\n    /** The zone to use as an override. */\n    private final DateTimeZone iZone;\n    /** The pivot year to use for two-digit year parsing. */\n    private final Integer iPivotYear;\n    /** The default year for parsing month/day without year. */\n    private final int iDefaultYear;\n\n    /**\n     * Creates a new formatter, however you will normally use the factory\n     * or the builder.\n     * \n     * @param printer  the internal printer, null if cannot print\n     * @param parser  the internal parser, null if cannot parse\n     */\n    public DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n\n    /**\n     * Constructor.\n     */\n    private DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser,\n            Locale locale, boolean offsetParsed,\n            Chronology chrono, DateTimeZone zone,\n            Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is this formatter capable of printing.\n     * \n     * @return true if this is a printer\n     */\n    public boolean isPrinter() {\n        return (iPrinter != null);\n    }\n\n    /**\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer; is null if printing not supported\n     */\n    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n\n    /**\n     * Is this formatter capable of parsing.\n     * \n     * @return true if this is a parser\n     */\n    public boolean isParser() {\n        return (iParser != null);\n    }\n\n    /**\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser; is null if parsing not supported\n     */\n    public DateTimeParser getParser() {\n        return iParser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use; if null, formatter uses default locale at\n     * invocation time\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will create a datetime with a time zone\n     * equal to that of the offset of the parsed string.\n     * <p>\n     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n     * savings rules). If the parsed string represents a local time (no zone\n     * offset) the parsed datetime will be in the default zone.\n     * <p>\n     * Calling this method sets the override zone to null.\n     * Calling the override zone method sets this flag off.\n     * \n     * @return the new formatter\n     */\n    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Checks whether the offset from the string is used as the zone of\n     * the parsed datetime.\n     * \n     * @return true if the offset from the string is used as the zone\n     */\n    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified chronology in\n     * preference to that of the printed object, or ISO on a parse.\n     * <p>\n     * When printing, this chronolgy will be used in preference to the chronology\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this chronology will be set on the parsed datetime.\n     * <p>\n     * A null chronology means no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param chrono  the chronology to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     * @deprecated Use the method with the correct spelling\n     */\n    @Deprecated\n    public Chronology getChronolgy() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the UTC zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, UTC will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, UTC will be set on the parsed datetime.\n     * <p>\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @return the new formatter, never null\n     * @since 2.0\n     */\n    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, this zone will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this zone will be set on the parsed datetime.\n     * <p>\n     * A null zone means of no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param zone  the zone to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the zone to use as an override.\n     * \n     * @return the zone to use as an override\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used. Null means no-override.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }\n\n    /**\n     * Gets the pivot year to use as an override.\n     *\n     * @return the pivot year to use as an override\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n      return iPivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     */\n    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n\n    /**\n     * Gets the default year for parsing months and days.\n     *\n     * @return the default year for parsing months and days\n     * @since 2.0\n     */\n    public int getDefaultYear() {\n      return iDefaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(out, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(StringBuffer buf, long instant) {\n        printTo(buf, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(Writer out, long instant) throws IOException {\n        printTo(out, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, long instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param buf  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(StringBuffer buf, ReadablePartial partial) {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(buf, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param out  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(out, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param partial  partial to format\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n        appendable.append(print(partial));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the chronology and zone of the instant.\n     *\n     * @param instant  instant to format, null means now\n     * @return the printed result\n     */\n    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a millisecond instant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the ISO chronology and default zone.\n     *\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @return the printed result\n     */\n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */\n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    /**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    /**\n     * Parses only the local time from the given text, returning a new LocalTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    /**\n     * Parses only the local date-time from the given text, returning a new LocalDateTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determines the correct chronology to use.\n     *\n     * @param chrono  the proposed chronology\n     * @return the actual chronology\n     */\n    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 8, "classes_modified": [{"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n    /** Maximum offset. */\n    private static final int MAX_MILLIS = (86400 * 1000) - 1;\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - minutesOffset;\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n        }\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalInstantException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n    /** Maximum offset. */\n    private static final int MAX_MILLIS = (86400 * 1000) - 1;\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n        }\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalInstantException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 9, "classes_modified": [{"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n    /** Maximum offset. */\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalInstantException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n    /** Maximum offset. */\n    private static final int MAX_MILLIS = (86400 * 1000) - 1;\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - minutesOffset;\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n        }\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalInstantException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 10, "classes_modified": [{"class_name": "org.joda.time.base.BaseSingleFieldPeriod", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.Period;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.FieldUtils;\n\n/**\n * BaseSingleFieldPeriod is an abstract implementation of ReadablePeriod that\n * manages a single duration field, such as days or minutes.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BaseSingleFieldPeriod subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @since 1.4\n */\npublic abstract class BaseSingleFieldPeriod\n        implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 9386874258972L;\n    /** The start of 1972. */\n\n    /** The period in the units of this period. */\n    private volatile int iPeriod;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified datetimes.\n     *\n     * @param start  the start instant, validated to not be null\n     * @param end  the end instant, validated to not be null\n     * @param field  the field type to use, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the instants are null or invalid\n     */\n    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n        return values[0];\n    }\n\n    /**\n     * Creates a new instance representing the number of complete standard length units\n     * in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, must not be null\n     * @param millisPerUnit  the number of milliseconds in one standard unit of this period\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */\n    protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {\n        if (period == null) {\n            return 0;\n        }\n        Chronology iso = ISOChronology.getInstanceUTC();\n        long duration = 0L;\n        for (int i = 0; i < period.size(); i++) {\n            int value = period.getValue(i);\n            if (value != 0) {\n                DurationField field = period.getFieldType(i).getField(iso);\n                if (field.isPrecise() == false) {\n                    throw new IllegalArgumentException(\n                            \"Cannot convert period to duration as \" + field.getName() +\n                            \" is not precise in the period \" + period);\n                }\n                duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n            }\n        }\n        return FieldUtils.safeToInt(duration / millisPerUnit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance representing the specified period.\n     *\n     * @param period  the period to represent\n     */\n    protected BaseSingleFieldPeriod(int period) {\n        super();\n        iPeriod = period;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the amount of this period.\n     *\n     * @return the period value\n     */\n    protected int getValue() {\n        return iPeriod;\n    }\n\n    /**\n     * Sets the amount of this period.\n     * To make a subclass immutable you must declare it final, or block this method.\n     *\n     * @param value  the period value\n     */\n    protected void setValue(int value) {\n        iPeriod = value;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the single duration field type.\n     *\n     * @return the duration field type, not null\n     */\n    public abstract DurationFieldType getFieldType();\n\n    /**\n     * Gets the period type which matches the duration field type.\n     *\n     * @return the period type, not null\n     */\n    public abstract PeriodType getPeriodType();\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields that this period supports, which is one.\n     *\n     * @return the number of fields supported, which is one\n     */\n    public int size() {\n        return 1;\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     * <p>\n     * The only index supported by this period is zero which returns the\n     * field type of this class.\n     *\n     * @param index  the index to retrieve, which must be zero\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DurationFieldType getFieldType(int index) {\n        if (index != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(index));\n        }\n        return getFieldType();\n    }\n\n    /**\n     * Gets the value at the specified index.\n     * <p>\n     * The only index supported by this period is zero.\n     *\n     * @param index  the index to retrieve, which must be zero\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        if (index != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(index));\n        }\n        return getValue();\n    }\n\n    /**\n     * Gets the value of a duration field represented by this period.\n     * <p>\n     * If the field type specified does not match the type used by this class\n     * then zero is returned.\n     *\n     * @param type  the field type to query, null returns zero\n     * @return the value of that field, zero if field not supported\n     */\n    public int get(DurationFieldType type) {\n        if (type == getFieldType()) {\n            return getValue();\n        }\n        return 0;\n    }\n\n    /**\n     * Checks whether the duration field specified is supported by this period.\n     *\n     * @param type  the type to check, may be null which returns false\n     * @return true if the field is supported\n     */\n    public boolean isSupported(DurationFieldType type) {\n        return (type == getFieldType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get this period as an immutable <code>Period</code> object.\n     * The period will use <code>PeriodType.standard()</code>.\n     *\n     * @return a <code>Period</code> representing the same number of days\n     */\n    public Period toPeriod() {\n        return Period.ZERO.withFields(this);\n    }\n\n    /**\n     * Get this object as a <code>MutablePeriod</code>.\n     * <p>\n     * This will always return a new <code>MutablePeriod</code> with the same fields.\n     * The period will use <code>PeriodType.standard()</code>.\n     * \n     * @return a MutablePeriod using the same field set and values\n     */\n    public MutablePeriod toMutablePeriod() {\n        MutablePeriod period = new MutablePeriod();\n        period.add(this);\n        return period;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object with the specified object for equality based on the\n     * value of each field. All ReadablePeriod instances are accepted, but only\n     * those with a matching <code>PeriodType</code> can return true.\n     *\n     * @param period  a readable period to check against\n     * @return true if all the field values are equal, false if\n     *  not or the period is null or of an incorrect type\n     */\n    public boolean equals(Object period) {\n        if (this == period) {\n            return true;\n        }\n        if (period instanceof ReadablePeriod == false) {\n            return false;\n        }\n        ReadablePeriod other = (ReadablePeriod) period;\n        return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\n    }\n\n    /**\n     * Gets a hash code for the period as defined by ReadablePeriod.\n     *\n     * @return a hash code\n     */\n    public int hashCode() {\n        int total = 17;\n        total = 27 * total + getValue();\n        total = 27 * total + getFieldType().hashCode();\n        return total;\n    }\n\n    /**\n     * Compares this period to another object of the same class.\n     *\n     * @param other  the other period, must not be null\n     * @return zero if equal, positive if greater, negative if less\n     * @throws NullPointerException if the other period is null\n     * @throws ClassCastException if the other period is of a different type\n     */\n    public int compareTo(BaseSingleFieldPeriod other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n        }\n        int otherValue = other.getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.Period;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.FieldUtils;\n\n/**\n * BaseSingleFieldPeriod is an abstract implementation of ReadablePeriod that\n * manages a single duration field, such as days or minutes.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BaseSingleFieldPeriod subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @since 1.4\n */\npublic abstract class BaseSingleFieldPeriod\n        implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 9386874258972L;\n    /** The start of 1972. */\n    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n\n    /** The period in the units of this period. */\n    private volatile int iPeriod;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified datetimes.\n     *\n     * @param start  the start instant, validated to not be null\n     * @param end  the end instant, validated to not be null\n     * @param field  the field type to use, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the instants are null or invalid\n     */\n    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n        return values[0];\n    }\n\n    /**\n     * Creates a new instance representing the number of complete standard length units\n     * in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, must not be null\n     * @param millisPerUnit  the number of milliseconds in one standard unit of this period\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */\n    protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {\n        if (period == null) {\n            return 0;\n        }\n        Chronology iso = ISOChronology.getInstanceUTC();\n        long duration = 0L;\n        for (int i = 0; i < period.size(); i++) {\n            int value = period.getValue(i);\n            if (value != 0) {\n                DurationField field = period.getFieldType(i).getField(iso);\n                if (field.isPrecise() == false) {\n                    throw new IllegalArgumentException(\n                            \"Cannot convert period to duration as \" + field.getName() +\n                            \" is not precise in the period \" + period);\n                }\n                duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n            }\n        }\n        return FieldUtils.safeToInt(duration / millisPerUnit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance representing the specified period.\n     *\n     * @param period  the period to represent\n     */\n    protected BaseSingleFieldPeriod(int period) {\n        super();\n        iPeriod = period;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the amount of this period.\n     *\n     * @return the period value\n     */\n    protected int getValue() {\n        return iPeriod;\n    }\n\n    /**\n     * Sets the amount of this period.\n     * To make a subclass immutable you must declare it final, or block this method.\n     *\n     * @param value  the period value\n     */\n    protected void setValue(int value) {\n        iPeriod = value;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the single duration field type.\n     *\n     * @return the duration field type, not null\n     */\n    public abstract DurationFieldType getFieldType();\n\n    /**\n     * Gets the period type which matches the duration field type.\n     *\n     * @return the period type, not null\n     */\n    public abstract PeriodType getPeriodType();\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields that this period supports, which is one.\n     *\n     * @return the number of fields supported, which is one\n     */\n    public int size() {\n        return 1;\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     * <p>\n     * The only index supported by this period is zero which returns the\n     * field type of this class.\n     *\n     * @param index  the index to retrieve, which must be zero\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DurationFieldType getFieldType(int index) {\n        if (index != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(index));\n        }\n        return getFieldType();\n    }\n\n    /**\n     * Gets the value at the specified index.\n     * <p>\n     * The only index supported by this period is zero.\n     *\n     * @param index  the index to retrieve, which must be zero\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        if (index != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(index));\n        }\n        return getValue();\n    }\n\n    /**\n     * Gets the value of a duration field represented by this period.\n     * <p>\n     * If the field type specified does not match the type used by this class\n     * then zero is returned.\n     *\n     * @param type  the field type to query, null returns zero\n     * @return the value of that field, zero if field not supported\n     */\n    public int get(DurationFieldType type) {\n        if (type == getFieldType()) {\n            return getValue();\n        }\n        return 0;\n    }\n\n    /**\n     * Checks whether the duration field specified is supported by this period.\n     *\n     * @param type  the type to check, may be null which returns false\n     * @return true if the field is supported\n     */\n    public boolean isSupported(DurationFieldType type) {\n        return (type == getFieldType());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get this period as an immutable <code>Period</code> object.\n     * The period will use <code>PeriodType.standard()</code>.\n     *\n     * @return a <code>Period</code> representing the same number of days\n     */\n    public Period toPeriod() {\n        return Period.ZERO.withFields(this);\n    }\n\n    /**\n     * Get this object as a <code>MutablePeriod</code>.\n     * <p>\n     * This will always return a new <code>MutablePeriod</code> with the same fields.\n     * The period will use <code>PeriodType.standard()</code>.\n     * \n     * @return a MutablePeriod using the same field set and values\n     */\n    public MutablePeriod toMutablePeriod() {\n        MutablePeriod period = new MutablePeriod();\n        period.add(this);\n        return period;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object with the specified object for equality based on the\n     * value of each field. All ReadablePeriod instances are accepted, but only\n     * those with a matching <code>PeriodType</code> can return true.\n     *\n     * @param period  a readable period to check against\n     * @return true if all the field values are equal, false if\n     *  not or the period is null or of an incorrect type\n     */\n    public boolean equals(Object period) {\n        if (this == period) {\n            return true;\n        }\n        if (period instanceof ReadablePeriod == false) {\n            return false;\n        }\n        ReadablePeriod other = (ReadablePeriod) period;\n        return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\n    }\n\n    /**\n     * Gets a hash code for the period as defined by ReadablePeriod.\n     *\n     * @return a hash code\n     */\n    public int hashCode() {\n        int total = 17;\n        total = 27 * total + getValue();\n        total = 27 * total + getFieldType().hashCode();\n        return total;\n    }\n\n    /**\n     * Compares this period to another object of the same class.\n     *\n     * @param other  the other period, must not be null\n     * @return zero if equal, positive if greater, negative if less\n     * @throws NullPointerException if the other period is null\n     * @throws ClassCastException if the other period is of a different type\n     */\n    public int compareTo(BaseSingleFieldPeriod other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n        }\n        int otherValue = other.getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 11, "classes_modified": [{"class_name": "org.joda.time.tz.ZoneInfoCompiler", "buggy_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.tz;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Map.Entry;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.LocalDate;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.chrono.LenientChronology;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Compiles Olson ZoneInfo database files into binary files for each time zone\n * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n * converts them back into {@link DateTimeZone} objects.\n * <p>\n * Although this tool is similar to zic, the binary formats are not\n * compatible. The latest Olson database files may be obtained\n * <a href=\"http://www.twinsun.com/tz/tz-link.htm\">here</a>.\n * <p>\n * ZoneInfoCompiler is mutable and not thread-safe, although the main method\n * may be safely invoked by multiple threads.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic class ZoneInfoCompiler {\n    static DateTimeOfYear cStartOfYear;\n\n    static Chronology cLenientISO;\n\n    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n    static {\n        cVerbose.set(Boolean.FALSE);\n    }\n\n    /**\n     * Gets a flag indicating that verbose logging is required.\n     * @return true to log verbosely\n     */\n    public static boolean verbose() {\n        return cVerbose.get();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Launches the ZoneInfoCompiler tool.\n     *\n     * <pre>\n     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;\n     * where possible options include:\n     *   -src &lt;directory&gt;    Specify where to read source files\n     *   -dst &lt;directory&gt;    Specify where to write generated files\n     *   -verbose            Output verbosely (default false)\n     * </pre>\n     */\n    public static void main(String[] args) throws Exception {\n        if (args.length == 0) {\n            printUsage();\n            return;\n        }\n\n        File inputDir = null;\n        File outputDir = null;\n        boolean verbose = false;\n\n        int i;\n        for (i=0; i<args.length; i++) {\n            try {\n                if (\"-src\".equals(args[i])) {\n                    inputDir = new File(args[++i]);\n                } else if (\"-dst\".equals(args[i])) {\n                    outputDir = new File(args[++i]);\n                } else if (\"-verbose\".equals(args[i])) {\n                    verbose = true;\n                } else if (\"-?\".equals(args[i])) {\n                    printUsage();\n                    return;\n                } else {\n                    break;\n                }\n            } catch (IndexOutOfBoundsException e) {\n                printUsage();\n                return;\n            }\n        }\n\n        if (i >= args.length) {\n            printUsage();\n            return;\n        }\n\n        File[] sources = new File[args.length - i];\n        for (int j=0; i<args.length; i++,j++) {\n            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n        }\n\n        cVerbose.set(verbose);\n        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n        zic.compile(outputDir, sources);\n    }\n\n    private static void printUsage() {\n        System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n        System.out.println(\"where possible options include:\");\n        System.out.println(\"  -src <directory>    Specify where to read source files\");\n        System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n        System.out.println(\"  -verbose            Output verbosely (default false)\");\n    }\n\n    static DateTimeOfYear getStartOfYear() {\n        if (cStartOfYear == null) {\n            cStartOfYear = new DateTimeOfYear();\n        }\n        return cStartOfYear;\n    }\n\n    static Chronology getLenientISOChronology() {\n        if (cLenientISO == null) {\n            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n        }\n        return cLenientISO;\n    }\n\n    /**\n     * @param zimap maps string ids to DateTimeZone objects.\n     */\n    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n        // Build the string pool.\n        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n\n        short count = 0;\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = (String)entry.getKey();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n            id = ((DateTimeZone)entry.getValue()).getID();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n        }\n\n        // Write the string pool, ordered by index.\n        dout.writeShort(indexToId.size());\n        for (String id : indexToId.values()) {\n            dout.writeUTF(id);\n        }\n\n        // Write the mappings.\n        dout.writeShort(zimap.size());\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = entry.getKey();\n            dout.writeShort(idToIndex.get(id).shortValue());\n            id = entry.getValue().getID();\n            dout.writeShort(idToIndex.get(id).shortValue());\n        }\n    }\n\n    static int parseYear(String str, int def) {\n        str = str.toLowerCase();\n        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n            return Integer.MIN_VALUE;\n        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n            return Integer.MAX_VALUE;\n        } else if (str.equals(\"only\")) {\n            return def;\n        }\n        return Integer.parseInt(str);\n    }\n\n    static int parseMonth(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n\n    static int parseDayOfWeek(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n    \n    static String parseOptional(String str) {\n        return (str.equals(\"-\")) ? null : str;\n    }\n\n    static int parseTime(String str) {\n        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n        int pos = 0;\n        if (str.startsWith(\"-\")) {\n            pos = 1;\n        }\n        int newPos = p.parseInto(mdt, str, pos);\n        if (newPos == ~pos) {\n            throw new IllegalArgumentException(str);\n        }\n        int millis = (int)mdt.getMillis();\n        if (pos == 1) {\n            millis = -millis;\n        }\n        return millis;\n    }\n\n    static char parseZoneChar(char c) {\n        switch (c) {\n        case 's': case 'S':\n            // Standard time\n            return 's';\n        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n            // UTC\n            return 'u';\n        case 'w': case 'W': default:\n            // Wall time\n            return 'w';\n        }\n    }\n\n    /**\n     * @return false if error.\n     */\n    static boolean test(String id, DateTimeZone tz) {\n        if (!id.equals(tz.getID())) {\n            return true;\n        }\n\n        // Test to ensure that reported transitions are not duplicated.\n\n        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n\n        int offset = tz.getOffset(millis);\n        String key = tz.getNameKey(millis);\n\n        List<Long> transitions = new ArrayList<Long>();\n\n        while (true) {\n            long next = tz.nextTransition(millis);\n            if (next == millis || next > end) {\n                break;\n            }\n\n            millis = next;\n\n            int nextOffset = tz.getOffset(millis);\n            String nextKey = tz.getNameKey(millis);\n\n            if (offset == nextOffset\n                && key.equals(nextKey)) {\n                System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()));\n                return false;\n            }\n\n            if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n                System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC())\n                                   + \", nameKey=\" + nextKey);\n                return false;\n            }\n\n            transitions.add(Long.valueOf(millis));\n\n            offset = nextOffset;\n            key = nextKey;\n        }\n\n        // Now verify that reverse transitions match up.\n\n        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n\n        for (int i=transitions.size(); --i>= 0; ) {\n            long prev = tz.previousTransition(millis);\n            if (prev == millis || prev < end) {\n                break;\n            }\n\n            millis = prev;\n\n            long trans = transitions.get(i).longValue();\n            \n            if (trans - 1 != millis) {\n                System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()) + \" != \"\n                                   + new DateTime(trans - 1,\n                                                  ISOChronology.getInstanceUTC()));\n                                   \n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Maps names to RuleSets.\n    private Map<String, RuleSet> iRuleSets;\n\n    // List of Zone objects.\n    private List<Zone> iZones;\n\n    // List String pairs to link.\n    private List<String> iLinks;\n\n    public ZoneInfoCompiler() {\n        iRuleSets = new HashMap<String, RuleSet>();\n        iZones = new ArrayList<Zone>();\n        iLinks = new ArrayList<String>();\n    }\n\n    /**\n     * Returns a map of ids to DateTimeZones.\n     *\n     * @param outputDir optional directory to write compiled data files to\n     * @param sources optional list of source files to parse\n     */\n    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n        if (sources != null) {\n            for (int i=0; i<sources.length; i++) {\n                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n                parseDataFile(in);\n                in.close();\n            }\n        }\n\n        if (outputDir != null) {\n            if (!outputDir.exists()) {\n                if (!outputDir.mkdirs()) {\n                    throw new IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n                }\n            }\n            if (!outputDir.isDirectory()) {\n                throw new IOException(\"Destination is not a directory: \" + outputDir);\n            }\n        }\n\n        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n\n        System.out.println(\"Writing zoneinfo files\");\n        for (int i=0; i<iZones.size(); i++) {\n            Zone zone = iZones.get(i);\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            zone.addToBuilder(builder, iRuleSets);\n            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n            DateTimeZone tz = original;\n            if (test(tz.getID(), tz)) {\n                map.put(tz.getID(), tz);\n                if (outputDir != null) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Writing \" + tz.getID());\n                    }\n                    File file = new File(outputDir, tz.getID());\n                    if (!file.getParentFile().exists()) {\n                        file.getParentFile().mkdirs();\n                    }\n                    OutputStream out = new FileOutputStream(file);\n                    try {\n                        builder.writeTo(zone.iName, out);\n                    } finally {\n                        out.close();\n                    }\n\n                    // Test if it can be read back.\n                    InputStream in = new FileInputStream(file);\n                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n                    in.close();\n\n                    if (!original.equals(tz2)) {\n                        System.out.println(\"*e* Error in \" + tz.getID() +\n                                           \": Didn't read properly from file\");\n                    }\n                }\n            }\n        }\n\n        for (int pass=0; pass<2; pass++) {\n            for (int i=0; i<iLinks.size(); i += 2) {\n                String id = iLinks.get(i);\n                String alias = iLinks.get(i + 1);\n                DateTimeZone tz = map.get(id);\n                if (tz == null) {\n                    if (pass > 0) {\n                        System.out.println(\"Cannot find time zone '\" + id +\n                                           \"' to link alias '\" + alias + \"' to\");\n                    }\n                } else {\n                    map.put(alias, tz);\n                }\n            }\n        }\n\n        if (outputDir != null) {\n            System.out.println(\"Writing ZoneInfoMap\");\n            File file = new File(outputDir, \"ZoneInfoMap\");\n            if (!file.getParentFile().exists()) {\n                file.getParentFile().mkdirs();\n            }\n\n            OutputStream out = new FileOutputStream(file);\n            DataOutputStream dout = new DataOutputStream(out);\n            try {\n                // Sort and filter out any duplicates that match case.\n                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n                zimap.putAll(map);\n                writeZoneInfoMap(dout, zimap);\n            } finally {\n                dout.close();\n            }\n        }\n\n        return map;\n    }\n\n    public void parseDataFile(BufferedReader in) throws IOException {\n        Zone zone = null;\n        String line;\n        while ((line = in.readLine()) != null) {\n            String trimmed = line.trim();\n            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {\n                continue;\n            }\n\n            int index = line.indexOf('#');\n            if (index >= 0) {\n                line = line.substring(0, index);\n            }\n\n            //System.out.println(line);\n\n            StringTokenizer st = new StringTokenizer(line, \" \\t\");\n\n            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n                if (zone != null) {\n                    // Zone continuation\n                    zone.chain(st);\n                }\n                continue;\n            } else {\n                if (zone != null) {\n                    iZones.add(zone);\n                }\n                zone = null;\n            }\n\n            if (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                if (token.equalsIgnoreCase(\"Rule\")) {\n                    Rule r = new Rule(st);\n                    RuleSet rs = iRuleSets.get(r.iName);\n                    if (rs == null) {\n                        rs = new RuleSet(r);\n                        iRuleSets.put(r.iName, rs);\n                    } else {\n                        rs.addRule(r);\n                    }\n                } else if (token.equalsIgnoreCase(\"Zone\")) {\n                    zone = new Zone(st);\n                } else if (token.equalsIgnoreCase(\"Link\")) {\n                    iLinks.add(st.nextToken());\n                    iLinks.add(st.nextToken());\n                } else {\n                    System.out.println(\"Unknown line: \" + line);\n                }\n            }\n        }\n\n        if (zone != null) {\n            iZones.add(zone);\n        }\n    }\n\n    static class DateTimeOfYear {\n        public final int iMonthOfYear;\n        public final int iDayOfMonth;\n        public final int iDayOfWeek;\n        public final boolean iAdvanceDayOfWeek;\n        public final int iMillisOfDay;\n        public final char iZoneChar;\n\n        DateTimeOfYear() {\n            iMonthOfYear = 1;\n            iDayOfMonth = 1;\n            iDayOfWeek = 0;\n            iAdvanceDayOfWeek = false;\n            iMillisOfDay = 0;\n            iZoneChar = 'w';\n        }\n\n        DateTimeOfYear(StringTokenizer st) {\n            int month = 1;\n            int day = 1;\n            int dayOfWeek = 0;\n            int millis = 0;\n            boolean advance = false;\n            char zoneChar = 'w';\n\n            if (st.hasMoreTokens()) {\n                month = parseMonth(st.nextToken());\n\n                if (st.hasMoreTokens()) {\n                    String str = st.nextToken();\n                    if (str.startsWith(\"last\")) {\n                        day = -1;\n                        dayOfWeek = parseDayOfWeek(str.substring(4));\n                        advance = false;\n                    } else {\n                        try {\n                            day = Integer.parseInt(str);\n                            dayOfWeek = 0;\n                            advance = false;\n                        } catch (NumberFormatException e) {\n                            int index = str.indexOf(\">=\");\n                            if (index > 0) {\n                                day = Integer.parseInt(str.substring(index + 2));\n                                dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                advance = true;\n                            } else {\n                                index = str.indexOf(\"<=\");\n                                if (index > 0) {\n                                    day = Integer.parseInt(str.substring(index + 2));\n                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                    advance = false;\n                                } else {\n                                    throw new IllegalArgumentException(str);\n                                }\n                            }\n                        }\n                    }\n\n                    if (st.hasMoreTokens()) {\n                        str = st.nextToken();\n                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n                        if (str.equals(\"24:00\")) {\n                            LocalDate date = (day == -1 ?\n                                    new LocalDate(2001, month, 1).plusMonths(1) :\n                                    new LocalDate(2001, month, day).plusDays(1));\n                            advance = (day != -1);\n                            month = date.getMonthOfYear();\n                            day = date.getDayOfMonth();\n                            dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;\n                        } else {\n                            millis = parseTime(str);\n                        }\n                    }\n                }\n            }\n\n            iMonthOfYear = month;\n            iDayOfMonth = day;\n            iDayOfWeek = dayOfWeek;\n            iAdvanceDayOfWeek = advance;\n            iMillisOfDay = millis;\n            iZoneChar = zoneChar;\n        }\n\n        /**\n         * Adds a recurring savings rule to the builder.\n         */\n        public void addRecurring(DateTimeZoneBuilder builder, String nameKey,\n                                 int saveMillis, int fromYear, int toYear)\n        {\n            builder.addRecurringSavings(nameKey, saveMillis,\n                                        fromYear, toYear,\n                                        iZoneChar,\n                                        iMonthOfYear,\n                                        iDayOfMonth,\n                                        iDayOfWeek,\n                                        iAdvanceDayOfWeek,\n                                        iMillisOfDay);\n        }\n\n        /**\n         * Adds a cutover to the builder.\n         */\n        public void addCutover(DateTimeZoneBuilder builder, int year) {\n            builder.addCutover(year,\n                               iZoneChar,\n                               iMonthOfYear,\n                               iDayOfMonth,\n                               iDayOfWeek,\n                               iAdvanceDayOfWeek,\n                               iMillisOfDay);\n        }\n\n        public String toString() {\n            return\n                \"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n                \"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n                \"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n                \"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n                \"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n                \"ZoneChar: \" + iZoneChar + \"\\n\";\n        }\n    }\n\n    private static class Rule {\n        public final String iName;\n        public final int iFromYear;\n        public final int iToYear;\n        public final String iType;\n        public final DateTimeOfYear iDateTimeOfYear;\n        public final int iSaveMillis;\n        public final String iLetterS;\n\n        Rule(StringTokenizer st) {\n            iName = st.nextToken().intern();\n            iFromYear = parseYear(st.nextToken(), 0);\n            iToYear = parseYear(st.nextToken(), iFromYear);\n            if (iToYear < iFromYear) {\n                throw new IllegalArgumentException();\n            }\n            iType = parseOptional(st.nextToken());\n            iDateTimeOfYear = new DateTimeOfYear(st);\n            iSaveMillis = parseTime(st.nextToken());\n            iLetterS = parseOptional(st.nextToken());\n        }\n\n        /**\n         * Adds a recurring savings rule to the builder.\n         */\n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            String nameKey = formatName(nameFormat);\n            iDateTimeOfYear.addRecurring\n                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n        }\n\n        private String formatName(String nameFormat) {\n            int index = nameFormat.indexOf('/');\n            if (index > 0) {\n                if (iSaveMillis == 0) {\n                    // Extract standard name.\n                    return nameFormat.substring(0, index).intern();\n                } else {\n                    return nameFormat.substring(index + 1).intern();\n                }\n            }\n            index = nameFormat.indexOf(\"%s\");\n            if (index < 0) {\n                return nameFormat;\n            }\n            String left = nameFormat.substring(0, index);\n            String right = nameFormat.substring(index + 2);\n            String name;\n            if (iLetterS == null) {\n                name = left.concat(right);\n            } else {\n                name = left + iLetterS + right;\n            }\n            return name.intern();\n        }\n\n        public String toString() {\n            return\n                \"[Rule]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"FromYear: \" + iFromYear + \"\\n\" +\n                \"ToYear: \" + iToYear + \"\\n\" +\n                \"Type: \" + iType + \"\\n\" +\n                iDateTimeOfYear +\n                \"SaveMillis: \" + iSaveMillis + \"\\n\" +\n                \"LetterS: \" + iLetterS + \"\\n\";\n        }\n    }\n\n    private static class RuleSet {\n        private List<Rule> iRules;\n\n        RuleSet(Rule rule) {\n            iRules = new ArrayList<Rule>();\n            iRules.add(rule);\n        }\n\n        void addRule(Rule rule) {\n            if (!(rule.iName.equals(iRules.get(0).iName))) {\n                throw new IllegalArgumentException(\"Rule name mismatch\");\n            }\n            iRules.add(rule);\n        }\n\n        /**\n         * Adds recurring savings rules to the builder.\n         */\n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            for (int i=0; i<iRules.size(); i++) {\n                Rule rule = iRules.get(i);\n                rule.addRecurring(builder, nameFormat);\n            }\n        }\n    }\n\n    private static class Zone {\n        public final String iName;\n        public final int iOffsetMillis;\n        public final String iRules;\n        public final String iFormat;\n        public final int iUntilYear;\n        public final DateTimeOfYear iUntilDateTimeOfYear;\n\n        private Zone iNext;\n\n        Zone(StringTokenizer st) {\n            this(st.nextToken(), st);\n        }\n\n        private Zone(String name, StringTokenizer st) {\n            iName = name.intern();\n            iOffsetMillis = parseTime(st.nextToken());\n            iRules = parseOptional(st.nextToken());\n            iFormat = st.nextToken().intern();\n\n            int year = Integer.MAX_VALUE;\n            DateTimeOfYear dtOfYear = getStartOfYear();\n\n            if (st.hasMoreTokens()) {\n                year = Integer.parseInt(st.nextToken());\n                if (st.hasMoreTokens()) {\n                    dtOfYear = new DateTimeOfYear(st);\n                }\n            }\n\n            iUntilYear = year;\n            iUntilDateTimeOfYear = dtOfYear;\n        }\n\n        void chain(StringTokenizer st) {\n            if (iNext != null) {\n                iNext.chain(st);\n            } else {\n                iNext = new Zone(iName, st);\n            }\n        }\n\n        /*\n        public DateTimeZone buildDateTimeZone(Map ruleSets) {\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            addToBuilder(builder, ruleSets);\n            return builder.toDateTimeZone(iName);\n        }\n        */\n\n        /**\n         * Adds zone info to the builder.\n         */\n        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n            addToBuilder(this, builder, ruleSets);\n        }\n\n        private static void addToBuilder(Zone zone,\n                                         DateTimeZoneBuilder builder,\n                                         Map<String, RuleSet> ruleSets)\n        {\n            for (; zone != null; zone = zone.iNext) {\n                builder.setStandardOffset(zone.iOffsetMillis);\n\n                if (zone.iRules == null) {\n                    builder.setFixedSavings(zone.iFormat, 0);\n                } else {\n                    try {\n                        // Check if iRules actually just refers to a savings.\n                        int saveMillis = parseTime(zone.iRules);\n                        builder.setFixedSavings(zone.iFormat, saveMillis);\n                    }\n                    catch (Exception e) {\n                        RuleSet rs = ruleSets.get(zone.iRules);\n                        if (rs == null) {\n                            throw new IllegalArgumentException\n                                (\"Rules not found: \" + zone.iRules);\n                        }\n                        rs.addRecurring(builder, zone.iFormat);\n                    }\n                }\n\n                if (zone.iUntilYear == Integer.MAX_VALUE) {\n                    break;\n                }\n\n                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n            }\n        }\n\n        public String toString() {\n            String str =\n                \"[Zone]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n                \"Rules: \" + iRules + \"\\n\" +\n                \"Format: \" + iFormat + \"\\n\" +\n                \"UntilYear: \" + iUntilYear + \"\\n\" +\n                iUntilDateTimeOfYear;\n\n            if (iNext == null) {\n                return str;\n            }\n\n            return str + \"...\\n\" + iNext.toString();\n        }\n    }\n}\n\n", "fixed_version": "/*\n *  Copyright 2001-2013 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.tz;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Map.Entry;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.LocalDate;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.chrono.LenientChronology;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Compiles Olson ZoneInfo database files into binary files for each time zone\n * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n * converts them back into {@link DateTimeZone} objects.\n * <p>\n * Although this tool is similar to zic, the binary formats are not\n * compatible. The latest Olson database files may be obtained\n * <a href=\"http://www.twinsun.com/tz/tz-link.htm\">here</a>.\n * <p>\n * ZoneInfoCompiler is mutable and not thread-safe, although the main method\n * may be safely invoked by multiple threads.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic class ZoneInfoCompiler {\n    static DateTimeOfYear cStartOfYear;\n\n    static Chronology cLenientISO;\n\n    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n        protected Boolean initialValue() {\n            return Boolean.FALSE;\n        }\n    };\n\n    /**\n     * Gets a flag indicating that verbose logging is required.\n     * @return true to log verbosely\n     */\n    public static boolean verbose() {\n        return cVerbose.get();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Launches the ZoneInfoCompiler tool.\n     *\n     * <pre>\n     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;\n     * where possible options include:\n     *   -src &lt;directory&gt;    Specify where to read source files\n     *   -dst &lt;directory&gt;    Specify where to write generated files\n     *   -verbose            Output verbosely (default false)\n     * </pre>\n     */\n    public static void main(String[] args) throws Exception {\n        if (args.length == 0) {\n            printUsage();\n            return;\n        }\n\n        File inputDir = null;\n        File outputDir = null;\n        boolean verbose = false;\n\n        int i;\n        for (i=0; i<args.length; i++) {\n            try {\n                if (\"-src\".equals(args[i])) {\n                    inputDir = new File(args[++i]);\n                } else if (\"-dst\".equals(args[i])) {\n                    outputDir = new File(args[++i]);\n                } else if (\"-verbose\".equals(args[i])) {\n                    verbose = true;\n                } else if (\"-?\".equals(args[i])) {\n                    printUsage();\n                    return;\n                } else {\n                    break;\n                }\n            } catch (IndexOutOfBoundsException e) {\n                printUsage();\n                return;\n            }\n        }\n\n        if (i >= args.length) {\n            printUsage();\n            return;\n        }\n\n        File[] sources = new File[args.length - i];\n        for (int j=0; i<args.length; i++,j++) {\n            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n        }\n\n        cVerbose.set(verbose);\n        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n        zic.compile(outputDir, sources);\n    }\n\n    private static void printUsage() {\n        System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n        System.out.println(\"where possible options include:\");\n        System.out.println(\"  -src <directory>    Specify where to read source files\");\n        System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n        System.out.println(\"  -verbose            Output verbosely (default false)\");\n    }\n\n    static DateTimeOfYear getStartOfYear() {\n        if (cStartOfYear == null) {\n            cStartOfYear = new DateTimeOfYear();\n        }\n        return cStartOfYear;\n    }\n\n    static Chronology getLenientISOChronology() {\n        if (cLenientISO == null) {\n            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n        }\n        return cLenientISO;\n    }\n\n    /**\n     * @param zimap maps string ids to DateTimeZone objects.\n     */\n    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n        // Build the string pool.\n        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n\n        short count = 0;\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = (String)entry.getKey();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n            id = ((DateTimeZone)entry.getValue()).getID();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"Too many time zone ids\");\n                }\n            }\n        }\n\n        // Write the string pool, ordered by index.\n        dout.writeShort(indexToId.size());\n        for (String id : indexToId.values()) {\n            dout.writeUTF(id);\n        }\n\n        // Write the mappings.\n        dout.writeShort(zimap.size());\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = entry.getKey();\n            dout.writeShort(idToIndex.get(id).shortValue());\n            id = entry.getValue().getID();\n            dout.writeShort(idToIndex.get(id).shortValue());\n        }\n    }\n\n    static int parseYear(String str, int def) {\n        str = str.toLowerCase();\n        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n            return Integer.MIN_VALUE;\n        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n            return Integer.MAX_VALUE;\n        } else if (str.equals(\"only\")) {\n            return def;\n        }\n        return Integer.parseInt(str);\n    }\n\n    static int parseMonth(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n\n    static int parseDayOfWeek(String str) {\n        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n        return field.get(field.set(0, str, Locale.ENGLISH));\n    }\n    \n    static String parseOptional(String str) {\n        return (str.equals(\"-\")) ? null : str;\n    }\n\n    static int parseTime(String str) {\n        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n        int pos = 0;\n        if (str.startsWith(\"-\")) {\n            pos = 1;\n        }\n        int newPos = p.parseInto(mdt, str, pos);\n        if (newPos == ~pos) {\n            throw new IllegalArgumentException(str);\n        }\n        int millis = (int)mdt.getMillis();\n        if (pos == 1) {\n            millis = -millis;\n        }\n        return millis;\n    }\n\n    static char parseZoneChar(char c) {\n        switch (c) {\n        case 's': case 'S':\n            // Standard time\n            return 's';\n        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n            // UTC\n            return 'u';\n        case 'w': case 'W': default:\n            // Wall time\n            return 'w';\n        }\n    }\n\n    /**\n     * @return false if error.\n     */\n    static boolean test(String id, DateTimeZone tz) {\n        if (!id.equals(tz.getID())) {\n            return true;\n        }\n\n        // Test to ensure that reported transitions are not duplicated.\n\n        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n\n        int offset = tz.getOffset(millis);\n        String key = tz.getNameKey(millis);\n\n        List<Long> transitions = new ArrayList<Long>();\n\n        while (true) {\n            long next = tz.nextTransition(millis);\n            if (next == millis || next > end) {\n                break;\n            }\n\n            millis = next;\n\n            int nextOffset = tz.getOffset(millis);\n            String nextKey = tz.getNameKey(millis);\n\n            if (offset == nextOffset\n                && key.equals(nextKey)) {\n                System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()));\n                return false;\n            }\n\n            if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n                System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC())\n                                   + \", nameKey=\" + nextKey);\n                return false;\n            }\n\n            transitions.add(Long.valueOf(millis));\n\n            offset = nextOffset;\n            key = nextKey;\n        }\n\n        // Now verify that reverse transitions match up.\n\n        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n\n        for (int i=transitions.size(); --i>= 0; ) {\n            long prev = tz.previousTransition(millis);\n            if (prev == millis || prev < end) {\n                break;\n            }\n\n            millis = prev;\n\n            long trans = transitions.get(i).longValue();\n            \n            if (trans - 1 != millis) {\n                System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()) + \" != \"\n                                   + new DateTime(trans - 1,\n                                                  ISOChronology.getInstanceUTC()));\n                                   \n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Maps names to RuleSets.\n    private Map<String, RuleSet> iRuleSets;\n\n    // List of Zone objects.\n    private List<Zone> iZones;\n\n    // List String pairs to link.\n    private List<String> iLinks;\n\n    public ZoneInfoCompiler() {\n        iRuleSets = new HashMap<String, RuleSet>();\n        iZones = new ArrayList<Zone>();\n        iLinks = new ArrayList<String>();\n    }\n\n    /**\n     * Returns a map of ids to DateTimeZones.\n     *\n     * @param outputDir optional directory to write compiled data files to\n     * @param sources optional list of source files to parse\n     */\n    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n        if (sources != null) {\n            for (int i=0; i<sources.length; i++) {\n                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n                parseDataFile(in);\n                in.close();\n            }\n        }\n\n        if (outputDir != null) {\n            if (!outputDir.exists()) {\n                if (!outputDir.mkdirs()) {\n                    throw new IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n                }\n            }\n            if (!outputDir.isDirectory()) {\n                throw new IOException(\"Destination is not a directory: \" + outputDir);\n            }\n        }\n\n        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n\n        System.out.println(\"Writing zoneinfo files\");\n        for (int i=0; i<iZones.size(); i++) {\n            Zone zone = iZones.get(i);\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            zone.addToBuilder(builder, iRuleSets);\n            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n            DateTimeZone tz = original;\n            if (test(tz.getID(), tz)) {\n                map.put(tz.getID(), tz);\n                if (outputDir != null) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Writing \" + tz.getID());\n                    }\n                    File file = new File(outputDir, tz.getID());\n                    if (!file.getParentFile().exists()) {\n                        file.getParentFile().mkdirs();\n                    }\n                    OutputStream out = new FileOutputStream(file);\n                    try {\n                        builder.writeTo(zone.iName, out);\n                    } finally {\n                        out.close();\n                    }\n\n                    // Test if it can be read back.\n                    InputStream in = new FileInputStream(file);\n                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n                    in.close();\n\n                    if (!original.equals(tz2)) {\n                        System.out.println(\"*e* Error in \" + tz.getID() +\n                                           \": Didn't read properly from file\");\n                    }\n                }\n            }\n        }\n\n        for (int pass=0; pass<2; pass++) {\n            for (int i=0; i<iLinks.size(); i += 2) {\n                String id = iLinks.get(i);\n                String alias = iLinks.get(i + 1);\n                DateTimeZone tz = map.get(id);\n                if (tz == null) {\n                    if (pass > 0) {\n                        System.out.println(\"Cannot find time zone '\" + id +\n                                           \"' to link alias '\" + alias + \"' to\");\n                    }\n                } else {\n                    map.put(alias, tz);\n                }\n            }\n        }\n\n        if (outputDir != null) {\n            System.out.println(\"Writing ZoneInfoMap\");\n            File file = new File(outputDir, \"ZoneInfoMap\");\n            if (!file.getParentFile().exists()) {\n                file.getParentFile().mkdirs();\n            }\n\n            OutputStream out = new FileOutputStream(file);\n            DataOutputStream dout = new DataOutputStream(out);\n            try {\n                // Sort and filter out any duplicates that match case.\n                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n                zimap.putAll(map);\n                writeZoneInfoMap(dout, zimap);\n            } finally {\n                dout.close();\n            }\n        }\n\n        return map;\n    }\n\n    public void parseDataFile(BufferedReader in) throws IOException {\n        Zone zone = null;\n        String line;\n        while ((line = in.readLine()) != null) {\n            String trimmed = line.trim();\n            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {\n                continue;\n            }\n\n            int index = line.indexOf('#');\n            if (index >= 0) {\n                line = line.substring(0, index);\n            }\n\n            //System.out.println(line);\n\n            StringTokenizer st = new StringTokenizer(line, \" \\t\");\n\n            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n                if (zone != null) {\n                    // Zone continuation\n                    zone.chain(st);\n                }\n                continue;\n            } else {\n                if (zone != null) {\n                    iZones.add(zone);\n                }\n                zone = null;\n            }\n\n            if (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                if (token.equalsIgnoreCase(\"Rule\")) {\n                    Rule r = new Rule(st);\n                    RuleSet rs = iRuleSets.get(r.iName);\n                    if (rs == null) {\n                        rs = new RuleSet(r);\n                        iRuleSets.put(r.iName, rs);\n                    } else {\n                        rs.addRule(r);\n                    }\n                } else if (token.equalsIgnoreCase(\"Zone\")) {\n                    zone = new Zone(st);\n                } else if (token.equalsIgnoreCase(\"Link\")) {\n                    iLinks.add(st.nextToken());\n                    iLinks.add(st.nextToken());\n                } else {\n                    System.out.println(\"Unknown line: \" + line);\n                }\n            }\n        }\n\n        if (zone != null) {\n            iZones.add(zone);\n        }\n    }\n\n    static class DateTimeOfYear {\n        public final int iMonthOfYear;\n        public final int iDayOfMonth;\n        public final int iDayOfWeek;\n        public final boolean iAdvanceDayOfWeek;\n        public final int iMillisOfDay;\n        public final char iZoneChar;\n\n        DateTimeOfYear() {\n            iMonthOfYear = 1;\n            iDayOfMonth = 1;\n            iDayOfWeek = 0;\n            iAdvanceDayOfWeek = false;\n            iMillisOfDay = 0;\n            iZoneChar = 'w';\n        }\n\n        DateTimeOfYear(StringTokenizer st) {\n            int month = 1;\n            int day = 1;\n            int dayOfWeek = 0;\n            int millis = 0;\n            boolean advance = false;\n            char zoneChar = 'w';\n\n            if (st.hasMoreTokens()) {\n                month = parseMonth(st.nextToken());\n\n                if (st.hasMoreTokens()) {\n                    String str = st.nextToken();\n                    if (str.startsWith(\"last\")) {\n                        day = -1;\n                        dayOfWeek = parseDayOfWeek(str.substring(4));\n                        advance = false;\n                    } else {\n                        try {\n                            day = Integer.parseInt(str);\n                            dayOfWeek = 0;\n                            advance = false;\n                        } catch (NumberFormatException e) {\n                            int index = str.indexOf(\">=\");\n                            if (index > 0) {\n                                day = Integer.parseInt(str.substring(index + 2));\n                                dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                advance = true;\n                            } else {\n                                index = str.indexOf(\"<=\");\n                                if (index > 0) {\n                                    day = Integer.parseInt(str.substring(index + 2));\n                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));\n                                    advance = false;\n                                } else {\n                                    throw new IllegalArgumentException(str);\n                                }\n                            }\n                        }\n                    }\n\n                    if (st.hasMoreTokens()) {\n                        str = st.nextToken();\n                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n                        if (str.equals(\"24:00\")) {\n                            LocalDate date = (day == -1 ?\n                                    new LocalDate(2001, month, 1).plusMonths(1) :\n                                    new LocalDate(2001, month, day).plusDays(1));\n                            advance = (day != -1);\n                            month = date.getMonthOfYear();\n                            day = date.getDayOfMonth();\n                            dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;\n                        } else {\n                            millis = parseTime(str);\n                        }\n                    }\n                }\n            }\n\n            iMonthOfYear = month;\n            iDayOfMonth = day;\n            iDayOfWeek = dayOfWeek;\n            iAdvanceDayOfWeek = advance;\n            iMillisOfDay = millis;\n            iZoneChar = zoneChar;\n        }\n\n        /**\n         * Adds a recurring savings rule to the builder.\n         */\n        public void addRecurring(DateTimeZoneBuilder builder, String nameKey,\n                                 int saveMillis, int fromYear, int toYear)\n        {\n            builder.addRecurringSavings(nameKey, saveMillis,\n                                        fromYear, toYear,\n                                        iZoneChar,\n                                        iMonthOfYear,\n                                        iDayOfMonth,\n                                        iDayOfWeek,\n                                        iAdvanceDayOfWeek,\n                                        iMillisOfDay);\n        }\n\n        /**\n         * Adds a cutover to the builder.\n         */\n        public void addCutover(DateTimeZoneBuilder builder, int year) {\n            builder.addCutover(year,\n                               iZoneChar,\n                               iMonthOfYear,\n                               iDayOfMonth,\n                               iDayOfWeek,\n                               iAdvanceDayOfWeek,\n                               iMillisOfDay);\n        }\n\n        public String toString() {\n            return\n                \"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n                \"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n                \"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n                \"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n                \"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n                \"ZoneChar: \" + iZoneChar + \"\\n\";\n        }\n    }\n\n    private static class Rule {\n        public final String iName;\n        public final int iFromYear;\n        public final int iToYear;\n        public final String iType;\n        public final DateTimeOfYear iDateTimeOfYear;\n        public final int iSaveMillis;\n        public final String iLetterS;\n\n        Rule(StringTokenizer st) {\n            iName = st.nextToken().intern();\n            iFromYear = parseYear(st.nextToken(), 0);\n            iToYear = parseYear(st.nextToken(), iFromYear);\n            if (iToYear < iFromYear) {\n                throw new IllegalArgumentException();\n            }\n            iType = parseOptional(st.nextToken());\n            iDateTimeOfYear = new DateTimeOfYear(st);\n            iSaveMillis = parseTime(st.nextToken());\n            iLetterS = parseOptional(st.nextToken());\n        }\n\n        /**\n         * Adds a recurring savings rule to the builder.\n         */\n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            String nameKey = formatName(nameFormat);\n            iDateTimeOfYear.addRecurring\n                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n        }\n\n        private String formatName(String nameFormat) {\n            int index = nameFormat.indexOf('/');\n            if (index > 0) {\n                if (iSaveMillis == 0) {\n                    // Extract standard name.\n                    return nameFormat.substring(0, index).intern();\n                } else {\n                    return nameFormat.substring(index + 1).intern();\n                }\n            }\n            index = nameFormat.indexOf(\"%s\");\n            if (index < 0) {\n                return nameFormat;\n            }\n            String left = nameFormat.substring(0, index);\n            String right = nameFormat.substring(index + 2);\n            String name;\n            if (iLetterS == null) {\n                name = left.concat(right);\n            } else {\n                name = left + iLetterS + right;\n            }\n            return name.intern();\n        }\n\n        public String toString() {\n            return\n                \"[Rule]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"FromYear: \" + iFromYear + \"\\n\" +\n                \"ToYear: \" + iToYear + \"\\n\" +\n                \"Type: \" + iType + \"\\n\" +\n                iDateTimeOfYear +\n                \"SaveMillis: \" + iSaveMillis + \"\\n\" +\n                \"LetterS: \" + iLetterS + \"\\n\";\n        }\n    }\n\n    private static class RuleSet {\n        private List<Rule> iRules;\n\n        RuleSet(Rule rule) {\n            iRules = new ArrayList<Rule>();\n            iRules.add(rule);\n        }\n\n        void addRule(Rule rule) {\n            if (!(rule.iName.equals(iRules.get(0).iName))) {\n                throw new IllegalArgumentException(\"Rule name mismatch\");\n            }\n            iRules.add(rule);\n        }\n\n        /**\n         * Adds recurring savings rules to the builder.\n         */\n        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            for (int i=0; i<iRules.size(); i++) {\n                Rule rule = iRules.get(i);\n                rule.addRecurring(builder, nameFormat);\n            }\n        }\n    }\n\n    private static class Zone {\n        public final String iName;\n        public final int iOffsetMillis;\n        public final String iRules;\n        public final String iFormat;\n        public final int iUntilYear;\n        public final DateTimeOfYear iUntilDateTimeOfYear;\n\n        private Zone iNext;\n\n        Zone(StringTokenizer st) {\n            this(st.nextToken(), st);\n        }\n\n        private Zone(String name, StringTokenizer st) {\n            iName = name.intern();\n            iOffsetMillis = parseTime(st.nextToken());\n            iRules = parseOptional(st.nextToken());\n            iFormat = st.nextToken().intern();\n\n            int year = Integer.MAX_VALUE;\n            DateTimeOfYear dtOfYear = getStartOfYear();\n\n            if (st.hasMoreTokens()) {\n                year = Integer.parseInt(st.nextToken());\n                if (st.hasMoreTokens()) {\n                    dtOfYear = new DateTimeOfYear(st);\n                }\n            }\n\n            iUntilYear = year;\n            iUntilDateTimeOfYear = dtOfYear;\n        }\n\n        void chain(StringTokenizer st) {\n            if (iNext != null) {\n                iNext.chain(st);\n            } else {\n                iNext = new Zone(iName, st);\n            }\n        }\n\n        /*\n        public DateTimeZone buildDateTimeZone(Map ruleSets) {\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            addToBuilder(builder, ruleSets);\n            return builder.toDateTimeZone(iName);\n        }\n        */\n\n        /**\n         * Adds zone info to the builder.\n         */\n        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n            addToBuilder(this, builder, ruleSets);\n        }\n\n        private static void addToBuilder(Zone zone,\n                                         DateTimeZoneBuilder builder,\n                                         Map<String, RuleSet> ruleSets)\n        {\n            for (; zone != null; zone = zone.iNext) {\n                builder.setStandardOffset(zone.iOffsetMillis);\n\n                if (zone.iRules == null) {\n                    builder.setFixedSavings(zone.iFormat, 0);\n                } else {\n                    try {\n                        // Check if iRules actually just refers to a savings.\n                        int saveMillis = parseTime(zone.iRules);\n                        builder.setFixedSavings(zone.iFormat, saveMillis);\n                    }\n                    catch (Exception e) {\n                        RuleSet rs = ruleSets.get(zone.iRules);\n                        if (rs == null) {\n                            throw new IllegalArgumentException\n                                (\"Rules not found: \" + zone.iRules);\n                        }\n                        rs.addRecurring(builder, zone.iFormat);\n                    }\n                }\n\n                if (zone.iUntilYear == Integer.MAX_VALUE) {\n                    break;\n                }\n\n                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n            }\n        }\n\n        public String toString() {\n            String str =\n                \"[Zone]\\n\" + \n                \"Name: \" + iName + \"\\n\" +\n                \"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n                \"Rules: \" + iRules + \"\\n\" +\n                \"Format: \" + iFormat + \"\\n\" +\n                \"UntilYear: \" + iUntilYear + \"\\n\" +\n                iUntilDateTimeOfYear;\n\n            if (iNext == null) {\n                return str;\n            }\n\n            return str + \"...\\n\" + iNext.toString();\n        }\n    }\n}\n\n"}]}
{"project": "Time", "bug_id": 12, "classes_modified": [{"class_name": "org.joda.time.LocalDate", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * LocalDate is an immutable datetime class representing a date\n * without a time zone.\n * <p>\n * LocalDate implements the {@link ReadablePartial} interface.\n * To do this, the interface methods focus on the key fields -\n * Year, MonthOfYear and DayOfMonth.\n * However, <b>all</b> date fields may in fact be queried.\n * <p>\n * LocalDate differs from DateMidnight in that this class does not\n * have a time zone and does not represent a single instant in time.\n * <p>\n * Calculations on LocalDate are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getMonthOfYear()</code>\n * <li><code>monthOfYear().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalDate is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3\n */\npublic final class LocalDate\n        extends BaseLocal\n        implements ReadablePartial, Serializable {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -8775358157899L;\n\n    /** The index of the year field in the field array */\n    private static final int YEAR = 0;\n    /** The index of the monthOfYear field in the field array */\n    private static final int MONTH_OF_YEAR = 1;\n    /** The index of the dayOfMonth field in the field array */\n    private static final int DAY_OF_MONTH = 2;\n    /** Set of known duration types. */\n    private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\n    static {\n        DATE_DURATION_TYPES.add(DurationFieldType.days());\n        DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n        DATE_DURATION_TYPES.add(DurationFieldType.months());\n        DATE_DURATION_TYPES.add(DurationFieldType.weekyears());\n        DATE_DURATION_TYPES.add(DurationFieldType.years());\n        DATE_DURATION_TYPES.add(DurationFieldType.centuries());\n        // eras are supported, although the DurationField generally isn't\n        DATE_DURATION_TYPES.add(DurationFieldType.eras());\n    }\n\n    /** The local millis from 1970-01-01T00:00:00 */\n    private final long iLocalMillis;\n    /** The chronology to use in UTC. */\n    private final Chronology iChronology;\n    /** The cached hash code. */\n    private transient volatile int iHash;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static LocalDate now() {\n        return new LocalDate();\n    }\n\n    /**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     *\n     * @param zone  the time zone, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static LocalDate now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDate(zone);\n    }\n\n    /**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static LocalDate now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDate(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code LocalDate} from the specified string.\n     * <p>\n     * This uses {@link ISODateTimeFormat#localDateParser()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static LocalDate parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateParser());\n    }\n\n    /**\n     * Parses a {@code LocalDate} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static LocalDate parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDate(str);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n\n    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */\n    public LocalDate() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */\n    public LocalDate(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */\n    public LocalDate(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */\n    public LocalDate(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */\n    public LocalDate(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDate(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n        iChronology = chronology;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from an Object that represents a datetime.\n     * The time zone will be retrieved from the object if possible,\n     * otherwise the default time zone will be used.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDate(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDate(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDate(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     */\n    public LocalDate(\n            int year,\n            int monthOfYear,\n            int dayOfMonth) {\n        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using the specified chronology, whose zone is ignored.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code> is used.\n     *\n     * @param year  the year, valid values defined by the chronology\n     * @param monthOfYear  the month of the year, valid values defined by the chronology\n     * @param dayOfMonth  the day of the month, valid values defined by the chronology\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDate(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    /**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */\n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDate(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial, which is three.\n     * The supported fields are Year, MonthOfYear and DayOfMonth.\n     * Note that all fields from day and above may in fact be queried via\n     * other methods.\n     *\n     * @return the field count, three\n     */\n    public int size() {\n        return 3;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * <p>\n     * This method must not use any instance variables.\n     *\n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    /**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.\n     * Note that all fields from day and above may in fact be queried via\n     * other methods.\n     *\n     * @param index  the index, zero to two\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * LocalDate dt = LocalDate.nowDefaultZone();\n     * int year = dt.get(DateTimeFieldType.year());\n     * </pre>\n     *\n     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */\n    public int get(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return fieldType.getField(getChronology()).get(getLocalMillis());\n    }\n\n    /**\n     * Checks if the field type specified is supported by this\n     * local date and chronology.\n     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationFieldType durType = type.getDurationType();\n        if (DATE_DURATION_TYPES.contains(durType) ||\n                durType.getField(getChronology()).getUnitMillis() >=\n                    getChronology().days().getUnitMillis()) {\n            return type.getField(getChronology()).isSupported();\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the duration type specified is supported by this\n     * local date and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type) ||\n            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the local milliseconds from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */\n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    /**\n     * Gets the chronology of the date.\n     * \n     * @return the Chronology that the date is using\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */\n    public boolean equals(Object partial) {\n        // override to perform faster\n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    /**\n     * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.\n     *\n     * @return a suitable hash code\n     */\n    public int hashCode() {\n        // override for performance\n        int hash = iHash;\n        if (hash == 0) {\n            hash = iHash = super.hashCode();\n        }\n        return hash;\n    }\n\n    /**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */\n    public int compareTo(ReadablePartial partial) {\n        // override to perform faster\n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a full datetime at the earliest valid time\n     * for the date using the default time zone.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     * \n     * @return this date as a datetime at the start of the day\n     * @since 1.5\n     */\n    public DateTime toDateTimeAtStartOfDay() {\n        return toDateTimeAtStartOfDay(null);\n    }\n\n    /**\n     * Converts this LocalDate to a full datetime at the earliest valid time\n     * for the date using the specified time zone.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime at the start of the day\n     * @since 1.5\n     */\n    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n        long instant = zone.convertLocalToUTC(localMillis, false);\n        instant = chrono.dayOfMonth().roundFloor(instant);\n        return new DateTime(instant, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a full datetime at midnight using the default\n     * time zone.\n     * <p>\n     * This method will throw an exception if the default time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     * \n     * @return this date as a datetime at midnight\n     * @deprecated Use {@link #toDateTimeAtStartOfDay()} which won't throw an exception\n     */\n    @Deprecated\n    public DateTime toDateTimeAtMidnight() {\n        return toDateTimeAtMidnight(null);\n    }\n\n    /**\n     * Converts this LocalDate to a full datetime at midnight using the\n     * specified time zone.\n     * <p>\n     * This method will throw an exception if the time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime at midnight\n     * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception\n     */\n    @Deprecated\n    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a full datetime using the default time zone\n     * setting the date fields from this instance and the time fields from\n     * the current time.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return this date as a datetime with the time as the current time\n     */\n    public DateTime toDateTimeAtCurrentTime() {\n        return toDateTimeAtCurrentTime(null);\n    }\n\n    /**\n     * Converts this LocalDate to a full datetime using the specified time zone\n     * setting the date fields from this instance and the time fields from\n     * the current time.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime with the time as the current time\n     */\n    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a DateMidnight in the default time zone.\n     * <p>\n     * As from v1.5, you are recommended to avoid DateMidnight and use\n     * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n     * detailed below.\n     * <p>\n     * This method will throw an exception if the default time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return the DateMidnight instance in the default zone\n     */\n    public DateMidnight toDateMidnight() {\n        return toDateMidnight(null);\n    }\n\n    /**\n     * Converts this LocalDate to a DateMidnight.\n     * <p>\n     * As from v1.5, you are recommended to avoid DateMidnight and use\n     * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n     * detailed below.\n     * <p>\n     * This method will throw an exception if the time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to get the DateMidnight in, null means default zone\n     * @return the DateMidnight instance\n     */\n    public DateMidnight toDateMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a LocalDateTime using a LocalTime to fill in\n     * the missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate. The chronology of the time must also match.\n     * If the time is null an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, must not be null\n     * @return the LocalDateTime instance\n     * @throws IllegalArgumentException if the time is null\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     * @since 1.5\n     */\n    public LocalDateTime toLocalDateTime(LocalTime time) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"The time must not be null\");\n        }\n        if (getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        long localMillis = getLocalMillis() + time.getLocalMillis();\n        return new LocalDateTime(localMillis, getChronology());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a DateTime using a LocalTime to fill in the\n     * missing fields and using the default time zone.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate. The chronology of the time must match.\n     * If the time is null, the current time in the date's chronology is used.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, null means current time\n     * @return the DateTime instance\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     */\n    public DateTime toDateTime(LocalTime time) {\n        return toDateTime(time, null);\n    }\n\n    /**\n     * Converts this object to a DateTime using a LocalTime to fill in the\n     * missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate plus the time zone. The chronology of the time must match.\n     * If the time is null, the current time in the date's chronology is used.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, null means current time\n     * @param zone  the zone to get the DateTime in, null means default\n     * @return the DateTime instance\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     */\n    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n        if (time != null && getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        Chronology chrono = getChronology().withZone(zone);\n        long instant = DateTimeUtils.currentTimeMillis();\n        instant = chrono.set(this, instant);\n        if (time != null) {\n            instant = chrono.set(time, instant);\n        }\n        return new DateTime(instant, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to an Interval representing the whole day\n     * in the default time zone.\n     * <p>\n     * The interval may have more or less than 24 hours if this is a daylight\n     * savings cutover date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a interval over the day\n     */\n    public Interval toInterval() {\n        return toInterval(null);\n    }\n\n    /**\n     * Converts this object to an Interval representing the whole day.\n     * <p>\n     * The interval may have more or less than 24 hours if this is a daylight\n     * savings cutover date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to get the Interval in, null means default\n     * @return a interval over the day\n     */\n    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        DateTime start = toDateTimeAtStartOfDay(zone);\n        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n        return new Interval(start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the date time as a <code>java.util.Date</code>.\n     * <p>\n     * The <code>Date</code> object created has exactly the same year, month and day\n     * as this date. The time will be set to the earliest valid time for that date.\n     * <p>\n     * Converting to a JDK Date is full of complications as the JDK Date constructor\n     * doesn't behave as you might expect around DST transitions. This method works\n     * by taking a first guess and then adjusting the JDK date until it has the\n     * earliest valid instant. This also handles the situation where the JDK time\n     * zone data differs from the Joda-Time time zone data.\n     *\n     * @return a Date initialised with this date, never null\n     * @since 2.0\n     */\n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\n        LocalDate check = LocalDate.fromDateFields(date);\n        if (check.isBefore(this)) {\n            // DST gap (no midnight)\n            // move forward in units of one hour until date correct\n            while (check.equals(this) == false) {\n                date.setTime(date.getTime() + 3600000);\n                check = LocalDate.fromDateFields(date);\n            }\n            // move back in units of one second until date wrong\n            while (date.getDate() == dom) {\n                date.setTime(date.getTime() - 1000);\n            }\n            // fix result\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            // check for DST overlap (two midnights)\n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            if (earlier.getDate() == dom) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this date with different millis\n     */\n    LocalDate withLocalMillis(long newMillis) {\n        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the partial set of fields replacing\n     * those from this instance.\n     * <p>\n     * For example, if the partial contains a year and a month then those two\n     * fields will be changed in the returned instance.\n     * Unsupported fields are ignored.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this date, null ignored\n     * @return a copy of this date with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */\n    public LocalDate withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>monthOfYear</code> then the\n     * month of year field will be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These two lines are equivalent:\n     * <pre>\n     * LocalDate updated = dt.withDayOfMonth(6);\n     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this date with the field set\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this date with the field updated\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getLocalMillis();\n        Chronology chrono = getChronology();\n        for (int i = 0; i < period.size(); i++) {\n            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n            DurationFieldType type = period.getFieldType(i);\n            if (isSupported(type)) {\n                instant = type.getField(chrono).add(instant, value);\n            }\n        }\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This adds the specified number of years to the date.\n     * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDate plus the increased years\n     */\n    public LocalDate plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This adds the specified number of months to the date.\n     * The addition may change the year, but the day-of-month is normally unchanged.\n     * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusMonths(6);\n     * LocalDate added = dt.plus(Period.months(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDate plus the increased months\n     */\n    public LocalDate plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date plus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusWeeks(6);\n     * LocalDate added = dt.plus(Period.weeks(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDate plus the increased weeks\n     */\n    public LocalDate plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusDays(6);\n     * LocalDate added = dt.plus(Period.days(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDate plus the increased days\n     */\n    public LocalDate plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus subtracting a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this LocalDate with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This subtracts the specified number of years from the date.\n     * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusYears(6);\n     * LocalDate subtracted = dt.minus(Period.years(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDate minus the increased years\n     */\n    public LocalDate minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This subtracts the specified number of months from the date.\n     * The subtraction may change the year, but the day-of-month is normally unchanged.\n     * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusMonths(6);\n     * LocalDate subtracted = dt.minus(Period.months(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDate minus the increased months\n     */\n    public LocalDate minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date minus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusWeeks(6);\n     * LocalDate subtracted = dt.minus(Period.weeks(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDate minus the increased weeks\n     */\n    public LocalDate minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusDays(6);\n     * LocalDate subtracted = dt.minus(Period.days(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDate minus the increased days\n     */\n    public LocalDate minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains many\n     * useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era field value.\n     *\n     * @return the era\n     */\n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of century field value.\n     *\n     * @return the year of century\n     */\n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year field value.\n     *\n     * @return the year\n     */\n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    /**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     *\n     * @return the weekyear\n     */\n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */\n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     *\n     * @return the week of a week based year\n     */\n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of year field value.\n     *\n     * @return the day of year\n     */\n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of month\n     */\n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of week\n     */\n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    /**\n     * Returns a copy of this date with the century of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    /**\n     * Returns a copy of this date with the year of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    /**\n     * Returns a copy of this date with the year of century field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    /**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    /**\n     * Returns a copy of this date with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    /**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    /**\n     * Returns a copy of this date with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    /**\n     * Returns a copy of this date with the day of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    /**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this date with the day of week field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era property which provides access to advanced functionality.\n     *\n     * @return the era property\n     */\n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    /**\n     * Get the century of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    /**\n     * Get the year of century property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    /**\n     * Get the year of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    /**\n     * Get the year property which provides access to advanced functionality.\n     *\n     * @return the year property\n     */\n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    /**\n     * Get the weekyear property which provides access to advanced functionality.\n     *\n     * @return the weekyear property\n     */\n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    /**\n     * Get the month of year property which provides access to advanced functionality.\n     *\n     * @return the month of year property\n     */\n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    /**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     *\n     * @return the week of a week based year property\n     */\n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    /**\n     * Get the day of year property which provides access to advanced functionality.\n     *\n     * @return the day of year property\n     */\n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    /**\n     * Get the day of month property which provides access to advanced functionality.\n     *\n     * @return the day of month property\n     */\n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    /**\n     * Get the day of week property which provides access to advanced functionality.\n     *\n     * @return the day of week property\n     */\n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date time in ISO8601 format (yyyy-MM-dd).\n     *\n     * @return ISO8601 time formatted string.\n     */\n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.date().print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * LocalDate.Property binds a LocalDate to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * LocalDate dt = new LocalDate(1972, 12, 3, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return\n     * new instances of LocalDate - they do not modify the original. The example\n     * below yields two independent immutable date objects 20 years apart.\n     * <pre>\n     * LocalDate dt = new LocalDate(1972, 12, 3);\n     * LocalDate dt1920 = dt.year().setCopy(1920);\n     * </pre>\n     * <p>\n     * LocalDate.Property itself is thread-safe and immutable, as well as the\n     * LocalDate being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3\n     */\n    public static final class Property extends AbstractReadableInstantFieldProperty {\n        \n        /** Serialization version */\n        private static final long serialVersionUID = -3193829732634L;\n        \n        /** The instant this property is working against */\n        private transient LocalDate iInstant;\n        /** The field this property is working against */\n        private transient DateTimeField iField;\n        \n        /**\n         * Constructor.\n         * \n         * @param instant  the instant to set\n         * @param field  the field to use\n         */\n        Property(LocalDate instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        /**\n         * Writes the property in a safe serialization format.\n         */\n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        /**\n         * Reads the property from a safe serialization format.\n         */\n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDate) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the field being used.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        /**\n         * Gets the milliseconds of the date that this property is linked to.\n         * \n         * @return the milliseconds\n         */\n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        /**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */\n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        /**\n         * Gets the LocalDate object linked to this property.\n         * \n         * @return the linked LocalDate\n         */\n        public LocalDate getLocalDate() {\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Adds to this field in a copy of this LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDate addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDate.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDate addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDate setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDate setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDate setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new LocalDate with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDate on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its maximum\n         */\n        public LocalDate withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        /**\n         * Returns a new LocalDate with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its minimum\n         */\n        public LocalDate withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * LocalDate is an immutable datetime class representing a date\n * without a time zone.\n * <p>\n * LocalDate implements the {@link ReadablePartial} interface.\n * To do this, the interface methods focus on the key fields -\n * Year, MonthOfYear and DayOfMonth.\n * However, <b>all</b> date fields may in fact be queried.\n * <p>\n * LocalDate differs from DateMidnight in that this class does not\n * have a time zone and does not represent a single instant in time.\n * <p>\n * Calculations on LocalDate are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getMonthOfYear()</code>\n * <li><code>monthOfYear().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalDate is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3\n */\npublic final class LocalDate\n        extends BaseLocal\n        implements ReadablePartial, Serializable {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -8775358157899L;\n\n    /** The index of the year field in the field array */\n    private static final int YEAR = 0;\n    /** The index of the monthOfYear field in the field array */\n    private static final int MONTH_OF_YEAR = 1;\n    /** The index of the dayOfMonth field in the field array */\n    private static final int DAY_OF_MONTH = 2;\n    /** Set of known duration types. */\n    private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\n    static {\n        DATE_DURATION_TYPES.add(DurationFieldType.days());\n        DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n        DATE_DURATION_TYPES.add(DurationFieldType.months());\n        DATE_DURATION_TYPES.add(DurationFieldType.weekyears());\n        DATE_DURATION_TYPES.add(DurationFieldType.years());\n        DATE_DURATION_TYPES.add(DurationFieldType.centuries());\n        // eras are supported, although the DurationField generally isn't\n        DATE_DURATION_TYPES.add(DurationFieldType.eras());\n    }\n\n    /** The local millis from 1970-01-01T00:00:00 */\n    private final long iLocalMillis;\n    /** The chronology to use in UTC. */\n    private final Chronology iChronology;\n    /** The cached hash code. */\n    private transient volatile int iHash;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static LocalDate now() {\n        return new LocalDate();\n    }\n\n    /**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     *\n     * @param zone  the time zone, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static LocalDate now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDate(zone);\n    }\n\n    /**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */\n    public static LocalDate now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDate(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code LocalDate} from the specified string.\n     * <p>\n     * This uses {@link ISODateTimeFormat#localDateParser()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static LocalDate parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateParser());\n    }\n\n    /**\n     * Parses a {@code LocalDate} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static LocalDate parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDate(str);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n\n    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            // handle years in era BC\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */\n    public LocalDate() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */\n    public LocalDate(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */\n    public LocalDate(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */\n    public LocalDate(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */\n    public LocalDate(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDate(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n        iChronology = chronology;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from an Object that represents a datetime.\n     * The time zone will be retrieved from the object if possible,\n     * otherwise the default time zone will be used.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDate(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDate(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDate(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     */\n    public LocalDate(\n            int year,\n            int monthOfYear,\n            int dayOfMonth) {\n        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using the specified chronology, whose zone is ignored.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code> is used.\n     *\n     * @param year  the year, valid values defined by the chronology\n     * @param monthOfYear  the month of the year, valid values defined by the chronology\n     * @param dayOfMonth  the day of the month, valid values defined by the chronology\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDate(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    /**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */\n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDate(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial, which is three.\n     * The supported fields are Year, MonthOfYear and DayOfMonth.\n     * Note that all fields from day and above may in fact be queried via\n     * other methods.\n     *\n     * @return the field count, three\n     */\n    public int size() {\n        return 3;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * <p>\n     * This method must not use any instance variables.\n     *\n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    /**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.\n     * Note that all fields from day and above may in fact be queried via\n     * other methods.\n     *\n     * @param index  the index, zero to two\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * LocalDate dt = LocalDate.nowDefaultZone();\n     * int year = dt.get(DateTimeFieldType.year());\n     * </pre>\n     *\n     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */\n    public int get(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return fieldType.getField(getChronology()).get(getLocalMillis());\n    }\n\n    /**\n     * Checks if the field type specified is supported by this\n     * local date and chronology.\n     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationFieldType durType = type.getDurationType();\n        if (DATE_DURATION_TYPES.contains(durType) ||\n                durType.getField(getChronology()).getUnitMillis() >=\n                    getChronology().days().getUnitMillis()) {\n            return type.getField(getChronology()).isSupported();\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the duration type specified is supported by this\n     * local date and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type) ||\n            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the local milliseconds from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */\n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    /**\n     * Gets the chronology of the date.\n     * \n     * @return the Chronology that the date is using\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */\n    public boolean equals(Object partial) {\n        // override to perform faster\n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    /**\n     * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.\n     *\n     * @return a suitable hash code\n     */\n    public int hashCode() {\n        // override for performance\n        int hash = iHash;\n        if (hash == 0) {\n            hash = iHash = super.hashCode();\n        }\n        return hash;\n    }\n\n    /**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */\n    public int compareTo(ReadablePartial partial) {\n        // override to perform faster\n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a full datetime at the earliest valid time\n     * for the date using the default time zone.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     * \n     * @return this date as a datetime at the start of the day\n     * @since 1.5\n     */\n    public DateTime toDateTimeAtStartOfDay() {\n        return toDateTimeAtStartOfDay(null);\n    }\n\n    /**\n     * Converts this LocalDate to a full datetime at the earliest valid time\n     * for the date using the specified time zone.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime at the start of the day\n     * @since 1.5\n     */\n    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n        long instant = zone.convertLocalToUTC(localMillis, false);\n        instant = chrono.dayOfMonth().roundFloor(instant);\n        return new DateTime(instant, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a full datetime at midnight using the default\n     * time zone.\n     * <p>\n     * This method will throw an exception if the default time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     * \n     * @return this date as a datetime at midnight\n     * @deprecated Use {@link #toDateTimeAtStartOfDay()} which won't throw an exception\n     */\n    @Deprecated\n    public DateTime toDateTimeAtMidnight() {\n        return toDateTimeAtMidnight(null);\n    }\n\n    /**\n     * Converts this LocalDate to a full datetime at midnight using the\n     * specified time zone.\n     * <p>\n     * This method will throw an exception if the time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime at midnight\n     * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception\n     */\n    @Deprecated\n    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a full datetime using the default time zone\n     * setting the date fields from this instance and the time fields from\n     * the current time.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return this date as a datetime with the time as the current time\n     */\n    public DateTime toDateTimeAtCurrentTime() {\n        return toDateTimeAtCurrentTime(null);\n    }\n\n    /**\n     * Converts this LocalDate to a full datetime using the specified time zone\n     * setting the date fields from this instance and the time fields from\n     * the current time.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime with the time as the current time\n     */\n    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this LocalDate to a DateMidnight in the default time zone.\n     * <p>\n     * As from v1.5, you are recommended to avoid DateMidnight and use\n     * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n     * detailed below.\n     * <p>\n     * This method will throw an exception if the default time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return the DateMidnight instance in the default zone\n     */\n    public DateMidnight toDateMidnight() {\n        return toDateMidnight(null);\n    }\n\n    /**\n     * Converts this LocalDate to a DateMidnight.\n     * <p>\n     * As from v1.5, you are recommended to avoid DateMidnight and use\n     * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n     * detailed below.\n     * <p>\n     * This method will throw an exception if the time zone switches\n     * to Daylight Savings Time at midnight and this LocalDate represents\n     * that switchover date. The problem is that there is no such time as\n     * midnight on the required date, and as such an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to get the DateMidnight in, null means default zone\n     * @return the DateMidnight instance\n     */\n    public DateMidnight toDateMidnight(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a LocalDateTime using a LocalTime to fill in\n     * the missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate. The chronology of the time must also match.\n     * If the time is null an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, must not be null\n     * @return the LocalDateTime instance\n     * @throws IllegalArgumentException if the time is null\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     * @since 1.5\n     */\n    public LocalDateTime toLocalDateTime(LocalTime time) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"The time must not be null\");\n        }\n        if (getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        long localMillis = getLocalMillis() + time.getLocalMillis();\n        return new LocalDateTime(localMillis, getChronology());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a DateTime using a LocalTime to fill in the\n     * missing fields and using the default time zone.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate. The chronology of the time must match.\n     * If the time is null, the current time in the date's chronology is used.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, null means current time\n     * @return the DateTime instance\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     */\n    public DateTime toDateTime(LocalTime time) {\n        return toDateTime(time, null);\n    }\n\n    /**\n     * Converts this object to a DateTime using a LocalTime to fill in the\n     * missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate plus the time zone. The chronology of the time must match.\n     * If the time is null, the current time in the date's chronology is used.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, null means current time\n     * @param zone  the zone to get the DateTime in, null means default\n     * @return the DateTime instance\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     */\n    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n        if (time != null && getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n        }\n        Chronology chrono = getChronology().withZone(zone);\n        long instant = DateTimeUtils.currentTimeMillis();\n        instant = chrono.set(this, instant);\n        if (time != null) {\n            instant = chrono.set(time, instant);\n        }\n        return new DateTime(instant, chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to an Interval representing the whole day\n     * in the default time zone.\n     * <p>\n     * The interval may have more or less than 24 hours if this is a daylight\n     * savings cutover date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a interval over the day\n     */\n    public Interval toInterval() {\n        return toInterval(null);\n    }\n\n    /**\n     * Converts this object to an Interval representing the whole day.\n     * <p>\n     * The interval may have more or less than 24 hours if this is a daylight\n     * savings cutover date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to get the Interval in, null means default\n     * @return a interval over the day\n     */\n    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        DateTime start = toDateTimeAtStartOfDay(zone);\n        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n        return new Interval(start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the date time as a <code>java.util.Date</code>.\n     * <p>\n     * The <code>Date</code> object created has exactly the same year, month and day\n     * as this date. The time will be set to the earliest valid time for that date.\n     * <p>\n     * Converting to a JDK Date is full of complications as the JDK Date constructor\n     * doesn't behave as you might expect around DST transitions. This method works\n     * by taking a first guess and then adjusting the JDK date until it has the\n     * earliest valid instant. This also handles the situation where the JDK time\n     * zone data differs from the Joda-Time time zone data.\n     *\n     * @return a Date initialised with this date, never null\n     * @since 2.0\n     */\n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\n        LocalDate check = LocalDate.fromDateFields(date);\n        if (check.isBefore(this)) {\n            // DST gap (no midnight)\n            // move forward in units of one hour until date correct\n            while (check.equals(this) == false) {\n                date.setTime(date.getTime() + 3600000);\n                check = LocalDate.fromDateFields(date);\n            }\n            // move back in units of one second until date wrong\n            while (date.getDate() == dom) {\n                date.setTime(date.getTime() - 1000);\n            }\n            // fix result\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            // check for DST overlap (two midnights)\n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            if (earlier.getDate() == dom) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this date with different millis\n     */\n    LocalDate withLocalMillis(long newMillis) {\n        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the partial set of fields replacing\n     * those from this instance.\n     * <p>\n     * For example, if the partial contains a year and a month then those two\n     * fields will be changed in the returned instance.\n     * Unsupported fields are ignored.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this date, null ignored\n     * @return a copy of this date with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */\n    public LocalDate withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>monthOfYear</code> then the\n     * month of year field will be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These two lines are equivalent:\n     * <pre>\n     * LocalDate updated = dt.withDayOfMonth(6);\n     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this date with the field set\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this date with the field updated\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getLocalMillis();\n        Chronology chrono = getChronology();\n        for (int i = 0; i < period.size(); i++) {\n            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n            DurationFieldType type = period.getFieldType(i);\n            if (isSupported(type)) {\n                instant = type.getField(chrono).add(instant, value);\n            }\n        }\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This adds the specified number of years to the date.\n     * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDate plus the increased years\n     */\n    public LocalDate plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This adds the specified number of months to the date.\n     * The addition may change the year, but the day-of-month is normally unchanged.\n     * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusMonths(6);\n     * LocalDate added = dt.plus(Period.months(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDate plus the increased months\n     */\n    public LocalDate plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date plus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusWeeks(6);\n     * LocalDate added = dt.plus(Period.weeks(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDate plus the increased weeks\n     */\n    public LocalDate plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusDays(6);\n     * LocalDate added = dt.plus(Period.days(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDate plus the increased days\n     */\n    public LocalDate plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus subtracting a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this LocalDate with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDate minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This subtracts the specified number of years from the date.\n     * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusYears(6);\n     * LocalDate subtracted = dt.minus(Period.years(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDate minus the increased years\n     */\n    public LocalDate minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This subtracts the specified number of months from the date.\n     * The subtraction may change the year, but the day-of-month is normally unchanged.\n     * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusMonths(6);\n     * LocalDate subtracted = dt.minus(Period.months(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDate minus the increased months\n     */\n    public LocalDate minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date minus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusWeeks(6);\n     * LocalDate subtracted = dt.minus(Period.weeks(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDate minus the increased weeks\n     */\n    public LocalDate minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusDays(6);\n     * LocalDate subtracted = dt.minus(Period.days(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDate minus the increased days\n     */\n    public LocalDate minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains many\n     * useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era field value.\n     *\n     * @return the era\n     */\n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of century field value.\n     *\n     * @return the year of century\n     */\n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year field value.\n     *\n     * @return the year\n     */\n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    /**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     *\n     * @return the weekyear\n     */\n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */\n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     *\n     * @return the week of a week based year\n     */\n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of year field value.\n     *\n     * @return the day of year\n     */\n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of month\n     */\n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of week\n     */\n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    /**\n     * Returns a copy of this date with the century of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    /**\n     * Returns a copy of this date with the year of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    /**\n     * Returns a copy of this date with the year of century field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    /**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    /**\n     * Returns a copy of this date with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    /**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    /**\n     * Returns a copy of this date with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    /**\n     * Returns a copy of this date with the day of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    /**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this date with the day of week field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDate withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era property which provides access to advanced functionality.\n     *\n     * @return the era property\n     */\n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    /**\n     * Get the century of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    /**\n     * Get the year of century property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    /**\n     * Get the year of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    /**\n     * Get the year property which provides access to advanced functionality.\n     *\n     * @return the year property\n     */\n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    /**\n     * Get the weekyear property which provides access to advanced functionality.\n     *\n     * @return the weekyear property\n     */\n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    /**\n     * Get the month of year property which provides access to advanced functionality.\n     *\n     * @return the month of year property\n     */\n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    /**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     *\n     * @return the week of a week based year property\n     */\n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    /**\n     * Get the day of year property which provides access to advanced functionality.\n     *\n     * @return the day of year property\n     */\n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    /**\n     * Get the day of month property which provides access to advanced functionality.\n     *\n     * @return the day of month property\n     */\n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    /**\n     * Get the day of week property which provides access to advanced functionality.\n     *\n     * @return the day of week property\n     */\n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date time in ISO8601 format (yyyy-MM-dd).\n     *\n     * @return ISO8601 time formatted string.\n     */\n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.date().print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * LocalDate.Property binds a LocalDate to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * LocalDate dt = new LocalDate(1972, 12, 3, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return\n     * new instances of LocalDate - they do not modify the original. The example\n     * below yields two independent immutable date objects 20 years apart.\n     * <pre>\n     * LocalDate dt = new LocalDate(1972, 12, 3);\n     * LocalDate dt1920 = dt.year().setCopy(1920);\n     * </pre>\n     * <p>\n     * LocalDate.Property itself is thread-safe and immutable, as well as the\n     * LocalDate being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3\n     */\n    public static final class Property extends AbstractReadableInstantFieldProperty {\n        \n        /** Serialization version */\n        private static final long serialVersionUID = -3193829732634L;\n        \n        /** The instant this property is working against */\n        private transient LocalDate iInstant;\n        /** The field this property is working against */\n        private transient DateTimeField iField;\n        \n        /**\n         * Constructor.\n         * \n         * @param instant  the instant to set\n         * @param field  the field to use\n         */\n        Property(LocalDate instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        /**\n         * Writes the property in a safe serialization format.\n         */\n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        /**\n         * Reads the property from a safe serialization format.\n         */\n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDate) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the field being used.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        /**\n         * Gets the milliseconds of the date that this property is linked to.\n         * \n         * @return the milliseconds\n         */\n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        /**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */\n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        /**\n         * Gets the LocalDate object linked to this property.\n         * \n         * @return the linked LocalDate\n         */\n        public LocalDate getLocalDate() {\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Adds to this field in a copy of this LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDate addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDate.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDate addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDate setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDate setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDate setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new LocalDate with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDate on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its maximum\n         */\n        public LocalDate withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        /**\n         * Returns a new LocalDate with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its minimum\n         */\n        public LocalDate withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */\n        public LocalDate roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n"}, {"class_name": "org.joda.time.LocalDateTime", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * LocalDateTime is an unmodifiable datetime class representing a\n * datetime without a time zone.\n * <p>\n * LocalDateTime implements the {@link ReadablePartial} interface.\n * To do this, certain methods focus on key fields Year, MonthOfYear,\n * DayOfYear and MillisOfDay.\n * However, <b>all</b> fields may in fact be queried.\n * <p>\n * Internally, LocalDateTime uses a single millisecond-based value to\n * represent the local datetime. This value is only used internally and\n * is not exposed to applications.\n * <p>\n * Calculations on LocalDateTime are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalDateTime is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3\n */\npublic final class LocalDateTime\n        extends BaseLocal\n        implements ReadablePartial, Serializable {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -268716875315837168L;\n\n    /** The index of the year field in the field array */\n    private static final int YEAR = 0;\n    /** The index of the monthOfYear field in the field array */\n    private static final int MONTH_OF_YEAR = 1;\n    /** The index of the dayOfMonth field in the field array */\n    private static final int DAY_OF_MONTH = 2;\n    /** The index of the millis field in the field array */\n    private static final int MILLIS_OF_DAY = 3;\n\n    /** The local millis from 1970-01-01T00:00:00 */\n    private final long iLocalMillis;\n    /** The chronology to use in UTC */\n    private final Chronology iChronology;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * The resulting object does not use the zone.\n     * \n     * @return the current date, not null\n     * @since 2.0\n     */\n    public static LocalDateTime now() {\n        return new LocalDateTime();\n    }\n\n    /**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * The resulting object does not use the zone.\n     *\n     * @param zone  the time zone, not null\n     * @return the current date, not null\n     * @since 2.0\n     */\n    public static LocalDateTime now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDateTime(zone);\n    }\n\n    /**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using the specified chronology.\n     * The resulting object does not use the zone.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date, not null\n     * @since 2.0\n     */\n    public static LocalDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDateTime(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code LocalDateTime} from the specified string.\n     * <p>\n     * This uses {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static LocalDateTime parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateOptionalTimeParser());\n    }\n\n    /**\n     * Parses a {@code LocalDateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static LocalDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDateTime(str);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */\n    public LocalDateTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */\n    public LocalDateTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */\n    public LocalDateTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */\n    public LocalDateTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */\n    public LocalDateTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDateTime(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        iLocalMillis = localMillis;\n        iChronology = chronology.withUTC();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the object contains no time zone, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDateTime(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDateTime(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDateTime(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param hourOfDay  the hour of the day, from 0 to 23\n     * @param minuteOfHour  the minute of the hour, from 0 to 59\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param hourOfDay  the hour of the day, from 0 to 23\n     * @param minuteOfHour  the minute of the hour, from 0 to 59\n     * @param secondOfMinute  the second of the minute, from 0 to 59\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param hourOfDay  the hour of the day, from 0 to 23\n     * @param minuteOfHour  the minute of the hour, from 0 to 59\n     * @param secondOfMinute  the second of the minute, from 0 to 59\n     * @param millisOfSecond  the millisecond of the second, from 0 to 999\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using the specified chronology, whose zone is ignored.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code> is used.\n     *\n     * @param year  the year, valid values defined by the chronology\n     * @param monthOfYear  the month of the year, valid values defined by the chronology\n     * @param dayOfMonth  the day of the month, valid values defined by the chronology\n     * @param hourOfDay  the hour of the day, valid values defined by the chronology\n     * @param minuteOfHour  the minute of the hour, valid values defined by the chronology\n     * @param secondOfMinute  the second of the minute, valid values defined by the chronology\n     * @param millisOfSecond  the millisecond of the second, valid values defined by the chronology\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    /**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */\n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDateTime(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial, which is four.\n     * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n     *\n     * @return the field count, four\n     */\n    public int size() {\n        return 4;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * <p>\n     * This method must not use any instance variables.\n     *\n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    /**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n     *\n     * @param index  the index, zero to two\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            case MILLIS_OF_DAY:\n                return getChronology().millisOfDay().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * DateTime dt = new DateTime();\n     * int year = dt.get(DateTimeFieldType.year());\n     * </pre>\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null\n     */\n    public int get(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        return type.getField(getChronology()).get(getLocalMillis());\n    }\n\n    /**\n     * Checks if the field type specified is supported by this\n     * local datetime and chronology.\n     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    /**\n     * Checks if the duration type specified is supported by this\n     * local datetime and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the milliseconds of the datetime instant from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     *\n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */\n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    /**\n     * Gets the chronology of the datetime.\n     *\n     * @return the Chronology that the datetime is using\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */\n    public boolean equals(Object partial) {\n        // override to perform faster\n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    /**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */\n    public int compareTo(ReadablePartial partial) {\n        // override to perform faster\n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a DateTime using the default zone.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * \n     * @return <code>this</code>\n     */\n    public DateTime toDateTime() {\n        return toDateTime((DateTimeZone) null);\n    }\n\n    /**\n     * Converts this object to a DateTime using the specified zone.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * \n     * @param zone time zone to apply, or default if null\n     * @return a DateTime using the same millis\n     */\n    public DateTime toDateTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = iChronology.withZone(zone);\n        return new DateTime(\n                getYear(), getMonthOfYear(), getDayOfMonth(),\n                getHourOfDay(), getMinuteOfHour(),\n                getSecondOfMinute(), getMillisOfSecond(), chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a LocalDate with the same date and chronology.\n     *\n     * @return a LocalDate with the same date and chronology\n     */\n    public LocalDate toLocalDate() {\n        return new LocalDate(getLocalMillis(), getChronology());\n    }\n\n    /**\n     * Converts this object to a LocalTime with the same time and chronology.\n     *\n     * @return a LocalTime with the same time and chronology\n     */\n    public LocalTime toLocalTime() {\n        return new LocalTime(getLocalMillis(), getChronology());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the date time as a <code>java.util.Date</code>.\n     * <p>\n     * The <code>Date</code> object created has exactly the same fields as this\n     * date-time, except when the time would be invalid due to a daylight savings\n     * gap. In that case, the time will be set to the earliest valid time after the gap.\n     * <p>\n     * In the case of a daylight savings overlap, the earlier instant is selected.\n     * <p>\n     * Converting to a JDK Date is full of complications as the JDK Date constructor\n     * doesn't behave as you might expect around DST transitions. This method works\n     * by taking a first guess and then adjusting. This also handles the situation\n     * where the JDK time zone data differs from the Joda-Time time zone data.\n     *\n     * @return a Date initialised with this date-time, never null\n     * @since 2.0\n     */\n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n        LocalDateTime check = LocalDateTime.fromDateFields(date);\n        if (check.isBefore(this)) {\n            // DST gap\n            // move forward in units of one minute until equal/after\n            while (check.isBefore(this)) {\n                date.setTime(date.getTime() + 60000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            // move back in units of one second until date wrong\n            while (check.isBefore(this) == false) {\n                date.setTime(date.getTime() - 1000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            // check for DST overlap\n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            check = LocalDateTime.fromDateFields(earlier);\n            if (check.equals(this)) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this datetime with different millis\n     */\n    LocalDateTime withLocalMillis(long newMillis) {\n        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified date,\n     * retaining the time fields.\n     * <p>\n     * If the date is already the date passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = dt.monthOfYear().setCopy(6);\n     * </pre>\n     *\n     * @param year  the new year value\n     * @param monthOfYear  the new monthOfYear value\n     * @param dayOfMonth  the new dayOfMonth value\n     * @return a copy of this datetime with a different date\n     * @throws IllegalArgumentException if any value if invalid\n     */\n    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified time,\n     * retaining the date fields.\n     * <p>\n     * If the time is already the time passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * LocalDateTime set = dt.hourOfDay().setCopy(6);\n     * </pre>\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @return a copy of this datetime with a different time\n     * @throws IllegalArgumentException if any value if invalid\n     */\n    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the partial set of fields\n     * replacing those from this instance.\n     * <p>\n     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */\n    public LocalDateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime with the value of the specified\n     * field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     *\n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime plus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDateTime plus the increased years\n     */\n    public LocalDateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMonths(6);\n     * LocalDateTime added = dt.plus(Period.months(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDateTime plus the increased months\n     */\n    public LocalDateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusWeeks(6);\n     * LocalDateTime added = dt.plus(Period.weeks(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDateTime plus the increased weeks\n     */\n    public LocalDateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusDays(6);\n     * LocalDateTime added = dt.plus(Period.days(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDateTime plus the increased days\n     */\n    public LocalDateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime plus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusHours(6);\n     * LocalDateTime added = dt.plus(Period.hours(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new LocalDateTime plus the increased hours\n     */\n    public LocalDateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMinutes(6);\n     * LocalDateTime added = dt.plus(Period.minutes(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new LocalDateTime plus the increased minutes\n     */\n    public LocalDateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusSeconds(6);\n     * LocalDateTime added = dt.plus(Period.seconds(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new LocalDateTime plus the increased seconds\n     */\n    public LocalDateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMillis(6);\n     * LocalDateTime added = dt.plus(Period.millis(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new LocalDateTime plus the increased millis\n     */\n    public LocalDateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime minus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusYears(6);\n     * LocalDateTime subtracted = dt.minus(Period.years(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDateTime minus the increased years\n     */\n    public LocalDateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMonths(6);\n     * LocalDateTime subtracted = dt.minus(Period.months(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDateTime minus the increased months\n     */\n    public LocalDateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusWeeks(6);\n     * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDateTime minus the increased weeks\n     */\n    public LocalDateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusDays(6);\n     * LocalDateTime subtracted = dt.minus(Period.days(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDateTime minus the increased days\n     */\n    public LocalDateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime minus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusHours(6);\n     * LocalDateTime subtracted = dt.minus(Period.hours(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new LocalDateTime minus the increased hours\n     */\n    public LocalDateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMinutes(6);\n     * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new LocalDateTime minus the increased minutes\n     */\n    public LocalDateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusSeconds(6);\n     * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new LocalDateTime minus the increased seconds\n     */\n    public LocalDateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMillis(6);\n     * LocalDateTime subtracted = dt.minus(Period.millis(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new LocalDateTime minus the increased millis\n     */\n    public LocalDateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains many\n     * useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era field value.\n     *\n     * @return the era\n     */\n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of century field value.\n     *\n     * @return the year of century\n     */\n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year field value.\n     *\n     * @return the year\n     */\n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    /**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     *\n     * @return the weekyear\n     */\n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */\n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     *\n     * @return the week of a week based year\n     */\n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of year field value.\n     *\n     * @return the day of year\n     */\n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of month\n     */\n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of week\n     */\n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the hour of day field value.\n     *\n     * @return the hour of day\n     */\n    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getLocalMillis());\n    }\n\n    /**\n     * Get the minute of hour field value.\n     *\n     * @return the minute of hour\n     */\n    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getLocalMillis());\n    }\n\n    /**\n     * Get the second of minute field value.\n     *\n     * @return the second of minute\n     */\n    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getLocalMillis());\n    }\n\n    /**\n     * Get the millis of second field value.\n     *\n     * @return the millis of second\n     */\n    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getLocalMillis());\n    }\n\n    /**\n     * Get the millis of day field value.\n     *\n     * @return the millis of day\n     */\n    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getLocalMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    /**\n     * Returns a copy of this datetime with the century of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    /**\n     * Returns a copy of this datetime with the year of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    /**\n     * Returns a copy of this datetime with the year of century field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    /**\n     * Returns a copy of this datetime with the year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    /**\n     * Returns a copy of this datetime with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the month of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the day of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the day of month field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this datetime with the day of week field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the hour of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }\n\n    /**\n     * Returns a copy of this datetime with the minute of hour field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }\n\n    /**\n     * Returns a copy of this datetime with the second of minute field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }\n\n    /**\n     * Returns a copy of this datetime with the millis of second field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }\n\n    /**\n     * Returns a copy of this datetime with the millis of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era property which provides access to advanced functionality.\n     *\n     * @return the era property\n     */\n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    /**\n     * Get the century of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    /**\n     * Get the year of century property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    /**\n     * Get the year of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    /**\n     * Get the year property which provides access to advanced functionality.\n     *\n     * @return the year property\n     */\n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    /**\n     * Get the weekyear property which provides access to advanced functionality.\n     *\n     * @return the weekyear property\n     */\n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    /**\n     * Get the month of year property which provides access to advanced functionality.\n     *\n     * @return the month of year property\n     */\n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    /**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     *\n     * @return the week of a week based year property\n     */\n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    /**\n     * Get the day of year property which provides access to advanced functionality.\n     *\n     * @return the day of year property\n     */\n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    /**\n     * Get the day of month property which provides access to advanced functionality.\n     *\n     * @return the day of month property\n     */\n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    /**\n     * Get the day of week property which provides access to advanced functionality.\n     *\n     * @return the day of week property\n     */\n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the hour of day field property which provides access to advanced functionality.\n     * \n     * @return the hour of day property\n     */\n    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }\n\n    /**\n     * Get the minute of hour field property which provides access to advanced functionality.\n     * \n     * @return the minute of hour property\n     */\n    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }\n\n    /**\n     * Get the second of minute field property which provides access to advanced functionality.\n     * \n     * @return the second of minute property\n     */\n    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }\n\n    /**\n     * Get the millis of second property which provides access to advanced functionality.\n     * \n     * @return the millis of second property\n     */\n    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }\n\n    /**\n     * Get the millis of day property which provides access to advanced functionality.\n     * \n     * @return the millis of day property\n     */\n    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSS).\n     * \n     * @return ISO8601 time formatted string.\n     */\n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * LocalDateTime.Property binds a LocalDateTime to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return\n     * new instances of LocalDateTime - they do not modify the original.\n     * The example below yields two independent immutable date objects\n     * 20 years apart.\n     * <pre>\n     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n     * LocalDateTime dt1920 = dt.year().setCopy(1920);\n     * </pre>\n     * <p>\n     * LocalDateTime.Property itself is thread-safe and immutable, as well as the\n     * LocalDateTime being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3\n     */\n    public static final class Property extends AbstractReadableInstantFieldProperty {\n        \n        /** Serialization version */\n        private static final long serialVersionUID = -358138762846288L;\n        \n        /** The instant this property is working against */\n        private transient LocalDateTime iInstant;\n        /** The field this property is working against */\n        private transient DateTimeField iField;\n        \n        /**\n         * Constructor.\n         * \n         * @param instant  the instant to set\n         * @param field  the field to use\n         */\n        Property(LocalDateTime instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        /**\n         * Writes the property in a safe serialization format.\n         */\n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        /**\n         * Reads the property from a safe serialization format.\n         */\n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the field being used.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        /**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */\n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        /**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */\n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        /**\n         * Gets the LocalDateTime object linked to this property.\n         * \n         * @return the linked LocalDateTime\n         */\n        public LocalDateTime getLocalDateTime() {\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime addToCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDateTime setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDateTime setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new LocalDateTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its maximum\n         */\n        public LocalDateTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        /**\n         * Returns a new LocalDateTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its minimum\n         */\n        public LocalDateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.base.BaseLocal;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PartialConverter;\nimport org.joda.time.field.AbstractReadableInstantFieldProperty;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * LocalDateTime is an unmodifiable datetime class representing a\n * datetime without a time zone.\n * <p>\n * LocalDateTime implements the {@link ReadablePartial} interface.\n * To do this, certain methods focus on key fields Year, MonthOfYear,\n * DayOfYear and MillisOfDay.\n * However, <b>all</b> fields may in fact be queried.\n * <p>\n * Internally, LocalDateTime uses a single millisecond-based value to\n * represent the local datetime. This value is only used internally and\n * is not exposed to applications.\n * <p>\n * Calculations on LocalDateTime are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalDateTime is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3\n */\npublic final class LocalDateTime\n        extends BaseLocal\n        implements ReadablePartial, Serializable {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -268716875315837168L;\n\n    /** The index of the year field in the field array */\n    private static final int YEAR = 0;\n    /** The index of the monthOfYear field in the field array */\n    private static final int MONTH_OF_YEAR = 1;\n    /** The index of the dayOfMonth field in the field array */\n    private static final int DAY_OF_MONTH = 2;\n    /** The index of the millis field in the field array */\n    private static final int MILLIS_OF_DAY = 3;\n\n    /** The local millis from 1970-01-01T00:00:00 */\n    private final long iLocalMillis;\n    /** The chronology to use in UTC */\n    private final Chronology iChronology;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * The resulting object does not use the zone.\n     * \n     * @return the current date, not null\n     * @since 2.0\n     */\n    public static LocalDateTime now() {\n        return new LocalDateTime();\n    }\n\n    /**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * The resulting object does not use the zone.\n     *\n     * @param zone  the time zone, not null\n     * @return the current date, not null\n     * @since 2.0\n     */\n    public static LocalDateTime now(DateTimeZone zone) {\n        if (zone == null) {\n            throw new NullPointerException(\"Zone must not be null\");\n        }\n        return new LocalDateTime(zone);\n    }\n\n    /**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using the specified chronology.\n     * The resulting object does not use the zone.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date, not null\n     * @since 2.0\n     */\n    public static LocalDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"Chronology must not be null\");\n        }\n        return new LocalDateTime(chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a {@code LocalDateTime} from the specified string.\n     * <p>\n     * This uses {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */\n    @FromString\n    public static LocalDateTime parse(String str) {\n        return parse(str, ISODateTimeFormat.localDateOptionalTimeParser());\n    }\n\n    /**\n     * Parses a {@code LocalDateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */\n    public static LocalDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDateTime(str);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            // handle years in era BC\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */\n    public LocalDateTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */\n    public LocalDateTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */\n    public LocalDateTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */\n    public LocalDateTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */\n    public LocalDateTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }\n\n    /**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDateTime(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        iLocalMillis = localMillis;\n        iChronology = chronology.withUTC();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the object contains no time zone, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDateTime(Object instant) {\n        this(instant, (Chronology) null);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDateTime(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    /**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */\n    public LocalDateTime(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param hourOfDay  the hour of the day, from 0 to 23\n     * @param minuteOfHour  the minute of the hour, from 0 to 59\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param hourOfDay  the hour of the day, from 0 to 23\n     * @param minuteOfHour  the minute of the hour, from 0 to 59\n     * @param secondOfMinute  the second of the minute, from 0 to 59\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using <code>ISOChronology</code>.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param hourOfDay  the hour of the day, from 0 to 23\n     * @param minuteOfHour  the minute of the hour, from 0 to 59\n     * @param secondOfMinute  the second of the minute, from 0 to 59\n     * @param millisOfSecond  the millisecond of the second, from 0 to 999\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());\n    }\n\n    /**\n     * Constructs an instance set to the specified date and time\n     * using the specified chronology, whose zone is ignored.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code> is used.\n     *\n     * @param year  the year, valid values defined by the chronology\n     * @param monthOfYear  the month of the year, valid values defined by the chronology\n     * @param dayOfMonth  the day of the month, valid values defined by the chronology\n     * @param hourOfDay  the hour of the day, valid values defined by the chronology\n     * @param minuteOfHour  the minute of the hour, valid values defined by the chronology\n     * @param secondOfMinute  the second of the minute, valid values defined by the chronology\n     * @param millisOfSecond  the millisecond of the second, valid values defined by the chronology\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public LocalDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iChronology = chronology;\n        iLocalMillis = instant;\n    }\n\n    /**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */\n    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDateTime(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields in this partial, which is four.\n     * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n     *\n     * @return the field count, four\n     */\n    public int size() {\n        return 4;\n    }\n\n    /**\n     * Gets the field for a specific index in the chronology specified.\n     * <p>\n     * This method must not use any instance variables.\n     *\n     * @param index  the index to retrieve\n     * @param chrono  the chronology to use\n     * @return the field\n     */\n    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    /**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n     *\n     * @param index  the index, zero to two\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            case MILLIS_OF_DAY:\n                return getChronology().millisOfDay().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * DateTime dt = new DateTime();\n     * int year = dt.get(DateTimeFieldType.year());\n     * </pre>\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null\n     */\n    public int get(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        return type.getField(getChronology()).get(getLocalMillis());\n    }\n\n    /**\n     * Checks if the field type specified is supported by this\n     * local datetime and chronology.\n     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    /**\n     * Checks if the duration type specified is supported by this\n     * local datetime and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */\n    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the milliseconds of the datetime instant from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     *\n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */\n    protected long getLocalMillis() {\n        return iLocalMillis;\n    }\n\n    /**\n     * Gets the chronology of the datetime.\n     *\n     * @return the Chronology that the datetime is using\n     */\n    public Chronology getChronology() {\n        return iChronology;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */\n    public boolean equals(Object partial) {\n        // override to perform faster\n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }\n\n    /**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */\n    public int compareTo(ReadablePartial partial) {\n        // override to perform faster\n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a DateTime using the default zone.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * \n     * @return <code>this</code>\n     */\n    public DateTime toDateTime() {\n        return toDateTime((DateTimeZone) null);\n    }\n\n    /**\n     * Converts this object to a DateTime using the specified zone.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * \n     * @param zone time zone to apply, or default if null\n     * @return a DateTime using the same millis\n     */\n    public DateTime toDateTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = iChronology.withZone(zone);\n        return new DateTime(\n                getYear(), getMonthOfYear(), getDayOfMonth(),\n                getHourOfDay(), getMinuteOfHour(),\n                getSecondOfMinute(), getMillisOfSecond(), chrono);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this object to a LocalDate with the same date and chronology.\n     *\n     * @return a LocalDate with the same date and chronology\n     */\n    public LocalDate toLocalDate() {\n        return new LocalDate(getLocalMillis(), getChronology());\n    }\n\n    /**\n     * Converts this object to a LocalTime with the same time and chronology.\n     *\n     * @return a LocalTime with the same time and chronology\n     */\n    public LocalTime toLocalTime() {\n        return new LocalTime(getLocalMillis(), getChronology());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the date time as a <code>java.util.Date</code>.\n     * <p>\n     * The <code>Date</code> object created has exactly the same fields as this\n     * date-time, except when the time would be invalid due to a daylight savings\n     * gap. In that case, the time will be set to the earliest valid time after the gap.\n     * <p>\n     * In the case of a daylight savings overlap, the earlier instant is selected.\n     * <p>\n     * Converting to a JDK Date is full of complications as the JDK Date constructor\n     * doesn't behave as you might expect around DST transitions. This method works\n     * by taking a first guess and then adjusting. This also handles the situation\n     * where the JDK time zone data differs from the Joda-Time time zone data.\n     *\n     * @return a Date initialised with this date-time, never null\n     * @since 2.0\n     */\n    @SuppressWarnings(\"deprecation\")\n    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n        LocalDateTime check = LocalDateTime.fromDateFields(date);\n        if (check.isBefore(this)) {\n            // DST gap\n            // move forward in units of one minute until equal/after\n            while (check.isBefore(this)) {\n                date.setTime(date.getTime() + 60000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            // move back in units of one second until date wrong\n            while (check.isBefore(this) == false) {\n                date.setTime(date.getTime() - 1000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            // check for DST overlap\n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            check = LocalDateTime.fromDateFields(earlier);\n            if (check.equals(this)) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this datetime with different millis\n     */\n    LocalDateTime withLocalMillis(long newMillis) {\n        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified date,\n     * retaining the time fields.\n     * <p>\n     * If the date is already the date passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = dt.monthOfYear().setCopy(6);\n     * </pre>\n     *\n     * @param year  the new year value\n     * @param monthOfYear  the new monthOfYear value\n     * @param dayOfMonth  the new dayOfMonth value\n     * @return a copy of this datetime with a different date\n     * @throws IllegalArgumentException if any value if invalid\n     */\n    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified time,\n     * retaining the date fields.\n     * <p>\n     * If the time is already the time passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * LocalDateTime set = dt.hourOfDay().setCopy(6);\n     * </pre>\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @return a copy of this datetime with a different time\n     * @throws IllegalArgumentException if any value if invalid\n     */\n    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the partial set of fields\n     * replacing those from this instance.\n     * <p>\n     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */\n    public LocalDateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime with the value of the specified\n     * field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     *\n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime plus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDateTime plus the increased years\n     */\n    public LocalDateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMonths(6);\n     * LocalDateTime added = dt.plus(Period.months(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDateTime plus the increased months\n     */\n    public LocalDateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusWeeks(6);\n     * LocalDateTime added = dt.plus(Period.weeks(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDateTime plus the increased weeks\n     */\n    public LocalDateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusDays(6);\n     * LocalDateTime added = dt.plus(Period.days(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDateTime plus the increased days\n     */\n    public LocalDateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime plus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusHours(6);\n     * LocalDateTime added = dt.plus(Period.hours(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new LocalDateTime plus the increased hours\n     */\n    public LocalDateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMinutes(6);\n     * LocalDateTime added = dt.plus(Period.minutes(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new LocalDateTime plus the increased minutes\n     */\n    public LocalDateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusSeconds(6);\n     * LocalDateTime added = dt.plus(Period.seconds(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new LocalDateTime plus the increased seconds\n     */\n    public LocalDateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime plus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMillis(6);\n     * LocalDateTime added = dt.plus(Period.millis(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new LocalDateTime plus the increased millis\n     */\n    public LocalDateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }\n\n    /**\n     * Returns a copy of this datetime with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */\n    public LocalDateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime minus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusYears(6);\n     * LocalDateTime subtracted = dt.minus(Period.years(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDateTime minus the increased years\n     */\n    public LocalDateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMonths(6);\n     * LocalDateTime subtracted = dt.minus(Period.months(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDateTime minus the increased months\n     */\n    public LocalDateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusWeeks(6);\n     * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDateTime minus the increased weeks\n     */\n    public LocalDateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusDays(6);\n     * LocalDateTime subtracted = dt.minus(Period.days(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDateTime minus the increased days\n     */\n    public LocalDateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime minus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusHours(6);\n     * LocalDateTime subtracted = dt.minus(Period.hours(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new LocalDateTime minus the increased hours\n     */\n    public LocalDateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMinutes(6);\n     * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new LocalDateTime minus the increased minutes\n     */\n    public LocalDateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusSeconds(6);\n     * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new LocalDateTime minus the increased seconds\n     */\n    public LocalDateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }\n\n    /**\n     * Returns a copy of this datetime minus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMillis(6);\n     * LocalDateTime subtracted = dt.minus(Period.millis(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new LocalDateTime minus the increased millis\n     */\n    public LocalDateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the property object for the specified type, which contains many\n     * useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */\n    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era field value.\n     *\n     * @return the era\n     */\n    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */\n    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year of century field value.\n     *\n     * @return the year of century\n     */\n    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }\n\n    /**\n     * Get the year field value.\n     *\n     * @return the year\n     */\n    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }\n\n    /**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     *\n     * @return the weekyear\n     */\n    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */\n    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     *\n     * @return the week of a week based year\n     */\n    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of year field value.\n     *\n     * @return the day of year\n     */\n    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of month\n     */\n    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }\n\n    /**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of week\n     */\n    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the hour of day field value.\n     *\n     * @return the hour of day\n     */\n    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getLocalMillis());\n    }\n\n    /**\n     * Get the minute of hour field value.\n     *\n     * @return the minute of hour\n     */\n    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getLocalMillis());\n    }\n\n    /**\n     * Get the second of minute field value.\n     *\n     * @return the second of minute\n     */\n    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getLocalMillis());\n    }\n\n    /**\n     * Get the millis of second field value.\n     *\n     * @return the millis of second\n     */\n    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getLocalMillis());\n    }\n\n    /**\n     * Get the millis of day field value.\n     *\n     * @return the millis of day\n     */\n    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getLocalMillis());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }\n\n    /**\n     * Returns a copy of this datetime with the century of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }\n\n    /**\n     * Returns a copy of this datetime with the year of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }\n\n    /**\n     * Returns a copy of this datetime with the year of century field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }\n\n    /**\n     * Returns a copy of this datetime with the year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }\n\n    /**\n     * Returns a copy of this datetime with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the month of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the day of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }\n\n    /**\n     * Returns a copy of this datetime with the day of month field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this datetime with the day of week field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this datetime with the hour of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }\n\n    /**\n     * Returns a copy of this datetime with the minute of hour field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }\n\n    /**\n     * Returns a copy of this datetime with the second of minute field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }\n\n    /**\n     * Returns a copy of this datetime with the millis of second field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }\n\n    /**\n     * Returns a copy of this datetime with the millis of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public LocalDateTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the era property which provides access to advanced functionality.\n     *\n     * @return the era property\n     */\n    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n\n    /**\n     * Get the century of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }\n\n    /**\n     * Get the year of century property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }\n\n    /**\n     * Get the year of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */\n    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }\n\n    /**\n     * Get the year property which provides access to advanced functionality.\n     *\n     * @return the year property\n     */\n    public Property year() {\n        return new Property(this, getChronology().year());\n    }\n\n    /**\n     * Get the weekyear property which provides access to advanced functionality.\n     *\n     * @return the weekyear property\n     */\n    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }\n\n    /**\n     * Get the month of year property which provides access to advanced functionality.\n     *\n     * @return the month of year property\n     */\n    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }\n\n    /**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     *\n     * @return the week of a week based year property\n     */\n    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }\n\n    /**\n     * Get the day of year property which provides access to advanced functionality.\n     *\n     * @return the day of year property\n     */\n    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }\n\n    /**\n     * Get the day of month property which provides access to advanced functionality.\n     *\n     * @return the day of month property\n     */\n    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }\n\n    /**\n     * Get the day of week property which provides access to advanced functionality.\n     *\n     * @return the day of week property\n     */\n    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the hour of day field property which provides access to advanced functionality.\n     * \n     * @return the hour of day property\n     */\n    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }\n\n    /**\n     * Get the minute of hour field property which provides access to advanced functionality.\n     * \n     * @return the minute of hour property\n     */\n    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }\n\n    /**\n     * Get the second of minute field property which provides access to advanced functionality.\n     * \n     * @return the second of minute property\n     */\n    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }\n\n    /**\n     * Get the millis of second property which provides access to advanced functionality.\n     * \n     * @return the millis of second property\n     */\n    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }\n\n    /**\n     * Get the millis of day property which provides access to advanced functionality.\n     * \n     * @return the millis of day property\n     */\n    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSS).\n     * \n     * @return ISO8601 time formatted string.\n     */\n    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).print(this);\n    }\n\n    /**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */\n    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * LocalDateTime.Property binds a LocalDateTime to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return\n     * new instances of LocalDateTime - they do not modify the original.\n     * The example below yields two independent immutable date objects\n     * 20 years apart.\n     * <pre>\n     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n     * LocalDateTime dt1920 = dt.year().setCopy(1920);\n     * </pre>\n     * <p>\n     * LocalDateTime.Property itself is thread-safe and immutable, as well as the\n     * LocalDateTime being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3\n     */\n    public static final class Property extends AbstractReadableInstantFieldProperty {\n        \n        /** Serialization version */\n        private static final long serialVersionUID = -358138762846288L;\n        \n        /** The instant this property is working against */\n        private transient LocalDateTime iInstant;\n        /** The field this property is working against */\n        private transient DateTimeField iField;\n        \n        /**\n         * Constructor.\n         * \n         * @param instant  the instant to set\n         * @param field  the field to use\n         */\n        Property(LocalDateTime instant, DateTimeField field) {\n            super();\n            iInstant = instant;\n            iField = field;\n        }\n        \n        /**\n         * Writes the property in a safe serialization format.\n         */\n        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }\n\n        /**\n         * Reads the property from a safe serialization format.\n         */\n        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the field being used.\n         * \n         * @return the field\n         */\n        public DateTimeField getField() {\n            return iField;\n        }\n        \n        /**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */\n        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }\n        \n        /**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */\n        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }\n        \n        /**\n         * Gets the LocalDateTime object linked to this property.\n         * \n         * @return the linked LocalDateTime\n         */\n        public LocalDateTime getLocalDateTime() {\n            return iInstant;\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime addToCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Sets this field in a copy of the LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */\n        public LocalDateTime setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDateTime setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }\n        \n        /**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */\n        public LocalDateTime setCopy(String text) {\n            return setCopy(text, null);\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Returns a new LocalDateTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its maximum\n         */\n        public LocalDateTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }\n        \n        /**\n         * Returns a new LocalDateTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its minimum\n         */\n        public LocalDateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n        \n        //-----------------------------------------------------------------------\n        /**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }\n        \n        /**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */\n        public LocalDateTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 13, "classes_modified": [{"class_name": "org.joda.time.format.PeriodFormatterBuilder", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TreeSet;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadablePeriod;\n\n/**\n * Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix(\" year\", \" years\")\n *     .appendSeparator(\" and \")\n *     .printZeroRarelyLast()\n *     .appendMonths()\n *     .appendSuffix(\" month\", \" months\")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n */\npublic class PeriodFormatterBuilder {\n    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n    private static final int PRINT_ZERO_RARELY_LAST = 2;\n    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n    private static final int PRINT_ZERO_ALWAYS = 4;\n    private static final int PRINT_ZERO_NEVER = 5;\n    \n    private static final int YEARS = 0;\n    private static final int MONTHS = 1;\n    private static final int WEEKS = 2;\n    private static final int DAYS = 3;\n    private static final int HOURS = 4;\n    private static final int MINUTES = 5;\n    private static final int SECONDS = 6;\n    private static final int MILLIS = 7;\n    private static final int SECONDS_MILLIS = 8;\n    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n\n    private int iMinPrintedDigits;\n    private int iPrintZeroSetting;\n    private int iMaxParsedDigits;\n    private boolean iRejectSignedValues;\n\n    private PeriodFieldAffix iPrefix;\n\n    // List of Printers and Parsers used to build a final formatter.\n    private List<Object> iElementPairs;\n    /** Set to true if the formatter is not a printer. */\n    private boolean iNotPrinter;\n    /** Set to true if the formatter is not a parser. */\n    private boolean iNotParser;\n\n    // Last PeriodFormatter appended of each field type.\n    private FieldFormatter[] iFieldFormatters;\n\n    public PeriodFormatterBuilder() {\n        clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a PeriodFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link PeriodFormatter#isPrinter()} and\n     * {@link PeriodFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     * \n     * @return the newly created formatter\n     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n     */\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }\n\n    /**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }\n\n    /**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }\n\n    /**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }\n\n    /**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */\n    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }\n\n    /**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }\n\n    /**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }\n\n    /**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }\n\n    /**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }\n\n    /**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String singularText,\n                                                 String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }\n\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }\n\n    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String singularText,\n                                               String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @param variants  set of text values which are also acceptable when parsed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                  String[] variants) {\n        return appendSeparator(text, finalText, variants, true, true);\n    }\n\n    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }\n\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n     */\n    static interface PeriodFieldAffix {\n        int calculatePrintedLength(int value);\n        \n        void printTo(StringBuffer buf, int value);\n        \n        void printTo(Writer out, int value) throws IOException;\n        \n        /**\n         * @return new position after parsing affix, or ~position of failure\n         */\n        int parse(String periodStr, int position);\n\n        /**\n         * @return position where affix starts, or original ~position if not found\n         */\n        int scan(String periodStr, int position);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text does not vary by the amount.\n     */\n    static class SimpleAffix implements PeriodFieldAffix {\n        private final String iText;\n\n        SimpleAffix(String text) {\n            iText = text;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(iText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.\n     */\n    static class PluralAffix implements PeriodFieldAffix {\n        private final String iSingularText;\n        private final String iPluralText;\n\n        PluralAffix(String singularText, String pluralText) {\n            iSingularText = singularText;\n            iPluralText = pluralText;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return (value == 1 ? iSingularText : iPluralText).length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            if (periodStr.regionMatches\n                (true, position, text1, 0, text1.length())) {\n                return position + text1.length();\n            }\n            if (periodStr.regionMatches\n                (true, position, text2, 0, text2.length())) {\n                return position + text2.length();\n            }\n\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            int textLength1 = text1.length();\n            int textLength2 = text2.length();\n\n            int sourceLength = periodStr.length();\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                    return pos;\n                }\n                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                    return pos;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Builds a composite affix by merging two other affix implementations.\n     */\n    static class CompositeAffix implements PeriodFieldAffix {\n        private final PeriodFieldAffix iLeft;\n        private final PeriodFieldAffix iRight;\n\n        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n            iLeft = left;\n            iRight = right;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iLeft.calculatePrintedLength(value)\n                + iRight.calculatePrintedLength(value);\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            iLeft.printTo(buf, value);\n            iRight.printTo(buf, value);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            iLeft.printTo(out, value);\n            iRight.printTo(out, value);\n        }\n\n        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats the numeric value of a field, potentially with prefix/suffix.\n     */\n    static class FieldFormatter\n            implements PeriodPrinter, PeriodParser {\n        private final int iMinPrintedDigits;\n        private final int iPrintZeroSetting;\n        private final int iMaxParsedDigits;\n        private final boolean iRejectSignedValues;\n        \n        /** The index of the field type, 0=year, etc. */\n        private final int iFieldType;\n        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 or 5 digits with a negative\n                sum = Math.max(sum, 4);\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }\n        \n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(out, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.writeUnpaddedInteger(out, value);\n            } else {\n                FormatUtils.writePaddedInteger(out, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    out.write('.');\n                    FormatUtils.writePaddedInteger(out, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(out, value);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }\n\n        /**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }\n\n        /**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }\n\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }\n\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }\n\n        int getFieldType() {\n            return iFieldType;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a simple literal piece of text.\n     */\n    static class Literal\n            implements PeriodPrinter, PeriodParser {\n        static final Literal EMPTY = new Literal(\"\");\n        private final String iText;\n\n        Literal(String text) {\n            iText = text;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            out.write(iText);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.\n     */\n    static class Separator\n            implements PeriodPrinter, PeriodParser {\n        private final String iText;\n        private final String iFinalText;\n        private final String[] iParsedForms;\n\n        private final boolean iUseBefore;\n        private final boolean iUseAfter;\n\n        private final PeriodPrinter iBeforePrinter;\n        private volatile PeriodPrinter iAfterPrinter;\n        private final PeriodParser iBeforeParser;\n        private volatile PeriodParser iAfterParser;\n\n        Separator(String text, String finalText, String[] variants,\n                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n                boolean useBefore, boolean useAfter) {\n            iText = text;\n            iFinalText = finalText;\n\n            if ((finalText == null || text.equals(finalText)) &&\n                (variants == null || variants.length == 0)) {\n\n                iParsedForms = new String[] {text};\n            } else {\n                // Filter and reverse sort the parsed forms.\n                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                parsedSet.add(text);\n                parsedSet.add(finalText);\n                if (variants != null) {\n                    for (int i=variants.length; --i>=0; ) {\n                        parsedSet.add(variants[i]);\n                    }\n                }\n                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                Collections.reverse(parsedList);\n                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n            }\n\n            iBeforePrinter = beforePrinter;\n            iBeforeParser = beforeParser;\n            iUseBefore = useBefore;\n            iUseAfter = useAfter;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n            if (sum < stopAt) {\n                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(out, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            out.write(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        out.write(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                out.write(iText);\n            }\n            after.printTo(out, period, locale);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += (parsedForm == null ? 0 : parsedForm.length());\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }\n\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Composite implementation that merges other fields to create a full pattern.\n     */\n    static class Composite\n            implements PeriodPrinter, PeriodParser {\n        \n        private final PeriodPrinter[] iPrinters;\n        private final PeriodParser[] iParsers;\n\n        Composite(List<Object> elementPairs) {\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n            } else {\n                iPrinters = printerList.toArray(\n                        new PeriodPrinter[printerList.size()]);\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n            } else {\n                iParsers = parserList.toArray(\n                        new PeriodParser[parserList.size()]);\n            }\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(out, period, locale);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }\n\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TreeSet;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadablePeriod;\n\n/**\n * Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix(\" year\", \" years\")\n *     .appendSeparator(\" and \")\n *     .printZeroRarelyLast()\n *     .appendMonths()\n *     .appendSuffix(\" month\", \" months\")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n */\npublic class PeriodFormatterBuilder {\n    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n    private static final int PRINT_ZERO_RARELY_LAST = 2;\n    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n    private static final int PRINT_ZERO_ALWAYS = 4;\n    private static final int PRINT_ZERO_NEVER = 5;\n    \n    private static final int YEARS = 0;\n    private static final int MONTHS = 1;\n    private static final int WEEKS = 2;\n    private static final int DAYS = 3;\n    private static final int HOURS = 4;\n    private static final int MINUTES = 5;\n    private static final int SECONDS = 6;\n    private static final int MILLIS = 7;\n    private static final int SECONDS_MILLIS = 8;\n    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n\n    private int iMinPrintedDigits;\n    private int iPrintZeroSetting;\n    private int iMaxParsedDigits;\n    private boolean iRejectSignedValues;\n\n    private PeriodFieldAffix iPrefix;\n\n    // List of Printers and Parsers used to build a final formatter.\n    private List<Object> iElementPairs;\n    /** Set to true if the formatter is not a printer. */\n    private boolean iNotPrinter;\n    /** Set to true if the formatter is not a parser. */\n    private boolean iNotParser;\n\n    // Last PeriodFormatter appended of each field type.\n    private FieldFormatter[] iFieldFormatters;\n\n    public PeriodFormatterBuilder() {\n        clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a PeriodFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link PeriodFormatter#isPrinter()} and\n     * {@link PeriodFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     * \n     * @return the newly created formatter\n     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n     */\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }\n\n    /**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }\n\n    /**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }\n\n    /**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }\n\n    /**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */\n    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }\n\n    /**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }\n\n    /**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }\n\n    /**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }\n\n    /**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }\n\n    /**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String singularText,\n                                                 String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }\n\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }\n\n    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String singularText,\n                                               String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @param variants  set of text values which are also acceptable when parsed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                  String[] variants) {\n        return appendSeparator(text, finalText, variants, true, true);\n    }\n\n    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }\n\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n     */\n    static interface PeriodFieldAffix {\n        int calculatePrintedLength(int value);\n        \n        void printTo(StringBuffer buf, int value);\n        \n        void printTo(Writer out, int value) throws IOException;\n        \n        /**\n         * @return new position after parsing affix, or ~position of failure\n         */\n        int parse(String periodStr, int position);\n\n        /**\n         * @return position where affix starts, or original ~position if not found\n         */\n        int scan(String periodStr, int position);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text does not vary by the amount.\n     */\n    static class SimpleAffix implements PeriodFieldAffix {\n        private final String iText;\n\n        SimpleAffix(String text) {\n            iText = text;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(iText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.\n     */\n    static class PluralAffix implements PeriodFieldAffix {\n        private final String iSingularText;\n        private final String iPluralText;\n\n        PluralAffix(String singularText, String pluralText) {\n            iSingularText = singularText;\n            iPluralText = pluralText;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return (value == 1 ? iSingularText : iPluralText).length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            if (periodStr.regionMatches\n                (true, position, text1, 0, text1.length())) {\n                return position + text1.length();\n            }\n            if (periodStr.regionMatches\n                (true, position, text2, 0, text2.length())) {\n                return position + text2.length();\n            }\n\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            int textLength1 = text1.length();\n            int textLength2 = text2.length();\n\n            int sourceLength = periodStr.length();\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                    return pos;\n                }\n                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                    return pos;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Builds a composite affix by merging two other affix implementations.\n     */\n    static class CompositeAffix implements PeriodFieldAffix {\n        private final PeriodFieldAffix iLeft;\n        private final PeriodFieldAffix iRight;\n\n        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n            iLeft = left;\n            iRight = right;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iLeft.calculatePrintedLength(value)\n                + iRight.calculatePrintedLength(value);\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            iLeft.printTo(buf, value);\n            iRight.printTo(buf, value);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            iLeft.printTo(out, value);\n            iRight.printTo(out, value);\n        }\n\n        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats the numeric value of a field, potentially with prefix/suffix.\n     */\n    static class FieldFormatter\n            implements PeriodPrinter, PeriodParser {\n        private final int iMinPrintedDigits;\n        private final int iPrintZeroSetting;\n        private final int iMaxParsedDigits;\n        private final boolean iRejectSignedValues;\n        \n        /** The index of the field type, 0=year, etc. */\n        private final int iFieldType;\n        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 or 5 digits with a negative\n                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }\n        \n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int bufLen = buf.length();\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n                        buf.insert(bufLen, '-');\n                    }\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(out, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.writeUnpaddedInteger(out, value);\n            } else {\n                FormatUtils.writePaddedInteger(out, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    out.write('.');\n                    FormatUtils.writePaddedInteger(out, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(out, value);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }\n\n        /**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }\n\n        /**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }\n\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }\n\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }\n\n        int getFieldType() {\n            return iFieldType;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a simple literal piece of text.\n     */\n    static class Literal\n            implements PeriodPrinter, PeriodParser {\n        static final Literal EMPTY = new Literal(\"\");\n        private final String iText;\n\n        Literal(String text) {\n            iText = text;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            out.write(iText);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.\n     */\n    static class Separator\n            implements PeriodPrinter, PeriodParser {\n        private final String iText;\n        private final String iFinalText;\n        private final String[] iParsedForms;\n\n        private final boolean iUseBefore;\n        private final boolean iUseAfter;\n\n        private final PeriodPrinter iBeforePrinter;\n        private volatile PeriodPrinter iAfterPrinter;\n        private final PeriodParser iBeforeParser;\n        private volatile PeriodParser iAfterParser;\n\n        Separator(String text, String finalText, String[] variants,\n                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n                boolean useBefore, boolean useAfter) {\n            iText = text;\n            iFinalText = finalText;\n\n            if ((finalText == null || text.equals(finalText)) &&\n                (variants == null || variants.length == 0)) {\n\n                iParsedForms = new String[] {text};\n            } else {\n                // Filter and reverse sort the parsed forms.\n                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                parsedSet.add(text);\n                parsedSet.add(finalText);\n                if (variants != null) {\n                    for (int i=variants.length; --i>=0; ) {\n                        parsedSet.add(variants[i]);\n                    }\n                }\n                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                Collections.reverse(parsedList);\n                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n            }\n\n            iBeforePrinter = beforePrinter;\n            iBeforeParser = beforeParser;\n            iUseBefore = useBefore;\n            iUseAfter = useAfter;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n            if (sum < stopAt) {\n                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(out, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            out.write(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        out.write(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                out.write(iText);\n            }\n            after.printTo(out, period, locale);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += (parsedForm == null ? 0 : parsedForm.length());\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }\n\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Composite implementation that merges other fields to create a full pattern.\n     */\n    static class Composite\n            implements PeriodPrinter, PeriodParser {\n        \n        private final PeriodPrinter[] iPrinters;\n        private final PeriodParser[] iParsers;\n\n        Composite(List<Object> elementPairs) {\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n            } else {\n                iPrinters = printerList.toArray(\n                        new PeriodPrinter[printerList.size()]);\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n            } else {\n                iParsers = parserList.toArray(\n                        new PeriodParser[parserList.size()]);\n            }\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(out, period, locale);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }\n\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 14, "classes_modified": [{"class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField", "buggy_version": "/*\n *  Copyright 2001-2005 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DurationField;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.field.ImpreciseDateTimeField;\n\n/**\n * Provides time calculations for the month of the year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.2, refactored from GJMonthOfYearDateTimeField\n */\nclass BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -8258715387168736L;\n\n    private static final int MIN = DateTimeConstants.JANUARY;\n\n    private final BasicChronology iChronology;\n    private final int iMax;\n    private final int iLeapMonth;\n\n    /**\n     * Restricted constructor.\n     * \n     * @param leapMonth the month of year that leaps\n     */\n    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isLenient() {\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the Month component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#get(long)\n     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n     * @param instant  the time instant in millis to query.\n     * @return the month extracted from the input.\n     */\n    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add the specified month to the specified time instant.\n     * The amount added may be negative.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 - (1 month) = 06-30<p>\n     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n     * \n     * @see org.joda.time.DateTimeField#add\n     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */\n    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n    //-----------------------------------------------------------------------\n    public long add(long instant, long months) {\n        int i_months = (int)months;\n        if (i_months == months) {\n            return add(instant, i_months);\n        }\n\n        // Copied from add(long, int) and modified slightly:\n\n        long timePart = iChronology.getMillisOfDay(instant);\n\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n\n        long yearToUse;\n        long monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = (int)(monthToUse % iMax);\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n\n        if (yearToUse < iChronology.getMinYear() ||\n            yearToUse > iChronology.getMaxYear()) {\n\n            throw new IllegalArgumentException\n                (\"Magnitude of add amount is too large: \" + months);\n        }\n\n        int i_yearToUse = (int)yearToUse;\n        int i_monthToUse = (int)monthToUse;\n\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n\n        long datePart =\n            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add to the Month component of the specified time instant\n     * wrapping around within that component if necessary.\n     * \n     * @see org.joda.time.DateTimeField#addWrapField\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */\n    public long addWrapField(long instant, int months) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n    }\n\n    //-----------------------------------------------------------------------\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -getDifference(subtrahendInstant, minuendInstant);\n        }\n\n        int minuendYear = iChronology.getYear(minuendInstant);\n        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n\n        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n\n        // Before adjusting for remainder, account for special case of add\n        // where the day-of-month is forced to the nearest sane value.\n        int minuendDom = iChronology.getDayOfMonth\n            (minuendInstant, minuendYear, minuendMonth);\n        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n            // Last day of the minuend month...\n            int subtrahendDom = iChronology.getDayOfMonth\n                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n            if (subtrahendDom > minuendDom) {\n                // ...and day of subtrahend month is larger.\n                // Note: This works fine, but it ideally shouldn't invoke other\n                // fields from within a field.\n                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n            }\n        }\n\n        // Inlined remainder method to avoid duplicate calls.\n        long minuendRem = minuendInstant\n            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n        long subtrahendRem = subtrahendInstant\n            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n\n        return difference;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the Month component of the specified time instant.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 to month 6 = 06-30<p>\n     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n     * \n     * @param instant  the time instant in millis to update.\n     * @param month  the month (1,12) to update the time to.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException  if month is invalid\n     */\n    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isLeap(long instant) {\n        int thisYear = iChronology.getYear(instant);\n        if (iChronology.isLeapYear(thisYear)) {\n            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    public int getLeapAmount(long instant) {\n        return isLeap(instant) ? 1 : 0;\n    }\n\n    //-----------------------------------------------------------------------\n    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n\n    //-----------------------------------------------------------------------\n    public int getMinimumValue() {\n        return MIN;\n    }\n\n    //-----------------------------------------------------------------------\n    public int getMaximumValue() {\n        return iMax;\n    }\n\n    //-----------------------------------------------------------------------\n    public long roundFloor(long instant) {\n        int year = iChronology.getYear(instant);\n        int month = iChronology.getMonthOfYear(instant, year);\n        return iChronology.getYearMonthMillis(year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    public long remainder(long instant) {\n        return instant - roundFloor(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return iChronology.monthOfYear();\n    }\n}\n", "fixed_version": "/*\n *  Copyright 2001-2005 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DurationField;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.field.ImpreciseDateTimeField;\n\n/**\n * Provides time calculations for the month of the year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.2, refactored from GJMonthOfYearDateTimeField\n */\nclass BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -8258715387168736L;\n\n    private static final int MIN = DateTimeConstants.JANUARY;\n\n    private final BasicChronology iChronology;\n    private final int iMax;\n    private final int iLeapMonth;\n\n    /**\n     * Restricted constructor.\n     * \n     * @param leapMonth the month of year that leaps\n     */\n    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isLenient() {\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the Month component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#get(long)\n     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n     * @param instant  the time instant in millis to query.\n     * @return the month extracted from the input.\n     */\n    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add the specified month to the specified time instant.\n     * The amount added may be negative.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 - (1 month) = 06-30<p>\n     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n     * \n     * @see org.joda.time.DateTimeField#add\n     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */\n    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n    //-----------------------------------------------------------------------\n    public long add(long instant, long months) {\n        int i_months = (int)months;\n        if (i_months == months) {\n            return add(instant, i_months);\n        }\n\n        // Copied from add(long, int) and modified slightly:\n\n        long timePart = iChronology.getMillisOfDay(instant);\n\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n\n        long yearToUse;\n        long monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = (int)(monthToUse % iMax);\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n\n        if (yearToUse < iChronology.getMinYear() ||\n            yearToUse > iChronology.getMaxYear()) {\n\n            throw new IllegalArgumentException\n                (\"Magnitude of add amount is too large: \" + months);\n        }\n\n        int i_yearToUse = (int)yearToUse;\n        int i_monthToUse = (int)monthToUse;\n\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n\n        long datePart =\n            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            // month is largest field and being added to, such as month-day\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add to the Month component of the specified time instant\n     * wrapping around within that component if necessary.\n     * \n     * @see org.joda.time.DateTimeField#addWrapField\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */\n    public long addWrapField(long instant, int months) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n    }\n\n    //-----------------------------------------------------------------------\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -getDifference(subtrahendInstant, minuendInstant);\n        }\n\n        int minuendYear = iChronology.getYear(minuendInstant);\n        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n\n        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n\n        // Before adjusting for remainder, account for special case of add\n        // where the day-of-month is forced to the nearest sane value.\n        int minuendDom = iChronology.getDayOfMonth\n            (minuendInstant, minuendYear, minuendMonth);\n        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n            // Last day of the minuend month...\n            int subtrahendDom = iChronology.getDayOfMonth\n                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n            if (subtrahendDom > minuendDom) {\n                // ...and day of subtrahend month is larger.\n                // Note: This works fine, but it ideally shouldn't invoke other\n                // fields from within a field.\n                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n            }\n        }\n\n        // Inlined remainder method to avoid duplicate calls.\n        long minuendRem = minuendInstant\n            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n        long subtrahendRem = subtrahendInstant\n            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n\n        return difference;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the Month component of the specified time instant.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 to month 6 = 06-30<p>\n     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n     * \n     * @param instant  the time instant in millis to update.\n     * @param month  the month (1,12) to update the time to.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException  if month is invalid\n     */\n    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isLeap(long instant) {\n        int thisYear = iChronology.getYear(instant);\n        if (iChronology.isLeapYear(thisYear)) {\n            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    public int getLeapAmount(long instant) {\n        return isLeap(instant) ? 1 : 0;\n    }\n\n    //-----------------------------------------------------------------------\n    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n\n    //-----------------------------------------------------------------------\n    public int getMinimumValue() {\n        return MIN;\n    }\n\n    //-----------------------------------------------------------------------\n    public int getMaximumValue() {\n        return iMax;\n    }\n\n    //-----------------------------------------------------------------------\n    public long roundFloor(long instant) {\n        int year = iChronology.getYear(instant);\n        int month = iChronology.getMonthOfYear(instant, year);\n        return iChronology.getYearMonthMillis(year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    public long remainder(long instant) {\n        return instant - roundFloor(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return iChronology.monthOfYear();\n    }\n}\n"}]}
{"project": "Time", "bug_id": 15, "classes_modified": [{"class_name": "org.joda.time.field.FieldUtils", "buggy_version": "/*\n *  Copyright 2001-2005 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n/**\n * General utilities that don't fit elsewhere.\n * <p>\n * FieldUtils is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic class FieldUtils {\n\n    /**\n     * Restricted constructor.\n     */\n    private FieldUtils() {\n        super();\n    }\n    \n    //------------------------------------------------------------------------\n    /**\n     * Negates the input throwing an exception if it can't negate it.\n     * \n     * @param value  the value to negate\n     * @return the negated value\n     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n     * @since 1.1\n     */\n    public static int safeNegate(int value) {\n        if (value == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n        }\n        return -value;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n    \n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n          throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n    \n    /**\n     * Casts to an int throwing an exception if overflow occurs.\n     * \n     * @param value  the value\n     * @return the value as an int\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n    }\n    \n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = FieldUtils.safeMultiply(val1, val2);\n        return FieldUtils.safeToInt(val);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */\n    public static void verifyValueBounds(DateTimeField field, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (field.getType(), Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     * @since 1.1\n     */\n    public static void verifyValueBounds(DateTimeFieldType fieldType, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldType, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */\n    public static void verifyValueBounds(String fieldName,\n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldName, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Utility method used by addWrapField implementations to ensure the new\n     * value lies within the field's legal value range.\n     *\n     * @param currentValue the current value of the data, which may lie outside\n     * the wrapped value range\n     * @param wrapValue  the value to add to current value before\n     *  wrapping.  This may be negative.\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */\n    public static int getWrappedValue(int currentValue, int wrapValue,\n                                      int minValue, int maxValue) {\n        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n    }\n\n    /**\n     * Utility method that ensures the given value lies within the field's\n     * legal value range.\n     * \n     * @param value  the value to fit into the wrapped value range\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */\n    public static int getWrappedValue(int value, int minValue, int maxValue) {\n        if (minValue >= maxValue) {\n            throw new IllegalArgumentException(\"MIN > MAX\");\n        }\n\n        int wrapRange = maxValue - minValue + 1;\n        value -= minValue;\n\n        if (value >= 0) {\n            return (value % wrapRange) + minValue;\n        }\n\n        int remByRange = (-value) % wrapRange;\n\n        if (remByRange == 0) {\n            return 0 + minValue;\n        }\n        return (wrapRange - remByRange) + minValue;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares two objects as equals handling null.\n     * \n     * @param object1  the first object\n     * @param object2  the second object\n     * @return true if equal\n     * @since 1.4\n     */\n    public static boolean equals(Object object1, Object object2) {\n        if (object1 == object2) {\n            return true;\n        }\n        if (object1 == null || object2 == null) {\n            return false;\n        }\n        return object1.equals(object2);\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2005 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n/**\n * General utilities that don't fit elsewhere.\n * <p>\n * FieldUtils is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic class FieldUtils {\n\n    /**\n     * Restricted constructor.\n     */\n    private FieldUtils() {\n        super();\n    }\n    \n    //------------------------------------------------------------------------\n    /**\n     * Negates the input throwing an exception if it can't negate it.\n     * \n     * @param value  the value to negate\n     * @return the negated value\n     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n     * @since 1.1\n     */\n    public static int safeNegate(int value) {\n        if (value == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n        }\n        return -value;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n    \n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n          throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n    \n    /**\n     * Casts to an int throwing an exception if overflow occurs.\n     * \n     * @param value  the value\n     * @return the value as an int\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n    }\n    \n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = FieldUtils.safeMultiply(val1, val2);\n        return FieldUtils.safeToInt(val);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */\n    public static void verifyValueBounds(DateTimeField field, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (field.getType(), Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     * @since 1.1\n     */\n    public static void verifyValueBounds(DateTimeFieldType fieldType, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldType, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */\n    public static void verifyValueBounds(String fieldName,\n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldName, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Utility method used by addWrapField implementations to ensure the new\n     * value lies within the field's legal value range.\n     *\n     * @param currentValue the current value of the data, which may lie outside\n     * the wrapped value range\n     * @param wrapValue  the value to add to current value before\n     *  wrapping.  This may be negative.\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */\n    public static int getWrappedValue(int currentValue, int wrapValue,\n                                      int minValue, int maxValue) {\n        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n    }\n\n    /**\n     * Utility method that ensures the given value lies within the field's\n     * legal value range.\n     * \n     * @param value  the value to fit into the wrapped value range\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */\n    public static int getWrappedValue(int value, int minValue, int maxValue) {\n        if (minValue >= maxValue) {\n            throw new IllegalArgumentException(\"MIN > MAX\");\n        }\n\n        int wrapRange = maxValue - minValue + 1;\n        value -= minValue;\n\n        if (value >= 0) {\n            return (value % wrapRange) + minValue;\n        }\n\n        int remByRange = (-value) % wrapRange;\n\n        if (remByRange == 0) {\n            return 0 + minValue;\n        }\n        return (wrapRange - remByRange) + minValue;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares two objects as equals handling null.\n     * \n     * @param object1  the first object\n     * @param object2  the second object\n     * @return true if equal\n     * @since 1.4\n     */\n    public static boolean equals(Object object1, Object object2) {\n        if (object1 == object2) {\n            return true;\n        }\n        if (object1 == null || object2 == null) {\n            return false;\n        }\n        return object1.equals(object2);\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 16, "classes_modified": [{"class_name": "org.joda.time.format.DateTimeFormatter", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.LocalDate;\nimport org.joda.time.LocalDateTime;\nimport org.joda.time.LocalTime;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadWritableInstant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\n\n/**\n * Controls the printing and parsing of a datetime to and from a string.\n * <p>\n * This class is the main API for printing and parsing used by most applications.\n * Instances of this class are created via one of three factory classes:\n * <ul>\n * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n * </ul>\n * <p>\n * An instance of this class holds a reference internally to one printer and\n * one parser. It is possible that one of these may be null, in which case the\n * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n * and {@link #isParser()} methods.\n * <p>\n * The underlying printer/parser can be altered to behave exactly as required\n * by using one of the decorator modifiers:\n * <ul>\n * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n * </ul>\n * Each of these returns a new formatter (instances of this class are immutable).\n * <p>\n * The main methods of the class are the <code>printXxx</code> and\n * <code>parseXxx</code> methods. These are used as follows:\n * <pre>\n * // print using the defaults (default locale, chronology/zone of the datetime)\n * String dateStr = formatter.print(dt);\n * // print using the French locale\n * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n * // print using the UTC zone\n * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n * \n * // parse using the Paris zone\n * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n * </pre>\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeFormatter {\n\n    /** The internal printer used to output the datetime. */\n    private final DateTimePrinter iPrinter;\n    /** The internal parser used to output the datetime. */\n    private final DateTimeParser iParser;\n    /** The locale to use for printing and parsing. */\n    private final Locale iLocale;\n    /** Whether the offset is parsed. */\n    private final boolean iOffsetParsed;\n    /** The chronology to use as an override. */\n    private final Chronology iChrono;\n    /** The zone to use as an override. */\n    private final DateTimeZone iZone;\n    /** The pivot year to use for two-digit year parsing. */\n    private final Integer iPivotYear;\n    /** The default year for parsing month/day without year. */\n    private final int iDefaultYear;\n\n    /**\n     * Creates a new formatter, however you will normally use the factory\n     * or the builder.\n     * \n     * @param printer  the internal printer, null if cannot print\n     * @param parser  the internal parser, null if cannot parse\n     */\n    public DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n\n    /**\n     * Constructor.\n     */\n    private DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser,\n            Locale locale, boolean offsetParsed,\n            Chronology chrono, DateTimeZone zone,\n            Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is this formatter capable of printing.\n     * \n     * @return true if this is a printer\n     */\n    public boolean isPrinter() {\n        return (iPrinter != null);\n    }\n\n    /**\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer; is null if printing not supported\n     */\n    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n\n    /**\n     * Is this formatter capable of parsing.\n     * \n     * @return true if this is a parser\n     */\n    public boolean isParser() {\n        return (iParser != null);\n    }\n\n    /**\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser; is null if parsing not supported\n     */\n    public DateTimeParser getParser() {\n        return iParser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use; if null, formatter uses default locale at\n     * invocation time\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will create a datetime with a time zone\n     * equal to that of the offset of the parsed string.\n     * <p>\n     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n     * savings rules). If the parsed string represents a local time (no zone\n     * offset) the parsed datetime will be in the default zone.\n     * <p>\n     * Calling this method sets the override zone to null.\n     * Calling the override zone method sets this flag off.\n     * \n     * @return the new formatter\n     */\n    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Checks whether the offset from the string is used as the zone of\n     * the parsed datetime.\n     * \n     * @return true if the offset from the string is used as the zone\n     */\n    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified chronology in\n     * preference to that of the printed object, or ISO on a parse.\n     * <p>\n     * When printing, this chronolgy will be used in preference to the chronology\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this chronology will be set on the parsed datetime.\n     * <p>\n     * A null chronology means no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param chrono  the chronology to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     * @deprecated Use the method with the correct spelling\n     */\n    @Deprecated\n    public Chronology getChronolgy() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the UTC zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, UTC will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, UTC will be set on the parsed datetime.\n     * <p>\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @return the new formatter, never null\n     * @since 2.0\n     */\n    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, this zone will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this zone will be set on the parsed datetime.\n     * <p>\n     * A null zone means of no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param zone  the zone to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the zone to use as an override.\n     * \n     * @return the zone to use as an override\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used. Null means no-override.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }\n\n    /**\n     * Gets the pivot year to use as an override.\n     *\n     * @return the pivot year to use as an override\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n      return iPivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     */\n    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n\n    /**\n     * Gets the default year for parsing months and days.\n     *\n     * @return the default year for parsing months and days\n     * @since 2.0\n     */\n    public int getDefaultYear() {\n      return iDefaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(out, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(StringBuffer buf, long instant) {\n        printTo(buf, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(Writer out, long instant) throws IOException {\n        printTo(out, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, long instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param buf  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(StringBuffer buf, ReadablePartial partial) {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(buf, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param out  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(out, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param partial  partial to format\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n        appendable.append(print(partial));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the chronology and zone of the instant.\n     *\n     * @param instant  instant to format, null means now\n     * @return the printed result\n     */\n    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a millisecond instant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the ISO chronology and default zone.\n     *\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @return the printed result\n     */\n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */\n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    /**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant as the default.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    /**\n     * Parses only the local time from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    /**\n     * Parses only the local date-time from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determines the correct chronology to use.\n     *\n     * @param chrono  the proposed chronology\n     * @return the actual chronology\n     */\n    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.LocalDate;\nimport org.joda.time.LocalDateTime;\nimport org.joda.time.LocalTime;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadWritableInstant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\n\n/**\n * Controls the printing and parsing of a datetime to and from a string.\n * <p>\n * This class is the main API for printing and parsing used by most applications.\n * Instances of this class are created via one of three factory classes:\n * <ul>\n * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n * </ul>\n * <p>\n * An instance of this class holds a reference internally to one printer and\n * one parser. It is possible that one of these may be null, in which case the\n * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n * and {@link #isParser()} methods.\n * <p>\n * The underlying printer/parser can be altered to behave exactly as required\n * by using one of the decorator modifiers:\n * <ul>\n * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n * </ul>\n * Each of these returns a new formatter (instances of this class are immutable).\n * <p>\n * The main methods of the class are the <code>printXxx</code> and\n * <code>parseXxx</code> methods. These are used as follows:\n * <pre>\n * // print using the defaults (default locale, chronology/zone of the datetime)\n * String dateStr = formatter.print(dt);\n * // print using the French locale\n * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n * // print using the UTC zone\n * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n * \n * // parse using the Paris zone\n * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n * </pre>\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeFormatter {\n\n    /** The internal printer used to output the datetime. */\n    private final DateTimePrinter iPrinter;\n    /** The internal parser used to output the datetime. */\n    private final DateTimeParser iParser;\n    /** The locale to use for printing and parsing. */\n    private final Locale iLocale;\n    /** Whether the offset is parsed. */\n    private final boolean iOffsetParsed;\n    /** The chronology to use as an override. */\n    private final Chronology iChrono;\n    /** The zone to use as an override. */\n    private final DateTimeZone iZone;\n    /** The pivot year to use for two-digit year parsing. */\n    private final Integer iPivotYear;\n    /** The default year for parsing month/day without year. */\n    private final int iDefaultYear;\n\n    /**\n     * Creates a new formatter, however you will normally use the factory\n     * or the builder.\n     * \n     * @param printer  the internal printer, null if cannot print\n     * @param parser  the internal parser, null if cannot parse\n     */\n    public DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n\n    /**\n     * Constructor.\n     */\n    private DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser,\n            Locale locale, boolean offsetParsed,\n            Chronology chrono, DateTimeZone zone,\n            Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is this formatter capable of printing.\n     * \n     * @return true if this is a printer\n     */\n    public boolean isPrinter() {\n        return (iPrinter != null);\n    }\n\n    /**\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer; is null if printing not supported\n     */\n    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n\n    /**\n     * Is this formatter capable of parsing.\n     * \n     * @return true if this is a parser\n     */\n    public boolean isParser() {\n        return (iParser != null);\n    }\n\n    /**\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser; is null if parsing not supported\n     */\n    public DateTimeParser getParser() {\n        return iParser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use; if null, formatter uses default locale at\n     * invocation time\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will create a datetime with a time zone\n     * equal to that of the offset of the parsed string.\n     * <p>\n     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n     * savings rules). If the parsed string represents a local time (no zone\n     * offset) the parsed datetime will be in the default zone.\n     * <p>\n     * Calling this method sets the override zone to null.\n     * Calling the override zone method sets this flag off.\n     * \n     * @return the new formatter\n     */\n    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Checks whether the offset from the string is used as the zone of\n     * the parsed datetime.\n     * \n     * @return true if the offset from the string is used as the zone\n     */\n    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified chronology in\n     * preference to that of the printed object, or ISO on a parse.\n     * <p>\n     * When printing, this chronolgy will be used in preference to the chronology\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this chronology will be set on the parsed datetime.\n     * <p>\n     * A null chronology means no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param chrono  the chronology to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    /**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     * @deprecated Use the method with the correct spelling\n     */\n    @Deprecated\n    public Chronology getChronolgy() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the UTC zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, UTC will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, UTC will be set on the parsed datetime.\n     * <p>\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @return the new formatter, never null\n     * @since 2.0\n     */\n    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, this zone will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this zone will be set on the parsed datetime.\n     * <p>\n     * A null zone means of no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param zone  the zone to use as an override\n     * @return the new formatter\n     */\n    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }\n\n    /**\n     * Gets the zone to use as an override.\n     * \n     * @return the zone to use as an override\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used. Null means no-override.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }\n\n    /**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */\n    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }\n\n    /**\n     * Gets the pivot year to use as an override.\n     *\n     * @return the pivot year to use as an override\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n      return iPivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     */\n    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n\n    /**\n     * Gets the default year for parsing months and days.\n     *\n     * @return the default year for parsing months and days\n     * @since 2.0\n     */\n    public int getDefaultYear() {\n      return iDefaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     */\n    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(out, millis, chrono);\n    }\n\n    /**\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(StringBuffer buf, long instant) {\n        printTo(buf, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param out  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     */\n    public void printTo(Writer out, long instant) throws IOException {\n        printTo(out, instant, null);\n    }\n\n    /**\n     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n     * using ISO chronology in the default DateTimeZone.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, long instant) throws IOException {\n        appendable.append(print(instant));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param buf  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(StringBuffer buf, ReadablePartial partial) {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(buf, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param out  the destination to format to, not null\n     * @param partial  partial to format\n     */\n    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        printer.printTo(out, partial, iLocale);\n    }\n\n    /**\n     * Prints a ReadablePartial.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param appendable  the destination to format to, not null\n     * @param partial  partial to format\n     * @since 2.0\n     */\n    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n        appendable.append(print(partial));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Prints a ReadableInstant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the chronology and zone of the instant.\n     *\n     * @param instant  instant to format, null means now\n     * @return the printed result\n     */\n    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a millisecond instant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the ISO chronology and default zone.\n     *\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @return the printed result\n     */\n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */\n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    /**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant as the default.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    /**\n     * Parses only the local time from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    /**\n     * Parses only the local date-time from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determines the correct chronology to use.\n     *\n     * @param chrono  the proposed chronology\n     * @return the actual chronology\n     */\n    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 17, "classes_modified": [{"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2012 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n    }\n//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2012 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 18, "classes_modified": [{"class_name": "org.joda.time.chrono.GJChronology", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.DecoratedDurationField;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Implements the Gregorian/Julian calendar system which is the calendar system\n * used in most of the world. Wherever possible, it is recommended to use the\n * {@link ISOChronology} instead.\n * <p>\n * The Gregorian calendar replaced the Julian calendar, and the point in time\n * when this chronology switches can be controlled using the second parameter\n * of the getInstance method. By default this cutover is set to the date the\n * Gregorian calendar was first instituted, October 15, 1582.\n * <p>\n * Before this date, this chronology uses the proleptic Julian calendar\n * (proleptic means extending indefinitely). The Julian calendar has leap years\n * every four years, whereas the Gregorian has special rules for 100 and 400\n * years. A meaningful result will thus be obtained for all input values.\n * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n * there was no Julian calendar.\n * <p>\n * This chronology differs from\n * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n * The yearOfEra field produces results compatible with GregorianCalendar.\n * <p>\n * The Julian calendar does not have a year zero, and so year -1 is followed by\n * year 1. If the Gregorian cutover date is specified at or before year -1\n * (Julian), year zero is defined. In other words, the proleptic Gregorian\n * chronology used by this class has a year zero.\n * <p>\n * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n * and to create a pure proleptic Gregorian chronology, use\n * {@link GregorianChronology}.\n * <p>\n * GJChronology is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic final class GJChronology extends AssembledChronology {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -2545574827706931671L;\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }\n\n    /**\n     * The default GregorianJulian cutover point.\n     */\n    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n\n    /** Cache of zone to chronology list */\n    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The time zone of the returned instance is UTC.\n     */\n    public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The returned chronology is in the default time zone.\n     */\n    public static GJChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. This uses\n     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n     * (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     */\n    public static GJChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n    \n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n\n        ArrayList<GJChronology> chronos = cCache.get(zone);\n        if (chronos == null) {\n            chronos = new ArrayList<GJChronology>(2);\n            cCache.put(zone, chronos);\n        } else {\n            for (int i=chronos.size(); --i>=0; ) {\n                chrono = chronos.get(i);\n                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n                    \n                    return chrono;\n                }\n            }\n        }\n\n        if (zone == DateTimeZone.UTC) {\n            chrono = new GJChronology\n                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                 cutoverInstant);\n        } else {\n            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n            chrono = new GJChronology\n                (ZonedChronology.getInstance(chrono, zone),\n                 chrono.iJulianChronology,\n                 chrono.iGregorianChronology,\n                 chrono.iCutoverInstant);\n        }\n\n        chronos.add(chrono);\n\n        return chrono;\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            long gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    private JulianChronology iJulianChronology;\n    private GregorianChronology iGregorianChronology;\n    private Instant iCutoverInstant;\n\n    private long iCutoverMillis;\n    private long iGapDuration;\n\n    /**\n     * @param julian chronology used before the cutover instant\n     * @param gregorian chronology used at and after the cutover instant\n     * @param cutoverInstant instant when the gregorian chronology began\n     */\n    private GJChronology(JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Called when applying a time zone.\n     */\n    private GJChronology(Chronology base,\n                         JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n\n    // Conversion\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */\n    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int millisOfDay)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        // Assume date is Gregorian.\n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth, millisOfDay);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth, millisOfDay);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    /**\n     * Gets the cutover instant between Gregorian and Julian chronologies.\n     * @return the cutover instant\n     */\n    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n\n    /**\n     * Gets the minimum days needed for a week to be the first week in a year.\n     * \n     * @return the minimum days\n     */\n    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n\n    /**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */\n    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n\n    /**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */\n    public int hashCode() {\n        return \"GJ\".hashCode() * 11 + iJulianChronology.hashCode() +\n            iGregorianChronology.hashCode() + iCutoverInstant.hashCode();\n    }\n\n    // Output\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"GJChronology\");\n        sb.append('[');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\",cutover=\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\",mdfw=\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append(']');\n        \n        return sb.toString();\n    }\n\n    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n\n    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n     * assumes that calls to add and addWrapField are unaffected by the cutover.\n     */\n    private class CutoverField extends BaseDateTimeField {\n        private static final long serialVersionUID = 3528501219481026402L;\n\n        final DateTimeField iJulianField;\n        final DateTimeField iGregorianField;\n        final long iCutover;\n        final boolean iConvertByWeekyear;\n\n        protected DurationField iDurationField;\n        protected DurationField iRangeDurationField;\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         * @param convertByWeekyear\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            // Although average length of Julian and Gregorian years differ,\n            // use the Gregorian duration field because it is more accurate.\n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n\n        public boolean isLenient() {\n            return false;\n        }\n\n        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsText(instant, locale);\n            } else {\n                return iJulianField.getAsText(instant, locale);\n            }\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsShortText(instant, locale);\n            } else {\n                return iJulianField.getAsShortText(instant, locale);\n            }\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n            // overridden as superclass algorithm can't handle\n            // 2004-02-29 + 48 months -> 2008-02-29 type dates\n            if (valueToAdd == 0) {\n                return values;\n            }\n            if (DateTimeUtils.isContiguous(partial)) {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return GJChronology.this.get(partial, instant);\n            } else {\n                return super.add(partial, fieldIndex, values, valueToAdd);\n            }\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n\n        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            }\n            return instant;\n        }\n\n        public DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.isLeap(instant);\n            } else {\n                return iJulianField.isLeap(instant);\n            }\n        }\n\n        public int getLeapAmount(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getLeapAmount(instant);\n            } else {\n                return iJulianField.getLeapAmount(instant);\n            }\n        }\n\n        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n\n\n        public int getMinimumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical. Choose Julian to tighten up the year limits.\n            return iJulianField.getMinimumValue();\n        }\n\n        public int getMinimumValue(ReadablePartial partial) {\n            return iJulianField.getMinimumValue(partial);\n        }\n\n        public int getMinimumValue(ReadablePartial partial, int[] values) {\n            return iJulianField.getMinimumValue(partial, values);\n        }\n\n        public int getMinimumValue(long instant) {\n            if (instant < iCutover) {\n                return iJulianField.getMinimumValue(instant);\n            }\n\n            int min = iGregorianField.getMinimumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the minimum by setting it.\n            instant = iGregorianField.set(instant, min);\n            if (instant < iCutover) {\n                min = iGregorianField.get(iCutover);\n            }\n\n            return min;\n        }\n\n        public int getMaximumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical.\n            return iGregorianField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            }\n\n            int max = iJulianField.getMaximumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the maximum by setting it.\n            instant = iJulianField.set(instant, max);\n            if (instant >= iCutover) {\n                max = iJulianField.get(iJulianField.add(iCutover, -1));\n            }\n\n            return max;\n        }\n\n        public int getMaximumValue(ReadablePartial partial) {\n            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n            return getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial partial, int[] values) {\n            Chronology chrono = GJChronology.getInstanceUTC();\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeField field = partial.getFieldType(i).getField(chrono);\n                if (values[i] <= field.getMaximumValue(instant)) {\n                    instant = field.set(instant, values[i]);\n                }\n            }\n            return getMaximumValue(instant);\n        }\n\n        public long roundFloor(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundFloor(instant);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.roundFloor(instant);\n            }\n            return instant;\n        }\n\n        public long roundCeiling(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundCeiling(instant);\n            } else {\n                instant = iJulianField.roundCeiling(instant);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumTextLength(locale),\n                            iGregorianField.getMaximumTextLength(locale));\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n                            iGregorianField.getMaximumShortTextLength(locale));\n        }\n\n        protected long julianToGregorian(long instant) {\n            if (iConvertByWeekyear) {\n                return julianToGregorianByWeekyear(instant);\n            } else {\n                return julianToGregorianByYear(instant);\n            }\n        }\n\n        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Cutover field for variable length fields. These fields internally call\n     * set whenever add is called. As a result, the same correction applied to\n     * set must be applied to add and addWrapField. Knowing when to use this\n     * field requires specific knowledge of how the GJ fields are implemented.\n     */\n    private final class ImpreciseCutoverField extends CutoverField {\n        private static final long serialVersionUID = 3410248757173576441L;\n\n        /**\n         * Creates a duration field that links back to this.\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n\n        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n        \n        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        // Since the imprecise fields have durations longer than the gap\n        // duration, keep these methods simple. The inherited implementations\n        // produce incorrect results.\n        //\n        // Degenerate case: If this field is a month, and the cutover is set\n        // far into the future, then the gap duration may be so large as to\n        // reduce the number of months in a year. If the missing month(s) are\n        // at the beginning or end of the year, then the minimum and maximum\n        // values are not 1 and 12. I don't expect this case to ever occur.\n\n        public int getMinimumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMinimumValue(instant);\n            } else {\n                return iJulianField.getMinimumValue(instant);\n            }\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            } else {\n                return iJulianField.getMaximumValue(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Links the duration back to a ImpreciseCutoverField.\n     */\n    private static class LinkedDurationField extends DecoratedDurationField {\n        private static final long serialVersionUID = 4097975388007713084L;\n\n        private final ImpreciseCutoverField iField;\n\n        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n\n        public long add(long instant, int value) {\n            return iField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.DecoratedDurationField;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.ISODateTimeFormat;\n\n/**\n * Implements the Gregorian/Julian calendar system which is the calendar system\n * used in most of the world. Wherever possible, it is recommended to use the\n * {@link ISOChronology} instead.\n * <p>\n * The Gregorian calendar replaced the Julian calendar, and the point in time\n * when this chronology switches can be controlled using the second parameter\n * of the getInstance method. By default this cutover is set to the date the\n * Gregorian calendar was first instituted, October 15, 1582.\n * <p>\n * Before this date, this chronology uses the proleptic Julian calendar\n * (proleptic means extending indefinitely). The Julian calendar has leap years\n * every four years, whereas the Gregorian has special rules for 100 and 400\n * years. A meaningful result will thus be obtained for all input values.\n * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n * there was no Julian calendar.\n * <p>\n * This chronology differs from\n * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n * The yearOfEra field produces results compatible with GregorianCalendar.\n * <p>\n * The Julian calendar does not have a year zero, and so year -1 is followed by\n * year 1. If the Gregorian cutover date is specified at or before year -1\n * (Julian), year zero is defined. In other words, the proleptic Gregorian\n * chronology used by this class has a year zero.\n * <p>\n * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n * and to create a pure proleptic Gregorian chronology, use\n * {@link GregorianChronology}.\n * <p>\n * GJChronology is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic final class GJChronology extends AssembledChronology {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -2545574827706931671L;\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n\n    /**\n     * Convert a datetime from one chronology to another.\n     */\n    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }\n\n    /**\n     * The default GregorianJulian cutover point.\n     */\n    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n\n    /** Cache of zone to chronology list */\n    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The time zone of the returned instance is UTC.\n     */\n    public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The returned chronology is in the default time zone.\n     */\n    public static GJChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. This uses\n     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n     * (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     */\n    public static GJChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, DEFAULT_CUTOVER, 4);\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n    \n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n\n        ArrayList<GJChronology> chronos = cCache.get(zone);\n        if (chronos == null) {\n            chronos = new ArrayList<GJChronology>(2);\n            cCache.put(zone, chronos);\n        } else {\n            for (int i=chronos.size(); --i>=0; ) {\n                chrono = chronos.get(i);\n                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n                    \n                    return chrono;\n                }\n            }\n        }\n\n        if (zone == DateTimeZone.UTC) {\n            chrono = new GJChronology\n                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                 cutoverInstant);\n        } else {\n            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n            chrono = new GJChronology\n                (ZonedChronology.getInstance(chrono, zone),\n                 chrono.iJulianChronology,\n                 chrono.iGregorianChronology,\n                 chrono.iCutoverInstant);\n        }\n\n        chronos.add(chrono);\n\n        return chrono;\n    }\n\n    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static GJChronology getInstance(\n            DateTimeZone zone,\n            long gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    private JulianChronology iJulianChronology;\n    private GregorianChronology iGregorianChronology;\n    private Instant iCutoverInstant;\n\n    private long iCutoverMillis;\n    private long iGapDuration;\n\n    /**\n     * @param julian chronology used before the cutover instant\n     * @param gregorian chronology used at and after the cutover instant\n     * @param cutoverInstant instant when the gregorian chronology began\n     */\n    private GJChronology(JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Called when applying a time zone.\n     */\n    private GJChronology(Chronology base,\n                         JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n\n    // Conversion\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */\n    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n\n    /**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int millisOfDay)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        // Assume date is Gregorian.\n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth, millisOfDay);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth, millisOfDay);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n        try {\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalFieldValueException ex) {\n            if (monthOfYear != 2 || dayOfMonth != 29) {\n                throw ex;\n            }\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, 28,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw ex;\n            }\n        }\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n\n    /**\n     * Gets the cutover instant between Gregorian and Julian chronologies.\n     * @return the cutover instant\n     */\n    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n\n    /**\n     * Gets the minimum days needed for a week to be the first week in a year.\n     * \n     * @return the minimum days\n     */\n    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n\n    /**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */\n    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n\n    /**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */\n    public int hashCode() {\n        return \"GJ\".hashCode() * 11 + iJulianChronology.hashCode() +\n            iGregorianChronology.hashCode() + iCutoverInstant.hashCode();\n    }\n\n    // Output\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"GJChronology\");\n        sb.append('[');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\",cutover=\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\",mdfw=\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append(']');\n        \n        return sb.toString();\n    }\n\n    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n\n    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }\n\n    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n     * assumes that calls to add and addWrapField are unaffected by the cutover.\n     */\n    private class CutoverField extends BaseDateTimeField {\n        private static final long serialVersionUID = 3528501219481026402L;\n\n        final DateTimeField iJulianField;\n        final DateTimeField iGregorianField;\n        final long iCutover;\n        final boolean iConvertByWeekyear;\n\n        protected DurationField iDurationField;\n        protected DurationField iRangeDurationField;\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n\n        /**\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         * @param convertByWeekyear\n         */\n        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            // Although average length of Julian and Gregorian years differ,\n            // use the Gregorian duration field because it is more accurate.\n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n\n        public boolean isLenient() {\n            return false;\n        }\n\n        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsText(instant, locale);\n            } else {\n                return iJulianField.getAsText(instant, locale);\n            }\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            if (instant >= iCutover) {\n                return iGregorianField.getAsShortText(instant, locale);\n            } else {\n                return iJulianField.getAsShortText(instant, locale);\n            }\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iGregorianField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iGregorianField.add(instant, value);\n        }\n\n        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n            // overridden as superclass algorithm can't handle\n            // 2004-02-29 + 48 months -> 2008-02-29 type dates\n            if (valueToAdd == 0) {\n                return values;\n            }\n            if (DateTimeUtils.isContiguous(partial)) {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return GJChronology.this.get(partial, instant);\n            } else {\n                return super.add(partial, fieldIndex, values, valueToAdd);\n            }\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n\n        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            }\n            return instant;\n        }\n\n        public DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.isLeap(instant);\n            } else {\n                return iJulianField.isLeap(instant);\n            }\n        }\n\n        public int getLeapAmount(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getLeapAmount(instant);\n            } else {\n                return iJulianField.getLeapAmount(instant);\n            }\n        }\n\n        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n\n\n        public int getMinimumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical. Choose Julian to tighten up the year limits.\n            return iJulianField.getMinimumValue();\n        }\n\n        public int getMinimumValue(ReadablePartial partial) {\n            return iJulianField.getMinimumValue(partial);\n        }\n\n        public int getMinimumValue(ReadablePartial partial, int[] values) {\n            return iJulianField.getMinimumValue(partial, values);\n        }\n\n        public int getMinimumValue(long instant) {\n            if (instant < iCutover) {\n                return iJulianField.getMinimumValue(instant);\n            }\n\n            int min = iGregorianField.getMinimumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the minimum by setting it.\n            instant = iGregorianField.set(instant, min);\n            if (instant < iCutover) {\n                min = iGregorianField.get(iCutover);\n            }\n\n            return min;\n        }\n\n        public int getMaximumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical.\n            return iGregorianField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            }\n\n            int max = iJulianField.getMaximumValue(instant);\n\n            // Because the cutover may reduce the length of this field, verify\n            // the maximum by setting it.\n            instant = iJulianField.set(instant, max);\n            if (instant >= iCutover) {\n                max = iJulianField.get(iJulianField.add(iCutover, -1));\n            }\n\n            return max;\n        }\n\n        public int getMaximumValue(ReadablePartial partial) {\n            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n            return getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial partial, int[] values) {\n            Chronology chrono = GJChronology.getInstanceUTC();\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeField field = partial.getFieldType(i).getField(chrono);\n                if (values[i] <= field.getMaximumValue(instant)) {\n                    instant = field.set(instant, values[i]);\n                }\n            }\n            return getMaximumValue(instant);\n        }\n\n        public long roundFloor(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundFloor(instant);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.roundFloor(instant);\n            }\n            return instant;\n        }\n\n        public long roundCeiling(long instant) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.roundCeiling(instant);\n            } else {\n                instant = iJulianField.roundCeiling(instant);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumTextLength(locale),\n                            iGregorianField.getMaximumTextLength(locale));\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n                            iGregorianField.getMaximumShortTextLength(locale));\n        }\n\n        protected long julianToGregorian(long instant) {\n            if (iConvertByWeekyear) {\n                return julianToGregorianByWeekyear(instant);\n            } else {\n                return julianToGregorianByYear(instant);\n            }\n        }\n\n        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Cutover field for variable length fields. These fields internally call\n     * set whenever add is called. As a result, the same correction applied to\n     * set must be applied to add and addWrapField. Knowing when to use this\n     * field requires specific knowledge of how the GJ fields are implemented.\n     */\n    private final class ImpreciseCutoverField extends CutoverField {\n        private static final long serialVersionUID = 3410248757173576441L;\n\n        /**\n         * Creates a duration field that links back to this.\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n\n        /**\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         */\n        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n\n        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n        \n        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            if (minuendInstant >= iCutover) {\n                if (subtrahendInstant >= iCutover) {\n                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Julian, convert minuend to Julian to match.\n                minuendInstant = gregorianToJulian(minuendInstant);\n                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            } else {\n                if (subtrahendInstant < iCutover) {\n                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n                }\n                // Remember, the add is being reversed. Since subtrahend is\n                // Gregorian, convert minuend to Gregorian to match.\n                minuendInstant = julianToGregorian(minuendInstant);\n                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n            }\n        }\n\n        // Since the imprecise fields have durations longer than the gap\n        // duration, keep these methods simple. The inherited implementations\n        // produce incorrect results.\n        //\n        // Degenerate case: If this field is a month, and the cutover is set\n        // far into the future, then the gap duration may be so large as to\n        // reduce the number of months in a year. If the missing month(s) are\n        // at the beginning or end of the year, then the minimum and maximum\n        // values are not 1 and 12. I don't expect this case to ever occur.\n\n        public int getMinimumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMinimumValue(instant);\n            } else {\n                return iJulianField.getMinimumValue(instant);\n            }\n        }\n\n        public int getMaximumValue(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.getMaximumValue(instant);\n            } else {\n                return iJulianField.getMaximumValue(instant);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Links the duration back to a ImpreciseCutoverField.\n     */\n    private static class LinkedDurationField extends DecoratedDurationField {\n        private static final long serialVersionUID = 4097975388007713084L;\n\n        private final ImpreciseCutoverField iField;\n\n        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n\n        public long add(long instant, int value) {\n            return iField.add(instant, value);\n        }\n\n        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifference(minuendInstant, subtrahendInstant);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 19, "classes_modified": [{"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (before == after) {\n            return instant;\n        }\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? after : before);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (before == after) {\n            return instant;\n        }\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? after : before);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 20, "classes_modified": [{"class_name": "org.joda.time.format.DateTimeFormatterBuilder", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.MutableDateTime.Property;\nimport org.joda.time.field.MillisDurationField;\nimport org.joda.time.field.PreciseDateTimeField;\n\n/**\n * Factory that creates complex instances of DateTimeFormatter via method calls.\n * <p>\n * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link DateTimeFormat} and {@link ISODateTimeFormat}.\n * <p>\n * DateTimeFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints month and year, like \"January 1970\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n *     .appendMonthOfYearText()\n *     .appendLiteral(' ')\n *     .appendYear(4, 4)\n *     .toFormatter();\n * </pre>\n * <p>\n * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n * @see DateTimeFormat\n * @see ISODateTimeFormat\n */\npublic class DateTimeFormatterBuilder {\n\n    /** Array of printers and parsers (alternating). */\n    private ArrayList<Object> iElementPairs;\n    /** Cache of the last returned formatter. */\n    private Object iFormatter;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a DateTimeFormatterBuilder.\n     */\n    public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a DateTimeFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link DateTimeFormatter#isPrinter()} and\n     * {@link DateTimeFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     *\n     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n     */\n    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }\n\n    /**\n     * Internal method to create a DateTimePrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     *\n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"Printing is not supported\");\n    }\n\n    /**\n     * Internal method to create a DateTimeParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a parser in an application, call {@link #toFormatter()}\n     * and just use the parsing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     *\n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"Parsing is not supported\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if toFormatter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a formatter can be built\n     */\n    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }\n\n    /**\n     * Returns true if toPrinter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a printer can be built\n     */\n    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }\n\n    /**\n     * Returns true if toParser can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a parser can be built\n     */\n    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be\n     * reused.\n     */\n    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends another formatter.\n     *\n     * @param formatter  the formatter to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if formatter is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }\n\n    /**\n     * Appends just a printer. With no matching parser, a parser cannot be\n     * built from this DateTimeFormatterBuilder.\n     *\n     * @param printer  the printer to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n        checkPrinter(printer);\n        return append0(printer, null);\n    }\n\n    /**\n     * Appends just a parser. With no matching printer, a printer cannot be\n     * built from this builder.\n     *\n     * @param parser  the parser to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n        checkParser(parser);\n        return append0(null, parser);\n    }\n\n    /**\n     * Appends a printer/parser pair.\n     *\n     * @param printer  the printer to add\n     * @param parser  the parser to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n        checkPrinter(printer);\n        checkParser(parser);\n        return append0(printer, parser);\n    }\n\n    /**\n     * Appends a printer and a set of matching parsers. When parsing, the first\n     * parser in the list is selected for parsing. If it fails, the next is\n     * chosen, and so on. If none of these parsers succeeds, then the failed\n     * position of the parser that made the greatest progress is returned.\n     * <p>\n     * Only the printer is optional. In addition, it is illegal for any but the\n     * last of the parser array elements to be null. If the last element is\n     * null, this represents the empty parser. The presence of an empty parser\n     * indicates that the entire array of parse formats is optional.\n     *\n     * @param printer  the printer to add\n     * @param parsers  the parsers to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n     * @throws IllegalArgumentException if any parser element but the last is null\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"No parsers supplied\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"No parser supplied\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"Incomplete parser array\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }\n\n    /**\n     * Appends just a parser element which is optional. With no matching\n     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the parser is non null and a provider.\n     * \n     * @param parser  the parser to check\n     */\n    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n    }\n\n    /**\n     * Checks if the printer is non null and a provider.\n     * \n     * @param printer  the printer to check\n     */\n    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"No printer supplied\");\n        }\n    }\n\n    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        // Add the element as both a printer and parser.\n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }\n\n    private DateTimeFormatterBuilder append0(\n            DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instructs the printer to emit a specific character, and the parser to\n     * expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect\n     * it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if text is null\n     */\n    public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect an unsigned decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an unsigned decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */\n    public DateTimeFormatterBuilder appendFixedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect a signed decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an signed decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */\n    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, false));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as short text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }\n\n    /**\n     * Instructs the printer to emit a remainder of time as a decimal fraction,\n     * without decimal point. For example, if the field is specified as\n     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n     * a minute.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to print.\n     * @param maxDigits  maximum number of digits to print or parse.\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendFraction(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }\n\n    /**\n     * Appends the print/parse of a fractional second.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 230 milliseconds.\n     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional minute.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional hour.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional day.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric millisOfSecond field.\n     * <p>\n     * This method will append a field that prints a three digit value.\n     * During parsing the value that is parsed is assumed to be three digits.\n     * If less than three digits are present then they will be counted as the\n     * smallest parts of the millisecond. This is probably not what you want\n     * if you are using the field as a fraction. Instead, a fractional\n     * millisecond should be produced using {@link #appendFractionOfSecond}.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric millisOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric secondOfMinute field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric secondOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric minuteOfHour field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric minuteOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric hourOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric clockhourOfDay field.\n     *\n     * @param minDigits minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric hourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfWeek field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfMonth field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekOfWeekyear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric monthOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot year to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute year. With lenient parsing, specifying a positive\n     * or negative sign before the year also makes it absolute.\n     *\n     * @param pivot  pivot year to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute year\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n     * or negative sign before the weekyear also makes it absolute.\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute weekyear\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }\n\n    /**\n     * Instructs the printer to emit a numeric yearOfEra field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year of century field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric century of era field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific AM/PM text, and the\n     * parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n     * parser will accept a long or short dayOfWeek text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific dayOfWeek\n     * text. The parser will accept a long or short dayOfWeek text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific monthOfYear\n     * text. The parser will accept a long or short monthOfYear text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific monthOfYear text. The\n     * parser will accept a long or short monthOfYear text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n     * the parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneShortName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific time zone\n     * name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    /**\n     * Instructs the printer to emit the identifier of the time zone.\n     * From version 2.0, this field can be parsed.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }\n\n    /**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset text is supplied, then it will be printed when the zone is zero.\n     * During parsing, either the zero offset text, or the offset will be parsed.\n     *\n     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }\n\n    /**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset print text is supplied, then it will be printed when the zone is zero.\n     * If zero offset parse text is supplied, then either it or the offset will be parsed.\n     *\n     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n     * zone offset is zero. If null, then always use the offset.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 2.0\n     */\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n     * results into this builder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormat\n     */\n    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }\n\n    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isFormatter(Object f) {\n        return (isPrinter(f) || isParser(f));\n    }\n\n    static void appendUnknownString(StringBuffer buf, int len) {\n        for (int i = len; --i >= 0;) {\n            buf.append('\\ufffd');\n        }\n    }\n\n    static void printUnknownString(Writer out, int len) throws IOException {\n        for (int i = len; --i >= 0;) {\n            out.write('\\ufffd');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class CharacterLiteral\n            implements DateTimePrinter, DateTimeParser {\n\n        private final char iValue;\n\n        CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return 1;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return 1;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class StringLiteral\n            implements DateTimePrinter, DateTimeParser {\n\n        private final String iValue;\n\n        StringLiteral(String value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return iValue.length();\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return iValue.length();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                return position + iValue.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static abstract class NumberFormatter\n            implements DateTimePrinter, DateTimeParser {\n        protected final DateTimeFieldType iFieldType;\n        protected final int iMaxParsedDigits;\n        protected final boolean iSigned;\n\n        NumberFormatter(DateTimeFieldType fieldType,\n                int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }\n\n        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                // Since value may exceed integer limits, use stock parser\n                // which checks for this.\n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class UnpaddedNumber extends NumberFormatter {\n\n        protected UnpaddedNumber(DateTimeFieldType fieldType,\n                       int maxParsedDigits, boolean signed)\n        {\n            super(fieldType, maxParsedDigits, signed);\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    buf.append('\\ufffd');\n                }\n            } else {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    out.write('\\ufffd');\n                }\n            } else {\n                out.write('\\ufffd');\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class PaddedNumber extends NumberFormatter {\n\n        protected final int iMinPrintedDigits;\n\n        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n                     boolean signed, int minPrintedDigits)\n        {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    appendUnknownString(buf, iMinPrintedDigits);\n                }\n            } else {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    printUnknownString(out, iMinPrintedDigits);\n                }\n            } else {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class FixedNumber extends PaddedNumber {\n\n        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n            super(fieldType, numDigits, signed, numDigits);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int newPos = super.parseInto(bucket, text, position);\n            if (newPos < 0) {\n                return newPos;\n            }\n            int expectedPos = position + iMaxParsedDigits;\n            if (newPos != expectedPos) {\n                if (iSigned) {\n                    char c = text.charAt(position);\n                    if (c == '-' || c == '+') {\n                        expectedPos++;\n                    }\n                }\n                if (newPos > expectedPos) {\n                    // The failure is at the position of the first extra digit.\n                    return ~(expectedPos + 1);\n                } else if (newPos < expectedPos) {\n                    // The failure is at the position where the next digit should be.\n                    return ~newPos;\n                }\n            }\n            return newPos;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TwoDigitYear\n            implements DateTimePrinter, DateTimeParser {\n\n        /** The field to print/parse. */\n        private final DateTimeFieldType iType;\n        /** The pivot year. */\n        private final int iPivot;\n        private final boolean iLenientParse;\n\n        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n            super();\n            iType = type;\n            iPivot = pivot;\n            iLenientParse = lenientParse;\n        }\n\n        public int estimateParsedLength() {\n            return iLenientParse ? 4 : 2;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }\n        \n        public int estimatePrintedLength() {\n            return 2;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(long instant, Chronology chrono) {\n            try {\n                int year = iType.getField(chrono).get(instant);\n                if (year < 0) {\n                    year = -year;\n                }\n                return year % 100;\n            } catch (RuntimeException e) {\n                return -1;\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(ReadablePartial partial) {\n            if (partial.isSupported(iType)) {\n                try {\n                    int year = partial.get(iType);\n                    if (year < 0) {\n                        year = -year;\n                    }\n                    return year % 100;\n                } catch (RuntimeException e) {}\n            } \n            return -1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TextField\n            implements DateTimePrinter, DateTimeParser {\n\n        private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =\n                    new HashMap<Locale, Map<DateTimeFieldType, Object[]>>();\n        private final DateTimeFieldType iFieldType;\n        private final boolean iShort;\n\n        TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }\n\n        public int estimatePrintedLength() {\n            return iShort ? 6 : 20;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                buf.append(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                out.write(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            try {\n                buf.append(print(partial, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            try {\n                out.write(print(partial, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        private String print(long instant, Chronology chrono, Locale locale) {\n            DateTimeField field = iFieldType.getField(chrono);\n            if (iShort) {\n                return field.getAsShortText(instant, locale);\n            } else {\n                return field.getAsText(instant, locale);\n            }\n        }\n\n        private String print(ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                DateTimeField field = iFieldType.getField(partial.getChronology());\n                if (iShort) {\n                    return field.getAsShortText(partial, locale);\n                } else {\n                    return field.getAsText(partial, locale);\n                }\n            } else {\n                return \"\\ufffd\";\n            }\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            Locale locale = bucket.getLocale();\n            // handle languages which might have non ASCII A-Z or punctuation\n            // bug 1788282\n            Set<String> validValues = null;\n            int maxLength = 0;\n            synchronized (cParseCache) {\n                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n                if (innerMap == null) {\n                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n                    cParseCache.put(locale, innerMap);\n                }\n                Object[] array = innerMap.get(iFieldType);\n                if (array == null) {\n                    validValues = new HashSet<String>(32);\n                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n                    Property property = dt.property(iFieldType);\n                    int min = property.getMinimumValueOverall();\n                    int max = property.getMaximumValueOverall();\n                    if (max - min > 32) {  // protect against invalid fields\n                        return ~position;\n                    }\n                    maxLength = property.getMaximumTextLength(locale);\n                    for (int i = min; i <= max; i++) {\n                        property.set(i);\n                        validValues.add(property.getAsShortText(locale));\n                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n                        validValues.add(property.getAsText(locale));\n                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n                    }\n                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n                        // hack to support for parsing \"BCE\" and \"CE\" if the language is English\n                        validValues.add(\"BCE\");\n                        validValues.add(\"bce\");\n                        validValues.add(\"CE\");\n                        validValues.add(\"ce\");\n                        maxLength = 3;\n                    }\n                    array = new Object[] {validValues, Integer.valueOf(maxLength)};\n                    innerMap.put(iFieldType, array);\n                } else {\n                    validValues = (Set<String>) array[0];\n                    maxLength = ((Integer) array[1]).intValue();\n                }\n            }\n            // match the longest string first using our knowledge of the max length\n            int limit = Math.min(text.length(), position + maxLength);\n            for (int i = limit; i > position; i--) {\n                String match = text.substring(position, i);\n                if (validValues.contains(match)) {\n                    bucket.saveField(iFieldType, match, locale);\n                    return i;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class Fraction\n            implements DateTimePrinter, DateTimeParser {\n\n        private final DateTimeFieldType iFieldType;\n        protected int iMinDigits;\n        protected int iMaxDigits;\n\n        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            // Limit the precision requirements.\n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                printTo(buf, null, instant, chrono);\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            printTo(null, out, instant, chrono);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // removed check whether field is supported, as input field is typically\n            // secondOfDay which is unsupported by TimeOfDay\n            long millis = partial.getChronology().set(partial, 0L);\n            try {\n                printTo(buf, null, millis, partial.getChronology());\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // removed check whether field is supported, as input field is typically\n            // secondOfDay which is unsupported by TimeOfDay\n            long millis = partial.getChronology().set(partial, 0L);\n            printTo(null, out, millis, partial.getChronology());\n        }\n\n        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\n            throws IOException\n        {\n            DateTimeField field = iFieldType.getField(chrono);\n            int minDigits = iMinDigits;\n\n            long fraction;\n            try {\n                fraction = field.remainder(instant);\n            } catch (RuntimeException e) {\n                if (buf != null) {\n                    appendUnknownString(buf, minDigits);\n                } else {\n                    printUnknownString(out, minDigits);\n                }\n                return;\n            }\n\n            if (fraction == 0) {\n                if (buf != null) {\n                    while (--minDigits >= 0) {\n                        buf.append('0');\n                    }\n                } else {\n                    while (--minDigits >= 0) {\n                        out.write('0');\n                    }\n                }\n                return;\n            }\n\n            String str;\n            long[] fractionData = getFractionData(fraction, field);\n            long scaled = fractionData[0];\n            int maxDigits = (int) fractionData[1];\n            \n            if ((scaled & 0x7fffffff) == scaled) {\n                str = Integer.toString((int) scaled);\n            } else {\n                str = Long.toString(scaled);\n            }\n\n            int length = str.length();\n            int digits = maxDigits;\n            while (length < digits) {\n                if (buf != null) {\n                    buf.append('0');\n                } else {\n                    out.write('0');\n                }\n                minDigits--;\n                digits--;\n            }\n\n            if (minDigits < digits) {\n                // Chop off as many trailing zero digits as necessary.\n                while (minDigits < digits) {\n                    if (length <= 1 || str.charAt(length - 1) != '0') {\n                        break;\n                    }\n                    digits--;\n                    length--;\n                }\n                if (length < str.length()) {\n                    if (buf != null) {\n                        for (int i=0; i<length; i++) {\n                            buf.append(str.charAt(i));\n                        }\n                    } else {\n                        for (int i=0; i<length; i++) {\n                            out.write(str.charAt(i));\n                        }\n                    }\n                    return;\n                }\n            }\n\n            if (buf != null) {\n                buf.append(str);\n            } else {\n                out.write(str);\n            }\n        }\n        \n        private long[] getFractionData(long fraction, DateTimeField field) {\n            long rangeMillis = field.getDurationField().getUnitMillis();\n            long scalar;\n            int maxDigits = iMaxDigits;\n            while (true) {\n                switch (maxDigits) {\n                default: scalar = 1L; break;\n                case 1:  scalar = 10L; break;\n                case 2:  scalar = 100L; break;\n                case 3:  scalar = 1000L; break;\n                case 4:  scalar = 10000L; break;\n                case 5:  scalar = 100000L; break;\n                case 6:  scalar = 1000000L; break;\n                case 7:  scalar = 10000000L; break;\n                case 8:  scalar = 100000000L; break;\n                case 9:  scalar = 1000000000L; break;\n                case 10: scalar = 10000000000L; break;\n                case 11: scalar = 100000000000L; break;\n                case 12: scalar = 1000000000000L; break;\n                case 13: scalar = 10000000000000L; break;\n                case 14: scalar = 100000000000000L; break;\n                case 15: scalar = 1000000000000000L; break;\n                case 16: scalar = 10000000000000000L; break;\n                case 17: scalar = 100000000000000000L; break;\n                case 18: scalar = 1000000000000000000L; break;\n                }\n                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                    break;\n                }\n                // Overflowed: scale down.\n                maxDigits--;\n            }\n            \n            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n        }\n\n        public int estimateParsedLength() {\n            return iMaxDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeField field = iFieldType.getField(bucket.getChronology());\n            \n            int limit = Math.min(iMaxDigits, text.length() - position);\n\n            long value = 0;\n            long n = field.getDurationField().getUnitMillis() * 10;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n                long nn = n / 10;\n                value += (c - '0') * nn;\n                n = nn;\n            }\n\n            value /= 10;\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            if (value > Integer.MAX_VALUE) {\n                return ~position;\n            }\n\n            DateTimeField parseField = new PreciseDateTimeField(\n                DateTimeFieldType.millisOfSecond(),\n                MillisDurationField.INSTANCE,\n                field.getDurationField());\n\n            bucket.saveField(parseField, (int) value);\n\n            return position + length;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TimeZoneOffset\n            implements DateTimePrinter, DateTimeParser {\n\n        private final String iZeroOffsetPrintText;\n        private final String iZeroOffsetParseText;\n        private final boolean iShowSeparators;\n        private final int iMinFields;\n        private final int iMaxFields;\n\n        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n                                boolean showSeparators,\n                                int minFields, int maxFields)\n        {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }\n            \n        public int estimatePrintedLength() {\n            int est = 1 + iMinFields << 1;\n            if (iShowSeparators) {\n                est += iMinFields - 1;\n            }\n            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n                est = iZeroOffsetPrintText.length();\n            }\n            return est;\n        }\n        \n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                buf.append(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                buf.append('+');\n            } else {\n                buf.append('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.appendPaddedInteger(buf, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields <= 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields <= 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields <= 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                buf.append('.');\n            }\n            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n        }\n        \n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                out.write(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                out.write('+');\n            } else {\n                out.write('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.writePaddedInteger(out, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields == 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields == 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields == 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                out.write('.');\n            }\n            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }\n\n        /**\n         * Returns actual amount of digits to parse, but no more than original\n         * 'amount' parameter.\n         */\n        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TimeZoneName\n            implements DateTimePrinter, DateTimeParser {\n\n        static final int LONG_NAME = 0;\n        static final int SHORT_NAME = 1;\n\n        private final Map<String, DateTimeZone> iParseLookup;\n        private final int iType;\n\n        TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n            super();\n            iType = type;\n            iParseLookup = parseLookup;\n        }\n\n        public int estimatePrintedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(print(instant - displayOffset, displayZone, locale));\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(print(instant - displayOffset, displayZone, locale));\n        }\n\n        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return \"\";  // no zone\n            }\n            switch (iType) {\n                case LONG_NAME:\n                    return displayZone.getName(instant, locale);\n                case SHORT_NAME:\n                    return displayZone.getShortName(instant, locale);\n            }\n            return \"\";\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String name : iParseLookup.keySet()) {\n                if (str.startsWith(name)) {\n                    bucket.setZone(iParseLookup.get(name));\n                    return position + name.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static enum TimeZoneId\n            implements DateTimePrinter, DateTimeParser {\n\n        INSTANCE;\n        static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();\n        static final int MAX_LENGTH;\n        static {\n            int max = 0;\n            for (String id : ALL_IDS) {\n                max = Math.max(max, id.length());\n            }\n            MAX_LENGTH = max;\n        }\n\n        public int estimatePrintedLength() {\n            return MAX_LENGTH;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return MAX_LENGTH;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class Composite\n            implements DateTimePrinter, DateTimeParser {\n\n        private final DateTimePrinter[] iPrinters;\n        private final DateTimeParser[] iParsers;\n\n        private final int iPrintedLengthEstimate;\n        private final int iParsedLengthEstimate;\n\n        Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }\n\n        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(buf, partial, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(out, partial, locale);\n            }\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }\n\n        boolean isPrinter() {\n            return iPrinters != null;\n        }\n\n        boolean isParser() {\n            return iParsers != null;\n        }\n\n        /**\n         * Processes the element pairs, putting results into the given printer\n         * and parser lists.\n         */\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class MatchingParser\n            implements DateTimeParser {\n\n        private final DateTimeParser[] iParsers;\n        private final int iParsedLengthEstimate;\n\n        MatchingParser(DateTimeParser[] parsers) {\n            super();\n            iParsers = parsers;\n            int est = 0;\n            for (int i=parsers.length; --i>=0 ;) {\n                DateTimeParser parser = parsers[i];\n                if (parser != null) {\n                    int len = parser.estimateParsedLength();\n                    if (len > est) {\n                        est = len;\n                    }\n                }\n            }\n            iParsedLengthEstimate = est;\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] parsers = iParsers;\n            int length = parsers.length;\n\n            final Object originalState = bucket.saveState();\n            boolean isOptional = false;\n\n            int bestValidPos = position;\n            Object bestValidState = null;\n\n            int bestInvalidPos = position;\n\n            for (int i=0; i<length; i++) {\n                DateTimeParser parser = parsers[i];\n                if (parser == null) {\n                    // The empty parser wins only if nothing is better.\n                    if (bestValidPos <= position) {\n                        return position;\n                    }\n                    isOptional = true;\n                    break;\n                }\n                int parsePos = parser.parseInto(bucket, text, position);\n                if (parsePos >= position) {\n                    if (parsePos > bestValidPos) {\n                        if (parsePos >= text.length() ||\n                            (i + 1) >= length || parsers[i + 1] == null) {\n\n                            // Completely parsed text or no more parsers to\n                            // check. Skip the rest.\n                            return parsePos;\n                        }\n                        bestValidPos = parsePos;\n                        bestValidState = bucket.saveState();\n                    }\n                } else {\n                    if (parsePos < 0) {\n                        parsePos = ~parsePos;\n                        if (parsePos > bestInvalidPos) {\n                            bestInvalidPos = parsePos;\n                        }\n                    }\n                }\n                bucket.restoreState(originalState);\n            }\n\n            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n                // Restore the state to the best valid parse.\n                if (bestValidState != null) {\n                    bucket.restoreState(bestValidState);\n                }\n                return bestValidPos;\n            }\n\n            return ~bestInvalidPos;\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.MutableDateTime.Property;\nimport org.joda.time.field.MillisDurationField;\nimport org.joda.time.field.PreciseDateTimeField;\n\n/**\n * Factory that creates complex instances of DateTimeFormatter via method calls.\n * <p>\n * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link DateTimeFormat} and {@link ISODateTimeFormat}.\n * <p>\n * DateTimeFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints month and year, like \"January 1970\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n *     .appendMonthOfYearText()\n *     .appendLiteral(' ')\n *     .appendYear(4, 4)\n *     .toFormatter();\n * </pre>\n * <p>\n * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n * @see DateTimeFormat\n * @see ISODateTimeFormat\n */\npublic class DateTimeFormatterBuilder {\n\n    /** Array of printers and parsers (alternating). */\n    private ArrayList<Object> iElementPairs;\n    /** Cache of the last returned formatter. */\n    private Object iFormatter;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a DateTimeFormatterBuilder.\n     */\n    public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a DateTimeFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link DateTimeFormatter#isPrinter()} and\n     * {@link DateTimeFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     *\n     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n     */\n    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }\n\n    /**\n     * Internal method to create a DateTimePrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     *\n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"Printing is not supported\");\n    }\n\n    /**\n     * Internal method to create a DateTimeParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a parser in an application, call {@link #toFormatter()}\n     * and just use the parsing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     *\n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"Parsing is not supported\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if toFormatter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a formatter can be built\n     */\n    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }\n\n    /**\n     * Returns true if toPrinter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a printer can be built\n     */\n    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }\n\n    /**\n     * Returns true if toParser can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a parser can be built\n     */\n    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be\n     * reused.\n     */\n    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends another formatter.\n     *\n     * @param formatter  the formatter to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if formatter is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }\n\n    /**\n     * Appends just a printer. With no matching parser, a parser cannot be\n     * built from this DateTimeFormatterBuilder.\n     *\n     * @param printer  the printer to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n        checkPrinter(printer);\n        return append0(printer, null);\n    }\n\n    /**\n     * Appends just a parser. With no matching printer, a printer cannot be\n     * built from this builder.\n     *\n     * @param parser  the parser to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n        checkParser(parser);\n        return append0(null, parser);\n    }\n\n    /**\n     * Appends a printer/parser pair.\n     *\n     * @param printer  the printer to add\n     * @param parser  the parser to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n        checkPrinter(printer);\n        checkParser(parser);\n        return append0(printer, parser);\n    }\n\n    /**\n     * Appends a printer and a set of matching parsers. When parsing, the first\n     * parser in the list is selected for parsing. If it fails, the next is\n     * chosen, and so on. If none of these parsers succeeds, then the failed\n     * position of the parser that made the greatest progress is returned.\n     * <p>\n     * Only the printer is optional. In addition, it is illegal for any but the\n     * last of the parser array elements to be null. If the last element is\n     * null, this represents the empty parser. The presence of an empty parser\n     * indicates that the entire array of parse formats is optional.\n     *\n     * @param printer  the printer to add\n     * @param parsers  the parsers to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n     * @throws IllegalArgumentException if any parser element but the last is null\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"No parsers supplied\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"No parser supplied\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"Incomplete parser array\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }\n\n    /**\n     * Appends just a parser element which is optional. With no matching\n     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the parser is non null and a provider.\n     * \n     * @param parser  the parser to check\n     */\n    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n    }\n\n    /**\n     * Checks if the printer is non null and a provider.\n     * \n     * @param printer  the printer to check\n     */\n    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"No printer supplied\");\n        }\n    }\n\n    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        // Add the element as both a printer and parser.\n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }\n\n    private DateTimeFormatterBuilder append0(\n            DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instructs the printer to emit a specific character, and the parser to\n     * expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect\n     * it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if text is null\n     */\n    public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect an unsigned decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an unsigned decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */\n    public DateTimeFormatterBuilder appendFixedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect a signed decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an signed decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */\n    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, false));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as short text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }\n\n    /**\n     * Instructs the printer to emit a remainder of time as a decimal fraction,\n     * without decimal point. For example, if the field is specified as\n     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n     * a minute.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to print.\n     * @param maxDigits  maximum number of digits to print or parse.\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendFraction(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }\n\n    /**\n     * Appends the print/parse of a fractional second.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 230 milliseconds.\n     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional minute.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional hour.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional day.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric millisOfSecond field.\n     * <p>\n     * This method will append a field that prints a three digit value.\n     * During parsing the value that is parsed is assumed to be three digits.\n     * If less than three digits are present then they will be counted as the\n     * smallest parts of the millisecond. This is probably not what you want\n     * if you are using the field as a fraction. Instead, a fractional\n     * millisecond should be produced using {@link #appendFractionOfSecond}.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric millisOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric secondOfMinute field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric secondOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric minuteOfHour field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric minuteOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric hourOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric clockhourOfDay field.\n     *\n     * @param minDigits minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric hourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfWeek field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfMonth field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekOfWeekyear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric monthOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot year to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute year. With lenient parsing, specifying a positive\n     * or negative sign before the year also makes it absolute.\n     *\n     * @param pivot  pivot year to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute year\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n     * or negative sign before the weekyear also makes it absolute.\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute weekyear\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }\n\n    /**\n     * Instructs the printer to emit a numeric yearOfEra field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year of century field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric century of era field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific AM/PM text, and the\n     * parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n     * parser will accept a long or short dayOfWeek text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific dayOfWeek\n     * text. The parser will accept a long or short dayOfWeek text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific monthOfYear\n     * text. The parser will accept a long or short monthOfYear text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific monthOfYear text. The\n     * parser will accept a long or short monthOfYear text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n     * the parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneShortName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific time zone\n     * name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    /**\n     * Instructs the printer to emit the identifier of the time zone.\n     * From version 2.0, this field can be parsed.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }\n\n    /**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset text is supplied, then it will be printed when the zone is zero.\n     * During parsing, either the zero offset text, or the offset will be parsed.\n     *\n     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }\n\n    /**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset print text is supplied, then it will be printed when the zone is zero.\n     * If zero offset parse text is supplied, then either it or the offset will be parsed.\n     *\n     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n     * zone offset is zero. If null, then always use the offset.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 2.0\n     */\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n     * results into this builder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormat\n     */\n    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }\n\n    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isFormatter(Object f) {\n        return (isPrinter(f) || isParser(f));\n    }\n\n    static void appendUnknownString(StringBuffer buf, int len) {\n        for (int i = len; --i >= 0;) {\n            buf.append('\\ufffd');\n        }\n    }\n\n    static void printUnknownString(Writer out, int len) throws IOException {\n        for (int i = len; --i >= 0;) {\n            out.write('\\ufffd');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class CharacterLiteral\n            implements DateTimePrinter, DateTimeParser {\n\n        private final char iValue;\n\n        CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return 1;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return 1;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class StringLiteral\n            implements DateTimePrinter, DateTimeParser {\n\n        private final String iValue;\n\n        StringLiteral(String value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return iValue.length();\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return iValue.length();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                return position + iValue.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static abstract class NumberFormatter\n            implements DateTimePrinter, DateTimeParser {\n        protected final DateTimeFieldType iFieldType;\n        protected final int iMaxParsedDigits;\n        protected final boolean iSigned;\n\n        NumberFormatter(DateTimeFieldType fieldType,\n                int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }\n\n        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                // Since value may exceed integer limits, use stock parser\n                // which checks for this.\n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class UnpaddedNumber extends NumberFormatter {\n\n        protected UnpaddedNumber(DateTimeFieldType fieldType,\n                       int maxParsedDigits, boolean signed)\n        {\n            super(fieldType, maxParsedDigits, signed);\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    buf.append('\\ufffd');\n                }\n            } else {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    out.write('\\ufffd');\n                }\n            } else {\n                out.write('\\ufffd');\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class PaddedNumber extends NumberFormatter {\n\n        protected final int iMinPrintedDigits;\n\n        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n                     boolean signed, int minPrintedDigits)\n        {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    appendUnknownString(buf, iMinPrintedDigits);\n                }\n            } else {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    printUnknownString(out, iMinPrintedDigits);\n                }\n            } else {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class FixedNumber extends PaddedNumber {\n\n        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n            super(fieldType, numDigits, signed, numDigits);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int newPos = super.parseInto(bucket, text, position);\n            if (newPos < 0) {\n                return newPos;\n            }\n            int expectedPos = position + iMaxParsedDigits;\n            if (newPos != expectedPos) {\n                if (iSigned) {\n                    char c = text.charAt(position);\n                    if (c == '-' || c == '+') {\n                        expectedPos++;\n                    }\n                }\n                if (newPos > expectedPos) {\n                    // The failure is at the position of the first extra digit.\n                    return ~(expectedPos + 1);\n                } else if (newPos < expectedPos) {\n                    // The failure is at the position where the next digit should be.\n                    return ~newPos;\n                }\n            }\n            return newPos;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TwoDigitYear\n            implements DateTimePrinter, DateTimeParser {\n\n        /** The field to print/parse. */\n        private final DateTimeFieldType iType;\n        /** The pivot year. */\n        private final int iPivot;\n        private final boolean iLenientParse;\n\n        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n            super();\n            iType = type;\n            iPivot = pivot;\n            iLenientParse = lenientParse;\n        }\n\n        public int estimateParsedLength() {\n            return iLenientParse ? 4 : 2;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }\n        \n        public int estimatePrintedLength() {\n            return 2;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(long instant, Chronology chrono) {\n            try {\n                int year = iType.getField(chrono).get(instant);\n                if (year < 0) {\n                    year = -year;\n                }\n                return year % 100;\n            } catch (RuntimeException e) {\n                return -1;\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(ReadablePartial partial) {\n            if (partial.isSupported(iType)) {\n                try {\n                    int year = partial.get(iType);\n                    if (year < 0) {\n                        year = -year;\n                    }\n                    return year % 100;\n                } catch (RuntimeException e) {}\n            } \n            return -1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TextField\n            implements DateTimePrinter, DateTimeParser {\n\n        private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =\n                    new HashMap<Locale, Map<DateTimeFieldType, Object[]>>();\n        private final DateTimeFieldType iFieldType;\n        private final boolean iShort;\n\n        TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }\n\n        public int estimatePrintedLength() {\n            return iShort ? 6 : 20;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                buf.append(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                out.write(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            try {\n                buf.append(print(partial, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            try {\n                out.write(print(partial, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        private String print(long instant, Chronology chrono, Locale locale) {\n            DateTimeField field = iFieldType.getField(chrono);\n            if (iShort) {\n                return field.getAsShortText(instant, locale);\n            } else {\n                return field.getAsText(instant, locale);\n            }\n        }\n\n        private String print(ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                DateTimeField field = iFieldType.getField(partial.getChronology());\n                if (iShort) {\n                    return field.getAsShortText(partial, locale);\n                } else {\n                    return field.getAsText(partial, locale);\n                }\n            } else {\n                return \"\\ufffd\";\n            }\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            Locale locale = bucket.getLocale();\n            // handle languages which might have non ASCII A-Z or punctuation\n            // bug 1788282\n            Set<String> validValues = null;\n            int maxLength = 0;\n            synchronized (cParseCache) {\n                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n                if (innerMap == null) {\n                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n                    cParseCache.put(locale, innerMap);\n                }\n                Object[] array = innerMap.get(iFieldType);\n                if (array == null) {\n                    validValues = new HashSet<String>(32);\n                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n                    Property property = dt.property(iFieldType);\n                    int min = property.getMinimumValueOverall();\n                    int max = property.getMaximumValueOverall();\n                    if (max - min > 32) {  // protect against invalid fields\n                        return ~position;\n                    }\n                    maxLength = property.getMaximumTextLength(locale);\n                    for (int i = min; i <= max; i++) {\n                        property.set(i);\n                        validValues.add(property.getAsShortText(locale));\n                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n                        validValues.add(property.getAsText(locale));\n                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n                    }\n                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n                        // hack to support for parsing \"BCE\" and \"CE\" if the language is English\n                        validValues.add(\"BCE\");\n                        validValues.add(\"bce\");\n                        validValues.add(\"CE\");\n                        validValues.add(\"ce\");\n                        maxLength = 3;\n                    }\n                    array = new Object[] {validValues, Integer.valueOf(maxLength)};\n                    innerMap.put(iFieldType, array);\n                } else {\n                    validValues = (Set<String>) array[0];\n                    maxLength = ((Integer) array[1]).intValue();\n                }\n            }\n            // match the longest string first using our knowledge of the max length\n            int limit = Math.min(text.length(), position + maxLength);\n            for (int i = limit; i > position; i--) {\n                String match = text.substring(position, i);\n                if (validValues.contains(match)) {\n                    bucket.saveField(iFieldType, match, locale);\n                    return i;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class Fraction\n            implements DateTimePrinter, DateTimeParser {\n\n        private final DateTimeFieldType iFieldType;\n        protected int iMinDigits;\n        protected int iMaxDigits;\n\n        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            // Limit the precision requirements.\n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                printTo(buf, null, instant, chrono);\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            printTo(null, out, instant, chrono);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // removed check whether field is supported, as input field is typically\n            // secondOfDay which is unsupported by TimeOfDay\n            long millis = partial.getChronology().set(partial, 0L);\n            try {\n                printTo(buf, null, millis, partial.getChronology());\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // removed check whether field is supported, as input field is typically\n            // secondOfDay which is unsupported by TimeOfDay\n            long millis = partial.getChronology().set(partial, 0L);\n            printTo(null, out, millis, partial.getChronology());\n        }\n\n        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\n            throws IOException\n        {\n            DateTimeField field = iFieldType.getField(chrono);\n            int minDigits = iMinDigits;\n\n            long fraction;\n            try {\n                fraction = field.remainder(instant);\n            } catch (RuntimeException e) {\n                if (buf != null) {\n                    appendUnknownString(buf, minDigits);\n                } else {\n                    printUnknownString(out, minDigits);\n                }\n                return;\n            }\n\n            if (fraction == 0) {\n                if (buf != null) {\n                    while (--minDigits >= 0) {\n                        buf.append('0');\n                    }\n                } else {\n                    while (--minDigits >= 0) {\n                        out.write('0');\n                    }\n                }\n                return;\n            }\n\n            String str;\n            long[] fractionData = getFractionData(fraction, field);\n            long scaled = fractionData[0];\n            int maxDigits = (int) fractionData[1];\n            \n            if ((scaled & 0x7fffffff) == scaled) {\n                str = Integer.toString((int) scaled);\n            } else {\n                str = Long.toString(scaled);\n            }\n\n            int length = str.length();\n            int digits = maxDigits;\n            while (length < digits) {\n                if (buf != null) {\n                    buf.append('0');\n                } else {\n                    out.write('0');\n                }\n                minDigits--;\n                digits--;\n            }\n\n            if (minDigits < digits) {\n                // Chop off as many trailing zero digits as necessary.\n                while (minDigits < digits) {\n                    if (length <= 1 || str.charAt(length - 1) != '0') {\n                        break;\n                    }\n                    digits--;\n                    length--;\n                }\n                if (length < str.length()) {\n                    if (buf != null) {\n                        for (int i=0; i<length; i++) {\n                            buf.append(str.charAt(i));\n                        }\n                    } else {\n                        for (int i=0; i<length; i++) {\n                            out.write(str.charAt(i));\n                        }\n                    }\n                    return;\n                }\n            }\n\n            if (buf != null) {\n                buf.append(str);\n            } else {\n                out.write(str);\n            }\n        }\n        \n        private long[] getFractionData(long fraction, DateTimeField field) {\n            long rangeMillis = field.getDurationField().getUnitMillis();\n            long scalar;\n            int maxDigits = iMaxDigits;\n            while (true) {\n                switch (maxDigits) {\n                default: scalar = 1L; break;\n                case 1:  scalar = 10L; break;\n                case 2:  scalar = 100L; break;\n                case 3:  scalar = 1000L; break;\n                case 4:  scalar = 10000L; break;\n                case 5:  scalar = 100000L; break;\n                case 6:  scalar = 1000000L; break;\n                case 7:  scalar = 10000000L; break;\n                case 8:  scalar = 100000000L; break;\n                case 9:  scalar = 1000000000L; break;\n                case 10: scalar = 10000000000L; break;\n                case 11: scalar = 100000000000L; break;\n                case 12: scalar = 1000000000000L; break;\n                case 13: scalar = 10000000000000L; break;\n                case 14: scalar = 100000000000000L; break;\n                case 15: scalar = 1000000000000000L; break;\n                case 16: scalar = 10000000000000000L; break;\n                case 17: scalar = 100000000000000000L; break;\n                case 18: scalar = 1000000000000000000L; break;\n                }\n                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                    break;\n                }\n                // Overflowed: scale down.\n                maxDigits--;\n            }\n            \n            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n        }\n\n        public int estimateParsedLength() {\n            return iMaxDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeField field = iFieldType.getField(bucket.getChronology());\n            \n            int limit = Math.min(iMaxDigits, text.length() - position);\n\n            long value = 0;\n            long n = field.getDurationField().getUnitMillis() * 10;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n                long nn = n / 10;\n                value += (c - '0') * nn;\n                n = nn;\n            }\n\n            value /= 10;\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            if (value > Integer.MAX_VALUE) {\n                return ~position;\n            }\n\n            DateTimeField parseField = new PreciseDateTimeField(\n                DateTimeFieldType.millisOfSecond(),\n                MillisDurationField.INSTANCE,\n                field.getDurationField());\n\n            bucket.saveField(parseField, (int) value);\n\n            return position + length;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TimeZoneOffset\n            implements DateTimePrinter, DateTimeParser {\n\n        private final String iZeroOffsetPrintText;\n        private final String iZeroOffsetParseText;\n        private final boolean iShowSeparators;\n        private final int iMinFields;\n        private final int iMaxFields;\n\n        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n                                boolean showSeparators,\n                                int minFields, int maxFields)\n        {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }\n            \n        public int estimatePrintedLength() {\n            int est = 1 + iMinFields << 1;\n            if (iShowSeparators) {\n                est += iMinFields - 1;\n            }\n            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n                est = iZeroOffsetPrintText.length();\n            }\n            return est;\n        }\n        \n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                buf.append(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                buf.append('+');\n            } else {\n                buf.append('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.appendPaddedInteger(buf, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields <= 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields <= 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields <= 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                buf.append('.');\n            }\n            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n        }\n        \n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                out.write(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                out.write('+');\n            } else {\n                out.write('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.writePaddedInteger(out, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields == 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields == 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields == 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                out.write('.');\n            }\n            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }\n\n        /**\n         * Returns actual amount of digits to parse, but no more than original\n         * 'amount' parameter.\n         */\n        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TimeZoneName\n            implements DateTimePrinter, DateTimeParser {\n\n        static final int LONG_NAME = 0;\n        static final int SHORT_NAME = 1;\n\n        private final Map<String, DateTimeZone> iParseLookup;\n        private final int iType;\n\n        TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n            super();\n            iType = type;\n            iParseLookup = parseLookup;\n        }\n\n        public int estimatePrintedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(print(instant - displayOffset, displayZone, locale));\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(print(instant - displayOffset, displayZone, locale));\n        }\n\n        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return \"\";  // no zone\n            }\n            switch (iType) {\n                case LONG_NAME:\n                    return displayZone.getName(instant, locale);\n                case SHORT_NAME:\n                    return displayZone.getShortName(instant, locale);\n            }\n            return \"\";\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String name : iParseLookup.keySet()) {\n                if (str.startsWith(name)) {\n                    bucket.setZone(iParseLookup.get(name));\n                    return position + name.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static enum TimeZoneId\n            implements DateTimePrinter, DateTimeParser {\n\n        INSTANCE;\n        static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();\n        static final int MAX_LENGTH;\n        static {\n            int max = 0;\n            for (String id : ALL_IDS) {\n                max = Math.max(max, id.length());\n            }\n            MAX_LENGTH = max;\n        }\n\n        public int estimatePrintedLength() {\n            return MAX_LENGTH;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return MAX_LENGTH;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            String best = null;\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                }\n            }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class Composite\n            implements DateTimePrinter, DateTimeParser {\n\n        private final DateTimePrinter[] iPrinters;\n        private final DateTimeParser[] iParsers;\n\n        private final int iPrintedLengthEstimate;\n        private final int iParsedLengthEstimate;\n\n        Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }\n\n        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(buf, partial, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(out, partial, locale);\n            }\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }\n\n        boolean isPrinter() {\n            return iPrinters != null;\n        }\n\n        boolean isParser() {\n            return iParsers != null;\n        }\n\n        /**\n         * Processes the element pairs, putting results into the given printer\n         * and parser lists.\n         */\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class MatchingParser\n            implements DateTimeParser {\n\n        private final DateTimeParser[] iParsers;\n        private final int iParsedLengthEstimate;\n\n        MatchingParser(DateTimeParser[] parsers) {\n            super();\n            iParsers = parsers;\n            int est = 0;\n            for (int i=parsers.length; --i>=0 ;) {\n                DateTimeParser parser = parsers[i];\n                if (parser != null) {\n                    int len = parser.estimateParsedLength();\n                    if (len > est) {\n                        est = len;\n                    }\n                }\n            }\n            iParsedLengthEstimate = est;\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] parsers = iParsers;\n            int length = parsers.length;\n\n            final Object originalState = bucket.saveState();\n            boolean isOptional = false;\n\n            int bestValidPos = position;\n            Object bestValidState = null;\n\n            int bestInvalidPos = position;\n\n            for (int i=0; i<length; i++) {\n                DateTimeParser parser = parsers[i];\n                if (parser == null) {\n                    // The empty parser wins only if nothing is better.\n                    if (bestValidPos <= position) {\n                        return position;\n                    }\n                    isOptional = true;\n                    break;\n                }\n                int parsePos = parser.parseInto(bucket, text, position);\n                if (parsePos >= position) {\n                    if (parsePos > bestValidPos) {\n                        if (parsePos >= text.length() ||\n                            (i + 1) >= length || parsers[i + 1] == null) {\n\n                            // Completely parsed text or no more parsers to\n                            // check. Skip the rest.\n                            return parsePos;\n                        }\n                        bestValidPos = parsePos;\n                        bestValidState = bucket.saveState();\n                    }\n                } else {\n                    if (parsePos < 0) {\n                        parsePos = ~parsePos;\n                        if (parsePos > bestInvalidPos) {\n                            bestInvalidPos = parsePos;\n                        }\n                    }\n                }\n                bucket.restoreState(originalState);\n            }\n\n            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n                // Restore the state to the best valid parse.\n                if (bestValidState != null) {\n                    bucket.restoreState(bestValidState);\n                }\n                return bestValidPos;\n            }\n\n            return ~bestInvalidPos;\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 22, "classes_modified": [{"class_name": "org.joda.time.base.BasePeriod", "buggy_version": "/*\n *  Copyright 2001-2007 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.Duration;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadableDuration;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PeriodConverter;\nimport org.joda.time.field.FieldUtils;\n\n/**\n * BasePeriod is an abstract implementation of ReadablePeriod that stores\n * data in a <code>PeriodType</code> and an <code>int[]</code>.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BasePeriod subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class BasePeriod\n        extends AbstractPeriod\n        implements ReadablePeriod, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2110953284060001145L;\n\n    /** The type of period */\n    private PeriodType iType;\n    /** The values */\n    private int[] iValues;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a period from a set of field values.\n     *\n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @param type  which set of fields this period supports\n     * @throws IllegalArgumentException if period type is invalid\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected BasePeriod(int years, int months, int weeks, int days,\n                         int hours, int minutes, int seconds, int millis,\n                         PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, startInstant, endInstant);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        if (startInstant == null && endInstant == null) {\n            iType = type;\n            iValues = new int[size()];\n        } else {\n            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        }\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     * <p>\n     * The two partials must contain the same fields, thus you can\n     * specify two <code>LocalDate</code> objects, or two <code>LocalTime</code>\n     * objects, but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a\n     * definition. Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super();\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            // for performance\n            type = checkPeriodType(type);\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (DateTimeUtils.isContiguous(start) == false) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            iType = checkPeriodType(type);\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n        }\n    }\n\n    /**\n     * Creates a period from the given start point and duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */\n    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        this(duration, null, null);\n        // bug [3264409]\n    }\n\n    /**\n     * Creates a period from the given millisecond duration, which is only really\n     * suitable for durations less than one day.\n     * <p>\n     * Only fields that are precise will be used.\n     * Thus the largest precise field may have a large value.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }\n\n    /**\n     * Creates a new period based on another using the {@link ConverterManager}.\n     *\n     * @param period  the period to convert\n     * @param type  which set of fields this period supports, null means use type from object\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period is invalid\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n        super();\n        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n        type = (type == null ? converter.getPeriodType(period) : type);\n        type = checkPeriodType(type);\n        iType = type;\n        if (this instanceof ReadWritablePeriod) {\n            iValues = new int[size()];\n            chrono = DateTimeUtils.getChronology(chrono);\n            converter.setInto((ReadWritablePeriod) this, period, chrono);\n        } else {\n            iValues = new MutablePeriod(period, type, chrono).getValues();\n        }\n    }\n\n    /**\n     * Constructor used when we trust ourselves.\n     * Do not expose publically.\n     *\n     * @param values  the values to use, not null, not cloned\n     * @param type  which set of fields this period supports, not null\n     */\n    protected BasePeriod(int[] values, PeriodType type) {\n        super();\n        iType = type;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Validates a period type, converting nulls to a default value and\n     * checking the type is suitable for this instance.\n     * \n     * @param type  the type to check, may be null\n     * @return the validated type to use, not null\n     * @throws IllegalArgumentException if the period type is invalid\n     */\n    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the period type.\n     *\n     * @return the period type\n     */\n    public PeriodType getPeriodType() {\n        return iType;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields that this period supports.\n     *\n     * @return the number of fields supported\n     */\n    public int size() {\n        return iType.size();\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the total millisecond duration of this period relative to a start instant.\n     * <p>\n     * This method adds the period to the specified instant in order to\n     * calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param startInstant  the instant to add the period to, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the start instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */\n    public Duration toDurationFrom(ReadableInstant startInstant) {\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        long endMillis = chrono.add(this, startMillis, 1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    /**\n     * Gets the total millisecond duration of this period relative to an\n     * end instant.\n     * <p>\n     * This method subtracts the period from the specified instant in order\n     * to calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param endInstant  the instant to subtract the period from, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the end instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */\n    public Duration toDurationTo(ReadableInstant endInstant) {\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        long startMillis = chrono.add(this, endMillis, -1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether a field type is supported, and if so adds the new value\n     * to the relevent index in the specified array.\n     * \n     * @param type  the field type\n     * @param values  the array to update\n     * @param newValue  the new value to store if successful\n     */\n    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets all the fields of this period from another.\n     * \n     * @param period  the period to copy from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void setPeriod(ReadablePeriod period) {\n        if (period == null) {\n            setValues(new int[size()]);\n        } else {\n            setPeriodInternal(period);\n        }\n    }\n\n    /**\n     * Private method called from constructor.\n     */\n    private void setPeriodInternal(ReadablePeriod period) {\n        int[] newValues = new int[size()];\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, newValues, value);\n        }\n        iValues = newValues;\n    }\n\n    /**\n     * Sets the eight standard the fields in one go.\n     * \n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void setPeriod(int years, int months, int weeks, int days,\n                             int hours, int minutes, int seconds, int millis) {\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n    }\n\n    /**\n     * Private method called from constructor.\n     */\n    private void setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        iValues = newValues;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }\n\n    /**\n     * Sets the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is null or not supported.\n     */\n    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }\n\n    /**\n     * Adds the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void addField(DurationFieldType field, int value) {\n        addFieldInto(iValues, field, value);\n    }\n\n    /**\n     * Adds the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = FieldUtils.safeAdd(values[index], value);\n        }\n    }\n\n    /**\n     * Merges the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void mergePeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = mergePeriodInto(getValues(), period);\n        }\n    }\n\n    /**\n     * Merges the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             checkAndUpdate(type, values, value);\n         }\n         return values;\n    }\n\n    /**\n     * Adds the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void addPeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = addPeriodInto(getValues(), period);\n        }\n    }\n\n    /**\n     * Adds the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             if (value != 0) {\n                 int index = indexOf(type);\n                 if (index == -1) {\n                     throw new IllegalArgumentException(\n                         \"Period does not support field '\" + type.getName() + \"'\");\n                 } else {\n                     values[index] = FieldUtils.safeAdd(getValue(index), value);\n                 }\n             }\n         }\n         return values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @param value  the value to set\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void setValue(int index, int value) {\n        iValues[index] = value;\n    }\n\n    /**\n     * Sets the values of all fields.\n     * \n     * @param values  the array of values\n     */\n    protected void setValues(int[] values) {\n        iValues = values;\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2007 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.Duration;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadableDuration;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PeriodConverter;\nimport org.joda.time.field.FieldUtils;\n\n/**\n * BasePeriod is an abstract implementation of ReadablePeriod that stores\n * data in a <code>PeriodType</code> and an <code>int[]</code>.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BasePeriod subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class BasePeriod\n        extends AbstractPeriod\n        implements ReadablePeriod, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2110953284060001145L;\n\n    /** The type of period */\n    private PeriodType iType;\n    /** The values */\n    private int[] iValues;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a period from a set of field values.\n     *\n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @param type  which set of fields this period supports\n     * @throws IllegalArgumentException if period type is invalid\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected BasePeriod(int years, int months, int weeks, int days,\n                         int hours, int minutes, int seconds, int millis,\n                         PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, startInstant, endInstant);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        if (startInstant == null && endInstant == null) {\n            iType = type;\n            iValues = new int[size()];\n        } else {\n            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        }\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     * <p>\n     * The two partials must contain the same fields, thus you can\n     * specify two <code>LocalDate</code> objects, or two <code>LocalTime</code>\n     * objects, but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a\n     * definition. Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super();\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            // for performance\n            type = checkPeriodType(type);\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (DateTimeUtils.isContiguous(start) == false) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            iType = checkPeriodType(type);\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n        }\n    }\n\n    /**\n     * Creates a period from the given start point and duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */\n    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        super();\n        // bug [3264409]\n        iType = PeriodType.time();\n        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n        iType = PeriodType.standard();\n        iValues = new int[8];\n        System.arraycopy(values, 0, iValues, 4, 4);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration, which is only really\n     * suitable for durations less than one day.\n     * <p>\n     * Only fields that are precise will be used.\n     * Thus the largest precise field may have a large value.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }\n\n    /**\n     * Creates a new period based on another using the {@link ConverterManager}.\n     *\n     * @param period  the period to convert\n     * @param type  which set of fields this period supports, null means use type from object\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period is invalid\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n        super();\n        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n        type = (type == null ? converter.getPeriodType(period) : type);\n        type = checkPeriodType(type);\n        iType = type;\n        if (this instanceof ReadWritablePeriod) {\n            iValues = new int[size()];\n            chrono = DateTimeUtils.getChronology(chrono);\n            converter.setInto((ReadWritablePeriod) this, period, chrono);\n        } else {\n            iValues = new MutablePeriod(period, type, chrono).getValues();\n        }\n    }\n\n    /**\n     * Constructor used when we trust ourselves.\n     * Do not expose publically.\n     *\n     * @param values  the values to use, not null, not cloned\n     * @param type  which set of fields this period supports, not null\n     */\n    protected BasePeriod(int[] values, PeriodType type) {\n        super();\n        iType = type;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Validates a period type, converting nulls to a default value and\n     * checking the type is suitable for this instance.\n     * \n     * @param type  the type to check, may be null\n     * @return the validated type to use, not null\n     * @throws IllegalArgumentException if the period type is invalid\n     */\n    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the period type.\n     *\n     * @return the period type\n     */\n    public PeriodType getPeriodType() {\n        return iType;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields that this period supports.\n     *\n     * @return the number of fields supported\n     */\n    public int size() {\n        return iType.size();\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the total millisecond duration of this period relative to a start instant.\n     * <p>\n     * This method adds the period to the specified instant in order to\n     * calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param startInstant  the instant to add the period to, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the start instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */\n    public Duration toDurationFrom(ReadableInstant startInstant) {\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        long endMillis = chrono.add(this, startMillis, 1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    /**\n     * Gets the total millisecond duration of this period relative to an\n     * end instant.\n     * <p>\n     * This method subtracts the period from the specified instant in order\n     * to calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param endInstant  the instant to subtract the period from, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the end instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */\n    public Duration toDurationTo(ReadableInstant endInstant) {\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        long startMillis = chrono.add(this, endMillis, -1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether a field type is supported, and if so adds the new value\n     * to the relevent index in the specified array.\n     * \n     * @param type  the field type\n     * @param values  the array to update\n     * @param newValue  the new value to store if successful\n     */\n    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets all the fields of this period from another.\n     * \n     * @param period  the period to copy from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void setPeriod(ReadablePeriod period) {\n        if (period == null) {\n            setValues(new int[size()]);\n        } else {\n            setPeriodInternal(period);\n        }\n    }\n\n    /**\n     * Private method called from constructor.\n     */\n    private void setPeriodInternal(ReadablePeriod period) {\n        int[] newValues = new int[size()];\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, newValues, value);\n        }\n        iValues = newValues;\n    }\n\n    /**\n     * Sets the eight standard the fields in one go.\n     * \n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void setPeriod(int years, int months, int weeks, int days,\n                             int hours, int minutes, int seconds, int millis) {\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n    }\n\n    /**\n     * Private method called from constructor.\n     */\n    private void setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        iValues = newValues;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }\n\n    /**\n     * Sets the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is null or not supported.\n     */\n    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }\n\n    /**\n     * Adds the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void addField(DurationFieldType field, int value) {\n        addFieldInto(iValues, field, value);\n    }\n\n    /**\n     * Adds the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = FieldUtils.safeAdd(values[index], value);\n        }\n    }\n\n    /**\n     * Merges the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void mergePeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = mergePeriodInto(getValues(), period);\n        }\n    }\n\n    /**\n     * Merges the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             checkAndUpdate(type, values, value);\n         }\n         return values;\n    }\n\n    /**\n     * Adds the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void addPeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = addPeriodInto(getValues(), period);\n        }\n    }\n\n    /**\n     * Adds the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             if (value != 0) {\n                 int index = indexOf(type);\n                 if (index == -1) {\n                     throw new IllegalArgumentException(\n                         \"Period does not support field '\" + type.getName() + \"'\");\n                 } else {\n                     values[index] = FieldUtils.safeAdd(getValue(index), value);\n                 }\n             }\n         }\n         return values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @param value  the value to set\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void setValue(int index, int value) {\n        iValues[index] = value;\n    }\n\n    /**\n     * Sets the values of all fields.\n     * \n     * @param values  the array of values\n     */\n    protected void setValues(int[] values) {\n        iValues = values;\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 23, "classes_modified": [{"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (before == after) {\n            return instant;\n        }\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? after : before);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (before == after) {\n            return instant;\n        }\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? after : before);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n\n}\n"}]}
{"project": "Time", "bug_id": 24, "classes_modified": [{"class_name": "org.joda.time.format.DateTimeParserBucket", "buggy_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n/**\n * DateTimeParserBucket is an advanced class, intended mainly for parser\n * implementations. It can also be used during normal parsing operations to\n * capture more information about the parse.\n * <p>\n * This class allows fields to be saved in any order, but be physically set in\n * a consistent order. This is useful for parsing against formats that allow\n * field values to contradict each other.\n * <p>\n * Field values are applied in an order where the \"larger\" fields are set\n * first, making their value less likely to stick.  A field is larger than\n * another when it's range duration is longer. If both ranges are the same,\n * then the larger field has the longer duration. If it cannot be determined\n * which field is larger, then the fields are set in the order they were saved.\n * <p>\n * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n * <p>\n * DateTimeParserBucket is mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeParserBucket {\n\n    /** The chronology to use for parsing. */\n    private final Chronology iChrono;\n    private final long iMillis;\n    \n    // TimeZone to switch to in computeMillis. If null, use offset.\n    private DateTimeZone iZone;\n    private int iOffset;\n    /** The locale to use for parsing. */\n    private Locale iLocale;\n    /** Used for parsing two-digit years. */\n    private Integer iPivotYear;\n    /** Used for parsing month/day without year. */\n    private int iDefaultYear;\n\n    private SavedField[] iSavedFields = new SavedField[8];\n    private int iSavedFieldsCount;\n    private boolean iSavedFieldsShared;\n    \n    private Object iSavedState;\n\n    /**\n     * Constructs a bucket.\n     * \n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @deprecated Use longer constructor\n     */\n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n        this(instantLocal, chrono, locale, null, 2000);\n    }\n\n    /**\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 1.1\n     * @deprecated Use longer constructor\n     */\n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n        this(instantLocal, chrono, locale, pivotYear, 2000);\n    }\n\n    /**\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 2.0\n     */\n    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        setZone(chrono.getZone());\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the locale to be used during parsing.\n     * \n     * @return the locale to use\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the time zone used by computeMillis, or null if an offset is\n     * used instead.\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n    \n    /**\n     * Set a time zone to be used when computeMillis is called, which\n     * overrides any set time zone offset.\n     *\n     * @param zone the date time zone to operate in, or null if UTC\n     */\n    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone == DateTimeZone.UTC ? null : zone;\n        iOffset = 0;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Returns the time zone offset in milliseconds used by computeMillis,\n     * unless getZone doesn't return null.\n     */\n    public int getOffset() {\n        return iOffset;\n    }\n    \n    /**\n     * Set a time zone offset to be used when computeMillis is called, which\n     * overrides the time zone.\n     */\n    public void setOffset(int offset) {\n        iSavedState = null;\n        iOffset = offset;\n        iZone = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the default year used when information is incomplete.\n     * <p>\n     * This is used for two-digit years and when the largest parsed field is\n     * months or days.\n     * <p>\n     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.\n     * A null value for month/day only parsing will cause the default of 2000 to be used.\n     *\n     * @return Integer value of the pivot year, null if not set\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n        return iPivotYear;\n    }\n\n    /**\n     * Sets the pivot year to use when parsing two digit years.\n     * <p>\n     * If the value is set to null, this will indicate that default\n     * behaviour should be used.\n     *\n     * @param pivotYear  the pivot year to use\n     * @since 1.1\n     */\n    public void setPivotYear(Integer pivotYear) {\n        iPivotYear = pivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Saves a datetime field value.\n     * \n     * @param field  the field, whose chronology must match that of this bucket\n     * @param value  the value\n     */\n    public void saveField(DateTimeField field, int value) {\n        saveField(new SavedField(field, value));\n    }\n    \n    /**\n     * Saves a datetime field value.\n     * \n     * @param fieldType  the field type\n     * @param value  the value\n     */\n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n    \n    /**\n     * Saves a datetime field text value.\n     * \n     * @param fieldType  the field type\n     * @param text  the text value\n     * @param locale  the locale to use\n     */\n    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n    }\n    \n    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            // Expand capacity or merely copy if saved fields are shared.\n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }\n    \n    /**\n     * Saves the state of this bucket, returning it in an opaque object. Call\n     * restoreState to undo any changes that were made since the state was\n     * saved. Calls to saveState may be nested.\n     *\n     * @return opaque saved state, which may be passed to restoreState\n     */\n    public Object saveState() {\n        if (iSavedState == null) {\n            iSavedState = new SavedState();\n        }\n        return iSavedState;\n    }\n    \n    /**\n     * Restores the state of this bucket from a previously saved state. The\n     * state object passed into this method is not consumed, and it can be used\n     * later to restore to that state again.\n     *\n     * @param savedState opaque saved state, returned from saveState\n     * @return true state object is valid and state restored\n     */\n    public boolean restoreState(Object savedState) {\n        if (savedState instanceof SavedState) {\n            if (((SavedState) savedState).restoreState(this)) {\n                iSavedState = savedState;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public long computeMillis() {\n        return computeMillis(false, null);\n    }\n    \n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public long computeMillis(boolean resetFields) {\n        return computeMillis(resetFields, null);\n    }\n\n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n    \n    /**\n     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n     * choice since it always creates an internal copy of the array, even if it\n     * doesn't need to. If the array slice is small enough, an insertion sort\n     * is chosen instead, but it doesn't need a copy!\n     * <p>\n     * This method has a modified version of that insertion sort, except it\n     * doesn't create an unnecessary array copy. If high is over 10, then\n     * java.util.Arrays is called, which will perform a merge sort, which is\n     * faster than insertion sort on large lists.\n     * <p>\n     * The end result is much greater performance when computeMillis is called.\n     * Since the amount of saved fields is small, the insertion sort is a\n     * better choice. Additional performance is gained since there is no extra\n     * array allocation and copying. Also, the insertion sort here does not\n     * perform any casting operations. The version in java.util.Arrays performs\n     * casts within the insertion sort loop.\n     */\n    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }\n\n    class SavedState {\n        final DateTimeZone iZone;\n        final int iOffset;\n        final SavedField[] iSavedFields;\n        final int iSavedFieldsCount;\n        \n        SavedState() {\n            this.iZone = DateTimeParserBucket.this.iZone;\n            this.iOffset = DateTimeParserBucket.this.iOffset;\n            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n        }\n        \n        boolean restoreState(DateTimeParserBucket enclosing) {\n            if (enclosing != DateTimeParserBucket.this) {\n                return false;\n            }\n            enclosing.iZone = this.iZone;\n            enclosing.iOffset = this.iOffset;\n            enclosing.iSavedFields = this.iSavedFields;\n            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n                // Since count is being restored to a lower count, the\n                // potential exists for new saved fields to destroy data being\n                // shared by another state. Set this flag such that the array\n                // of saved fields is cloned prior to modification.\n                enclosing.iSavedFieldsShared = true;\n            }\n            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n            return true;\n        }\n    }\n    \n    static class SavedField implements Comparable<SavedField> {\n        final DateTimeField iField;\n        final int iValue;\n        final String iText;\n        final Locale iLocale;\n        \n        SavedField(DateTimeField field, int value) {\n            iField = field;\n            iValue = value;\n            iText = null;\n            iLocale = null;\n        }\n        \n        SavedField(DateTimeField field, String text, Locale locale) {\n            iField = field;\n            iValue = 0;\n            iText = text;\n            iLocale = locale;\n        }\n        \n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n        \n        /**\n         * The field with the longer range duration is ordered first, where\n         * null is considered infinite. If the ranges match, then the field\n         * with the longer duration is ordered first.\n         */\n        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }\n    }\n\n    static int compareReverse(DurationField a, DurationField b) {\n        if (a == null || !a.isSupported()) {\n            if (b == null || !b.isSupported()) {\n                return 0;\n            }\n            return -1;\n        }\n        if (b == null || !b.isSupported()) {\n            return 1;\n        }\n        return -a.compareTo(b);\n    }\n}\n", "fixed_version": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n/**\n * DateTimeParserBucket is an advanced class, intended mainly for parser\n * implementations. It can also be used during normal parsing operations to\n * capture more information about the parse.\n * <p>\n * This class allows fields to be saved in any order, but be physically set in\n * a consistent order. This is useful for parsing against formats that allow\n * field values to contradict each other.\n * <p>\n * Field values are applied in an order where the \"larger\" fields are set\n * first, making their value less likely to stick.  A field is larger than\n * another when it's range duration is longer. If both ranges are the same,\n * then the larger field has the longer duration. If it cannot be determined\n * which field is larger, then the fields are set in the order they were saved.\n * <p>\n * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n * <p>\n * DateTimeParserBucket is mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeParserBucket {\n\n    /** The chronology to use for parsing. */\n    private final Chronology iChrono;\n    private final long iMillis;\n    \n    // TimeZone to switch to in computeMillis. If null, use offset.\n    private DateTimeZone iZone;\n    private int iOffset;\n    /** The locale to use for parsing. */\n    private Locale iLocale;\n    /** Used for parsing two-digit years. */\n    private Integer iPivotYear;\n    /** Used for parsing month/day without year. */\n    private int iDefaultYear;\n\n    private SavedField[] iSavedFields = new SavedField[8];\n    private int iSavedFieldsCount;\n    private boolean iSavedFieldsShared;\n    \n    private Object iSavedState;\n\n    /**\n     * Constructs a bucket.\n     * \n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @deprecated Use longer constructor\n     */\n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n        this(instantLocal, chrono, locale, null, 2000);\n    }\n\n    /**\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 1.1\n     * @deprecated Use longer constructor\n     */\n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n        this(instantLocal, chrono, locale, pivotYear, 2000);\n    }\n\n    /**\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 2.0\n     */\n    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        setZone(chrono.getZone());\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the locale to be used during parsing.\n     * \n     * @return the locale to use\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the time zone used by computeMillis, or null if an offset is\n     * used instead.\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n    \n    /**\n     * Set a time zone to be used when computeMillis is called, which\n     * overrides any set time zone offset.\n     *\n     * @param zone the date time zone to operate in, or null if UTC\n     */\n    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone == DateTimeZone.UTC ? null : zone;\n        iOffset = 0;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Returns the time zone offset in milliseconds used by computeMillis,\n     * unless getZone doesn't return null.\n     */\n    public int getOffset() {\n        return iOffset;\n    }\n    \n    /**\n     * Set a time zone offset to be used when computeMillis is called, which\n     * overrides the time zone.\n     */\n    public void setOffset(int offset) {\n        iSavedState = null;\n        iOffset = offset;\n        iZone = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the default year used when information is incomplete.\n     * <p>\n     * This is used for two-digit years and when the largest parsed field is\n     * months or days.\n     * <p>\n     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.\n     * A null value for month/day only parsing will cause the default of 2000 to be used.\n     *\n     * @return Integer value of the pivot year, null if not set\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n        return iPivotYear;\n    }\n\n    /**\n     * Sets the pivot year to use when parsing two digit years.\n     * <p>\n     * If the value is set to null, this will indicate that default\n     * behaviour should be used.\n     *\n     * @param pivotYear  the pivot year to use\n     * @since 1.1\n     */\n    public void setPivotYear(Integer pivotYear) {\n        iPivotYear = pivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Saves a datetime field value.\n     * \n     * @param field  the field, whose chronology must match that of this bucket\n     * @param value  the value\n     */\n    public void saveField(DateTimeField field, int value) {\n        saveField(new SavedField(field, value));\n    }\n    \n    /**\n     * Saves a datetime field value.\n     * \n     * @param fieldType  the field type\n     * @param value  the value\n     */\n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n    \n    /**\n     * Saves a datetime field text value.\n     * \n     * @param fieldType  the field type\n     * @param text  the text value\n     * @param locale  the locale to use\n     */\n    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n    }\n    \n    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            // Expand capacity or merely copy if saved fields are shared.\n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }\n    \n    /**\n     * Saves the state of this bucket, returning it in an opaque object. Call\n     * restoreState to undo any changes that were made since the state was\n     * saved. Calls to saveState may be nested.\n     *\n     * @return opaque saved state, which may be passed to restoreState\n     */\n    public Object saveState() {\n        if (iSavedState == null) {\n            iSavedState = new SavedState();\n        }\n        return iSavedState;\n    }\n    \n    /**\n     * Restores the state of this bucket from a previously saved state. The\n     * state object passed into this method is not consumed, and it can be used\n     * later to restore to that state again.\n     *\n     * @param savedState opaque saved state, returned from saveState\n     * @return true state object is valid and state restored\n     */\n    public boolean restoreState(Object savedState) {\n        if (savedState instanceof SavedState) {\n            if (((SavedState) savedState).restoreState(this)) {\n                iSavedState = savedState;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public long computeMillis() {\n        return computeMillis(false, null);\n    }\n    \n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public long computeMillis(boolean resetFields) {\n        return computeMillis(resetFields, null);\n    }\n\n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n    \n    /**\n     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n     * choice since it always creates an internal copy of the array, even if it\n     * doesn't need to. If the array slice is small enough, an insertion sort\n     * is chosen instead, but it doesn't need a copy!\n     * <p>\n     * This method has a modified version of that insertion sort, except it\n     * doesn't create an unnecessary array copy. If high is over 10, then\n     * java.util.Arrays is called, which will perform a merge sort, which is\n     * faster than insertion sort on large lists.\n     * <p>\n     * The end result is much greater performance when computeMillis is called.\n     * Since the amount of saved fields is small, the insertion sort is a\n     * better choice. Additional performance is gained since there is no extra\n     * array allocation and copying. Also, the insertion sort here does not\n     * perform any casting operations. The version in java.util.Arrays performs\n     * casts within the insertion sort loop.\n     */\n    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }\n\n    class SavedState {\n        final DateTimeZone iZone;\n        final int iOffset;\n        final SavedField[] iSavedFields;\n        final int iSavedFieldsCount;\n        \n        SavedState() {\n            this.iZone = DateTimeParserBucket.this.iZone;\n            this.iOffset = DateTimeParserBucket.this.iOffset;\n            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n        }\n        \n        boolean restoreState(DateTimeParserBucket enclosing) {\n            if (enclosing != DateTimeParserBucket.this) {\n                return false;\n            }\n            enclosing.iZone = this.iZone;\n            enclosing.iOffset = this.iOffset;\n            enclosing.iSavedFields = this.iSavedFields;\n            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n                // Since count is being restored to a lower count, the\n                // potential exists for new saved fields to destroy data being\n                // shared by another state. Set this flag such that the array\n                // of saved fields is cloned prior to modification.\n                enclosing.iSavedFieldsShared = true;\n            }\n            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n            return true;\n        }\n    }\n    \n    static class SavedField implements Comparable<SavedField> {\n        final DateTimeField iField;\n        final int iValue;\n        final String iText;\n        final Locale iLocale;\n        \n        SavedField(DateTimeField field, int value) {\n            iField = field;\n            iValue = value;\n            iText = null;\n            iLocale = null;\n        }\n        \n        SavedField(DateTimeField field, String text, Locale locale) {\n            iField = field;\n            iValue = 0;\n            iText = text;\n            iLocale = locale;\n        }\n        \n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n        \n        /**\n         * The field with the longer range duration is ordered first, where\n         * null is considered infinite. If the ranges match, then the field\n         * with the longer duration is ordered first.\n         */\n        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }\n    }\n\n    static int compareReverse(DurationField a, DurationField b) {\n        if (a == null || !a.isSupported()) {\n            if (b == null || !b.isSupported()) {\n                return 0;\n            }\n            return -1;\n        }\n        if (b == null || !b.isSupported()) {\n            return 1;\n        }\n        return -a.compareTo(b);\n    }\n}\n"}]}
{"project": "Time", "bug_id": 25, "classes_modified": [{"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n"}]}
{"project": "Time", "bug_id": 26, "classes_modified": [{"class_name": "org.joda.time.chrono.ZonedChronology", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport java.util.HashMap;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.BaseDurationField;\nimport org.joda.time.format.DateTimeFormat;\n\n/**\n * Wraps another Chronology to add support for time zones.\n * <p>\n * ZonedChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic final class ZonedChronology extends AssembledChronology {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -1079258847191166848L;\n\n    /**\n     * Create a ZonedChronology for any chronology, overriding any time zone it\n     * may already have.\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     * @throws IllegalArgumentException if chronology or time zone is null\n     */\n    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }\n\n    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }\n\n    /**\n     * Restricted constructor\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     */\n    private ZonedChronology(Chronology base, DateTimeZone zone) {\n        super(base, zone);\n    }\n\n    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }\n\n    public Chronology withUTC() {\n        return getBase();\n    }\n\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getParam()) {\n            return this;\n        }\n        if (zone == DateTimeZone.UTC) {\n            return getBase();\n        }\n        return new ZonedChronology(getBase(), zone);\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int millisOfDay)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, millisOfDay));\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    public long getDateTimeMillis(long instant,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (instant + getZone().getOffset(instant),\n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    /**\n     * @param instant instant from 1970-01-01T00:00:00 local time\n     * @return instant from 1970-01-01T00:00:00Z\n     */\n    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n\n    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n\n    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A zoned chronology is only equal to a zoned chronology with the\n     * same base chronology and zone.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.4\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof ZonedChronology == false) {\n            return false;\n        }\n        ZonedChronology chrono = (ZonedChronology) obj;\n        return\n            getBase().equals(chrono.getBase()) &&\n            getZone().equals(chrono.getZone());\n    }\n\n    /**\n     * A suitable hashcode for the chronology.\n     * \n     * @return the hashcode\n     * @since 1.4\n     */\n    public int hashCode() {\n        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n    }\n\n    /**\n     * A debugging string for the chronology.\n     * \n     * @return the debugging string\n     */\n    public String toString() {\n        return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n    }\n\n    //-----------------------------------------------------------------------\n    /*\n     * Because time durations are typically smaller than time zone offsets, the\n     * arithmetic methods subtract the original offset. This produces a more\n     * expected behavior when crossing time zone offset transitions. For dates,\n     * the new offset is subtracted off. This behavior, if applied to time\n     * fields, can nullify or reverse an add when crossing a transition.\n     */\n    static class ZonedDurationField extends BaseDurationField {\n        private static final long serialVersionUID = -485345310999208286L;\n\n        final DurationField iField;\n        final boolean iTimeField;\n        final DateTimeZone iZone;\n\n        ZonedDurationField(DurationField field, DateTimeZone zone) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iTimeField = useTimeArithmetic(field);\n            iZone = zone;\n        }\n\n        public boolean isPrecise() {\n            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n        }\n\n        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }\n\n        public int getValue(long duration, long instant) {\n            return iField.getValue(duration, addOffset(instant));\n        }\n\n        public long getValueAsLong(long duration, long instant) {\n            return iField.getValueAsLong(duration, addOffset(instant));\n        }\n\n        public long getMillis(int value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long getMillis(long value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long add(long instant, int value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public long add(long instant, long value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            // If there is a sign change, but the two values have the same sign...\n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private int getOffsetFromLocalToSubtract(long instant) {\n            int offset = this.iZone.getOffsetFromLocal(instant);\n            long diff = instant - offset;\n            // If there is a sign change, but the two values have different signs...\n            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private long addOffset(long instant) {\n            return iZone.convertUTCToLocal(instant);\n        }\n    }\n\n    /**\n     * A DateTimeField that decorates another to add timezone behaviour.\n     * <p>\n     * This class converts passed in instants to local wall time, and vice\n     * versa on output.\n     */\n    static final class ZonedDateTimeField extends BaseDateTimeField {\n        private static final long serialVersionUID = -3968986277775529794L;\n\n        final DateTimeField iField;\n        final DateTimeZone iZone;\n        final DurationField iDurationField;\n        final boolean iTimeField;\n        final DurationField iRangeDurationField;\n        final DurationField iLeapDurationField;\n\n        ZonedDateTimeField(DateTimeField field,\n                           DateTimeZone zone,\n                           DurationField durationField,\n                           DurationField rangeDurationField,\n                           DurationField leapDurationField) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iZone = zone;\n            iDurationField = durationField;\n            iTimeField = useTimeArithmetic(durationField);\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n\n        public boolean isLenient() {\n            return iField.isLenient();\n        }\n\n        public int get(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.get(localInstant);\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsText(localInstant, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsShortText(localInstant, locale);\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long add(long instant, long value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long addWrapField(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.addWrapField(instant + offset, value);\n                return localInstant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            // cannot verify that new value stuck because set may be lenient\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public final DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.isLeap(localInstant);\n        }\n\n        public int getLeapAmount(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getLeapAmount(localInstant);\n        }\n\n        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }\n\n        public long roundFloor(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundFloor(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long roundCeiling(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundCeiling(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n            }\n        }\n\n        public long remainder(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.remainder(localInstant);\n        }\n\n        public int getMinimumValue() {\n            return iField.getMinimumValue();\n        }\n\n        public int getMinimumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMinimumValue(localInstant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant) {\n            return iField.getMinimumValue(instant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant, int[] values) {\n            return iField.getMinimumValue(instant, values);\n        }\n\n        public int getMaximumValue() {\n            return iField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMaximumValue(localInstant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant) {\n            return iField.getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant, int[] values) {\n            return iField.getMaximumValue(instant, values);\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return iField.getMaximumTextLength(locale);\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return iField.getMaximumShortTextLength(locale);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            // If there is a sign change, but the two values have the same sign...\n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport java.util.HashMap;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.IllegalFieldValueException;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.BaseDateTimeField;\nimport org.joda.time.field.BaseDurationField;\nimport org.joda.time.format.DateTimeFormat;\n\n/**\n * Wraps another Chronology to add support for time zones.\n * <p>\n * ZonedChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic final class ZonedChronology extends AssembledChronology {\n\n    /** Serialization lock */\n    private static final long serialVersionUID = -1079258847191166848L;\n\n    /**\n     * Create a ZonedChronology for any chronology, overriding any time zone it\n     * may already have.\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     * @throws IllegalArgumentException if chronology or time zone is null\n     */\n    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }\n\n    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }\n\n    /**\n     * Restricted constructor\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     */\n    private ZonedChronology(Chronology base, DateTimeZone zone) {\n        super(base, zone);\n    }\n\n    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }\n\n    public Chronology withUTC() {\n        return getBase();\n    }\n\n    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getParam()) {\n            return this;\n        }\n        if (zone == DateTimeZone.UTC) {\n            return getBase();\n        }\n        return new ZonedChronology(getBase(), zone);\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int millisOfDay)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, millisOfDay));\n    }\n\n    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    public long getDateTimeMillis(long instant,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (instant + getZone().getOffset(instant),\n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n\n    /**\n     * @param instant instant from 1970-01-01T00:00:00 local time\n     * @return instant from 1970-01-01T00:00:00Z\n     */\n    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n\n    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n\n    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A zoned chronology is only equal to a zoned chronology with the\n     * same base chronology and zone.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.4\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof ZonedChronology == false) {\n            return false;\n        }\n        ZonedChronology chrono = (ZonedChronology) obj;\n        return\n            getBase().equals(chrono.getBase()) &&\n            getZone().equals(chrono.getZone());\n    }\n\n    /**\n     * A suitable hashcode for the chronology.\n     * \n     * @return the hashcode\n     * @since 1.4\n     */\n    public int hashCode() {\n        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n    }\n\n    /**\n     * A debugging string for the chronology.\n     * \n     * @return the debugging string\n     */\n    public String toString() {\n        return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n    }\n\n    //-----------------------------------------------------------------------\n    /*\n     * Because time durations are typically smaller than time zone offsets, the\n     * arithmetic methods subtract the original offset. This produces a more\n     * expected behavior when crossing time zone offset transitions. For dates,\n     * the new offset is subtracted off. This behavior, if applied to time\n     * fields, can nullify or reverse an add when crossing a transition.\n     */\n    static class ZonedDurationField extends BaseDurationField {\n        private static final long serialVersionUID = -485345310999208286L;\n\n        final DurationField iField;\n        final boolean iTimeField;\n        final DateTimeZone iZone;\n\n        ZonedDurationField(DurationField field, DateTimeZone zone) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iTimeField = useTimeArithmetic(field);\n            iZone = zone;\n        }\n\n        public boolean isPrecise() {\n            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n        }\n\n        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }\n\n        public int getValue(long duration, long instant) {\n            return iField.getValue(duration, addOffset(instant));\n        }\n\n        public long getValueAsLong(long duration, long instant) {\n            return iField.getValueAsLong(duration, addOffset(instant));\n        }\n\n        public long getMillis(int value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long getMillis(long value, long instant) {\n            return iField.getMillis(value, addOffset(instant));\n        }\n\n        public long add(long instant, int value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public long add(long instant, long value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            // If there is a sign change, but the two values have the same sign...\n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private int getOffsetFromLocalToSubtract(long instant) {\n            int offset = this.iZone.getOffsetFromLocal(instant);\n            long diff = instant - offset;\n            // If there is a sign change, but the two values have different signs...\n            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n            }\n            return offset;\n        }\n\n        private long addOffset(long instant) {\n            return iZone.convertUTCToLocal(instant);\n        }\n    }\n\n    /**\n     * A DateTimeField that decorates another to add timezone behaviour.\n     * <p>\n     * This class converts passed in instants to local wall time, and vice\n     * versa on output.\n     */\n    static final class ZonedDateTimeField extends BaseDateTimeField {\n        private static final long serialVersionUID = -3968986277775529794L;\n\n        final DateTimeField iField;\n        final DateTimeZone iZone;\n        final DurationField iDurationField;\n        final boolean iTimeField;\n        final DurationField iRangeDurationField;\n        final DurationField iLeapDurationField;\n\n        ZonedDateTimeField(DateTimeField field,\n                           DateTimeZone zone,\n                           DurationField durationField,\n                           DurationField rangeDurationField,\n                           DurationField leapDurationField) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iZone = zone;\n            iDurationField = durationField;\n            iTimeField = useTimeArithmetic(durationField);\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n\n        public boolean isLenient() {\n            return iField.isLenient();\n        }\n\n        public int get(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.get(localInstant);\n        }\n\n        public String getAsText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsText(localInstant, locale);\n        }\n\n        public String getAsShortText(long instant, Locale locale) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getAsShortText(localInstant, locale);\n        }\n\n        public String getAsText(int fieldValue, Locale locale) {\n            return iField.getAsText(fieldValue, locale);\n        }\n\n        public String getAsShortText(int fieldValue, Locale locale) {\n            return iField.getAsShortText(fieldValue, locale);\n        }\n\n        public long add(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long add(long instant, long value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.add(instant + offset, value);\n                return localInstant - offset;\n            } else {\n               long localInstant = iZone.convertUTCToLocal(instant);\n               localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long addWrapField(long instant, int value) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                long localInstant = iField.addWrapField(instant + offset, value);\n                return localInstant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }\n\n        public long set(long instant, String text, Locale locale) {\n            // cannot verify that new value stuck because set may be lenient\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false, instant);\n        }\n\n        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifferenceAsLong\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n\n        public final DurationField getDurationField() {\n            return iDurationField;\n        }\n\n        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n\n        public boolean isLeap(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.isLeap(localInstant);\n        }\n\n        public int getLeapAmount(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getLeapAmount(localInstant);\n        }\n\n        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }\n\n        public long roundFloor(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundFloor(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long roundCeiling(long instant) {\n            if (iTimeField) {\n                int offset = getOffsetToAdd(instant);\n                instant = iField.roundCeiling(instant + offset);\n                return instant - offset;\n            } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n            }\n        }\n\n        public long remainder(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.remainder(localInstant);\n        }\n\n        public int getMinimumValue() {\n            return iField.getMinimumValue();\n        }\n\n        public int getMinimumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMinimumValue(localInstant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant) {\n            return iField.getMinimumValue(instant);\n        }\n\n        public int getMinimumValue(ReadablePartial instant, int[] values) {\n            return iField.getMinimumValue(instant, values);\n        }\n\n        public int getMaximumValue() {\n            return iField.getMaximumValue();\n        }\n\n        public int getMaximumValue(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.getMaximumValue(localInstant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant) {\n            return iField.getMaximumValue(instant);\n        }\n\n        public int getMaximumValue(ReadablePartial instant, int[] values) {\n            return iField.getMaximumValue(instant, values);\n        }\n\n        public int getMaximumTextLength(Locale locale) {\n            return iField.getMaximumTextLength(locale);\n        }\n\n        public int getMaximumShortTextLength(Locale locale) {\n            return iField.getMaximumShortTextLength(locale);\n        }\n\n        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            // If there is a sign change, but the two values have the same sign...\n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n    }\n\n}\n"}, {"class_name": "org.joda.time.DateTimeZone", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * NOTE: The behaviour of this method changed in v1.5, with the emphasis\n     * on returning a consistent result later along the time-line (shown above).\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to\n     * get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.joda.convert.FromString;\nimport org.joda.convert.ToString;\nimport org.joda.time.chrono.BaseChronology;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.joda.time.format.DateTimeFormatterBuilder;\nimport org.joda.time.format.FormatUtils;\nimport org.joda.time.tz.DefaultNameProvider;\nimport org.joda.time.tz.FixedDateTimeZone;\nimport org.joda.time.tz.NameProvider;\nimport org.joda.time.tz.Provider;\nimport org.joda.time.tz.UTCProvider;\nimport org.joda.time.tz.ZoneInfoProvider;\n\n/**\n * DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions of time are generally used:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Standard Time - The local time without a daylight saving time offset.\n * For example, in Paris, standard time is UTC+01:00.\n * <li>Daylight Saving Time - The local time with a daylight saving time \n * offset. This offset is typically one hour, but not always. It is typically\n * used in most countries away from the equator.  In Paris, daylight saving \n * time is UTC+02:00.\n * <li>Wall Time - This is what a local clock on the wall reads. This will be\n * either Standard Time or Daylight Saving Time depending on the time of year\n * and whether the location uses Daylight Saving Time.\n * </ul>\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus EST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class DateTimeZone implements Serializable {\n    \n    /** Serialization version. */\n    private static final long serialVersionUID = 5546345482340108586L;\n\n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     */\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n\n    /**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n\n    /**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static Provider getProvider() {\n        return cProvider;\n    }\n\n    /**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }\n\n    /**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n\n    /**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n\n    /**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }\n\n    // Instance fields and methods\n    //--------------------------------------------------------------------\n\n    private final String iID;\n\n    /**\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     */\n    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n\n    // Principal methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     */\n    @ToString\n    public final String getID() {\n        return iID;\n    }\n\n    /**\n     * Returns a non-localized name that is unique to this time zone. It can be\n     * combined with id to form a unique key for fetching localized names.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return name key or null if id should be used for names\n     */\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */\n    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable long name in the default locale\n     */\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }\n\n    /**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */\n    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }\n\n    /**\n     * Gets the standard millisecond offset to add to UTC to get local time,\n     * when standard time is in effect.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * NOTE: The behaviour of this method changed in v1.5, with the emphasis\n     * on returning a consistent result later along the time-line (shown above).\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to\n     * get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n\n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = oldInstant + getOffset(oldInstant);\n        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n    }\n\n//    //-----------------------------------------------------------------------\n//    /**\n//     * Checks if the given {@link LocalDateTime} is within an overlap.\n//     * <p>\n//     * When switching from Daylight Savings Time to standard time there is\n//     * typically an overlap where the same clock hour occurs twice. This\n//     * method identifies whether the local datetime refers to such an overlap.\n//     * \n//     * @param localDateTime  the time to check, not null\n//     * @return true if the given datetime refers to an overlap\n//     */\n//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n//        if (isFixed()) {\n//            return false;\n//        }\n//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n//        // get the offset at instantLocal (first estimate)\n//        int offsetLocal = getOffset(instantLocal);\n//        // adjust instantLocal using the estimate and recalc the offset\n//        int offset = getOffset(instantLocal - offsetLocal);\n//        // if the offsets differ, we must be near a DST boundary\n//        if (offsetLocal != offset) {\n//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n//            long nextAdjusted = nextTransition(instantLocal - offset);\n//            if (nextLocal != nextAdjusted) {\n//                // in DST gap\n//                return false;\n//            }\n//            long diff = Math.abs(offset - offsetLocal);\n//            DateTime dateTime = localDateTime.toDateTime(this);\n//            DateTime adjusted = dateTime.plus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            adjusted = dateTime.minus(diff);\n//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//                return true;\n//            }\n//            return false;\n//        }\n//        return false;\n//    }\n//        \n//        \n//        DateTime dateTime = null;\n//        try {\n//            dateTime = localDateTime.toDateTime(this);\n//        } catch (IllegalArgumentException ex) {\n//            return false;  // it is a gap, not an overlap\n//        }\n//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n//        long offset = Math.max(offset1, offset2);\n//        if (offset == 0) {\n//            return false;\n//        }\n//        DateTime adjusted = dateTime.plus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        adjusted = dateTime.minus(offset);\n//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n//            return true;\n//        }\n//        return false;\n        \n//        long millis = dateTime.getMillis();\n//        long nextTransition = nextTransition(millis);\n//        long previousTransition = previousTransition(millis);\n//        long deltaToPreviousTransition = millis - previousTransition;\n//        long deltaToNextTransition = nextTransition - millis;\n//        if (deltaToNextTransition < deltaToPreviousTransition) {\n//            int offset = getOffset(nextTransition);\n//            int standardOffset = getStandardOffset(nextTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n//                return true;\n//            }\n//        } else  {\n//            int offset = getOffset(previousTransition);\n//            int standardOffset = getStandardOffset(previousTransition);\n//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    /**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }\n\n    /**\n     * Compare this datetime zone with another.\n     * \n     * @param object the object to compare with\n     * @return true if equal, based on the ID and all internal rules\n     */\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n\n    /**\n     * Gets the datetime zone as a string, which is simply its ID.\n     * @return the id of the zone\n     */\n    public String toString() {\n        return getID();\n    }\n\n    /**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }\n\n    /**\n     * Used to serialize DateTimeZones by id.\n     */\n    private static final class Stub implements Serializable {\n        /** Serialization lock. */\n        private static final long serialVersionUID = -6471952376487863581L;\n        /** The ID of the zone. */\n        private transient String iID;\n\n        /**\n         * Constructor.\n         * @param id  the id of the zone\n         */\n        Stub(String id) {\n            iID = id;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }\n\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }\n    }\n}\n"}, {"class_name": "org.joda.time.field.LenientDateTimeField", "buggy_version": "/*\n *  Copyright 2001-2007 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\n\n/**\n * Converts a strict DateTimeField into a lenient one. By being lenient, the\n * set method accepts out of bounds values, performing an addition instead.\n * <p>\n * LenientDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @see org.joda.time.chrono.LenientChronology\n * @see StrictDateTimeField\n * @since 1.0\n */\npublic class LenientDateTimeField extends DelegatedDateTimeField {\n\n    private static final long serialVersionUID = 8714085824173290599L;\n\n    private final Chronology iBase;\n\n    /**\n     * Returns a lenient version of the given field. If it is already lenient,\n     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n     * returned.\n     */\n    public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof StrictDateTimeField) {\n            field = ((StrictDateTimeField)field).getWrappedField();\n        }\n        if (field.isLenient()) {\n            return field;\n        }\n        return new LenientDateTimeField(field, base);\n    }\n\n    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n        super(field);\n        iBase = base;\n    }\n\n    public final boolean isLenient() {\n        return true;\n    }\n\n    /**\n     * Set values which may be out of bounds by adding the difference between\n     * the new value and the current value.\n     */\n    public long set(long instant, int value) {\n        // lenient needs to handle time zone chronologies\n        // so we do the calculation using local milliseconds\n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false);\n    }\n}\n", "fixed_version": "/*\n *  Copyright 2001-2007 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\n\n/**\n * Converts a strict DateTimeField into a lenient one. By being lenient, the\n * set method accepts out of bounds values, performing an addition instead.\n * <p>\n * LenientDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @see org.joda.time.chrono.LenientChronology\n * @see StrictDateTimeField\n * @since 1.0\n */\npublic class LenientDateTimeField extends DelegatedDateTimeField {\n\n    private static final long serialVersionUID = 8714085824173290599L;\n\n    private final Chronology iBase;\n\n    /**\n     * Returns a lenient version of the given field. If it is already lenient,\n     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n     * returned.\n     */\n    public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof StrictDateTimeField) {\n            field = ((StrictDateTimeField)field).getWrappedField();\n        }\n        if (field.isLenient()) {\n            return field;\n        }\n        return new LenientDateTimeField(field, base);\n    }\n\n    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n        super(field);\n        iBase = base;\n    }\n\n    public final boolean isLenient() {\n        return true;\n    }\n\n    /**\n     * Set values which may be out of bounds by adding the difference between\n     * the new value and the current value.\n     */\n    public long set(long instant, int value) {\n        // lenient needs to handle time zone chronologies\n        // so we do the calculation using local milliseconds\n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n    }\n}\n"}]}
{"project": "Time", "bug_id": 27, "classes_modified": [{"class_name": "org.joda.time.format.PeriodFormatterBuilder", "buggy_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TreeSet;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadablePeriod;\n\n/**\n * Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix(\" year\", \" years\")\n *     .appendSeparator(\" and \")\n *     .printZeroRarely()\n *     .appendMonths()\n *     .appendSuffix(\" month\", \" months\")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n */\npublic class PeriodFormatterBuilder {\n    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n    private static final int PRINT_ZERO_RARELY_LAST = 2;\n    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n    private static final int PRINT_ZERO_ALWAYS = 4;\n    private static final int PRINT_ZERO_NEVER = 5;\n    \n    private static final int YEARS = 0;\n    private static final int MONTHS = 1;\n    private static final int WEEKS = 2;\n    private static final int DAYS = 3;\n    private static final int HOURS = 4;\n    private static final int MINUTES = 5;\n    private static final int SECONDS = 6;\n    private static final int MILLIS = 7;\n    private static final int SECONDS_MILLIS = 8;\n    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n\n    private int iMinPrintedDigits;\n    private int iPrintZeroSetting;\n    private int iMaxParsedDigits;\n    private boolean iRejectSignedValues;\n\n    private PeriodFieldAffix iPrefix;\n\n    // List of Printers and Parsers used to build a final formatter.\n    private List<Object> iElementPairs;\n    /** Set to true if the formatter is not a printer. */\n    private boolean iNotPrinter;\n    /** Set to true if the formatter is not a parser. */\n    private boolean iNotParser;\n\n    // Last PeriodFormatter appended of each field type.\n    private FieldFormatter[] iFieldFormatters;\n\n    public PeriodFormatterBuilder() {\n        clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a PeriodFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link PeriodFormatter#isPrinter()} and\n     * {@link PeriodFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     * \n     * @return the newly created formatter\n     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n     */\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }\n\n    /**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }\n\n    /**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }\n\n    /**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }\n\n    /**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */\n    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }\n\n    /**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }\n\n    /**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }\n\n    /**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }\n\n    /**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }\n\n    /**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String singularText,\n                                                 String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }\n\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }\n\n    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String singularText,\n                                               String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @param variants  set of text values which are also acceptable when parsed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                  String[] variants) {\n        return appendSeparator(text, finalText, variants, true, true);\n    }\n\n    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }\n\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n     */\n    static interface PeriodFieldAffix {\n        int calculatePrintedLength(int value);\n        \n        void printTo(StringBuffer buf, int value);\n        \n        void printTo(Writer out, int value) throws IOException;\n        \n        /**\n         * @return new position after parsing affix, or ~position of failure\n         */\n        int parse(String periodStr, int position);\n\n        /**\n         * @return position where affix starts, or original ~position if not found\n         */\n        int scan(String periodStr, int position);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text does not vary by the amount.\n     */\n    static class SimpleAffix implements PeriodFieldAffix {\n        private final String iText;\n\n        SimpleAffix(String text) {\n            iText = text;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(iText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.\n     */\n    static class PluralAffix implements PeriodFieldAffix {\n        private final String iSingularText;\n        private final String iPluralText;\n\n        PluralAffix(String singularText, String pluralText) {\n            iSingularText = singularText;\n            iPluralText = pluralText;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return (value == 1 ? iSingularText : iPluralText).length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            if (periodStr.regionMatches\n                (true, position, text1, 0, text1.length())) {\n                return position + text1.length();\n            }\n            if (periodStr.regionMatches\n                (true, position, text2, 0, text2.length())) {\n                return position + text2.length();\n            }\n\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            int textLength1 = text1.length();\n            int textLength2 = text2.length();\n\n            int sourceLength = periodStr.length();\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                    return pos;\n                }\n                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                    return pos;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Builds a composite affix by merging two other affix implementations.\n     */\n    static class CompositeAffix implements PeriodFieldAffix {\n        private final PeriodFieldAffix iLeft;\n        private final PeriodFieldAffix iRight;\n\n        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n            iLeft = left;\n            iRight = right;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iLeft.calculatePrintedLength(value)\n                + iRight.calculatePrintedLength(value);\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            iLeft.printTo(buf, value);\n            iRight.printTo(buf, value);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            iLeft.printTo(out, value);\n            iRight.printTo(out, value);\n        }\n\n        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats the numeric value of a field, potentially with prefix/suffix.\n     */\n    static class FieldFormatter\n            implements PeriodPrinter, PeriodParser {\n        private final int iMinPrintedDigits;\n        private final int iPrintZeroSetting;\n        private final int iMaxParsedDigits;\n        private final boolean iRejectSignedValues;\n        \n        /** The index of the field type, 0=year, etc. */\n        private final int iFieldType;\n        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 digits\n                sum = Math.max(sum, 4);\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }\n        \n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(out, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.writeUnpaddedInteger(out, value);\n            } else {\n                FormatUtils.writePaddedInteger(out, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    out.write('.');\n                    FormatUtils.writePaddedInteger(out, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(out, value);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }\n\n        /**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }\n\n        /**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }\n\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }\n\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }\n\n        int getFieldType() {\n            return iFieldType;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a simple literal piece of text.\n     */\n    static class Literal\n            implements PeriodPrinter, PeriodParser {\n        static final Literal EMPTY = new Literal(\"\");\n        private final String iText;\n\n        Literal(String text) {\n            iText = text;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            out.write(iText);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.\n     */\n    static class Separator\n            implements PeriodPrinter, PeriodParser {\n        private final String iText;\n        private final String iFinalText;\n        private final String[] iParsedForms;\n\n        private final boolean iUseBefore;\n        private final boolean iUseAfter;\n\n        private final PeriodPrinter iBeforePrinter;\n        private volatile PeriodPrinter iAfterPrinter;\n        private final PeriodParser iBeforeParser;\n        private volatile PeriodParser iAfterParser;\n\n        Separator(String text, String finalText, String[] variants,\n                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n                boolean useBefore, boolean useAfter) {\n            iText = text;\n            iFinalText = finalText;\n\n            if ((finalText == null || text.equals(finalText)) &&\n                (variants == null || variants.length == 0)) {\n\n                iParsedForms = new String[] {text};\n            } else {\n                // Filter and reverse sort the parsed forms.\n                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                parsedSet.add(text);\n                parsedSet.add(finalText);\n                if (variants != null) {\n                    for (int i=variants.length; --i>=0; ) {\n                        parsedSet.add(variants[i]);\n                    }\n                }\n                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                Collections.reverse(parsedList);\n                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n            }\n\n            iBeforePrinter = beforePrinter;\n            iBeforeParser = beforeParser;\n            iUseBefore = useBefore;\n            iUseAfter = useAfter;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n            if (sum < stopAt) {\n                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(out, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            out.write(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        out.write(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                out.write(iText);\n            }\n            after.printTo(out, period, locale);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += parsedForm.length();\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }\n\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Composite implementation that merges other fields to create a full pattern.\n     */\n    static class Composite\n            implements PeriodPrinter, PeriodParser {\n        \n        private final PeriodPrinter[] iPrinters;\n        private final PeriodParser[] iParsers;\n\n        Composite(List<Object> elementPairs) {\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n            } else {\n                iPrinters = printerList.toArray(\n                        new PeriodPrinter[printerList.size()]);\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n            } else {\n                iParsers = parserList.toArray(\n                        new PeriodParser[parserList.size()]);\n            }\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(out, period, locale);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }\n\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TreeSet;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadablePeriod;\n\n/**\n * Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix(\" year\", \" years\")\n *     .appendSeparator(\" and \")\n *     .printZeroRarely()\n *     .appendMonths()\n *     .appendSuffix(\" month\", \" months\")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n */\npublic class PeriodFormatterBuilder {\n    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n    private static final int PRINT_ZERO_RARELY_LAST = 2;\n    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n    private static final int PRINT_ZERO_ALWAYS = 4;\n    private static final int PRINT_ZERO_NEVER = 5;\n    \n    private static final int YEARS = 0;\n    private static final int MONTHS = 1;\n    private static final int WEEKS = 2;\n    private static final int DAYS = 3;\n    private static final int HOURS = 4;\n    private static final int MINUTES = 5;\n    private static final int SECONDS = 6;\n    private static final int MILLIS = 7;\n    private static final int SECONDS_MILLIS = 8;\n    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n\n    private int iMinPrintedDigits;\n    private int iPrintZeroSetting;\n    private int iMaxParsedDigits;\n    private boolean iRejectSignedValues;\n\n    private PeriodFieldAffix iPrefix;\n\n    // List of Printers and Parsers used to build a final formatter.\n    private List<Object> iElementPairs;\n    /** Set to true if the formatter is not a printer. */\n    private boolean iNotPrinter;\n    /** Set to true if the formatter is not a parser. */\n    private boolean iNotParser;\n\n    // Last PeriodFormatter appended of each field type.\n    private FieldFormatter[] iFieldFormatters;\n\n    public PeriodFormatterBuilder() {\n        clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a PeriodFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link PeriodFormatter#isPrinter()} and\n     * {@link PeriodFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     * \n     * @return the newly created formatter\n     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n     */\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }\n\n    /**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }\n\n    /**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }\n\n    /**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }\n\n    /**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */\n    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }\n\n    /**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }\n\n    /**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }\n\n    /**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }\n\n    /**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }\n\n    /**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String singularText,\n                                                 String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }\n\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }\n\n    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String singularText,\n                                               String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @param variants  set of text values which are also acceptable when parsed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                  String[] variants) {\n        return appendSeparator(text, finalText, variants, true, true);\n    }\n\n    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }\n\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n     */\n    static interface PeriodFieldAffix {\n        int calculatePrintedLength(int value);\n        \n        void printTo(StringBuffer buf, int value);\n        \n        void printTo(Writer out, int value) throws IOException;\n        \n        /**\n         * @return new position after parsing affix, or ~position of failure\n         */\n        int parse(String periodStr, int position);\n\n        /**\n         * @return position where affix starts, or original ~position if not found\n         */\n        int scan(String periodStr, int position);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text does not vary by the amount.\n     */\n    static class SimpleAffix implements PeriodFieldAffix {\n        private final String iText;\n\n        SimpleAffix(String text) {\n            iText = text;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(iText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.\n     */\n    static class PluralAffix implements PeriodFieldAffix {\n        private final String iSingularText;\n        private final String iPluralText;\n\n        PluralAffix(String singularText, String pluralText) {\n            iSingularText = singularText;\n            iPluralText = pluralText;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return (value == 1 ? iSingularText : iPluralText).length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            if (periodStr.regionMatches\n                (true, position, text1, 0, text1.length())) {\n                return position + text1.length();\n            }\n            if (periodStr.regionMatches\n                (true, position, text2, 0, text2.length())) {\n                return position + text2.length();\n            }\n\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            int textLength1 = text1.length();\n            int textLength2 = text2.length();\n\n            int sourceLength = periodStr.length();\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                    return pos;\n                }\n                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                    return pos;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Builds a composite affix by merging two other affix implementations.\n     */\n    static class CompositeAffix implements PeriodFieldAffix {\n        private final PeriodFieldAffix iLeft;\n        private final PeriodFieldAffix iRight;\n\n        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n            iLeft = left;\n            iRight = right;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iLeft.calculatePrintedLength(value)\n                + iRight.calculatePrintedLength(value);\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            iLeft.printTo(buf, value);\n            iRight.printTo(buf, value);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            iLeft.printTo(out, value);\n            iRight.printTo(out, value);\n        }\n\n        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats the numeric value of a field, potentially with prefix/suffix.\n     */\n    static class FieldFormatter\n            implements PeriodPrinter, PeriodParser {\n        private final int iMinPrintedDigits;\n        private final int iPrintZeroSetting;\n        private final int iMaxParsedDigits;\n        private final boolean iRejectSignedValues;\n        \n        /** The index of the field type, 0=year, etc. */\n        private final int iFieldType;\n        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 digits\n                sum = Math.max(sum, 4);\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }\n        \n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(out, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.writeUnpaddedInteger(out, value);\n            } else {\n                FormatUtils.writePaddedInteger(out, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    out.write('.');\n                    FormatUtils.writePaddedInteger(out, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(out, value);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }\n\n        /**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }\n\n        /**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }\n\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }\n\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }\n\n        int getFieldType() {\n            return iFieldType;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a simple literal piece of text.\n     */\n    static class Literal\n            implements PeriodPrinter, PeriodParser {\n        static final Literal EMPTY = new Literal(\"\");\n        private final String iText;\n\n        Literal(String text) {\n            iText = text;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            out.write(iText);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.\n     */\n    static class Separator\n            implements PeriodPrinter, PeriodParser {\n        private final String iText;\n        private final String iFinalText;\n        private final String[] iParsedForms;\n\n        private final boolean iUseBefore;\n        private final boolean iUseAfter;\n\n        private final PeriodPrinter iBeforePrinter;\n        private volatile PeriodPrinter iAfterPrinter;\n        private final PeriodParser iBeforeParser;\n        private volatile PeriodParser iAfterParser;\n\n        Separator(String text, String finalText, String[] variants,\n                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n                boolean useBefore, boolean useAfter) {\n            iText = text;\n            iFinalText = finalText;\n\n            if ((finalText == null || text.equals(finalText)) &&\n                (variants == null || variants.length == 0)) {\n\n                iParsedForms = new String[] {text};\n            } else {\n                // Filter and reverse sort the parsed forms.\n                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                parsedSet.add(text);\n                parsedSet.add(finalText);\n                if (variants != null) {\n                    for (int i=variants.length; --i>=0; ) {\n                        parsedSet.add(variants[i]);\n                    }\n                }\n                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                Collections.reverse(parsedList);\n                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n            }\n\n            iBeforePrinter = beforePrinter;\n            iBeforeParser = beforeParser;\n            iUseBefore = useBefore;\n            iUseAfter = useAfter;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n            if (sum < stopAt) {\n                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(out, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            out.write(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        out.write(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                out.write(iText);\n            }\n            after.printTo(out, period, locale);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += parsedForm.length();\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }\n\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Composite implementation that merges other fields to create a full pattern.\n     */\n    static class Composite\n            implements PeriodPrinter, PeriodParser {\n        \n        private final PeriodPrinter[] iPrinters;\n        private final PeriodParser[] iParsers;\n\n        Composite(List<Object> elementPairs) {\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n            } else {\n                iPrinters = printerList.toArray(\n                        new PeriodPrinter[printerList.size()]);\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n            } else {\n                iParsers = parserList.toArray(\n                        new PeriodParser[parserList.size()]);\n            }\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(out, period, locale);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }\n\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n}\n"}]}
