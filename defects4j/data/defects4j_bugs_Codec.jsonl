{"project": "Codec", "bug_id": 1, "classes_modified": [{"class_name": "org.apache.commons.codec.language.Caverphone", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a caverphone value. \n *\n * This is an algorithm created the Caversham Project at the University of Otago. \n * It implements the Caverphone 2.0 algorithm:\n *\n *\n * @author Apache Software Foundation\n * @version $Id$\n * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n */\npublic class Caverphone implements StringEncoder {\n\n    /**\n     * Creates an instance of the Caverphone encoder\n     */\n    public Caverphone() {\n        super();\n    }\n\n    /**\n     * Find the caverphone value of a String. \n     *\n     * @param txt String to find the caverphone code for\n     * @return A caverphone code corresponding to the String supplied\n     */\n    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase();\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }\n\n    /**\n     * Encodes an Object using the caverphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         caverphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof java.lang.String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\"); \n        }\n        return caverphone((String) pObject);\n    }\n\n    /**\n     * Encodes a String using the Caverphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     */\n    public String encode(String pString) {\n        return caverphone(pString);   \n    }\n\n    /**\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     */\n    public boolean isCaverphoneEqual(String str1, String str2) {\n        return caverphone(str1).equals(caverphone(str2));\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a caverphone value. \n *\n * This is an algorithm created the Caversham Project at the University of Otago. \n * It implements the Caverphone 2.0 algorithm:\n *\n *\n * @author Apache Software Foundation\n * @version $Id$\n * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n */\npublic class Caverphone implements StringEncoder {\n\n    /**\n     * Creates an instance of the Caverphone encoder\n     */\n    public Caverphone() {\n        super();\n    }\n\n    /**\n     * Find the caverphone value of a String. \n     *\n     * @param txt String to find the caverphone code for\n     * @return A caverphone code corresponding to the String supplied\n     */\n    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }\n\n    /**\n     * Encodes an Object using the caverphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         caverphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof java.lang.String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\"); \n        }\n        return caverphone((String) pObject);\n    }\n\n    /**\n     * Encodes a String using the Caverphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     */\n    public String encode(String pString) {\n        return caverphone(pString);   \n    }\n\n    /**\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     */\n    public boolean isCaverphoneEqual(String str1, String str2) {\n        return caverphone(str1).equals(caverphone(str2));\n    }\n\n}\n"}, {"class_name": "org.apache.commons.codec.language.Metaphone", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a metaphone value. \n * <p>\n * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>. \n * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.\n * </p>\n * <p>\n * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990, p\n * 39.</CITE>\n * </p>\n * <p>\n * Note, that this does not match the algorithm that ships with PHP, or the algorithm \n * found in the Perl <a href=\"http://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm\">Text:Metaphone-1.96</a>.\n * They have had undocumented changes from the originally published algorithm. \n * </p>\n * \n * @author Apache Software Foundation\n * @version $Id$\n */\npublic class Metaphone implements StringEncoder {\n\n    /**\n     * Five values in the English language \n     */\n    private static final String VOWELS = \"AEIOU\" ;\n\n    /**\n     * Variable used in Metaphone algorithm\n     */\n    private static final String FRONTV = \"EIY\"   ;\n\n    /**\n     * Variable used in Metaphone algorithm\n     */\n    private static final String VARSON = \"CSPTG\" ;\n\n    /**\n     * The max code length for metaphone is 4\n     */\n    private int maxCodeLen = 4 ;\n\n    /**\n     * Creates an instance of the Metaphone encoder\n     */\n    public Metaphone() {\n        super();\n    }\n\n    /**\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     */\n    public String metaphone(String txt) {\n        boolean hard = false ;\n        if ((txt == null) || (txt.length() == 0)) {\n            return \"\" ;\n        }\n        // single character is itself\n        if (txt.length() == 1) {\n            return txt.toUpperCase() ;\n        }\n      \n        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n      \n        StringBuffer local = new StringBuffer(40); // manipulate\n        StringBuffer code = new StringBuffer(10) ; //   output\n        // handle initial 2 characters exceptions\n        switch(inwd[0]) {\n        case 'K' : \n        case 'G' : \n        case 'P' : /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A': /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W' : /* looking for WR or WH */\n            if (inwd[1] == 'R') {   // WR -> R\n                local.append(inwd, 1, inwd.length - 1); \n                break ;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, 'W'); // WH -> W\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X' : /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break ;\n        default :\n            local.append(inwd);\n        } // now local has working string with initials fixed\n\n        int wdsz = local.length();\n        int n = 0 ;\n\n        while ((code.length() < this.getMaxCodeLen()) && \n        \t   (n < wdsz) ) { // max code size of 4 works well\n            char symb = local.charAt(n) ;\n            // remove duplicate letters except C\n            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                n++ ;\n            } else { // not dup\n                switch(symb) {\n                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                    if (n == 0) { \n                        code.append(symb);\n                    }\n                    break ; // only use vowel if leading char\n                case 'B' :\n                    if ( isPreviousChar(local, n, 'M') && \n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n\t\t\t\t\t\tbreak;\n                    }\n                    code.append(symb);\n                    break;\n                case 'C' : // lots of C special cases\n                    /* discard if SCI, SCE or SCY */\n                    if ( isPreviousChar(local, n, 'S') && \n                         !isLastChar(wdsz, n) && \n                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { \n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n                        code.append('X'); \n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                        break; // CI,CE,CY -> S\n                    }\n                    if (isPreviousChar(local, n, 'S') &&\n\t\t\t\t\t\tisNextChar(local, n, 'H') ) { // SCH->sk\n                        code.append('K') ; \n                        break ;\n                    }\n                    if (isNextChar(local, n, 'H')) { // detect CH\n                        if ((n == 0) && \n                        \t(wdsz >= 3) && \n                            isVowel(local,2) ) { // CH consonant -> K consonant\n                            code.append('K');\n                        } else { \n                            code.append('X'); // CHvowel -> X\n                        }\n                    } else { \n                        code.append('K');\n                    }\n                    break ;\n                case 'D' :\n                    if (!isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'G') && \n                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                        code.append('J'); n += 2 ;\n                    } else { \n                        code.append('T');\n                    }\n                    break ;\n                case 'G' : // GH silent at end or before consonant\n                    if (isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&  \n                        isNextChar(local,n,'H') && \n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if ((n > 0) && \n                    \t( regionMatch(local, n, \"GN\") ||\n\t\t\t\t\t      regionMatch(local, n, \"GNED\") ) ) {\n                        break; // silent G\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        hard = true ;\n                    } else {\n                        hard = false ;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && \n                        (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break ;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        break ; // terminal H\n                    }\n                    if ((n > 0) && \n                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append('H'); // Hvowel\n                    }\n                    break;\n                case 'F': \n                case 'J' : \n                case 'L' :\n                case 'M': \n                case 'N' : \n                case 'R' :\n                    code.append(symb); \n                    break;\n                case 'K' :\n                    if (n > 0) { // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); // initial K\n                    }\n                    break ;\n                case 'P' :\n                    if (isNextChar(local,n,'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'Q' :\n                    code.append('K');\n                    break;\n                case 'S' :\n                    if (regionMatch(local,n,\"SH\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIO\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T' :\n                    if (regionMatch(local,n,\"TIA\") || \n\t\t\t\t\t\tregionMatch(local,n,\"TIO\")) {\n                        code.append('X'); \n                        break;\n                    }\n                    if (regionMatch(local,n,\"TCH\")) {\n\t\t\t\t\t\t// Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local,n,\"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break ;\n                case 'V' :\n                    code.append('F'); break ;\n                case 'W' : case 'Y' : // silent if not followed by vowel\n                    if (!isLastChar(wdsz,n) && \n                    \tisVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'X' :\n                    code.append('K'); code.append('S');\n                    break ;\n                case 'Z' :\n                    code.append('S'); break ;\n                } // end switch\n                n++ ;\n            } // end else from symb != 'C'\n            if (code.length() > this.getMaxCodeLen()) { \n            \tcode.setLength(this.getMaxCodeLen()); \n            }\n        }\n        return code.toString();\n    }\n\n\tprivate boolean isVowel(StringBuffer string, int index) {\n\t\treturn VOWELS.indexOf(string.charAt(index)) >= 0;\n\t}\n\n\tprivate boolean isPreviousChar(StringBuffer string, int index, char c) {\n\t\tboolean matches = false;\n\t\tif( index > 0 &&\n\t\t    index < string.length() ) {\n\t\t\tmatches = string.charAt(index - 1) == c;\n\t\t}\n\t\treturn matches;\n\t}\n\n\tprivate boolean isNextChar(StringBuffer string, int index, char c) {\n\t\tboolean matches = false;\n\t\tif( index >= 0 &&\n\t\t    index < string.length() - 1 ) {\n\t\t\tmatches = string.charAt(index + 1) == c;\n\t\t}\n\t\treturn matches;\n\t}\n\n\tprivate boolean regionMatch(StringBuffer string, int index, String test) {\n\t\tboolean matches = false;\n\t\tif( index >= 0 &&\n\t\t    (index + test.length() - 1) < string.length() ) {\n\t\t\tString substring = string.substring( index, index + test.length());\n\t\t\tmatches = substring.equals( test );\n\t\t}\n\t\treturn matches;\n\t}\n\n\tprivate boolean isLastChar(int wdsz, int n) {\n\t\treturn n + 1 == wdsz;\n\t} \n    \n    \n    /**\n     * Encodes an Object using the metaphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         metaphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof java.lang.String)) {\n            throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\"); \n        }\n        return metaphone((String) pObject);\n    }\n\n    /**\n     * Encodes a String using the Metaphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The metaphone code corresponding to the String supplied\n     */\n    public String encode(String pString) {\n        return metaphone(pString);   \n    }\n\n    /**\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the metaphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     */\n    public boolean isMetaphoneEqual(String str1, String str2) {\n        return metaphone(str1).equals(metaphone(str2));\n    }\n\n    /**\n     * Returns the maxCodeLen.\n     * @return int\n     */\n    public int getMaxCodeLen() { return this.maxCodeLen; }\n\n    /**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */\n    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a metaphone value. \n * <p>\n * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>. \n * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.\n * </p>\n * <p>\n * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990, p\n * 39.</CITE>\n * </p>\n * <p>\n * Note, that this does not match the algorithm that ships with PHP, or the algorithm \n * found in the Perl <a href=\"http://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm\">Text:Metaphone-1.96</a>.\n * They have had undocumented changes from the originally published algorithm. \n * </p>\n * \n * @author Apache Software Foundation\n * @version $Id$\n */\npublic class Metaphone implements StringEncoder {\n\n    /**\n     * Five values in the English language \n     */\n    private static final String VOWELS = \"AEIOU\" ;\n\n    /**\n     * Variable used in Metaphone algorithm\n     */\n    private static final String FRONTV = \"EIY\"   ;\n\n    /**\n     * Variable used in Metaphone algorithm\n     */\n    private static final String VARSON = \"CSPTG\" ;\n\n    /**\n     * The max code length for metaphone is 4\n     */\n    private int maxCodeLen = 4 ;\n\n    /**\n     * Creates an instance of the Metaphone encoder\n     */\n    public Metaphone() {\n        super();\n    }\n\n    /**\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     */\n    public String metaphone(String txt) {\n        boolean hard = false ;\n        if ((txt == null) || (txt.length() == 0)) {\n            return \"\" ;\n        }\n        // single character is itself\n        if (txt.length() == 1) {\n            return txt.toUpperCase(java.util.Locale.ENGLISH) ;\n        }\n      \n        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n      \n        StringBuffer local = new StringBuffer(40); // manipulate\n        StringBuffer code = new StringBuffer(10) ; //   output\n        // handle initial 2 characters exceptions\n        switch(inwd[0]) {\n        case 'K' : \n        case 'G' : \n        case 'P' : /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A': /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W' : /* looking for WR or WH */\n            if (inwd[1] == 'R') {   // WR -> R\n                local.append(inwd, 1, inwd.length - 1); \n                break ;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, 'W'); // WH -> W\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X' : /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break ;\n        default :\n            local.append(inwd);\n        } // now local has working string with initials fixed\n\n        int wdsz = local.length();\n        int n = 0 ;\n\n        while ((code.length() < this.getMaxCodeLen()) && \n        \t   (n < wdsz) ) { // max code size of 4 works well\n            char symb = local.charAt(n) ;\n            // remove duplicate letters except C\n            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                n++ ;\n            } else { // not dup\n                switch(symb) {\n                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                    if (n == 0) { \n                        code.append(symb);\n                    }\n                    break ; // only use vowel if leading char\n                case 'B' :\n                    if ( isPreviousChar(local, n, 'M') && \n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n\t\t\t\t\t\tbreak;\n                    }\n                    code.append(symb);\n                    break;\n                case 'C' : // lots of C special cases\n                    /* discard if SCI, SCE or SCY */\n                    if ( isPreviousChar(local, n, 'S') && \n                         !isLastChar(wdsz, n) && \n                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { \n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n                        code.append('X'); \n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                        break; // CI,CE,CY -> S\n                    }\n                    if (isPreviousChar(local, n, 'S') &&\n\t\t\t\t\t\tisNextChar(local, n, 'H') ) { // SCH->sk\n                        code.append('K') ; \n                        break ;\n                    }\n                    if (isNextChar(local, n, 'H')) { // detect CH\n                        if ((n == 0) && \n                        \t(wdsz >= 3) && \n                            isVowel(local,2) ) { // CH consonant -> K consonant\n                            code.append('K');\n                        } else { \n                            code.append('X'); // CHvowel -> X\n                        }\n                    } else { \n                        code.append('K');\n                    }\n                    break ;\n                case 'D' :\n                    if (!isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'G') && \n                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                        code.append('J'); n += 2 ;\n                    } else { \n                        code.append('T');\n                    }\n                    break ;\n                case 'G' : // GH silent at end or before consonant\n                    if (isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&  \n                        isNextChar(local,n,'H') && \n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if ((n > 0) && \n                    \t( regionMatch(local, n, \"GN\") ||\n\t\t\t\t\t      regionMatch(local, n, \"GNED\") ) ) {\n                        break; // silent G\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        hard = true ;\n                    } else {\n                        hard = false ;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && \n                        (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break ;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        break ; // terminal H\n                    }\n                    if ((n > 0) && \n                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append('H'); // Hvowel\n                    }\n                    break;\n                case 'F': \n                case 'J' : \n                case 'L' :\n                case 'M': \n                case 'N' : \n                case 'R' :\n                    code.append(symb); \n                    break;\n                case 'K' :\n                    if (n > 0) { // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); // initial K\n                    }\n                    break ;\n                case 'P' :\n                    if (isNextChar(local,n,'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'Q' :\n                    code.append('K');\n                    break;\n                case 'S' :\n                    if (regionMatch(local,n,\"SH\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIO\") || \n\t\t\t\t\t    regionMatch(local,n,\"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T' :\n                    if (regionMatch(local,n,\"TIA\") || \n\t\t\t\t\t\tregionMatch(local,n,\"TIO\")) {\n                        code.append('X'); \n                        break;\n                    }\n                    if (regionMatch(local,n,\"TCH\")) {\n\t\t\t\t\t\t// Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local,n,\"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break ;\n                case 'V' :\n                    code.append('F'); break ;\n                case 'W' : case 'Y' : // silent if not followed by vowel\n                    if (!isLastChar(wdsz,n) && \n                    \tisVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'X' :\n                    code.append('K'); code.append('S');\n                    break ;\n                case 'Z' :\n                    code.append('S'); break ;\n                } // end switch\n                n++ ;\n            } // end else from symb != 'C'\n            if (code.length() > this.getMaxCodeLen()) { \n            \tcode.setLength(this.getMaxCodeLen()); \n            }\n        }\n        return code.toString();\n    }\n\n\tprivate boolean isVowel(StringBuffer string, int index) {\n\t\treturn VOWELS.indexOf(string.charAt(index)) >= 0;\n\t}\n\n\tprivate boolean isPreviousChar(StringBuffer string, int index, char c) {\n\t\tboolean matches = false;\n\t\tif( index > 0 &&\n\t\t    index < string.length() ) {\n\t\t\tmatches = string.charAt(index - 1) == c;\n\t\t}\n\t\treturn matches;\n\t}\n\n\tprivate boolean isNextChar(StringBuffer string, int index, char c) {\n\t\tboolean matches = false;\n\t\tif( index >= 0 &&\n\t\t    index < string.length() - 1 ) {\n\t\t\tmatches = string.charAt(index + 1) == c;\n\t\t}\n\t\treturn matches;\n\t}\n\n\tprivate boolean regionMatch(StringBuffer string, int index, String test) {\n\t\tboolean matches = false;\n\t\tif( index >= 0 &&\n\t\t    (index + test.length() - 1) < string.length() ) {\n\t\t\tString substring = string.substring( index, index + test.length());\n\t\t\tmatches = substring.equals( test );\n\t\t}\n\t\treturn matches;\n\t}\n\n\tprivate boolean isLastChar(int wdsz, int n) {\n\t\treturn n + 1 == wdsz;\n\t} \n    \n    \n    /**\n     * Encodes an Object using the metaphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         metaphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof java.lang.String)) {\n            throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\"); \n        }\n        return metaphone((String) pObject);\n    }\n\n    /**\n     * Encodes a String using the Metaphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The metaphone code corresponding to the String supplied\n     */\n    public String encode(String pString) {\n        return metaphone(pString);   \n    }\n\n    /**\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the metaphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     */\n    public boolean isMetaphoneEqual(String str1, String str2) {\n        return metaphone(str1).equals(metaphone(str2));\n    }\n\n    /**\n     * Returns the maxCodeLen.\n     * @return int\n     */\n    public int getMaxCodeLen() { return this.maxCodeLen; }\n\n    /**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */\n    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\n\n}\n"}, {"class_name": "org.apache.commons.codec.language.SoundexUtils", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.\n * \n * @author Apache Software Foundation\n * @version $Id$\n * @since 1.3\n */\nfinal class SoundexUtils {\n\n    /**\n\t * Cleans up the input string before Soundex processing by only returning\n\t * upper case letters.\n\t * \n\t * @param str\n\t *                  The String to clean.\n\t * @return A clean String.\n\t */\n    static String clean(String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        int len = str.length();\n        char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase();\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }\n\n    /**\n\t * Encodes the Strings and returns the number of characters in the two\n\t * encoded Strings that are the same.\n\t * <ul>\n\t * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n\t * little or no similarity, and 4 indicates strong similarity or identical\n\t * values.</li>\n\t * <li>For refined Soundex, the return value can be greater than 4.</li>\n\t * </ul>\n\t * \n\t * @param encoder\n\t *                  The encoder to use to encode the Strings.\n\t * @param s1\n\t *                  A String that will be encoded and compared.\n\t * @param s2\n\t *                  A String that will be encoded and compared.\n\t * @return The number of characters in the two Soundex encoded Strings that\n\t *             are the same.\n\t * \n\t * @see #differenceEncoded(String,String)\n\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n\t *          MS T-SQL DIFFERENCE</a>\n\t * \n\t * @throws EncoderException\n\t *                  if an error occurs encoding one of the strings\n\t */\n    static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n    }\n\n    /**\n\t * Returns the number of characters in the two Soundex encoded Strings that\n\t * are the same.\n\t * <ul>\n\t * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n\t * little or no similarity, and 4 indicates strong similarity or identical\n\t * values.</li>\n\t * <li>For refined Soundex, the return value can be greater than 4.</li>\n\t * </ul>\n\t * \n\t * @param es1\n\t *                  An encoded String.\n\t * @param es2\n\t *                  An encoded String.\n\t * @return The number of characters in the two Soundex encoded Strings that\n\t *             are the same.\n\t * \n\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n\t *          MS T-SQL DIFFERENCE</a>\n\t */\n    static int differenceEncoded(String es1, String es2) {\n\n        if (es1 == null || es2 == null) {\n            return 0;\n        }\n        int lengthToMatch = Math.min(es1.length(), es2.length());\n        int diff = 0;\n        for (int i = 0; i < lengthToMatch; i++) {\n            if (es1.charAt(i) == es2.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.\n * \n * @author Apache Software Foundation\n * @version $Id$\n * @since 1.3\n */\nfinal class SoundexUtils {\n\n    /**\n\t * Cleans up the input string before Soundex processing by only returning\n\t * upper case letters.\n\t * \n\t * @param str\n\t *                  The String to clean.\n\t * @return A clean String.\n\t */\n    static String clean(String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        int len = str.length();\n        char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }\n\n    /**\n\t * Encodes the Strings and returns the number of characters in the two\n\t * encoded Strings that are the same.\n\t * <ul>\n\t * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n\t * little or no similarity, and 4 indicates strong similarity or identical\n\t * values.</li>\n\t * <li>For refined Soundex, the return value can be greater than 4.</li>\n\t * </ul>\n\t * \n\t * @param encoder\n\t *                  The encoder to use to encode the Strings.\n\t * @param s1\n\t *                  A String that will be encoded and compared.\n\t * @param s2\n\t *                  A String that will be encoded and compared.\n\t * @return The number of characters in the two Soundex encoded Strings that\n\t *             are the same.\n\t * \n\t * @see #differenceEncoded(String,String)\n\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n\t *          MS T-SQL DIFFERENCE</a>\n\t * \n\t * @throws EncoderException\n\t *                  if an error occurs encoding one of the strings\n\t */\n    static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n    }\n\n    /**\n\t * Returns the number of characters in the two Soundex encoded Strings that\n\t * are the same.\n\t * <ul>\n\t * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n\t * little or no similarity, and 4 indicates strong similarity or identical\n\t * values.</li>\n\t * <li>For refined Soundex, the return value can be greater than 4.</li>\n\t * </ul>\n\t * \n\t * @param es1\n\t *                  An encoded String.\n\t * @param es2\n\t *                  An encoded String.\n\t * @return The number of characters in the two Soundex encoded Strings that\n\t *             are the same.\n\t * \n\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n\t *          MS T-SQL DIFFERENCE</a>\n\t */\n    static int differenceEncoded(String es1, String es2) {\n\n        if (es1 == null || es2 == null) {\n            return 0;\n        }\n        int lengthToMatch = Math.min(es1.length(), es2.length());\n        int diff = 0;\n        for (int i = 0; i < lengthToMatch; i++) {\n            if (es1.charAt(i) == es2.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff;\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 2, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0-dev\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer\n     * index values into their \"Base64 Alphabet\" equivalents as specified\n     * in Table 1 of RFC 2045.\n     *\n     * Thanks to \"commons\" project in ws.apache.org for this code. \n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters\n     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n     * into their 6-bit positive integer equivalents.  Characters that\n     * are not in the Base64 alphabet but fall within the bounds of the\n     * array are translated to -1.\n     *\n     * Note:  '+' and '-' both decode to 62.  '/' and '_' both decode to 63.\n     * This means decoder seamlessly handles both URL_SAFE and STANDARD base64.\n     * (The encoder, on the other hand, needs to know ahead of time what to emit).\n     *\n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use:  either STANDARD or URL_SAFE.  Note:  the DECODE_TABLE above remains static\n     * because it is able to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member\n     * variable so we can switch between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding.  Not used when decoding.  A value of zero or less implies\n     * no chunking of the base64 encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of\n     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of\n     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming. \n     */\n    private byte[] buf;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line.\n     * Only used when encoding.  We use it to make sure each encoded line never\n     * goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an\n     * every 4 reads when decoding.  This variable helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached.  Once EOF has been\n     * reached, this Base64 object becomes useless, and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic.\n     * Bitwise operations store and extract the base64 encoding or decoding from\n     * this variable.\n     */\n    private int x;\n\n    /**\n     * Sets state for decoding and encoding.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and we use the STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants can be decoded.\n     * </p>\n     */\n    public Base64() {\n        this(false);\n    }\n\n    /**\n     * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is\n     * supplied.\n     * \n     * When decoding: all variants can be decoded.\n     * \n     * @param urlSafe\n     *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * <p>\n     * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.\n     * </p>\n     * <p>\n     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n     * data.\n     * </p>\n     * \n     * @param lineLength\n     *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If\n     *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * <p>\n     * Sets the line length and line separator when encoding. All forms of data can be decoded.\n     * </p>\n     * <p>\n     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n     * data.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored\n     *            when decoding. If <= 0, then output will not be divided into lines (chunks).\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * <p>\n     * Consumer can use this constructor to choose a different lineLength,\n     * lineSeparator, and whether to use URL-SAFE mode when encoding.\n     * All forms of data can be decoded.\n     * </p><p>\n     * Note:  lineLengths that aren't multiples of 4 will still essentially\n     * end up being multiples of 4 in the encoded data.\n     * </p>\n     * @param lineLength    Each line of encoded data will be at most this long\n     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.\n     *                      If <= 0, then output will not be divided into lines (chunks).\n     * @param lineSeparator Each line of encoded data will end with this\n     *                      sequence of bytes.\n     *                      If lineLength <= 0, then the lineSeparator is not used.\n     * @param urlSafe       Instead of emitting '+' and '/' we emit '-' and '_' respectively.\n     *                      urlSafe is only applied to \"encode\" operations.  Decoding seamlessly\n     *                      handles both modes.\n     *\n     * @throws IllegalArgumentException The provided lineSeparator included\n     *                                  some base64 characters.  That's not going to work!\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        this.lineLength = lineLength;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep;\n            try {\n                sep = new String(lineSeparator, \"UTF-8\");\n            } catch (UnsupportedEncodingException uee) {\n                sep = new String(lineSeparator);\n            }\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buf != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buf != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuf() {\n        if (buf == null) {\n            buf = new byte[8192];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buf.length * 2];\n            System.arraycopy(buf, 0, b, 0, buf.length);\n            buf = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting\n     * at position bPos, up to a maximum of bAvail bytes.  Returns how\n     * many bytes were actually extracted.\n     *\n     * @param b      byte[] array to extract the buffered data into.\n     * @param bPos   position in byte[] array to start extraction at.\n     * @param bAvail amount of bytes we're allowed to extract.  We may extract\n     *               fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided\n     *         byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buf != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buf != b) {\n                System.arraycopy(buf, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buf = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buf = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out byte[] array to buffer directly to.\n     * @param outPos Position to start buffering into.\n     * @param outAvail Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buf = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Must be called at least twice:  once with the data to encode, and once\n     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n     * so flush last remaining bytes (if not multiple of 3).\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in byte[] array of binary data to base64 encode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Should be called at least twice:  once with the data to decode, and once\n     * with inAvail set to \"-1\" to alert decoder that EOF has been reached.\n     * The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n     * </p><p>\n     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)\n     * data is handled, since CR and LF are silently ignored, but has implications\n     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out\n     * philosophy:  it will not check the provided data for validity.\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n\n     * @param in byte[] array of ascii data to base64 decode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */    \n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < decodeSize) {\n                resizeBuf();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // WE'RE DONE!!!!\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buf[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned:  actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2:\n                    x = x << 6;\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3:\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * Currently the method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.\n     * The url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n        }\n        return decode((byte[]) pObject);\n    }\n\n    /**\n     * Decodes a byte[] containing containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        return decodeBase64(pArray);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        long len = (binaryData.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (isChunked) {\n            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n        }\n        if (len > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.encode(binaryData, 0, binaryData.length);\n        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (b64.buf != buf) {\n            b64.readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (urlSafe && b64.pos < buf.length) {\n            byte[] smallerBuf = new byte[b64.pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n            buf = smallerBuf;\n        }\n        return buf;\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        if (base64Data == null || base64Data.length == 0) {\n            return base64Data;\n        }\n        Base64 b64 = new Base64();\n        long len = (base64Data.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.decode(base64Data, 0, base64Data.length);\n        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n        // We have no idea what the line-length was, so we\n        // cannot know how much of our array wasn't used.\n        byte[] result = new byte[b64.pos];\n        b64.readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     * \n     * @param data\n     *            The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            if (isBase64(data[i])) {\n                groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        return encodeBase64(pArray, false, isUrlSafe());\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto\n     * standards such as W3C's XML-Signature\n     * \n     * @param pArray a byte array containing base64 character data\n     * @return A BigInteger\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto\n     * standards such as W3C's XML-Signature\n     * \n     * @param bigInt a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException if null is passed in\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if(bigInt == null)  {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code>\n     * without sign bit.\n     *\n     * @param bigInt <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n     static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if(((bigInt.bitLength() % 8) != 0) &&\n            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0-dev\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer\n     * index values into their \"Base64 Alphabet\" equivalents as specified\n     * in Table 1 of RFC 2045.\n     *\n     * Thanks to \"commons\" project in ws.apache.org for this code. \n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters\n     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n     * into their 6-bit positive integer equivalents.  Characters that\n     * are not in the Base64 alphabet but fall within the bounds of the\n     * array are translated to -1.\n     *\n     * Note:  '+' and '-' both decode to 62.  '/' and '_' both decode to 63.\n     * This means decoder seamlessly handles both URL_SAFE and STANDARD base64.\n     * (The encoder, on the other hand, needs to know ahead of time what to emit).\n     *\n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use:  either STANDARD or URL_SAFE.  Note:  the DECODE_TABLE above remains static\n     * because it is able to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member\n     * variable so we can switch between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding.  Not used when decoding.  A value of zero or less implies\n     * no chunking of the base64 encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of\n     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of\n     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming. \n     */\n    private byte[] buf;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line.\n     * Only used when encoding.  We use it to make sure each encoded line never\n     * goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an\n     * every 4 reads when decoding.  This variable helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached.  Once EOF has been\n     * reached, this Base64 object becomes useless, and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic.\n     * Bitwise operations store and extract the base64 encoding or decoding from\n     * this variable.\n     */\n    private int x;\n\n    /**\n     * Sets state for decoding and encoding.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and we use the STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants can be decoded.\n     * </p>\n     */\n    public Base64() {\n        this(false);\n    }\n\n    /**\n     * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is\n     * supplied.\n     * \n     * When decoding: all variants can be decoded.\n     * \n     * @param urlSafe\n     *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * <p>\n     * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.\n     * </p>\n     * <p>\n     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n     * data.\n     * </p>\n     * \n     * @param lineLength\n     *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If\n     *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * <p>\n     * Sets the line length and line separator when encoding. All forms of data can be decoded.\n     * </p>\n     * <p>\n     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n     * data.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored\n     *            when decoding. If <= 0, then output will not be divided into lines (chunks).\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * <p>\n     * Consumer can use this constructor to choose a different lineLength,\n     * lineSeparator, and whether to use URL-SAFE mode when encoding.\n     * All forms of data can be decoded.\n     * </p><p>\n     * Note:  lineLengths that aren't multiples of 4 will still essentially\n     * end up being multiples of 4 in the encoded data.\n     * </p>\n     * @param lineLength    Each line of encoded data will be at most this long\n     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.\n     *                      If <= 0, then output will not be divided into lines (chunks).\n     * @param lineSeparator Each line of encoded data will end with this\n     *                      sequence of bytes.\n     *                      If lineLength <= 0, then the lineSeparator is not used.\n     * @param urlSafe       Instead of emitting '+' and '/' we emit '-' and '_' respectively.\n     *                      urlSafe is only applied to \"encode\" operations.  Decoding seamlessly\n     *                      handles both modes.\n     *\n     * @throws IllegalArgumentException The provided lineSeparator included\n     *                                  some base64 characters.  That's not going to work!\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        this.lineLength = lineLength;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep;\n            try {\n                sep = new String(lineSeparator, \"UTF-8\");\n            } catch (UnsupportedEncodingException uee) {\n                sep = new String(lineSeparator);\n            }\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buf != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buf != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuf() {\n        if (buf == null) {\n            buf = new byte[8192];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buf.length * 2];\n            System.arraycopy(buf, 0, b, 0, buf.length);\n            buf = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting\n     * at position bPos, up to a maximum of bAvail bytes.  Returns how\n     * many bytes were actually extracted.\n     *\n     * @param b      byte[] array to extract the buffered data into.\n     * @param bPos   position in byte[] array to start extraction at.\n     * @param bAvail amount of bytes we're allowed to extract.  We may extract\n     *               fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided\n     *         byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buf != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buf != b) {\n                System.arraycopy(buf, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buf = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buf = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out byte[] array to buffer directly to.\n     * @param outPos Position to start buffering into.\n     * @param outAvail Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buf = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Must be called at least twice:  once with the data to encode, and once\n     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n     * so flush last remaining bytes (if not multiple of 3).\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in byte[] array of binary data to base64 encode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Should be called at least twice:  once with the data to decode, and once\n     * with inAvail set to \"-1\" to alert decoder that EOF has been reached.\n     * The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n     * </p><p>\n     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)\n     * data is handled, since CR and LF are silently ignored, but has implications\n     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out\n     * philosophy:  it will not check the provided data for validity.\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n\n     * @param in byte[] array of ascii data to base64 decode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */    \n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < decodeSize) {\n                resizeBuf();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // WE'RE DONE!!!!\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buf[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned:  actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2:\n                    x = x << 6;\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3:\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * Currently the method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n     *         empty; false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.\n     * The url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n        }\n        return decode((byte[]) pObject);\n    }\n\n    /**\n     * Decodes a byte[] containing containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        return decodeBase64(pArray);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        long len = (binaryData.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (isChunked) {\n            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n        }\n        if (len > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.encode(binaryData, 0, binaryData.length);\n        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (b64.buf != buf) {\n            b64.readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (urlSafe && b64.pos < buf.length) {\n            byte[] smallerBuf = new byte[b64.pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n            buf = smallerBuf;\n        }\n        return buf;\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        if (base64Data == null || base64Data.length == 0) {\n            return base64Data;\n        }\n        Base64 b64 = new Base64();\n        long len = (base64Data.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.decode(base64Data, 0, base64Data.length);\n        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n        // We have no idea what the line-length was, so we\n        // cannot know how much of our array wasn't used.\n        byte[] result = new byte[b64.pos];\n        b64.readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    /**\n     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n     * \n     * @param data\n     *            The base-64 encoded data to groom\n     * @return The data, less non-base64 characters (see RFC 2045).\n     */\n    static byte[] discardNonBase64(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            if (isBase64(data[i])) {\n                groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        return encodeBase64(pArray, false, isUrlSafe());\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto\n     * standards such as W3C's XML-Signature\n     * \n     * @param pArray a byte array containing base64 character data\n     * @return A BigInteger\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto\n     * standards such as W3C's XML-Signature\n     * \n     * @param bigInt a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException if null is passed in\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if(bigInt == null)  {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code>\n     * without sign bit.\n     *\n     * @param bigInt <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n     static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if(((bigInt.bitLength() % 8) != 0) &&\n            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 3, "classes_modified": [{"class_name": "org.apache.commons.codec.language.DoubleMetaphone", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a double metaphone value.\n * This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>.\n * <ul>\n * <li>Original Article: <a \n * href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\">\n * http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li>\n * <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\">\n * ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li>\n * </ul>\n * \n * @author Apache Software Foundation\n * @version $Id$\n */\npublic class DoubleMetaphone implements StringEncoder {\n\n    /**\n     * \"Vowels\" to test for\n     */\n    private static final String VOWELS = \"AEIOUY\";\n\n    /**\n     * Prefixes when present which are not pronounced\n     */\n    private static final String[] SILENT_START = \n    { \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };\n    private static final String[] L_R_N_M_B_H_F_V_W_SPACE = \n    { \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = \n    { \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n    private static final String[] L_T_K_S_N_M_B_Z = \n    { \"L\", \"T\", \"K\", \"S\", \"N\", \"M\", \"B\", \"Z\" };\n\n    /**\n     * Maximum length of an encoding, default is 4\n     */\n    protected int maxCodeLen = 4;\n\n    /**\n     * Creates an instance of this DoubleMetaphone encoder\n     */\n    public DoubleMetaphone() {\n        super();\n    }\n    \n    /**\n     * Encode a value with Double Metaphone\n     *\n     * @param value String to encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(String value) {\n        return doubleMetaphone(value, false);\n    }\n    \n    /**\n     * Encode a value with Double Metaphone, optionally using the alternate\n     * encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(String value, boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n        \n        boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n        \n        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n        \n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(value, result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break; \n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }\n    \n    /**\n     * Encode the value using DoubleMetaphone.  It will only work if \n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     */\n    public Object encode(Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\"); \n        } \n        return doubleMetaphone((String) obj);\n    }\n\n    /**\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     */\n    public String encode(String value) {\n        return doubleMetaphone(value);   \n    }\n\n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal.\n     * \n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     */\n    public boolean isDoubleMetaphoneEqual(String value1, String value2) {\n        return isDoubleMetaphoneEqual(value1, value2, false);\n    }\n    \n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     * \n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if <code>true</code>.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     */\n    public boolean isDoubleMetaphoneEqual(String value1, \n                                          String value2, \n                                          boolean alternate) {\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone\n                                                         (value2, alternate));\n    }\n    \n    /**\n     * Returns the maxCodeLen.\n     * @return int\n     */\n    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }\n\n    /**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */\n    public void setMaxCodeLen(int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }\n\n    //-- BEGIN HANDLERS --//\n\n    /**\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases\n     */\n    private int handleAEIOUY(String value, DoubleMetaphoneResult result, int \n                             index) {\n        if (index == 0) {\n            result.append('A');\n        }\n        return index + 1;\n    }\n    \n    /**\n     * Handles 'C' cases\n     */\n    private int handleC(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (conditionC0(value, index)) {  // very confusing, moved out\n            result.append('K');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n            result.append('S');\n            index += 2;\n        } else if (contains(value, index, 2, \"CH\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"CZ\") && \n                   !contains(value, index - 2, 4, \"WICZ\")) {\n            //-- \"Czerny\" --//\n            result.append('S', 'X');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\n            //-- \"focaccia\" --//\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"CC\") && \n                   !(index == 1 && charAt(value, 0) == 'M')) {\n            //-- double \"cc\" but not \"McClelland\" --//\n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n            result.append('K');\n            index += 2;\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n            //-- Italian vs. English --//\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n                result.append('S', 'X');\n            } else {\n                result.append('S');\n            }\n            index += 2;\n        } else {\n            result.append('K');\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) { \n                //-- Mac Caffrey, Mac Gregor --//\n                index += 3;\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && \n                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n        \n        return index;\n    }\n\n    /**\n     * Handles 'CC' cases\n     */\n    private int handleCC(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") && \n            !contains(value, index + 2, 2, \"HU\")) {\n            //-- \"bellocchio\" but not \"bacchus\" --//\n            if ((index == 1 && charAt(value, index - 1) == 'A') || \n                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n                //-- \"accident\", \"accede\", \"succeed\" --//\n                result.append(\"KS\");\n            } else {\n                //-- \"bacci\", \"bertucci\", other Italian --//\n                result.append('X');\n            }\n            index += 3;\n        } else {    // Pierce's rule\n            result.append('K');\n            index += 2;\n        }\n        \n        return index;\n    }\n    \n    /**\n     * Handles 'CH' cases\n     */\n    private int handleCH(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n            result.append('K', 'X');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n            result.append('K');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n            result.append('K');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"MC\")) {\n                    result.append('K');\n                } else {\n                    result.append('X', 'K');\n                }\n            } else {\n                result.append('X');\n            }\n            return index + 2;\n        }\n    }\n\n    /**\n     * Handles 'D' cases\n     */\n    private int handleD(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 2, \"DG\")) {\n            //-- \"Edge\" --//\n            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n                result.append('J');\n                index += 3;\n                //-- \"Edgar\" --//\n            } else {\n                result.append(\"TK\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n            result.append('T');\n            index += 2;\n        } else {\n            result.append('T');\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'G' cases\n     */\n    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 4, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n     */\n    private int handleGH(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('K');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == 'I') {\n                result.append('J');\n            } else {\n                result.append('K');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n            //-- Parker's rule (with some further refinements) - \"hugh\"\n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == 'U' && \n                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n                result.append('F');\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n                result.append('K');\n            }\n            index += 2;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'H' cases\n     */\n    private int handleH(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        //-- only keep if first & before vowel or between 2 vowels --//\n        if ((index == 0 || isVowel(charAt(value, index - 1))) && \n            isVowel(charAt(value, index + 1))) {\n            result.append('H');\n            index += 2;\n            //-- also takes car of \"HH\" --//\n        } else {\n            index++;\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'J' cases\n     */\n    private int handleJ(String value, DoubleMetaphoneResult result, int index, \n                        boolean slavoGermanic) {\n        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                if ((index == 0 && (charAt(value, index + 4) == ' ') || \n                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n                    result.append('H');\n                } else {\n                    result.append('J', 'H');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n                    result.append('J', 'A');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && \n                              (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n                    result.append('J', 'H');\n                } else if (index == value.length() - 1) {\n                    result.append('J', ' ');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n                    result.append('J');\n                }\n\n                if (charAt(value, index + 1) == 'J') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }\n    \n    /**\n     * Handles 'L' cases\n     */\n    private int handleL(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (charAt(value, index + 1) == 'L') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('L');\n            } else {\n                result.append('L');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('L');\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'P' cases\n     */\n    private int handleP(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (charAt(value, index + 1) == 'H') {\n            result.append('F');\n            index += 2;\n        } else {\n            result.append('P');\n            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'R' cases\n     */\n    private int handleR(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic && \n            contains(value, index - 2, 2, \"IE\") && \n            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n            result.appendAlternate('R');\n        } else {\n            result.append('R');\n        }\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n    }\n\n    /**\n     * Handles 'S' cases\n     */\n    private int handleS(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n            //-- special case \"sugar-\" --//\n            result.append('X', 'S');\n            index++;\n        } else if (contains(value, index, 2, \"SH\")) {\n            if (contains(value, index + 1, 4, \n                         \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n                //-- germanic --//\n                result.append('S');\n            } else {\n                result.append('X');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n            //-- Italian and Armenian --//\n            if (slavoGermanic) {\n                result.append('S');\n            } else {\n                result.append('S', 'X');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n            // \"snider\" match \"schneider\" --//\n            //-- also, -sz- in slavic language altho in hungarian it //\n            //   is pronounced \"s\" --//\n            result.append('S', 'X');\n            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"SC\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, \n                                                        2, \"AI\", \"OI\")){\n                //-- french e.g. \"resnais\", \"artois\" --//\n                result.appendAlternate('S');\n            } else {\n                result.append('S');\n            }\n            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'SC' cases\n     */\n    private int handleSC(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (charAt(value, index + 2) == 'H') {\n            //-- Schlesinger's rule --//\n            if (contains(value, index + 3, \n                         2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n                    //-- \"schermerhorn\", \"schenker\" --//\n                    result.append(\"X\", \"SK\");\n                } else {\n                    result.append(\"SK\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n                    result.append('X', 'S');\n                } else {\n                    result.append('X');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n            result.append('S');\n        } else {\n            result.append(\"SK\");\n        }\n        return index + 3;\n    }\n\n    /**\n     * Handles 'T' cases\n     */\n    private int handleT(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 4, \"TION\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"TH\") || contains(value, index, \n                                                               3, \"TTH\")) {\n            if (contains(value, index + 2, 2, \"OM\", \"AM\") || \n                //-- special case \"thomas\", \"thames\" or germanic --//\n                contains(value, 0, 4, \"VAN \", \"VON \") || \n                contains(value, 0, 3, \"SCH\")) {\n                result.append('T');\n            } else {\n                result.append('0', 'T');\n            }\n            index += 2;\n        } else {\n            result.append('T');\n            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'W' cases\n     */\n    private int handleW(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 2, \"WR\")) {\n            //-- can also be in middle of word --//\n            result.append('R');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) || \n                               contains(value, index, 2, \"WH\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    //-- Wasserman should match Vasserman --//\n                    result.append('A', 'F');\n                } else {\n                    //-- need Uomo to match Womo --//\n                    result.append('A');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, \n                                5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n                       contains(value, 0, 3, \"SCH\")) {\n                //-- Arnow should match Arnoff --//\n                result.appendAlternate('F');\n                index++;\n            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n                //-- Polish e.g. \"filipowicz\" --//\n                result.append(\"TS\", \"FX\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'X' cases\n     */\n    private int handleX(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (index == 0) {\n            result.append('S');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) && \n                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") || \n                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n                //-- French e.g. breaux --//\n                result.append(\"KS\");\n            }\n            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'Z' cases\n     */\n    private int handleZ(String value, DoubleMetaphoneResult result, int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n            result.append('J');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n                result.append(\"S\", \"TS\");\n            } else {\n                result.append('S');\n            }\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    //-- BEGIN CONDITIONS --//\n\n    /**\n     * Complex condition 0 for 'C'\n     */\n    private boolean conditionC0(String value, int index) {\n        if (contains(value, index, 4, \"CHIA\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n            return false;\n        } else {\n            char c = charAt(value, index + 2);\n            return (c != 'I' && c != 'E') ||\n                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n        }\n    }\n    \n    /**\n     * Complex condition 0 for 'CH'\n     */\n    private boolean conditionCH0(String value, int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") && \n                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"CHORE\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n    \n    /**\n     * Complex condition 1 for 'CH'\n     */\n    private boolean conditionCH1(String value, int index) {\n        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, \n                                                                   3, \"SCH\")) ||\n                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                contains(value, index + 2, 1, \"T\", \"S\") ||\n                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }\n    \n    /**\n     * Complex condition 0 for 'L'\n     */\n    private boolean conditionL0(String value, int index) {\n        if (index == value.length() - 3 && \n            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") || \n                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                   contains(value, index - 1, 4, \"ALLE\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    /**\n     * Complex condition 0 for 'M'\n     */\n    private boolean conditionM0(String value, int index) {\n        if (charAt(value, index + 1) == 'M') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"UMB\") &&\n                ((index + 1) == value.length() - 1 || contains(value,\n                        index + 2, 2, \"ER\"));\n    }\n    \n    //-- BEGIN HELPER FUNCTIONS --//\n\n    /**\n     * Determines whether or not a value is of slavo-germanic orgin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     */\n    private boolean isSlavoGermanic(String value) {\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 || \n            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n    }\n\n    /**\n     * Determines whether or not a character is a vowel or not\n     */\n    private boolean isVowel(char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }\n\n    /**\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     */    \n    private boolean isSilentStart(String value) {\n        boolean result = false;\n        for (int i = 0; i < SILENT_START.length; i++) {\n            if (value.startsWith(SILENT_START[i])) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Cleans the input\n     */    \n    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }\n\n    /**\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default\n     */    \n    protected char charAt(String value, int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        } \n        return value.charAt(index);\n    }\n\n    /**\n     * Shortcut method with 1 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria) {\n        return contains(value, start, length, \n                        new String[] { criteria });\n    }\n\n    /**\n     * Shortcut method with 2 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2 });\n    }\n\n    /**\n     * Shortcut method with 3 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3 });\n    }\n\n    /**\n     * Shortcut method with 4 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4 });\n    }\n\n    /**\n     * Shortcut method with 5 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4, \n                                    String criteria5) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4, criteria5 });\n    }\n\n    /**\n     * Shortcut method with 6 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4, \n                                    String criteria5, String criteria6) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4, criteria5, criteria6 });\n    }\n    \n    /**\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>\n     */\n    protected static boolean contains(String value, int start, int length, \n                                      String[] criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            String target = value.substring(start, start + length);\n\n            for (int i = 0; i < criteria.length; i++) {\n                if (target.equals(criteria[i])) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    \n    //-- BEGIN INNER CLASSES --//\n    \n    /**\n     * Inner class for storing results, since there is the optional alternate\n     * encoding.\n     */\n    public class DoubleMetaphoneResult {\n\n        private StringBuffer primary = new StringBuffer(getMaxCodeLen());\n        private StringBuffer alternate = new StringBuffer(getMaxCodeLen());\n        private int maxLength;\n\n        public DoubleMetaphoneResult(int maxLength) {\n            this.maxLength = maxLength;\n        }\n\n        public void append(char value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(char primary, char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(char value) {\n            if (this.primary.length() < this.maxLength) {\n                this.primary.append(value);\n            }\n        }\n\n        public void appendAlternate(char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }\n\n        public void append(String value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(String primary, String alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(String value) {\n            int addChars = this.maxLength - this.primary.length();\n            if (value.length() <= addChars) {\n                this.primary.append(value);\n            } else {\n                this.primary.append(value.substring(0, addChars));\n            }\n        }\n\n        public void appendAlternate(String value) {\n            int addChars = this.maxLength - this.alternate.length();\n            if (value.length() <= addChars) {\n                this.alternate.append(value);\n            } else {\n                this.alternate.append(value.substring(0, addChars));\n            }\n        }\n\n        public String getPrimary() {\n            return this.primary.toString();\n        }\n\n        public String getAlternate() {\n            return this.alternate.toString();\n        }\n\n        public boolean isComplete() {\n            return this.primary.length() >= this.maxLength && \n                this.alternate.length() >= this.maxLength;\n        }\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a double metaphone value.\n * This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>.\n * <ul>\n * <li>Original Article: <a \n * href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\">\n * http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li>\n * <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\">\n * ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li>\n * </ul>\n * \n * @author Apache Software Foundation\n * @version $Id$\n */\npublic class DoubleMetaphone implements StringEncoder {\n\n    /**\n     * \"Vowels\" to test for\n     */\n    private static final String VOWELS = \"AEIOUY\";\n\n    /**\n     * Prefixes when present which are not pronounced\n     */\n    private static final String[] SILENT_START = \n    { \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };\n    private static final String[] L_R_N_M_B_H_F_V_W_SPACE = \n    { \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = \n    { \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n    private static final String[] L_T_K_S_N_M_B_Z = \n    { \"L\", \"T\", \"K\", \"S\", \"N\", \"M\", \"B\", \"Z\" };\n\n    /**\n     * Maximum length of an encoding, default is 4\n     */\n    protected int maxCodeLen = 4;\n\n    /**\n     * Creates an instance of this DoubleMetaphone encoder\n     */\n    public DoubleMetaphone() {\n        super();\n    }\n    \n    /**\n     * Encode a value with Double Metaphone\n     *\n     * @param value String to encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(String value) {\n        return doubleMetaphone(value, false);\n    }\n    \n    /**\n     * Encode a value with Double Metaphone, optionally using the alternate\n     * encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(String value, boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n        \n        boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n        \n        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n        \n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(value, result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break; \n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }\n    \n    /**\n     * Encode the value using DoubleMetaphone.  It will only work if \n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     */\n    public Object encode(Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\"); \n        } \n        return doubleMetaphone((String) obj);\n    }\n\n    /**\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     */\n    public String encode(String value) {\n        return doubleMetaphone(value);   \n    }\n\n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal.\n     * \n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     */\n    public boolean isDoubleMetaphoneEqual(String value1, String value2) {\n        return isDoubleMetaphoneEqual(value1, value2, false);\n    }\n    \n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     * \n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if <code>true</code>.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     */\n    public boolean isDoubleMetaphoneEqual(String value1, \n                                          String value2, \n                                          boolean alternate) {\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone\n                                                         (value2, alternate));\n    }\n    \n    /**\n     * Returns the maxCodeLen.\n     * @return int\n     */\n    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }\n\n    /**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */\n    public void setMaxCodeLen(int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }\n\n    //-- BEGIN HANDLERS --//\n\n    /**\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases\n     */\n    private int handleAEIOUY(String value, DoubleMetaphoneResult result, int \n                             index) {\n        if (index == 0) {\n            result.append('A');\n        }\n        return index + 1;\n    }\n    \n    /**\n     * Handles 'C' cases\n     */\n    private int handleC(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (conditionC0(value, index)) {  // very confusing, moved out\n            result.append('K');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n            result.append('S');\n            index += 2;\n        } else if (contains(value, index, 2, \"CH\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"CZ\") && \n                   !contains(value, index - 2, 4, \"WICZ\")) {\n            //-- \"Czerny\" --//\n            result.append('S', 'X');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\n            //-- \"focaccia\" --//\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"CC\") && \n                   !(index == 1 && charAt(value, 0) == 'M')) {\n            //-- double \"cc\" but not \"McClelland\" --//\n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n            result.append('K');\n            index += 2;\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n            //-- Italian vs. English --//\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n                result.append('S', 'X');\n            } else {\n                result.append('S');\n            }\n            index += 2;\n        } else {\n            result.append('K');\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) { \n                //-- Mac Caffrey, Mac Gregor --//\n                index += 3;\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && \n                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n        \n        return index;\n    }\n\n    /**\n     * Handles 'CC' cases\n     */\n    private int handleCC(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") && \n            !contains(value, index + 2, 2, \"HU\")) {\n            //-- \"bellocchio\" but not \"bacchus\" --//\n            if ((index == 1 && charAt(value, index - 1) == 'A') || \n                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n                //-- \"accident\", \"accede\", \"succeed\" --//\n                result.append(\"KS\");\n            } else {\n                //-- \"bacci\", \"bertucci\", other Italian --//\n                result.append('X');\n            }\n            index += 3;\n        } else {    // Pierce's rule\n            result.append('K');\n            index += 2;\n        }\n        \n        return index;\n    }\n    \n    /**\n     * Handles 'CH' cases\n     */\n    private int handleCH(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n            result.append('K', 'X');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n            result.append('K');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n            result.append('K');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"MC\")) {\n                    result.append('K');\n                } else {\n                    result.append('X', 'K');\n                }\n            } else {\n                result.append('X');\n            }\n            return index + 2;\n        }\n    }\n\n    /**\n     * Handles 'D' cases\n     */\n    private int handleD(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 2, \"DG\")) {\n            //-- \"Edge\" --//\n            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n                result.append('J');\n                index += 3;\n                //-- \"Edgar\" --//\n            } else {\n                result.append(\"TK\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n            result.append('T');\n            index += 2;\n        } else {\n            result.append('T');\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'G' cases\n     */\n    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n     */\n    private int handleGH(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('K');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == 'I') {\n                result.append('J');\n            } else {\n                result.append('K');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n            //-- Parker's rule (with some further refinements) - \"hugh\"\n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == 'U' && \n                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n                result.append('F');\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n                result.append('K');\n            }\n            index += 2;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'H' cases\n     */\n    private int handleH(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        //-- only keep if first & before vowel or between 2 vowels --//\n        if ((index == 0 || isVowel(charAt(value, index - 1))) && \n            isVowel(charAt(value, index + 1))) {\n            result.append('H');\n            index += 2;\n            //-- also takes car of \"HH\" --//\n        } else {\n            index++;\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'J' cases\n     */\n    private int handleJ(String value, DoubleMetaphoneResult result, int index, \n                        boolean slavoGermanic) {\n        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                if ((index == 0 && (charAt(value, index + 4) == ' ') || \n                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n                    result.append('H');\n                } else {\n                    result.append('J', 'H');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n                    result.append('J', 'A');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && \n                              (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n                    result.append('J', 'H');\n                } else if (index == value.length() - 1) {\n                    result.append('J', ' ');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n                    result.append('J');\n                }\n\n                if (charAt(value, index + 1) == 'J') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }\n    \n    /**\n     * Handles 'L' cases\n     */\n    private int handleL(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (charAt(value, index + 1) == 'L') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('L');\n            } else {\n                result.append('L');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('L');\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'P' cases\n     */\n    private int handleP(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (charAt(value, index + 1) == 'H') {\n            result.append('F');\n            index += 2;\n        } else {\n            result.append('P');\n            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'R' cases\n     */\n    private int handleR(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic && \n            contains(value, index - 2, 2, \"IE\") && \n            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n            result.appendAlternate('R');\n        } else {\n            result.append('R');\n        }\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n    }\n\n    /**\n     * Handles 'S' cases\n     */\n    private int handleS(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n            //-- special case \"sugar-\" --//\n            result.append('X', 'S');\n            index++;\n        } else if (contains(value, index, 2, \"SH\")) {\n            if (contains(value, index + 1, 4, \n                         \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n                //-- germanic --//\n                result.append('S');\n            } else {\n                result.append('X');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n            //-- Italian and Armenian --//\n            if (slavoGermanic) {\n                result.append('S');\n            } else {\n                result.append('S', 'X');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n            // \"snider\" match \"schneider\" --//\n            //-- also, -sz- in slavic language altho in hungarian it //\n            //   is pronounced \"s\" --//\n            result.append('S', 'X');\n            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"SC\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, \n                                                        2, \"AI\", \"OI\")){\n                //-- french e.g. \"resnais\", \"artois\" --//\n                result.appendAlternate('S');\n            } else {\n                result.append('S');\n            }\n            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'SC' cases\n     */\n    private int handleSC(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (charAt(value, index + 2) == 'H') {\n            //-- Schlesinger's rule --//\n            if (contains(value, index + 3, \n                         2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n                    //-- \"schermerhorn\", \"schenker\" --//\n                    result.append(\"X\", \"SK\");\n                } else {\n                    result.append(\"SK\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n                    result.append('X', 'S');\n                } else {\n                    result.append('X');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n            result.append('S');\n        } else {\n            result.append(\"SK\");\n        }\n        return index + 3;\n    }\n\n    /**\n     * Handles 'T' cases\n     */\n    private int handleT(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 4, \"TION\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"TH\") || contains(value, index, \n                                                               3, \"TTH\")) {\n            if (contains(value, index + 2, 2, \"OM\", \"AM\") || \n                //-- special case \"thomas\", \"thames\" or germanic --//\n                contains(value, 0, 4, \"VAN \", \"VON \") || \n                contains(value, 0, 3, \"SCH\")) {\n                result.append('T');\n            } else {\n                result.append('0', 'T');\n            }\n            index += 2;\n        } else {\n            result.append('T');\n            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'W' cases\n     */\n    private int handleW(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 2, \"WR\")) {\n            //-- can also be in middle of word --//\n            result.append('R');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) || \n                               contains(value, index, 2, \"WH\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    //-- Wasserman should match Vasserman --//\n                    result.append('A', 'F');\n                } else {\n                    //-- need Uomo to match Womo --//\n                    result.append('A');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, \n                                5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n                       contains(value, 0, 3, \"SCH\")) {\n                //-- Arnow should match Arnoff --//\n                result.appendAlternate('F');\n                index++;\n            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n                //-- Polish e.g. \"filipowicz\" --//\n                result.append(\"TS\", \"FX\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'X' cases\n     */\n    private int handleX(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (index == 0) {\n            result.append('S');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) && \n                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") || \n                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n                //-- French e.g. breaux --//\n                result.append(\"KS\");\n            }\n            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'Z' cases\n     */\n    private int handleZ(String value, DoubleMetaphoneResult result, int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n            result.append('J');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n                result.append(\"S\", \"TS\");\n            } else {\n                result.append('S');\n            }\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    //-- BEGIN CONDITIONS --//\n\n    /**\n     * Complex condition 0 for 'C'\n     */\n    private boolean conditionC0(String value, int index) {\n        if (contains(value, index, 4, \"CHIA\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n            return false;\n        } else {\n            char c = charAt(value, index + 2);\n            return (c != 'I' && c != 'E') ||\n                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n        }\n    }\n    \n    /**\n     * Complex condition 0 for 'CH'\n     */\n    private boolean conditionCH0(String value, int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") && \n                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"CHORE\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n    \n    /**\n     * Complex condition 1 for 'CH'\n     */\n    private boolean conditionCH1(String value, int index) {\n        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, \n                                                                   3, \"SCH\")) ||\n                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                contains(value, index + 2, 1, \"T\", \"S\") ||\n                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }\n    \n    /**\n     * Complex condition 0 for 'L'\n     */\n    private boolean conditionL0(String value, int index) {\n        if (index == value.length() - 3 && \n            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") || \n                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                   contains(value, index - 1, 4, \"ALLE\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    /**\n     * Complex condition 0 for 'M'\n     */\n    private boolean conditionM0(String value, int index) {\n        if (charAt(value, index + 1) == 'M') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"UMB\") &&\n                ((index + 1) == value.length() - 1 || contains(value,\n                        index + 2, 2, \"ER\"));\n    }\n    \n    //-- BEGIN HELPER FUNCTIONS --//\n\n    /**\n     * Determines whether or not a value is of slavo-germanic orgin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     */\n    private boolean isSlavoGermanic(String value) {\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 || \n            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n    }\n\n    /**\n     * Determines whether or not a character is a vowel or not\n     */\n    private boolean isVowel(char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }\n\n    /**\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     */    \n    private boolean isSilentStart(String value) {\n        boolean result = false;\n        for (int i = 0; i < SILENT_START.length; i++) {\n            if (value.startsWith(SILENT_START[i])) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Cleans the input\n     */    \n    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }\n\n    /**\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default\n     */    \n    protected char charAt(String value, int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        } \n        return value.charAt(index);\n    }\n\n    /**\n     * Shortcut method with 1 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria) {\n        return contains(value, start, length, \n                        new String[] { criteria });\n    }\n\n    /**\n     * Shortcut method with 2 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2 });\n    }\n\n    /**\n     * Shortcut method with 3 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3 });\n    }\n\n    /**\n     * Shortcut method with 4 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4 });\n    }\n\n    /**\n     * Shortcut method with 5 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4, \n                                    String criteria5) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4, criteria5 });\n    }\n\n    /**\n     * Shortcut method with 6 criteria\n     */    \n    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4, \n                                    String criteria5, String criteria6) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4, criteria5, criteria6 });\n    }\n    \n    /**\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>\n     */\n    protected static boolean contains(String value, int start, int length, \n                                      String[] criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            String target = value.substring(start, start + length);\n\n            for (int i = 0; i < criteria.length; i++) {\n                if (target.equals(criteria[i])) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    \n    //-- BEGIN INNER CLASSES --//\n    \n    /**\n     * Inner class for storing results, since there is the optional alternate\n     * encoding.\n     */\n    public class DoubleMetaphoneResult {\n\n        private StringBuffer primary = new StringBuffer(getMaxCodeLen());\n        private StringBuffer alternate = new StringBuffer(getMaxCodeLen());\n        private int maxLength;\n\n        public DoubleMetaphoneResult(int maxLength) {\n            this.maxLength = maxLength;\n        }\n\n        public void append(char value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(char primary, char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(char value) {\n            if (this.primary.length() < this.maxLength) {\n                this.primary.append(value);\n            }\n        }\n\n        public void appendAlternate(char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }\n\n        public void append(String value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(String primary, String alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(String value) {\n            int addChars = this.maxLength - this.primary.length();\n            if (value.length() <= addChars) {\n                this.primary.append(value);\n            } else {\n                this.primary.append(value.substring(0, addChars));\n            }\n        }\n\n        public void appendAlternate(String value) {\n            int addChars = this.maxLength - this.alternate.length();\n            if (value.length() <= addChars) {\n                this.alternate.append(value);\n            } else {\n                this.alternate.append(value.substring(0, addChars));\n            }\n        }\n\n        public String getPrimary() {\n            return this.primary.toString();\n        }\n\n        public String getAlternate() {\n            return this.alternate.toString();\n        }\n\n        public boolean isComplete() {\n            return this.primary.length() >= this.maxLength && \n                this.alternate.length() >= this.maxLength;\n        }\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 4, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * Chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    static final int CHUNK_SIZE = 76;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 5, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 6, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64InputStream", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @author Apache Software Foundation \n * @version $Id$\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n */\npublic class Base64InputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final Base64 base64;\n\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     */\n    public Base64InputStream(InputStream in) {\n        this(in, false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            return base64.readResults(b, offset, len);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @author Apache Software Foundation \n * @version $Id$\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n */\npublic class Base64InputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final Base64 base64;\n\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     */\n    public Base64InputStream(InputStream in) {\n        this(in, false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 7, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     */\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 8, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            System.arraycopy(buffer, readPos, b, bPos, len);\n            readPos += len;\n            if (readPos >= pos) {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            // Don't want to append the CRLF two times in a row, so make sure previous\n            // character is not from CRLF!\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        byte[] buf = new byte[pos - readPos];\n        readResults(buf, 0, buf.length);\n        return buf;\n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            System.arraycopy(buffer, readPos, b, bPos, len);\n            readPos += len;\n            if (readPos >= pos) {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            // Don't want to append the CRLF two times in a row, so make sure previous\n            // character is not from CRLF!\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        byte[] buf = new byte[pos - readPos];\n        readResults(buf, 0, buf.length);\n        return buf;\n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n"}, {"class_name": "org.apache.commons.codec.binary.Base64InputStream", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @author Apache Software Foundation \n * @version $Id$\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n */\npublic class Base64InputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final Base64 base64;\n\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     */\n    public Base64InputStream(InputStream in) {\n        this(in, false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @author Apache Software Foundation \n * @version $Id$\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n */\npublic class Base64InputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final Base64 base64;\n\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     */\n    public Base64InputStream(InputStream in) {\n        this(in, false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 9, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base64", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            System.arraycopy(buffer, readPos, b, bPos, len);\n            readPos += len;\n            if (readPos >= pos) {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            // Don't want to append the CRLF two times in a row, so make sure previous\n            // character is not from CRLF!\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            // We have some spare bits remaining\n            // Output all whole multiples of 8 bits and ignore the rest\n            switch (modulus) {\n           //   case 1: // 6 bits - ignore entirely\n           //       break;\n                case 2 : // 12 bits = 8 + 4\n                    x = x >> 4;\n                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n                    break;\n                case 3 : // 18 bits = 8 + 8 + 2\n                    x = x >> 2;\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param base64\n     *            String to test\n     * @return <code>true</code> if all characters in the String are valid characters in the Base64 alphabet or if\n     *         the String is empty; <code>false</code>, otherwise\n     *  @since 1.5\n     */\n    public static boolean isBase64(String base64) {\n        return isBase64(StringUtils.getBytesUtf8(base64));\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        return isBase64(arrayOctet);\n    }\n    \n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @since 1.5\n     */    \n    public static boolean isBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Tests a given byte array to see if it contains any characters fromn the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; <code>false</code> otherwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5). \n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        byte[] buf = new byte[pos - readPos];\n        readResults(buf, 0, buf.length);\n        return buf;\n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\n\n/**\n * Provides Base64 encoding and decoding as defined by RFC 2045.\n * \n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * \n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @author Apache Software Foundation\n * @since 1.0\n * @version $Id$\n */\npublic class Base64 implements BinaryEncoder, BinaryDecoder {\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     *  MIME chunk size per RFC 2045 section 6.8.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n     */\n    public static final int MIME_CHUNK_SIZE = 76;\n\n    /**\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\n     * \n     * <p>\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n     * equal signs.\n     * </p>\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n     */\n    public static final int PEM_CHUNK_SIZE = 64;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * <p>\n     * N.B. The next major release may break compatibility and make this field private.\n     * </p>\n     * \n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n     * equivalents as specified in Table 1 of RFC 2045.\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] STANDARD_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    /**\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n     * This table is only used when the Base64's mode is set to URL-SAFE.\n     */    \n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n    };\n\n    /**\n     * Byte used to pad output.\n     */\n    private static final byte PAD = '=';\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n     * alphabet but fall within the bounds of the array are translated to -1.\n     * \n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n     * \n     * Thanks to \"commons\" project in ws.apache.org for this code.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     */\n    private static final byte[] DECODE_TABLE = {\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    /** Mask used to extract 6 bits, used when encoding */\n    private static final int MASK_6BITS = 0x3f;\n\n    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n    private static final int MASK_8BITS = 0xff;\n\n    // The static final fields above are used for the original static byte[] methods on Base64.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n     * between the two modes.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n     * encoded data.\n     */\n    private final int lineLength;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Buffer for streaming.\n     */\n    private byte[] buffer;\n\n    /**\n     * Position where next character should be written in the buffer.\n     */\n    private int pos;\n\n    /**\n     * Position where next character should be read from the buffer.\n     */\n    private int readPos;\n\n    /**\n     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n     */\n    private int currentLinePos;\n\n    /**\n     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n     * helps track that.\n     */\n    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     */\n    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }\n\n    /**\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     */\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n    /**\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     */\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n    /** Doubles our buffer. */\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n    /**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            System.arraycopy(buffer, readPos, b, bPos, len);\n            readPos += len;\n            if (readPos >= pos) {\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            // Don't want to append the CRLF two times in a row, so make sure previous\n            // character is not from CRLF!\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            // We have some spare bits remaining\n            // Output all whole multiples of 8 bits and ignore the rest\n            switch (modulus) {\n           //   case 1: // 6 bits - ignore entirely\n           //       break;\n                case 2 : // 12 bits = 8 + 4\n                    x = x >> 4;\n                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n                    break;\n                case 3 : // 18 bits = 8 + 8 + 2\n                    x = x >> 2;\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     */\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }\n\n    /**\n     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param base64\n     *            String to test\n     * @return <code>true</code> if all characters in the String are valid characters in the Base64 alphabet or if\n     *         the String is empty; <code>false</code>, otherwise\n     *  @since 1.5\n     */\n    public static boolean isBase64(String base64) {\n        return isBase64(StringUtils.getBytesUtf8(base64));\n    }\n\n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}\n     */\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        return isBase64(arrayOctet);\n    }\n    \n    /**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @since 1.5\n     */    \n    public static boolean isBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Tests a given byte array to see if it contains any characters fromn the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; <code>false</code> otherwise\n     */\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5). \n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }\n\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n\n    /**\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     */\n    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     */\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    // Implementation of the Encoder Interface\n\n    /**\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     */    \n    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }\n\n    /**\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     */\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        byte[] buf = new byte[pos - readPos];\n        readResults(buf, 0, buf.length);\n        return buf;\n    }\n\n    /**\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     */\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }\n\n    /**\n     * Resets this Base64 object to its initial newly constructed state.\n     */\n    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 10, "classes_modified": [{"class_name": "org.apache.commons.codec.language.Caverphone", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a Caverphone value.\n * \n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n * \n * @author Apache Software Foundation\n * @version $Id$\n * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n * @since 1.4\n */\npublic class Caverphone implements StringEncoder {\n\n    /**\n     * Creates an instance of the Caverphone encoder\n     */\n    public Caverphone() {\n        super();\n    }\n\n    /**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param txt String the source string\n     * @return A caverphone code for the given String\n     */\n    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }\n\n    /**\n     * Encodes an Object using the caverphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         caverphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\"); \n        }\n        return caverphone((String) pObject);\n    }\n\n    /**\n     * Encodes a String using the Caverphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     */\n    public String encode(String pString) {\n        return caverphone(pString);   \n    }\n\n    /**\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     */\n    public boolean isCaverphoneEqual(String str1, String str2) {\n        return caverphone(str1).equals(caverphone(str2));\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a Caverphone value.\n * \n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n * \n * @author Apache Software Foundation\n * @version $Id$\n * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n * @since 1.4\n */\npublic class Caverphone implements StringEncoder {\n\n    /**\n     * Creates an instance of the Caverphone encoder\n     */\n    public Caverphone() {\n        super();\n    }\n\n    /**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param txt String the source string\n     * @return A caverphone code for the given String\n     */\n    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"mb$\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }\n\n    /**\n     * Encodes an Object using the caverphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         caverphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\"); \n        }\n        return caverphone((String) pObject);\n    }\n\n    /**\n     * Encodes a String using the Caverphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     */\n    public String encode(String pString) {\n        return caverphone(pString);   \n    }\n\n    /**\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     */\n    public boolean isCaverphoneEqual(String str1, String str2) {\n        return caverphone(str1).equals(caverphone(str2));\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 11, "classes_modified": [{"class_name": "org.apache.commons.codec.net.QuotedPrintableCodec", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.net;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.BitSet;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringDecoder;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\n\n/**\n * <p>\n * Codec for the Quoted-Printable section of <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>.\n * </p>\n * <p>\n * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to\n * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are\n * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the\n * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable\n * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\n * gateway.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\"> RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n *\n * @author Apache Software Foundation\n * @since 1.3\n * @version $Id$\n */\npublic class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\n    /**\n     * The default charset used for string decoding and encoding.\n     */\n    private final String charset;\n\n    /**\n     * BitSet of printable characters as defined in RFC 1521.\n     */\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\n    private static final byte ESCAPE_CHAR = '=';\n\n    private static final byte TAB = 9;\n\n    private static final byte SPACE = 32;\n\n\n\n    /** Safe line length for quoted printable encoded text. */\n\n    // Static initializer for printable chars collection\n    static {\n        // alpha characters\n        for (int i = 33; i <= 60; i++) {\n            PRINTABLE_CHARS.set(i);\n        }\n        for (int i = 62; i <= 126; i++) {\n            PRINTABLE_CHARS.set(i);\n        }\n        PRINTABLE_CHARS.set(TAB);\n        PRINTABLE_CHARS.set(SPACE);\n    }\n\n    /**\n     * Default constructor.\n     */\n    public QuotedPrintableCodec() {\n        this(CharEncoding.UTF_8);\n    }\n\n    /**\n     * Constructor which allows for the selection of a default charset\n     * \n     * @param charset\n     *                  the default string charset to use.\n     */\n    public QuotedPrintableCodec(String charset) {\n        super();\n        this.charset = charset;\n    }\n\n    /**\n     * Encodes byte into its quoted-printable representation.\n     * \n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the <code>buffer</code>\n     */\n    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n    }\n\n    /**\n     * Return the byte at position <code>index</code> of the byte array and\n     * make sure it is unsigned.\n     *\n     * @param index\n     *                  position in the array\n     * @param bytes\n     *                  the byte array\n     * @return the unsigned octet at position <code>index</code> from the array\n     */\n\n    /**\n     * Write a byte to the buffer.\n     *\n     * @param b\n     *                  byte to write\n     * @param encode\n     *                  indicates whether the octet shall be encoded\n     * @param buffer\n     *                  the buffer to write to\n     * @return the number of bytes that have been written to the buffer\n     */\n\n    /**\n     * Checks whether the given byte is whitespace.\n     *\n     * @param b\n     *                  byte to be checked\n     * @return <code>true</code> if the byte is either a space or tab character\n     */\n\n    /**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param printable\n     *                  bitset of characters deemed quoted-printable\n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     */\n    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        // encode up to buffer.length - 3, the last three octets will be treated\n        // separately for simplification of note #3\n                // up to this length it is safe to add any byte, encoded or not\n        for (byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (printable.get(b)) {\n                buffer.write(b);\n            } else {\n                // rule #3: whitespace at the end of a line *must* be encoded\n\n                // rule #5: soft line break\n                encodeQuotedPrintable(b, buffer);\n            }\n        }\n\n        // rule #3: whitespace at the end of a line *must* be encoded\n        // if we would do a soft break line after this octet, encode whitespace\n\n        // note #3: '=' *must not* be the ultimate or penultimate character\n        // simplification: if < 6 bytes left, do a soft line break as we may need\n        //                 exactly 6 bytes space for the last 2 bytes\n            // rule #3: trailing whitespace shall be encoded\n\n        return buffer.toByteArray();\n    }\n\n    /**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n     * converted back to their original representation.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */\n    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    // if the next octet is a CR we have found a soft line break\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else {\n                // every other octet is appended except for CR & LF\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }\n\n    /**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     */\n    public byte[] encode(byte[] bytes) {\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n    }\n\n    /**\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521.\n     * </p>\n     * \n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */\n    public byte[] decode(byte[] bytes) throws DecoderException {\n        return decodeQuotedPrintable(bytes);\n    }\n\n    /**\n     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521 and is suitable for encoding binary data.\n     * </p>\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @return quoted-printable string\n     * \n     * @throws EncoderException\n     *                  Thrown if quoted-printable encoding is unsuccessful\n     * \n     * @see #getDefaultCharset()\n     */\n    public String encode(String pString) throws EncoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return encode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\n     * are converted back to their original representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * @param charset\n     *                  the original string charset\n     * @return original string\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *                  Thrown if charset is not supported\n     */\n    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n    }\n\n    /**\n     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\n     * converted back to their original representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful.\n     *                  Thrown if charset is not supported.\n     * @see #getDefaultCharset()\n     */\n    public String decode(String pString) throws DecoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return decode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\n     * \n     * @param pObject\n     *                  string to convert to a quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *                  Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\n     *                  unsuccessful\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return encode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return encode((String) pObject);\n        } else {\n            throw new EncoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be quoted-printable encoded\");\n        }\n    }\n\n    /**\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param pObject\n     *                  quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is\n     *                  encountered during the decode process.\n     */\n    public Object decode(Object pObject) throws DecoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be quoted-printable decoded\");\n        }\n    }\n\n    /**\n     * Returns the default charset used for string decoding and encoding.\n     * \n     * @return the default string charset.\n     */\n    public String getDefaultCharset() {\n        return this.charset;\n    }\n\n    /**\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @param charset\n     *                  the charset for pString\n     * @return quoted-printable string\n     * \n     * @throws UnsupportedEncodingException\n     *                  Thrown if the charset is not supported\n     */\n    public String encode(String pString, String charset) throws UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.net;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.BitSet;\n\nimport org.apache.commons.codec.BinaryDecoder;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringDecoder;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\n\n/**\n * <p>\n * Codec for the Quoted-Printable section of <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>.\n * </p>\n * <p>\n * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to\n * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are\n * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the\n * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable\n * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\n * gateway.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\"> RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n *\n * @author Apache Software Foundation\n * @since 1.3\n * @version $Id$\n */\npublic class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\n    /**\n     * The default charset used for string decoding and encoding.\n     */\n    private final String charset;\n\n    /**\n     * BitSet of printable characters as defined in RFC 1521.\n     */\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\n    private static final byte ESCAPE_CHAR = '=';\n\n    private static final byte TAB = 9;\n\n    private static final byte SPACE = 32;\n\n    private static final byte CR = 13;\n\n    private static final byte LF = 10;\n\n    /** Safe line length for quoted printable encoded text. */\n    private static final int SAFE_LENGTH = 73;\n\n    // Static initializer for printable chars collection\n    static {\n        // alpha characters\n        for (int i = 33; i <= 60; i++) {\n            PRINTABLE_CHARS.set(i);\n        }\n        for (int i = 62; i <= 126; i++) {\n            PRINTABLE_CHARS.set(i);\n        }\n        PRINTABLE_CHARS.set(TAB);\n        PRINTABLE_CHARS.set(SPACE);\n    }\n\n    /**\n     * Default constructor.\n     */\n    public QuotedPrintableCodec() {\n        this(CharEncoding.UTF_8);\n    }\n\n    /**\n     * Constructor which allows for the selection of a default charset\n     * \n     * @param charset\n     *                  the default string charset to use.\n     */\n    public QuotedPrintableCodec(String charset) {\n        super();\n        this.charset = charset;\n    }\n\n    /**\n     * Encodes byte into its quoted-printable representation.\n     * \n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the <code>buffer</code>\n     */\n    private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n        return 3;\n    }\n\n    /**\n     * Return the byte at position <code>index</code> of the byte array and\n     * make sure it is unsigned.\n     *\n     * @param index\n     *                  position in the array\n     * @param bytes\n     *                  the byte array\n     * @return the unsigned octet at position <code>index</code> from the array\n     */\n    private static int getUnsignedOctet(final int index, final byte[] bytes) {\n        int b = bytes[index];\n        if (b < 0) {\n            b = 256 + b;\n        }\n        return b;\n    }\n\n    /**\n     * Write a byte to the buffer.\n     *\n     * @param b\n     *                  byte to write\n     * @param encode\n     *                  indicates whether the octet shall be encoded\n     * @param buffer\n     *                  the buffer to write to\n     * @return the number of bytes that have been written to the buffer\n     */\n    private static int encodeByte(final int b, final boolean encode,\n                                  final ByteArrayOutputStream buffer) {\n        if (encode) {\n            return encodeQuotedPrintable(b, buffer);\n        } else {\n            buffer.write(b);\n            return 1;\n        }\n    }\n\n    /**\n     * Checks whether the given byte is whitespace.\n     *\n     * @param b\n     *                  byte to be checked\n     * @return <code>true</code> if the byte is either a space or tab character\n     */\n    private static boolean isWhitespace(final int b) {\n        return b == SPACE || b == TAB;\n    }\n\n    /**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param printable\n     *                  bitset of characters deemed quoted-printable\n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     */\n    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int pos = 1;\n        // encode up to buffer.length - 3, the last three octets will be treated\n        // separately for simplification of note #3\n        for (int i = 0; i < bytes.length - 3; i++) {\n            int b = getUnsignedOctet(i, bytes);\n            if (pos < SAFE_LENGTH) {\n                // up to this length it is safe to add any byte, encoded or not\n                pos += encodeByte(b, !printable.get(b), buffer);\n            } else {\n                // rule #3: whitespace at the end of a line *must* be encoded\n                encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                // rule #5: soft line break\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n                pos = 1;\n            }\n        }\n\n        // rule #3: whitespace at the end of a line *must* be encoded\n        // if we would do a soft break line after this octet, encode whitespace\n        int b = getUnsignedOctet(bytes.length - 3, bytes);\n        boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\n        pos += encodeByte(b, encode, buffer);\n\n        // note #3: '=' *must not* be the ultimate or penultimate character\n        // simplification: if < 6 bytes left, do a soft line break as we may need\n        //                 exactly 6 bytes space for the last 2 bytes\n        if (pos > SAFE_LENGTH - 2) {\n            buffer.write(ESCAPE_CHAR);\n            buffer.write(CR);\n            buffer.write(LF);\n        }\n        for (int i = bytes.length - 2; i < bytes.length; i++) {\n            b = getUnsignedOctet(i, bytes);\n            // rule #3: trailing whitespace shall be encoded\n            encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\n            encodeByte(b, encode, buffer);\n        }\n\n        return buffer.toByteArray();\n    }\n\n    /**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n     * converted back to their original representation.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */\n    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    // if the next octet is a CR we have found a soft line break\n                    if (bytes[++i] == CR) {\n                        continue;\n                    }\n                    int u = Utils.digit16(bytes[i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else if (b != CR && b != LF) {\n                // every other octet is appended except for CR & LF\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }\n\n    /**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     */\n    public byte[] encode(byte[] bytes) {\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n    }\n\n    /**\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521.\n     * </p>\n     * \n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */\n    public byte[] decode(byte[] bytes) throws DecoderException {\n        return decodeQuotedPrintable(bytes);\n    }\n\n    /**\n     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521 and is suitable for encoding binary data.\n     * </p>\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @return quoted-printable string\n     * \n     * @throws EncoderException\n     *                  Thrown if quoted-printable encoding is unsuccessful\n     * \n     * @see #getDefaultCharset()\n     */\n    public String encode(String pString) throws EncoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return encode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\n     * are converted back to their original representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * @param charset\n     *                  the original string charset\n     * @return original string\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *                  Thrown if charset is not supported\n     */\n    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n    }\n\n    /**\n     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\n     * converted back to their original representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful.\n     *                  Thrown if charset is not supported.\n     * @see #getDefaultCharset()\n     */\n    public String decode(String pString) throws DecoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return decode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\n     * \n     * @param pObject\n     *                  string to convert to a quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *                  Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\n     *                  unsuccessful\n     */\n    public Object encode(Object pObject) throws EncoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return encode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return encode((String) pObject);\n        } else {\n            throw new EncoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be quoted-printable encoded\");\n        }\n    }\n\n    /**\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param pObject\n     *                  quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is\n     *                  encountered during the decode process.\n     */\n    public Object decode(Object pObject) throws DecoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be quoted-printable decoded\");\n        }\n    }\n\n    /**\n     * Returns the default charset used for string decoding and encoding.\n     * \n     * @return the default string charset.\n     */\n    public String getDefaultCharset() {\n        return this.charset;\n    }\n\n    /**\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @param charset\n     *                  the charset for pString\n     * @return quoted-printable string\n     * \n     * @throws UnsupportedEncodingException\n     *                  Thrown if the charset is not supported\n     */\n    public String encode(String pString, String charset) throws UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 12, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport static org.apache.commons.codec.binary.BaseNCodec.EOF;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Abstract superclass for Base-N input streams.\n * \n * @since 1.5\n */\npublic class BaseNCodecInputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final BaseNCodec baseNCodec;\n\n    private final byte[] singleByte = new byte[1];\n\n    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    @Override\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            final byte b = singleByte[0];\n            return b < 0 ? 256 + b : b;\n        }\n        return EOF;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    @Override\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base32.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base32, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!baseNCodec.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (doEncode) {\n                        baseNCodec.encode(buf, 0, c);\n                    } else {\n                        baseNCodec.decode(buf, 0, c);\n                    }\n                }\n                readLen = baseNCodec.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    @Override\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the provided skip length is negative\n     */\n\n        // skip in chunks of 512 bytes\n\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n     * <code>1</code> otherwise\n     */\n        // Note: the logic is similar to the InflaterInputStream:\n        //       as long as we have not reached EOF, indicate that there is more\n        //       data available. As we do not know for sure how much data is left,\n        //       just return 1 as a safe guess.\n\n        // use the EOF flag of the underlying codec instance\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport static org.apache.commons.codec.binary.BaseNCodec.EOF;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Abstract superclass for Base-N input streams.\n * \n * @since 1.5\n */\npublic class BaseNCodecInputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final BaseNCodec baseNCodec;\n\n    private final byte[] singleByte = new byte[1];\n\n    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    @Override\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            final byte b = singleByte[0];\n            return b < 0 ? 256 + b : b;\n        }\n        return EOF;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    @Override\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base32.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base32, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!baseNCodec.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (doEncode) {\n                        baseNCodec.encode(buf, 0, c);\n                    } else {\n                        baseNCodec.decode(buf, 0, c);\n                    }\n                }\n                readLen = baseNCodec.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    @Override\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the provided skip length is negative\n     */\n    @Override\n    public long skip(long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Negative skip length\");\n        }\n\n        // skip in chunks of 512 bytes\n        final byte[] b = new byte[512];\n        final int max = (int) Math.min(n, Integer.MAX_VALUE);\n        int total = 0;\n\n        while (total < max) {\n            int len = max - total;\n            if (len > b.length) {\n                len = b.length;\n            }\n            len = read(b, 0, len);\n            if (len == EOF) {\n                break;\n            }\n            total += len;\n        }\n\n        return total;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n     * <code>1</code> otherwise\n     */\n    public int available() throws IOException {\n        // Note: the logic is similar to the InflaterInputStream:\n        //       as long as we have not reached EOF, indicate that there is more\n        //       data available. As we do not know for sure how much data is left,\n        //       just return 1 as a safe guess.\n\n        // use the EOF flag of the underlying codec instance\n        if (baseNCodec.eof) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 13, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.StringUtils", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.Charsets;\n\n/**\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @version $Id$\n * @since 1.4\n */\npublic class StringUtils {\n\n    /**\n     * <p>\n     * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.\n     * </p>\n     * \n     * <p>\n     * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal. The\n     * comparison is case sensitive.\n     * </p>\n     * \n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     * \n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     * \n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be {@code null}\n     * @param cs2\n     *            the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 1.10\n     */\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }\n\n\n    /**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }\n\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     */\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */\n    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return new String(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.Charsets;\n\n/**\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @version $Id$\n * @since 1.4\n */\npublic class StringUtils {\n\n    /**\n     * <p>\n     * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.\n     * </p>\n     * \n     * <p>\n     * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal. The\n     * comparison is case sensitive.\n     * </p>\n     * \n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     * \n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     * \n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be {@code null}\n     * @param cs2\n     *            the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }\n\n\n    /**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }\n\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     */\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */\n    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return new String(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }\n\n}\n"}, {"class_name": "org.apache.commons.codec.language.DoubleMetaphone", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\n * Philips</CITE>.\n * <p>\n * This class is conditionally thread-safe. The instance field {@link #maxCodeLen} is mutable\n * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is\n * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication\n * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.\n *\n * @see <a href=\"http://drdobbs.com/184401251?pgno=2\">Original Article</a>\n * @see <a href=\"http://en.wikipedia.org/wiki/Metaphone\">http://en.wikipedia.org/wiki/Metaphone</a>\n *\n * @version $Id$\n */\npublic class DoubleMetaphone implements StringEncoder {\n\n    /**\n     * \"Vowels\" to test for\n     */\n    private static final String VOWELS = \"AEIOUY\";\n\n    /**\n     * Prefixes when present which are not pronounced\n     */\n    private static final String[] SILENT_START =\n        { \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };\n    private static final String[] L_R_N_M_B_H_F_V_W_SPACE =\n        { \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER =\n        { \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n    private static final String[] L_T_K_S_N_M_B_Z =\n        { \"L\", \"T\", \"K\", \"S\", \"N\", \"M\", \"B\", \"Z\" };\n\n    /**\n     * Maximum length of an encoding, default is 4\n     */\n    private int maxCodeLen = 4;\n\n    /**\n     * Creates an instance of this DoubleMetaphone encoder\n     */\n    public DoubleMetaphone() {\n        super();\n    }\n\n    /**\n     * Encode a value with Double Metaphone.\n     *\n     * @param value String to encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(final String value) {\n        return doubleMetaphone(value, false);\n    }\n\n    /**\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(String value, final boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n\n        final boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break;\n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }\n\n    /**\n     * Encode the value using DoubleMetaphone.  It will only work if\n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     */\n    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\");\n        }\n        return doubleMetaphone((String) obj);\n    }\n\n    /**\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     */\n    @Override\n    public String encode(final String value) {\n        return doubleMetaphone(value);\n    }\n\n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return {@code true} if the encoded <code>String</code>s are equal;\n     *          {@code false} otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     */\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\n        return isDoubleMetaphoneEqual(value1, value2, false);\n    }\n\n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if {@code true}.\n     * @return {@code true} if the encoded <code>String</code>s are equal;\n     *          {@code false} otherwise.\n     */\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n    }\n\n    /**\n     * Returns the maxCodeLen.\n     * @return int\n     */\n    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }\n\n    /**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */\n    public void setMaxCodeLen(final int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }\n\n    //-- BEGIN HANDLERS --//\n\n    /**\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n     */\n    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\n        if (index == 0) {\n            result.append('A');\n        }\n        return index + 1;\n    }\n\n    /**\n     * Handles 'C' cases.\n     */\n    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (conditionC0(value, index)) {  // very confusing, moved out\n            result.append('K');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n            result.append('S');\n            index += 2;\n        } else if (contains(value, index, 2, \"CH\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"CZ\") &&\n                   !contains(value, index - 2, 4, \"WICZ\")) {\n            //-- \"Czerny\" --//\n            result.append('S', 'X');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\n            //-- \"focaccia\" --//\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"CC\") &&\n                   !(index == 1 && charAt(value, 0) == 'M')) {\n            //-- double \"cc\" but not \"McClelland\" --//\n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n            result.append('K');\n            index += 2;\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n            //-- Italian vs. English --//\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n                result.append('S', 'X');\n            } else {\n                result.append('S');\n            }\n            index += 2;\n        } else {\n            result.append('K');\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\n                //-- Mac Caffrey, Mac Gregor --//\n                index += 3;\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") &&\n                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n\n        return index;\n    }\n\n    /**\n     * Handles 'CC' cases.\n     */\n    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") &&\n            !contains(value, index + 2, 2, \"HU\")) {\n            //-- \"bellocchio\" but not \"bacchus\" --//\n            if ((index == 1 && charAt(value, index - 1) == 'A') ||\n                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n                //-- \"accident\", \"accede\", \"succeed\" --//\n                result.append(\"KS\");\n            } else {\n                //-- \"bacci\", \"bertucci\", other Italian --//\n                result.append('X');\n            }\n            index += 3;\n        } else {    // Pierce's rule\n            result.append('K');\n            index += 2;\n        }\n\n        return index;\n    }\n\n    /**\n     * Handles 'CH' cases.\n     */\n    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n            result.append('K', 'X');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n            result.append('K');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n            result.append('K');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"MC\")) {\n                    result.append('K');\n                } else {\n                    result.append('X', 'K');\n                }\n            } else {\n                result.append('X');\n            }\n            return index + 2;\n        }\n    }\n\n    /**\n     * Handles 'D' cases.\n     */\n    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"DG\")) {\n            //-- \"Edge\" --//\n            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n                result.append('J');\n                index += 3;\n                //-- \"Edgar\" --//\n            } else {\n                result.append(\"TK\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n            result.append('T');\n            index += 2;\n        } else {\n            result.append('T');\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'G' cases.\n     */\n    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") &&\n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 &&\n                   (charAt(value, index + 1) == 'Y' ||\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") ||\n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") &&\n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") ||\n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if (contains(value, 0 ,4, \"VAN \", \"VON \") ||\n                contains(value, 0, 3, \"SCH\") ||\n                contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'GH' cases.\n     */\n    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('K');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == 'I') {\n                result.append('J');\n            } else {\n                result.append('K');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n            //-- Parker's rule (with some further refinements) - \"hugh\"\n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == 'U' &&\n                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n                result.append('F');\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n                result.append('K');\n            }\n            index += 2;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'H' cases.\n     */\n    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\n        //-- only keep if first & before vowel or between 2 vowels --//\n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\n            isVowel(charAt(value, index + 1))) {\n            result.append('H');\n            index += 2;\n            //-- also takes car of \"HH\" --//\n        } else {\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'J' cases.\n     */\n    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                if ((index == 0 && (charAt(value, index + 4) == ' ') ||\n                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n                    result.append('H');\n                } else {\n                    result.append('J', 'H');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n                    result.append('J', 'A');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\n                           (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n                    result.append('J', 'H');\n                } else if (index == value.length() - 1) {\n                    result.append('J', ' ');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\n                           !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n                    result.append('J');\n                }\n\n                if (charAt(value, index + 1) == 'J') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }\n\n    /**\n     * Handles 'L' cases.\n     */\n    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == 'L') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('L');\n            } else {\n                result.append('L');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('L');\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'P' cases.\n     */\n    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == 'H') {\n            result.append('F');\n            index += 2;\n        } else {\n            result.append('P');\n            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'R' cases.\n     */\n    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\n                        final boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic &&\n            contains(value, index - 2, 2, \"IE\") &&\n            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n            result.appendAlternate('R');\n        } else {\n            result.append('R');\n        }\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n    }\n\n    /**\n     * Handles 'S' cases.\n     */\n    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n            //-- special case \"sugar-\" --//\n            result.append('X', 'S');\n            index++;\n        } else if (contains(value, index, 2, \"SH\")) {\n            if (contains(value, index + 1, 4, \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n                //-- germanic --//\n                result.append('S');\n            } else {\n                result.append('X');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n            //-- Italian and Armenian --//\n            if (slavoGermanic) {\n                result.append('S');\n            } else {\n                result.append('S', 'X');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) ||\n                   contains(value, index + 1, 1, \"Z\")) {\n            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n            // \"snider\" match \"schneider\" --//\n            //-- also, -sz- in slavic language although in hungarian it //\n            //   is pronounced \"s\" --//\n            result.append('S', 'X');\n            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"SC\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \"AI\", \"OI\")) {\n                //-- french e.g. \"resnais\", \"artois\" --//\n                result.appendAlternate('S');\n            } else {\n                result.append('S');\n            }\n            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'SC' cases.\n     */\n    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (charAt(value, index + 2) == 'H') {\n            //-- Schlesinger's rule --//\n            if (contains(value, index + 3, 2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n                    //-- \"schermerhorn\", \"schenker\" --//\n                    result.append(\"X\", \"SK\");\n                } else {\n                    result.append(\"SK\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n                    result.append('X', 'S');\n                } else {\n                    result.append('X');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n            result.append('S');\n        } else {\n            result.append(\"SK\");\n        }\n        return index + 3;\n    }\n\n    /**\n     * Handles 'T' cases.\n     */\n    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 4, \"TION\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"TH\") || contains(value, index, 3, \"TTH\")) {\n            if (contains(value, index + 2, 2, \"OM\", \"AM\") ||\n                //-- special case \"thomas\", \"thames\" or germanic --//\n                contains(value, 0, 4, \"VAN \", \"VON \") ||\n                contains(value, 0, 3, \"SCH\")) {\n                result.append('T');\n            } else {\n                result.append('0', 'T');\n            }\n            index += 2;\n        } else {\n            result.append('T');\n            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'W' cases.\n     */\n    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"WR\")) {\n            //-- can also be in middle of word --//\n            result.append('R');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\n                               contains(value, index, 2, \"WH\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    //-- Wasserman should match Vasserman --//\n                    result.append('A', 'F');\n                } else {\n                    //-- need Uomo to match Womo --//\n                    result.append('A');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, 5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n                       contains(value, 0, 3, \"SCH\")) {\n                //-- Arnow should match Arnoff --//\n                result.appendAlternate('F');\n                index++;\n            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n                //-- Polish e.g. \"filipowicz\" --//\n                result.append(\"TS\", \"FX\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'X' cases.\n     */\n    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index == 0) {\n            result.append('S');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) &&\n                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") ||\n                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n                //-- French e.g. breaux --//\n                result.append(\"KS\");\n            }\n            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'Z' cases.\n     */\n    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n            result.append('J');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") ||\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n                result.append(\"S\", \"TS\");\n            } else {\n                result.append('S');\n            }\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    //-- BEGIN CONDITIONS --//\n\n    /**\n     * Complex condition 0 for 'C'.\n     */\n    private boolean conditionC0(final String value, final int index) {\n        if (contains(value, index, 4, \"CHIA\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n            return false;\n        } else {\n            final char c = charAt(value, index + 2);\n            return (c != 'I' && c != 'E') ||\n                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n        }\n    }\n\n    /**\n     * Complex condition 0 for 'CH'.\n     */\n    private boolean conditionCH0(final String value, final int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") &&\n                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"CHORE\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Complex condition 1 for 'CH'.\n     */\n    private boolean conditionCH1(final String value, final int index) {\n        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) ||\n                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                contains(value, index + 2, 1, \"T\", \"S\") ||\n                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }\n\n    /**\n     * Complex condition 0 for 'L'.\n     */\n    private boolean conditionL0(final String value, final int index) {\n        if (index == value.length() - 3 &&\n            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") ||\n                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                   contains(value, index - 1, 4, \"ALLE\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Complex condition 0 for 'M'.\n     */\n    private boolean conditionM0(final String value, final int index) {\n        if (charAt(value, index + 1) == 'M') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"UMB\") &&\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \"ER\"));\n    }\n\n    //-- BEGIN HELPER FUNCTIONS --//\n\n    /**\n     * Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     */\n    private boolean isSlavoGermanic(final String value) {\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\n            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n    }\n\n    /**\n     * Determines whether or not a character is a vowel or not\n     */\n    private boolean isVowel(final char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }\n\n    /**\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return {@code true} if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     */\n    private boolean isSilentStart(final String value) {\n        boolean result = false;\n        for (final String element : SILENT_START) {\n            if (value.startsWith(element)) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Cleans the input.\n     */\n    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }\n\n    /**\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default.\n     */\n    protected char charAt(final String value, final int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        }\n        return value.charAt(index);\n    }\n\n    /**\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>.\n     */\n    protected static boolean contains(final String value, final int start, final int length,\n                                      final String... criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            final String target = value.substring(start, start + length);\n\n            for (final String element : criteria) {\n                if (target.equals(element)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    //-- BEGIN INNER CLASSES --//\n\n    /**\n     * Inner class for storing results, since there is the optional alternate encoding.\n     */\n    public class DoubleMetaphoneResult {\n\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\n        private final int maxLength;\n\n        public DoubleMetaphoneResult(final int maxLength) {\n            this.maxLength = maxLength;\n        }\n\n        public void append(final char value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(final char primary, final char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(final char value) {\n            if (this.primary.length() < this.maxLength) {\n                this.primary.append(value);\n            }\n        }\n\n        public void appendAlternate(final char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }\n\n        public void append(final String value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(final String primary, final String alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(final String value) {\n            final int addChars = this.maxLength - this.primary.length();\n            if (value.length() <= addChars) {\n                this.primary.append(value);\n            } else {\n                this.primary.append(value.substring(0, addChars));\n            }\n        }\n\n        public void appendAlternate(final String value) {\n            final int addChars = this.maxLength - this.alternate.length();\n            if (value.length() <= addChars) {\n                this.alternate.append(value);\n            } else {\n                this.alternate.append(value.substring(0, addChars));\n            }\n        }\n\n        public String getPrimary() {\n            return this.primary.toString();\n        }\n\n        public String getAlternate() {\n            return this.alternate.toString();\n        }\n\n        public boolean isComplete() {\n            return this.primary.length() >= this.maxLength &&\n                   this.alternate.length() >= this.maxLength;\n        }\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\n\n/**\n * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\n * Philips</CITE>.\n * <p>\n * This class is conditionally thread-safe. The instance field {@link #maxCodeLen} is mutable\n * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is\n * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication\n * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.\n *\n * @see <a href=\"http://drdobbs.com/184401251?pgno=2\">Original Article</a>\n * @see <a href=\"http://en.wikipedia.org/wiki/Metaphone\">http://en.wikipedia.org/wiki/Metaphone</a>\n *\n * @version $Id$\n */\npublic class DoubleMetaphone implements StringEncoder {\n\n    /**\n     * \"Vowels\" to test for\n     */\n    private static final String VOWELS = \"AEIOUY\";\n\n    /**\n     * Prefixes when present which are not pronounced\n     */\n    private static final String[] SILENT_START =\n        { \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };\n    private static final String[] L_R_N_M_B_H_F_V_W_SPACE =\n        { \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER =\n        { \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n    private static final String[] L_T_K_S_N_M_B_Z =\n        { \"L\", \"T\", \"K\", \"S\", \"N\", \"M\", \"B\", \"Z\" };\n\n    /**\n     * Maximum length of an encoding, default is 4\n     */\n    private int maxCodeLen = 4;\n\n    /**\n     * Creates an instance of this DoubleMetaphone encoder\n     */\n    public DoubleMetaphone() {\n        super();\n    }\n\n    /**\n     * Encode a value with Double Metaphone.\n     *\n     * @param value String to encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(final String value) {\n        return doubleMetaphone(value, false);\n    }\n\n    /**\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     */\n    public String doubleMetaphone(String value, final boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n\n        final boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break;\n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }\n\n    /**\n     * Encode the value using DoubleMetaphone.  It will only work if\n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     */\n    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\");\n        }\n        return doubleMetaphone((String) obj);\n    }\n\n    /**\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     */\n    @Override\n    public String encode(final String value) {\n        return doubleMetaphone(value);\n    }\n\n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return {@code true} if the encoded <code>String</code>s are equal;\n     *          {@code false} otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     */\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\n        return isDoubleMetaphoneEqual(value1, value2, false);\n    }\n\n    /**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if {@code true}.\n     * @return {@code true} if the encoded <code>String</code>s are equal;\n     *          {@code false} otherwise.\n     */\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\n    }\n\n    /**\n     * Returns the maxCodeLen.\n     * @return int\n     */\n    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }\n\n    /**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */\n    public void setMaxCodeLen(final int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }\n\n    //-- BEGIN HANDLERS --//\n\n    /**\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n     */\n    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\n        if (index == 0) {\n            result.append('A');\n        }\n        return index + 1;\n    }\n\n    /**\n     * Handles 'C' cases.\n     */\n    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (conditionC0(value, index)) {  // very confusing, moved out\n            result.append('K');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n            result.append('S');\n            index += 2;\n        } else if (contains(value, index, 2, \"CH\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"CZ\") &&\n                   !contains(value, index - 2, 4, \"WICZ\")) {\n            //-- \"Czerny\" --//\n            result.append('S', 'X');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\n            //-- \"focaccia\" --//\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"CC\") &&\n                   !(index == 1 && charAt(value, 0) == 'M')) {\n            //-- double \"cc\" but not \"McClelland\" --//\n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n            result.append('K');\n            index += 2;\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n            //-- Italian vs. English --//\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n                result.append('S', 'X');\n            } else {\n                result.append('S');\n            }\n            index += 2;\n        } else {\n            result.append('K');\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\n                //-- Mac Caffrey, Mac Gregor --//\n                index += 3;\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") &&\n                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n\n        return index;\n    }\n\n    /**\n     * Handles 'CC' cases.\n     */\n    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") &&\n            !contains(value, index + 2, 2, \"HU\")) {\n            //-- \"bellocchio\" but not \"bacchus\" --//\n            if ((index == 1 && charAt(value, index - 1) == 'A') ||\n                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n                //-- \"accident\", \"accede\", \"succeed\" --//\n                result.append(\"KS\");\n            } else {\n                //-- \"bacci\", \"bertucci\", other Italian --//\n                result.append('X');\n            }\n            index += 3;\n        } else {    // Pierce's rule\n            result.append('K');\n            index += 2;\n        }\n\n        return index;\n    }\n\n    /**\n     * Handles 'CH' cases.\n     */\n    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n            result.append('K', 'X');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n            result.append('K');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n            result.append('K');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"MC\")) {\n                    result.append('K');\n                } else {\n                    result.append('X', 'K');\n                }\n            } else {\n                result.append('X');\n            }\n            return index + 2;\n        }\n    }\n\n    /**\n     * Handles 'D' cases.\n     */\n    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"DG\")) {\n            //-- \"Edge\" --//\n            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n                result.append('J');\n                index += 3;\n                //-- \"Edgar\" --//\n            } else {\n                result.append(\"TK\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n            result.append('T');\n            index += 2;\n        } else {\n            result.append('T');\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'G' cases.\n     */\n    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") &&\n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 &&\n                   (charAt(value, index + 1) == 'Y' ||\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") ||\n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") &&\n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") ||\n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if (contains(value, 0 ,4, \"VAN \", \"VON \") ||\n                contains(value, 0, 3, \"SCH\") ||\n                contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'GH' cases.\n     */\n    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('K');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == 'I') {\n                result.append('J');\n            } else {\n                result.append('K');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n            //-- Parker's rule (with some further refinements) - \"hugh\"\n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == 'U' &&\n                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n                result.append('F');\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n                result.append('K');\n            }\n            index += 2;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'H' cases.\n     */\n    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\n        //-- only keep if first & before vowel or between 2 vowels --//\n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\n            isVowel(charAt(value, index + 1))) {\n            result.append('H');\n            index += 2;\n            //-- also takes car of \"HH\" --//\n        } else {\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'J' cases.\n     */\n    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                if ((index == 0 && (charAt(value, index + 4) == ' ') ||\n                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n                    result.append('H');\n                } else {\n                    result.append('J', 'H');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n                    result.append('J', 'A');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\n                           (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n                    result.append('J', 'H');\n                } else if (index == value.length() - 1) {\n                    result.append('J', ' ');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\n                           !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n                    result.append('J');\n                }\n\n                if (charAt(value, index + 1) == 'J') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }\n\n    /**\n     * Handles 'L' cases.\n     */\n    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == 'L') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('L');\n            } else {\n                result.append('L');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('L');\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'P' cases.\n     */\n    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == 'H') {\n            result.append('F');\n            index += 2;\n        } else {\n            result.append('P');\n            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'R' cases.\n     */\n    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\n                        final boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic &&\n            contains(value, index - 2, 2, \"IE\") &&\n            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n            result.appendAlternate('R');\n        } else {\n            result.append('R');\n        }\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n    }\n\n    /**\n     * Handles 'S' cases.\n     */\n    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n            //-- special case \"sugar-\" --//\n            result.append('X', 'S');\n            index++;\n        } else if (contains(value, index, 2, \"SH\")) {\n            if (contains(value, index + 1, 4, \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n                //-- germanic --//\n                result.append('S');\n            } else {\n                result.append('X');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n            //-- Italian and Armenian --//\n            if (slavoGermanic) {\n                result.append('S');\n            } else {\n                result.append('S', 'X');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) ||\n                   contains(value, index + 1, 1, \"Z\")) {\n            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n            // \"snider\" match \"schneider\" --//\n            //-- also, -sz- in slavic language although in hungarian it //\n            //   is pronounced \"s\" --//\n            result.append('S', 'X');\n            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"SC\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \"AI\", \"OI\")) {\n                //-- french e.g. \"resnais\", \"artois\" --//\n                result.appendAlternate('S');\n            } else {\n                result.append('S');\n            }\n            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'SC' cases.\n     */\n    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (charAt(value, index + 2) == 'H') {\n            //-- Schlesinger's rule --//\n            if (contains(value, index + 3, 2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n                    //-- \"schermerhorn\", \"schenker\" --//\n                    result.append(\"X\", \"SK\");\n                } else {\n                    result.append(\"SK\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n                    result.append('X', 'S');\n                } else {\n                    result.append('X');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n            result.append('S');\n        } else {\n            result.append(\"SK\");\n        }\n        return index + 3;\n    }\n\n    /**\n     * Handles 'T' cases.\n     */\n    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 4, \"TION\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"TH\") || contains(value, index, 3, \"TTH\")) {\n            if (contains(value, index + 2, 2, \"OM\", \"AM\") ||\n                //-- special case \"thomas\", \"thames\" or germanic --//\n                contains(value, 0, 4, \"VAN \", \"VON \") ||\n                contains(value, 0, 3, \"SCH\")) {\n                result.append('T');\n            } else {\n                result.append('0', 'T');\n            }\n            index += 2;\n        } else {\n            result.append('T');\n            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'W' cases.\n     */\n    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"WR\")) {\n            //-- can also be in middle of word --//\n            result.append('R');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\n                               contains(value, index, 2, \"WH\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    //-- Wasserman should match Vasserman --//\n                    result.append('A', 'F');\n                } else {\n                    //-- need Uomo to match Womo --//\n                    result.append('A');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, 5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n                       contains(value, 0, 3, \"SCH\")) {\n                //-- Arnow should match Arnoff --//\n                result.appendAlternate('F');\n                index++;\n            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n                //-- Polish e.g. \"filipowicz\" --//\n                result.append(\"TS\", \"FX\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'X' cases.\n     */\n    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index == 0) {\n            result.append('S');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) &&\n                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") ||\n                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n                //-- French e.g. breaux --//\n                result.append(\"KS\");\n            }\n            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    /**\n     * Handles 'Z' cases.\n     */\n    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n            result.append('J');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") ||\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n                result.append(\"S\", \"TS\");\n            } else {\n                result.append('S');\n            }\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n        }\n        return index;\n    }\n\n    //-- BEGIN CONDITIONS --//\n\n    /**\n     * Complex condition 0 for 'C'.\n     */\n    private boolean conditionC0(final String value, final int index) {\n        if (contains(value, index, 4, \"CHIA\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n            return false;\n        } else {\n            final char c = charAt(value, index + 2);\n            return (c != 'I' && c != 'E') ||\n                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n        }\n    }\n\n    /**\n     * Complex condition 0 for 'CH'.\n     */\n    private boolean conditionCH0(final String value, final int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") &&\n                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"CHORE\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Complex condition 1 for 'CH'.\n     */\n    private boolean conditionCH1(final String value, final int index) {\n        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) ||\n                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                contains(value, index + 2, 1, \"T\", \"S\") ||\n                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }\n\n    /**\n     * Complex condition 0 for 'L'.\n     */\n    private boolean conditionL0(final String value, final int index) {\n        if (index == value.length() - 3 &&\n            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") ||\n                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                   contains(value, index - 1, 4, \"ALLE\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Complex condition 0 for 'M'.\n     */\n    private boolean conditionM0(final String value, final int index) {\n        if (charAt(value, index + 1) == 'M') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"UMB\") &&\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \"ER\"));\n    }\n\n    //-- BEGIN HELPER FUNCTIONS --//\n\n    /**\n     * Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     */\n    private boolean isSlavoGermanic(final String value) {\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\n            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n    }\n\n    /**\n     * Determines whether or not a character is a vowel or not\n     */\n    private boolean isVowel(final char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }\n\n    /**\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return {@code true} if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     */\n    private boolean isSilentStart(final String value) {\n        boolean result = false;\n        for (final String element : SILENT_START) {\n            if (value.startsWith(element)) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Cleans the input.\n     */\n    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }\n\n    /**\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default.\n     */\n    protected char charAt(final String value, final int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        }\n        return value.charAt(index);\n    }\n\n    /**\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>.\n     */\n    protected static boolean contains(final String value, final int start, final int length,\n                                      final String... criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            final String target = value.substring(start, start + length);\n\n            for (final String element : criteria) {\n                if (target.equals(element)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    //-- BEGIN INNER CLASSES --//\n\n    /**\n     * Inner class for storing results, since there is the optional alternate encoding.\n     */\n    public class DoubleMetaphoneResult {\n\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\n        private final int maxLength;\n\n        public DoubleMetaphoneResult(final int maxLength) {\n            this.maxLength = maxLength;\n        }\n\n        public void append(final char value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(final char primary, final char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(final char value) {\n            if (this.primary.length() < this.maxLength) {\n                this.primary.append(value);\n            }\n        }\n\n        public void appendAlternate(final char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }\n\n        public void append(final String value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }\n\n        public void append(final String primary, final String alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n        public void appendPrimary(final String value) {\n            final int addChars = this.maxLength - this.primary.length();\n            if (value.length() <= addChars) {\n                this.primary.append(value);\n            } else {\n                this.primary.append(value.substring(0, addChars));\n            }\n        }\n\n        public void appendAlternate(final String value) {\n            final int addChars = this.maxLength - this.alternate.length();\n            if (value.length() <= addChars) {\n                this.alternate.append(value);\n            } else {\n                this.alternate.append(value.substring(0, addChars));\n            }\n        }\n\n        public String getPrimary() {\n            return this.primary.toString();\n        }\n\n        public String getAlternate() {\n            return this.alternate.toString();\n        }\n\n        public boolean isComplete() {\n            return this.primary.length() >= this.maxLength &&\n                   this.alternate.length() >= this.maxLength;\n        }\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 14, "classes_modified": [{"class_name": "org.apache.commons.codec.language.bm.Lang", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language.bm;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * Language guessing utility.\n * <p>\n * This class encapsulates rules used to guess the possible languages that a word originates from. This is\n * done by reference to a whole series of rules distributed in resource files.\n * <p>\n * Instances of this class are typically managed through the static factory method instance().\n * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.\n * <p>\n * This class is intended to be immutable and thread-safe.\n * <p>\n * <b>Lang resources</b>\n * <p>\n * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.\n * They are systematically named following the pattern:\n * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>\n * The format of these resources is the following:\n * <ul>\n * <li><b>Rules:</b> whitespace separated strings.\n * There should be 3 columns to each row, and these will be interpreted as:\n * <ol>\n * <li>pattern: a regular expression.</li>\n * <li>languages: a '+'-separated list of languages.</li>\n * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\n * discarded as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\n * This will skip all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n * <p>\n * Port of lang.php\n *\n * @since 1.6\n * @version $Id$\n */\npublic class Lang {\n    // Implementation note: This class is divided into two sections. The first part is a static factory interface that\n    // exposes the LANGUAGE_RULES_RN resource as a Lang instance. The second part is the Lang instance methods that\n    // encapsulate a particular language-guessing rule table and the language guessing itself.\n    //\n    // It may make sense in the future to expose the private constructor to allow power users to build custom language-\n    // guessing rules, perhaps by marking it protected and allowing sub-classing. However, the vast majority of users\n    // should be strongly encouraged to use the static factory <code>instance</code> method to get their Lang instances.\n\n    private static final class LangRule {\n        private final boolean acceptOnMatch;\n        private final Set<String> languages;\n        private final Pattern pattern;\n\n        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\n            this.pattern = pattern;\n            this.languages = languages;\n            this.acceptOnMatch = acceptOnMatch;\n        }\n\n        public boolean matches(final String txt) {\n            return this.pattern.matcher(txt).find();\n        }\n    }\n\n    private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n\n    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n\n    static {\n        for (final NameType s : NameType.values()) {\n            Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n        }\n    }\n\n    /**\n     * Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type\n     */\n    public static Lang instance(final NameType nameType) {\n        return Langs.get(nameType);\n    }\n\n    /**\n     * Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules.\n     */\n    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n        final List<LangRule> rules = new ArrayList<LangRule>();\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n\n        if (lRulesIS == null) {\n            throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n        }\n\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n        try {\n            boolean inExtendedComment = false;\n            while (scanner.hasNextLine()) {\n                final String rawLine = scanner.nextLine();\n                String line = rawLine;\n                if (inExtendedComment) {\n                    // check for closing comment marker, otherwise discard doc comment line\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                        inExtendedComment = false;\n                    }\n                } else {\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                        inExtendedComment = true;\n                    } else {\n                        // discard comments\n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\n                        if (cmtI >= 0) {\n                            line = line.substring(0, cmtI);\n                        }\n\n                        // trim leading-trailing whitespace\n                        line = line.trim();\n\n                        if (line.length() == 0) {\n                            continue; // empty lines can be safely skipped\n                        }\n\n                        // split it up\n                        final String[] parts = line.split(\"\\\\s+\");\n\n                        if (parts.length != 3) {\n                            throw new IllegalArgumentException(\"Malformed line '\" + rawLine +\n                                    \"' in language resource '\" + languageRulesResourceName + \"'\");\n                        }\n\n                        final Pattern pattern = Pattern.compile(parts[0]);\n                        final String[] langs = parts[1].split(\"\\\\+\");\n                        final boolean accept = parts[2].equals(\"true\");\n\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n                    }\n                }\n            }\n        } finally {\n            scanner.close();\n        }\n        return new Lang(rules, languages);\n    }\n\n    private final Languages languages;\n    private final List<LangRule> rules;\n\n    private Lang(final List<LangRule> rules, final Languages languages) {\n        this.rules = Collections.unmodifiableList(rules);\n        this.languages = languages;\n    }\n\n    /**\n     * Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n     */\n    public String guessLanguage(final String text) {\n        final Languages.LanguageSet ls = guessLanguages(text);\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n    }\n\n    /**\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     */\n    public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language.bm;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * Language guessing utility.\n * <p>\n * This class encapsulates rules used to guess the possible languages that a word originates from. This is\n * done by reference to a whole series of rules distributed in resource files.\n * <p>\n * Instances of this class are typically managed through the static factory method instance().\n * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.\n * <p>\n * This class is intended to be immutable and thread-safe.\n * <p>\n * <b>Lang resources</b>\n * <p>\n * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.\n * They are systematically named following the pattern:\n * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>\n * The format of these resources is the following:\n * <ul>\n * <li><b>Rules:</b> whitespace separated strings.\n * There should be 3 columns to each row, and these will be interpreted as:\n * <ol>\n * <li>pattern: a regular expression.</li>\n * <li>languages: a '+'-separated list of languages.</li>\n * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\n * discarded as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\n * This will skip all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n * <p>\n * Port of lang.php\n *\n * @since 1.6\n * @version $Id$\n */\npublic class Lang {\n    // Implementation note: This class is divided into two sections. The first part is a static factory interface that\n    // exposes the LANGUAGE_RULES_RN resource as a Lang instance. The second part is the Lang instance methods that\n    // encapsulate a particular language-guessing rule table and the language guessing itself.\n    //\n    // It may make sense in the future to expose the private constructor to allow power users to build custom language-\n    // guessing rules, perhaps by marking it protected and allowing sub-classing. However, the vast majority of users\n    // should be strongly encouraged to use the static factory <code>instance</code> method to get their Lang instances.\n\n    private static final class LangRule {\n        private final boolean acceptOnMatch;\n        private final Set<String> languages;\n        private final Pattern pattern;\n\n        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\n            this.pattern = pattern;\n            this.languages = languages;\n            this.acceptOnMatch = acceptOnMatch;\n        }\n\n        public boolean matches(final String txt) {\n            return this.pattern.matcher(txt).find();\n        }\n    }\n\n    private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n\n    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/%s_lang.txt\";\n\n    static {\n        for (final NameType s : NameType.values()) {\n            Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));\n        }\n    }\n\n    /**\n     * Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type\n     */\n    public static Lang instance(final NameType nameType) {\n        return Langs.get(nameType);\n    }\n\n    /**\n     * Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules.\n     */\n    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n        final List<LangRule> rules = new ArrayList<LangRule>();\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n\n        if (lRulesIS == null) {\n            throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n        }\n\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n        try {\n            boolean inExtendedComment = false;\n            while (scanner.hasNextLine()) {\n                final String rawLine = scanner.nextLine();\n                String line = rawLine;\n                if (inExtendedComment) {\n                    // check for closing comment marker, otherwise discard doc comment line\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                        inExtendedComment = false;\n                    }\n                } else {\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                        inExtendedComment = true;\n                    } else {\n                        // discard comments\n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\n                        if (cmtI >= 0) {\n                            line = line.substring(0, cmtI);\n                        }\n\n                        // trim leading-trailing whitespace\n                        line = line.trim();\n\n                        if (line.length() == 0) {\n                            continue; // empty lines can be safely skipped\n                        }\n\n                        // split it up\n                        final String[] parts = line.split(\"\\\\s+\");\n\n                        if (parts.length != 3) {\n                            throw new IllegalArgumentException(\"Malformed line '\" + rawLine +\n                                    \"' in language resource '\" + languageRulesResourceName + \"'\");\n                        }\n\n                        final Pattern pattern = Pattern.compile(parts[0]);\n                        final String[] langs = parts[1].split(\"\\\\+\");\n                        final boolean accept = parts[2].equals(\"true\");\n\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n                    }\n                }\n            }\n        } finally {\n            scanner.close();\n        }\n        return new Lang(rules, languages);\n    }\n\n    private final Languages languages;\n    private final List<LangRule> rules;\n\n    private Lang(final List<LangRule> rules, final Languages languages) {\n        this.rules = Collections.unmodifiableList(rules);\n        this.languages = languages;\n    }\n\n    /**\n     * Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n     */\n    public String guessLanguage(final String text) {\n        final Languages.LanguageSet ls = guessLanguages(text);\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n    }\n\n    /**\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     */\n    public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }\n}\n"}, {"class_name": "org.apache.commons.codec.language.bm.PhoneticEngine", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language.bm;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\nimport org.apache.commons.codec.language.bm.Rule.Phoneme;\n\n/**\n * Converts words into potential phonetic representations.\n * <p>\n * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes\n * into account the likely source language. Next, this phonetic representation is converted into a\n * pan-European 'average' representation, allowing comparison between different versions of essentially\n * the same word from different languages.\n * <p>\n * This class is intentionally immutable and thread-safe.\n * If you wish to alter the settings for a PhoneticEngine, you\n * must make a new one with the updated settings.\n * <p>\n * Ported from phoneticengine.php\n *\n * @since 1.6\n * @version $Id$\n */\npublic class PhoneticEngine {\n\n    /**\n     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\n     * this package, and probably not outside the {@link PhoneticEngine} class.\n     *\n     * @since 1.6\n     */\n    static final class PhonemeBuilder {\n\n        /**\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder\n         */\n        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n            return new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n        }\n\n        private final Set<Rule.Phoneme> phonemes;\n\n        private PhonemeBuilder(final Rule.Phoneme phoneme) {\n            this.phonemes = new LinkedHashSet<Rule.Phoneme>();\n            this.phonemes.add(phoneme);\n        }\n\n        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\n            this.phonemes = phonemes;\n        }\n\n        /**\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\n         *\n         * @param str   the characters to append to the phonemes\n         */\n        public void append(final CharSequence str) {\n            for (final Rule.Phoneme ph : this.phonemes) {\n                ph.append(str);\n            }\n        }\n\n        /**\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up\n         */\n        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\n                    if (!languages.isEmpty()) {\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\n                        if (newPhonemes.size() < maxPhonemes) {\n                            newPhonemes.add(join);\n                            if (newPhonemes.size() >= maxPhonemes) {\n                                break EXPR;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.phonemes.clear();\n            this.phonemes.addAll(newPhonemes);\n        }\n\n        /**\n         * Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set\n         */\n        public Set<Rule.Phoneme> getPhonemes() {\n            return this.phonemes;\n        }\n\n        /**\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set\n         */\n        public String makeString() {\n            final StringBuilder sb = new StringBuilder();\n\n            for (final Rule.Phoneme ph : this.phonemes) {\n                if (sb.length() > 0) {\n                    sb.append(\"|\");\n                }\n                sb.append(ph.getPhonemeText());\n            }\n\n            return sb.toString();\n        }\n    }\n\n    /**\n     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\n     * After invocation, the values <code>i</code> and <code>found</code> are updated. <code>i</code> points to the\n     * index of the next char in <code>input</code> that must be processed next (the input up to that index having been\n     * processed already), and <code>found</code> indicates if a matching rule was found or not. In the case where a\n     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new builder containing the phonemes\n     * updated by the matching rule.\n     *\n     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\n     * as it is constructed as needed by the calling methods.\n     * @since 1.6\n     */\n    private static final class RulesApplication {\n        private final Map<String, List<Rule>> finalRules;\n        private final CharSequence input;\n\n        private PhonemeBuilder phonemeBuilder;\n        private int i;\n        private final int maxPhonemes;\n        private boolean found;\n\n        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\n                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\n            if (finalRules == null) {\n                throw new NullPointerException(\"The finalRules argument must not be null\");\n            }\n            this.finalRules = finalRules;\n            this.phonemeBuilder = phonemeBuilder;\n            this.input = input;\n            this.i = i;\n            this.maxPhonemes = maxPhonemes;\n        }\n\n        public int getI() {\n            return this.i;\n        }\n\n        public PhonemeBuilder getPhonemeBuilder() {\n            return this.phonemeBuilder;\n        }\n\n        /**\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return <code>this</code>\n         */\n        public RulesApplication invoke() {\n            this.found = false;\n            int patternLength = 1;\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\n            if (rules != null) {\n                for (final Rule rule : rules) {\n                    final String pattern = rule.getPattern();\n                    patternLength = pattern.length();\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                        this.found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!this.found) {\n                patternLength = 1;\n            }\n\n            this.i += patternLength;\n            return this;\n        }\n\n        public boolean isFound() {\n            return this.found;\n        }\n    }\n\n    private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\n\n    static {\n        NAME_PREFIXES.put(NameType.ASHKENAZI,\n                Collections.unmodifiableSet(\n                        new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n        NAME_PREFIXES.put(NameType.SEPHARDIC,\n                Collections.unmodifiableSet(\n                        new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\",\n                                                          \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n        NAME_PREFIXES.put(NameType.GENERIC,\n                Collections.unmodifiableSet(\n                        new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\",\n                                                          \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n    }\n\n    /**\n     * Joins some strings with an internal separator.\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n     */\n    private static String join(final Iterable<String> strings, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        final Iterator<String> si = strings.iterator();\n        if (si.hasNext()) {\n            sb.append(si.next());\n        }\n        while (si.hasNext()) {\n            sb.append(sep).append(si.next());\n        }\n\n        return sb.toString();\n    }\n\n    private static final int DEFAULT_MAX_PHONEMES = 20;\n\n    private final Lang lang;\n\n    private final NameType nameType;\n\n    private final RuleType ruleType;\n\n    private final boolean concat;\n\n    private final int maxPhonemes;\n\n    /**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     */\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n    }\n\n    /**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     * @param maxPhonemes\n     *            the maximum number of phonemes that will be handled\n     * @since 1.7\n     */\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\n                          final int maxPhonemes) {\n        if (ruleType == RuleType.RULES) {\n            throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n        }\n        this.nameType = nameType;\n        this.ruleType = ruleType;\n        this.concat = concat;\n        this.lang = Lang.instance(nameType);\n        this.maxPhonemes = maxPhonemes;\n    }\n\n    /**\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     */\n    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"finalRules can not be null\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    // not found, appending as-is\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n            // phonemes with the same text but different language set get lost\n            phonemes.addAll(subBuilder.getPhonemes());\n        }\n\n        return new PhonemeBuilder(phonemes);\n    }\n\n    /**\n     * Encodes a string to its phonetic representation.\n     *\n     * @param input\n     *            the String to encode\n     * @return the encoding of the input\n     */\n    public String encode(final String input) {\n        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n        return encode(input, languageSet);\n    }\n\n    /**\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations\n     *   of the input\n     */\n    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<String>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            for (final String aWord : words) {\n                final String[] parts = aWord.split(\"'\");\n                final String lastPart = parts[parts.length - 1];\n                words2.add(lastPart);\n            }\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            for (final String word : words2) {\n                result.append(\"-\").append(encode(word));\n            }\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }\n\n    /**\n     * Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use\n     */\n    public Lang getLang() {\n        return this.lang;\n    }\n\n    /**\n     * Gets the NameType being used.\n     *\n     * @return the NameType in use\n     */\n    public NameType getNameType() {\n        return this.nameType;\n    }\n\n    /**\n     * Gets the RuleType being used.\n     *\n     * @return the RuleType in use\n     */\n    public RuleType getRuleType() {\n        return this.ruleType;\n    }\n\n    /**\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is\n     */\n    public boolean isConcat() {\n        return this.concat;\n    }\n\n    /**\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7\n     */\n    public int getMaxPhonemes() {\n        return this.maxPhonemes;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language.bm;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\nimport org.apache.commons.codec.language.bm.Rule.Phoneme;\n\n/**\n * Converts words into potential phonetic representations.\n * <p>\n * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes\n * into account the likely source language. Next, this phonetic representation is converted into a\n * pan-European 'average' representation, allowing comparison between different versions of essentially\n * the same word from different languages.\n * <p>\n * This class is intentionally immutable and thread-safe.\n * If you wish to alter the settings for a PhoneticEngine, you\n * must make a new one with the updated settings.\n * <p>\n * Ported from phoneticengine.php\n *\n * @since 1.6\n * @version $Id$\n */\npublic class PhoneticEngine {\n\n    /**\n     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\n     * this package, and probably not outside the {@link PhoneticEngine} class.\n     *\n     * @since 1.6\n     */\n    static final class PhonemeBuilder {\n\n        /**\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder\n         */\n        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n            return new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n        }\n\n        private final Set<Rule.Phoneme> phonemes;\n\n        private PhonemeBuilder(final Rule.Phoneme phoneme) {\n            this.phonemes = new LinkedHashSet<Rule.Phoneme>();\n            this.phonemes.add(phoneme);\n        }\n\n        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\n            this.phonemes = phonemes;\n        }\n\n        /**\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\n         *\n         * @param str   the characters to append to the phonemes\n         */\n        public void append(final CharSequence str) {\n            for (final Rule.Phoneme ph : this.phonemes) {\n                ph.append(str);\n            }\n        }\n\n        /**\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up\n         */\n        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\n                    if (!languages.isEmpty()) {\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\n                        if (newPhonemes.size() < maxPhonemes) {\n                            newPhonemes.add(join);\n                            if (newPhonemes.size() >= maxPhonemes) {\n                                break EXPR;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.phonemes.clear();\n            this.phonemes.addAll(newPhonemes);\n        }\n\n        /**\n         * Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set\n         */\n        public Set<Rule.Phoneme> getPhonemes() {\n            return this.phonemes;\n        }\n\n        /**\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set\n         */\n        public String makeString() {\n            final StringBuilder sb = new StringBuilder();\n\n            for (final Rule.Phoneme ph : this.phonemes) {\n                if (sb.length() > 0) {\n                    sb.append(\"|\");\n                }\n                sb.append(ph.getPhonemeText());\n            }\n\n            return sb.toString();\n        }\n    }\n\n    /**\n     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\n     * After invocation, the values <code>i</code> and <code>found</code> are updated. <code>i</code> points to the\n     * index of the next char in <code>input</code> that must be processed next (the input up to that index having been\n     * processed already), and <code>found</code> indicates if a matching rule was found or not. In the case where a\n     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new builder containing the phonemes\n     * updated by the matching rule.\n     *\n     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\n     * as it is constructed as needed by the calling methods.\n     * @since 1.6\n     */\n    private static final class RulesApplication {\n        private final Map<String, List<Rule>> finalRules;\n        private final CharSequence input;\n\n        private PhonemeBuilder phonemeBuilder;\n        private int i;\n        private final int maxPhonemes;\n        private boolean found;\n\n        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\n                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\n            if (finalRules == null) {\n                throw new NullPointerException(\"The finalRules argument must not be null\");\n            }\n            this.finalRules = finalRules;\n            this.phonemeBuilder = phonemeBuilder;\n            this.input = input;\n            this.i = i;\n            this.maxPhonemes = maxPhonemes;\n        }\n\n        public int getI() {\n            return this.i;\n        }\n\n        public PhonemeBuilder getPhonemeBuilder() {\n            return this.phonemeBuilder;\n        }\n\n        /**\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return <code>this</code>\n         */\n        public RulesApplication invoke() {\n            this.found = false;\n            int patternLength = 1;\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\n            if (rules != null) {\n                for (final Rule rule : rules) {\n                    final String pattern = rule.getPattern();\n                    patternLength = pattern.length();\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                        this.found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!this.found) {\n                patternLength = 1;\n            }\n\n            this.i += patternLength;\n            return this;\n        }\n\n        public boolean isFound() {\n            return this.found;\n        }\n    }\n\n    private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\n\n    static {\n        NAME_PREFIXES.put(NameType.ASHKENAZI,\n                Collections.unmodifiableSet(\n                        new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n        NAME_PREFIXES.put(NameType.SEPHARDIC,\n                Collections.unmodifiableSet(\n                        new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\",\n                                                          \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n        NAME_PREFIXES.put(NameType.GENERIC,\n                Collections.unmodifiableSet(\n                        new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\",\n                                                          \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n    }\n\n    /**\n     * Joins some strings with an internal separator.\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n     */\n    private static String join(final Iterable<String> strings, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        final Iterator<String> si = strings.iterator();\n        if (si.hasNext()) {\n            sb.append(si.next());\n        }\n        while (si.hasNext()) {\n            sb.append(sep).append(si.next());\n        }\n\n        return sb.toString();\n    }\n\n    private static final int DEFAULT_MAX_PHONEMES = 20;\n\n    private final Lang lang;\n\n    private final NameType nameType;\n\n    private final RuleType ruleType;\n\n    private final boolean concat;\n\n    private final int maxPhonemes;\n\n    /**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     */\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n    }\n\n    /**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     * @param maxPhonemes\n     *            the maximum number of phonemes that will be handled\n     * @since 1.7\n     */\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\n                          final int maxPhonemes) {\n        if (ruleType == RuleType.RULES) {\n            throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n        }\n        this.nameType = nameType;\n        this.ruleType = ruleType;\n        this.concat = concat;\n        this.lang = Lang.instance(nameType);\n        this.maxPhonemes = maxPhonemes;\n    }\n\n    /**\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     */\n    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"finalRules can not be null\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    // not found, appending as-is\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n            // phonemes with the same text but different language set get lost\n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n                if (phonemes.containsKey(newPhoneme)) {\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\n                } else {\n                    phonemes.put(newPhoneme, newPhoneme);\n                }\n            }\n        }\n\n        return new PhonemeBuilder(phonemes.keySet());\n    }\n\n    /**\n     * Encodes a string to its phonetic representation.\n     *\n     * @param input\n     *            the String to encode\n     * @return the encoding of the input\n     */\n    public String encode(final String input) {\n        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n        return encode(input, languageSet);\n    }\n\n    /**\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations\n     *   of the input\n     */\n    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<String>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            for (final String aWord : words) {\n                final String[] parts = aWord.split(\"'\");\n                final String lastPart = parts[parts.length - 1];\n                words2.add(lastPart);\n            }\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            for (final String word : words2) {\n                result.append(\"-\").append(encode(word));\n            }\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }\n\n    /**\n     * Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use\n     */\n    public Lang getLang() {\n        return this.lang;\n    }\n\n    /**\n     * Gets the NameType being used.\n     *\n     * @return the NameType in use\n     */\n    public NameType getNameType() {\n        return this.nameType;\n    }\n\n    /**\n     * Gets the RuleType being used.\n     *\n     * @return the RuleType in use\n     */\n    public RuleType getRuleType() {\n        return this.ruleType;\n    }\n\n    /**\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is\n     */\n    public boolean isConcat() {\n        return this.concat;\n    }\n\n    /**\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7\n     */\n    public int getMaxPhonemes() {\n        return this.maxPhonemes;\n    }\n}\n"}, {"class_name": "org.apache.commons.codec.language.bm.Rule", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language.bm;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\n\n/**\n * A phoneme rule.\n * <p>\n * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply\n * and a logical flag indicating if all languages must be in play. A rule matches if:\n * <ul>\n * <li>the pattern matches at the current position</li>\n * <li>the string up until the beginning of the pattern matches the left context</li>\n * <li>the string from the end of the pattern matches the right context</li>\n * <li>logical is ALL and all languages are in scope; or</li>\n * <li>logical is any other value and at least one language is in scope</li>\n * </ul>\n * <p>\n * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user\n * to explicitly construct their own.\n * <p>\n * Rules are immutable and thread-safe.\n * <p>\n * <b>Rules resources</b>\n * <p>\n * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically\n * named following the pattern:\n * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * <ul>\n * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these\n * will be interpreted as:\n * <ol>\n * <li>pattern</li>\n * <li>left context</li>\n * <li>right context</li>\n * <li>phoneme</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be discarded\n * as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip\n * all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n *\n * @since 1.6\n * @version $Id$\n */\npublic class Rule {\n\n    public static final class Phoneme implements PhonemeExpr {\n        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\n            @Override\n            public int compare(final Phoneme o1, final Phoneme o2) {\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\n                    if (i >= o2.phonemeText.length()) {\n                        return +1;\n                    }\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\n                    if (c != 0) {\n                        return c;\n                    }\n                }\n\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\n                    return -1;\n                }\n\n                return 0;\n            }\n        };\n\n        private final StringBuilder phonemeText;\n        private final Languages.LanguageSet languages;\n\n        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\n            this.phonemeText = new StringBuilder(phonemeText);\n            this.languages = languages;\n        }\n\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {\n            this(phonemeLeft.phonemeText, phonemeLeft.languages);\n            this.phonemeText.append(phonemeRight.phonemeText);\n        }\n\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\n            this(phonemeLeft.phonemeText, languages);\n            this.phonemeText.append(phonemeRight.phonemeText);\n        }\n\n        public Phoneme append(final CharSequence str) {\n            this.phonemeText.append(str);\n            return this;\n        }\n\n        public Languages.LanguageSet getLanguages() {\n            return this.languages;\n        }\n\n        @Override\n        public Iterable<Phoneme> getPhonemes() {\n            return Collections.singleton(this);\n        }\n\n        public CharSequence getPhonemeText() {\n            return this.phonemeText;\n        }\n\n        /**\n         * @deprecated since 1.9\n         */\n        @Deprecated\n        public Phoneme join(final Phoneme right) {\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\n                               this.languages.restrictTo(right.languages));\n        }\n\n        /**\n         * Returns a new Phoneme with the same text but a union of its\n         * current language set and the given one.\n         *\n         * @param lang the language set to merge\n         * @return a new Phoneme\n         */\n\n        @Override\n        public String toString() {\n          return phonemeText.toString() + \"[\" + languages + \"]\";\n        }\n    }\n\n    public interface PhonemeExpr {\n        Iterable<Phoneme> getPhonemes();\n    }\n\n    public static final class PhonemeList implements PhonemeExpr {\n        private final List<Phoneme> phonemes;\n\n        public PhonemeList(final List<Phoneme> phonemes) {\n            this.phonemes = phonemes;\n        }\n\n        @Override\n        public List<Phoneme> getPhonemes() {\n            return this.phonemes;\n        }\n    }\n\n    /**\n     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n     */\n    public interface RPattern {\n        boolean isMatch(CharSequence input);\n    }\n\n    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n        @Override\n        public boolean isMatch(final CharSequence input) {\n            return true;\n        }\n    };\n\n    public static final String ALL = \"ALL\";\n\n    private static final String DOUBLE_QUOTE = \"\\\"\";\n\n    private static final String HASH_INCLUDE = \"#include\";\n\n    private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES =\n            new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\n\n    static {\n        for (final NameType s : NameType.values()) {\n            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts =\n                    new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\n\n            for (final RuleType rt : RuleType.values()) {\n                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\n\n                final Languages ls = Languages.getInstance(s);\n                for (final String l : ls.getLanguages()) {\n                    try {\n                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));\n                    } catch (final IllegalStateException e) {\n                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n                    }\n                }\n                if (!rt.equals(RuleType.RULES)) {\n                    rs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\")));\n                }\n\n                rts.put(rt, Collections.unmodifiableMap(rs));\n            }\n\n            RULES.put(s, Collections.unmodifiableMap(rts));\n        }\n    }\n\n    private static boolean contains(final CharSequence chars, final char input) {\n        for (int i = 0; i < chars.length(); i++) {\n            if (chars.charAt(i) == input) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\n        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\n                             nameType.getName(), rt.getName(), lang);\n    }\n\n    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\n        final String resName = createResourceName(nameType, rt, lang);\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\n        if (rulesIS == null) {\n            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n        }\n\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n    }\n\n    private static Scanner createScanner(final String lang) {\n        final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\n        if (rulesIS == null) {\n            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n        }\n\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n    }\n\n    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\n        if (suffix.length() > input.length()) {\n            return false;\n        }\n        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n            if (input.charAt(i) != suffix.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a list of Rules that apply\n     */\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\n                                         final Languages.LanguageSet langs) {\n        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\n        final List<Rule> allRules = new ArrayList<Rule>();\n        for (final List<Rule> rules : ruleMap.values()) {\n            allRules.addAll(rules);\n        }\n        return allRules;\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply\n     */\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     */\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final Languages.LanguageSet langs) {\n        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\n                                     getInstanceMap(nameType, rt, Languages.ANY);\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     */\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final String lang) {\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n\n        if (rules == null) {\n            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\n                                               nameType.getName(), rt.getName(), lang));\n        }\n\n        return rules;\n    }\n\n    private static Phoneme parsePhoneme(final String ph) {\n        final int open = ph.indexOf(\"[\");\n        if (open >= 0) {\n            if (!ph.endsWith(\"]\")) {\n                throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n            }\n            final String before = ph.substring(0, open);\n            final String in = ph.substring(open + 1, ph.length() - 1);\n            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n\n            return new Phoneme(before, Languages.LanguageSet.from(langs));\n        } else {\n            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n        }\n    }\n\n    private static PhonemeExpr parsePhonemeExpr(final String ph) {\n        if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n            if (!ph.endsWith(\")\")) {\n                throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n            }\n\n            final List<Phoneme> phs = new ArrayList<Phoneme>();\n            final String body = ph.substring(1, ph.length() - 1);\n            for (final String part : body.split(\"[|]\")) {\n                phs.add(parsePhoneme(part));\n            }\n            if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n                phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n            }\n\n            return new PhonemeList(phs);\n        } else {\n            return parsePhoneme(ph);\n        }\n    }\n\n    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\n        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\n        int currentLine = 0;\n\n        boolean inMultilineComment = false;\n        while (scanner.hasNextLine()) {\n            currentLine++;\n            final String rawLine = scanner.nextLine();\n            String line = rawLine;\n\n            if (inMultilineComment) {\n                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                    inMultilineComment = false;\n                }\n            } else {\n                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                    inMultilineComment = true;\n                } else {\n                    // discard comments\n                    final int cmtI = line.indexOf(ResourceConstants.CMT);\n                    if (cmtI >= 0) {\n                        line = line.substring(0, cmtI);\n                    }\n\n                    // trim leading-trailing whitespace\n                    line = line.trim();\n\n                    if (line.length() == 0) {\n                        continue; // empty lines can be safely skipped\n                    }\n\n                    if (line.startsWith(HASH_INCLUDE)) {\n                        // include statement\n                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\n                        if (incl.contains(\" \")) {\n                            throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\n                                                               location);\n                        } else {\n                            lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                        }\n                    } else {\n                        // rule\n                        final String[] parts = line.split(\"\\\\s+\");\n                        if (parts.length != 4) {\n                            throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n                                                               \" parts: \" + rawLine + \" in \" + location);\n                        } else {\n                            try {\n                                final String pat = stripQuotes(parts[0]);\n                                final String lCon = stripQuotes(parts[1]);\n                                final String rCon = stripQuotes(parts[2]);\n                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n                                final int cLine = currentLine;\n                                final Rule r = new Rule(pat, lCon, rCon, ph) {\n                                    private final int myLine = cLine;\n                                    private final String loc = location;\n\n                                    @Override\n                                    public String toString() {\n                                        final StringBuilder sb = new StringBuilder();\n                                        sb.append(\"Rule\");\n                                        sb.append(\"{line=\").append(myLine);\n                                        sb.append(\", loc='\").append(loc).append('\\'');\n                                        sb.append(\", pat='\").append(pat).append('\\'');\n                                        sb.append(\", lcon='\").append(lCon).append('\\'');\n                                        sb.append(\", rcon='\").append(rCon).append('\\'');\n                                        sb.append('}');\n                                        return sb.toString();\n                                    }\n                                };\n                                final String patternKey = r.pattern.substring(0,1);\n                                List<Rule> rules = lines.get(patternKey);\n                                if (rules == null) {\n                                    rules = new ArrayList<Rule>();\n                                    lines.put(patternKey, rules);\n                                }\n                                rules.add(r);\n                            } catch (final IllegalArgumentException e) {\n                                throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n                                                                location, e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return lines;\n    }\n\n    /**\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex\n     */\n    private static RPattern pattern(final String regex) {\n        final boolean startsWith = regex.startsWith(\"^\");\n        final boolean endsWith = regex.endsWith(\"$\");\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n        final boolean boxes = content.contains(\"[\");\n\n        if (!boxes) {\n            if (startsWith && endsWith) {\n                // exact match\n                if (content.length() == 0) {\n                    // empty\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.length() == 0;\n                        }\n                    };\n                } else {\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.equals(content);\n                        }\n                    };\n                }\n            } else if ((startsWith || endsWith) && content.length() == 0) {\n                // matches every string\n                return ALL_STRINGS_RMATCHER;\n            } else if (startsWith) {\n                // matches from start\n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return startsWith(input, content);\n                    }\n                };\n            } else if (endsWith) {\n                // matches from start\n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return endsWith(input, content);\n                    }\n                };\n            }\n        } else {\n            final boolean startsWithBox = content.startsWith(\"[\");\n            final boolean endsWithBox = content.endsWith(\"]\");\n\n            if (startsWithBox && endsWithBox) {\n                String boxContent = content.substring(1, content.length() - 1);\n                if (!boxContent.contains(\"[\")) {\n                    // box containing alternatives\n                    final boolean negate = boxContent.startsWith(\"^\");\n                    if (negate) {\n                        boxContent = boxContent.substring(1);\n                    }\n                    final String bContent = boxContent;\n                    final boolean shouldMatch = !negate;\n\n                    if (startsWith && endsWith) {\n                        // exact match\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (startsWith) {\n                        // first char\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (endsWith) {\n                        // last char\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 &&\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        return new RPattern() {\n            Pattern pattern = Pattern.compile(regex);\n\n            @Override\n            public boolean isMatch(final CharSequence input) {\n                final Matcher matcher = pattern.matcher(input);\n                return matcher.find();\n            }\n        };\n    }\n\n    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\n        if (prefix.length() > input.length()) {\n            return false;\n        }\n        for (int i = 0; i < prefix.length(); i++) {\n            if (input.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static String stripQuotes(String str) {\n        if (str.startsWith(DOUBLE_QUOTE)) {\n            str = str.substring(1);\n        }\n\n        if (str.endsWith(DOUBLE_QUOTE)) {\n            str = str.substring(0, str.length() - 1);\n        }\n\n        return str;\n    }\n\n    private final RPattern lContext;\n\n    private final String pattern;\n\n    private final PhonemeExpr phoneme;\n\n    private final RPattern rContext;\n\n    /**\n     * Creates a new rule.\n     *\n     * @param pattern\n     *            the pattern\n     * @param lContext\n     *            the left context\n     * @param rContext\n     *            the right context\n     * @param phoneme\n     *            the resulting phoneme\n     */\n    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\n        this.pattern = pattern;\n        this.lContext = pattern(lContext + \"$\");\n        this.rContext = pattern(\"^\" + rContext);\n        this.phoneme = phoneme;\n    }\n\n    /**\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern\n     */\n    public RPattern getLContext() {\n        return this.lContext;\n    }\n\n    /**\n     * Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern\n     */\n    public String getPattern() {\n        return this.pattern;\n    }\n\n    /**\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme\n     */\n    public PhonemeExpr getPhoneme() {\n        return this.phoneme;\n    }\n\n    /**\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern\n     */\n    public RPattern getRContext() {\n        return this.rContext;\n    }\n\n    /**\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise\n     */\n    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n        if (i < 0) {\n            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n        }\n\n        final int patternLength = this.pattern.length();\n        final int ipl = i + patternLength;\n\n        if (ipl > input.length()) {\n            // not enough room for the pattern to match\n            return false;\n        }\n\n        // evaluate the pattern, left context and right context\n        // fail early if any of the evaluations is not successful\n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\n            return false;\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\n            return false;\n        }\n        return this.lContext.isMatch(input.subSequence(0, i));\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language.bm;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\n\n/**\n * A phoneme rule.\n * <p>\n * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply\n * and a logical flag indicating if all languages must be in play. A rule matches if:\n * <ul>\n * <li>the pattern matches at the current position</li>\n * <li>the string up until the beginning of the pattern matches the left context</li>\n * <li>the string from the end of the pattern matches the right context</li>\n * <li>logical is ALL and all languages are in scope; or</li>\n * <li>logical is any other value and at least one language is in scope</li>\n * </ul>\n * <p>\n * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user\n * to explicitly construct their own.\n * <p>\n * Rules are immutable and thread-safe.\n * <p>\n * <b>Rules resources</b>\n * <p>\n * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically\n * named following the pattern:\n * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * <ul>\n * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these\n * will be interpreted as:\n * <ol>\n * <li>pattern</li>\n * <li>left context</li>\n * <li>right context</li>\n * <li>phoneme</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be discarded\n * as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip\n * all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n *\n * @since 1.6\n * @version $Id$\n */\npublic class Rule {\n\n    public static final class Phoneme implements PhonemeExpr {\n        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\n            @Override\n            public int compare(final Phoneme o1, final Phoneme o2) {\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\n                    if (i >= o2.phonemeText.length()) {\n                        return +1;\n                    }\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\n                    if (c != 0) {\n                        return c;\n                    }\n                }\n\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\n                    return -1;\n                }\n\n                return 0;\n            }\n        };\n\n        private final StringBuilder phonemeText;\n        private final Languages.LanguageSet languages;\n\n        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\n            this.phonemeText = new StringBuilder(phonemeText);\n            this.languages = languages;\n        }\n\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {\n            this(phonemeLeft.phonemeText, phonemeLeft.languages);\n            this.phonemeText.append(phonemeRight.phonemeText);\n        }\n\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\n            this(phonemeLeft.phonemeText, languages);\n            this.phonemeText.append(phonemeRight.phonemeText);\n        }\n\n        public Phoneme append(final CharSequence str) {\n            this.phonemeText.append(str);\n            return this;\n        }\n\n        public Languages.LanguageSet getLanguages() {\n            return this.languages;\n        }\n\n        @Override\n        public Iterable<Phoneme> getPhonemes() {\n            return Collections.singleton(this);\n        }\n\n        public CharSequence getPhonemeText() {\n            return this.phonemeText;\n        }\n\n        /**\n         * @deprecated since 1.9\n         */\n        @Deprecated\n        public Phoneme join(final Phoneme right) {\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\n                               this.languages.restrictTo(right.languages));\n        }\n\n        /**\n         * Returns a new Phoneme with the same text but a union of its\n         * current language set and the given one.\n         *\n         * @param lang the language set to merge\n         * @return a new Phoneme\n         */\n        public Phoneme mergeWithLanguage(final LanguageSet lang) {\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\n        }\n\n        @Override\n        public String toString() {\n          return phonemeText.toString() + \"[\" + languages + \"]\";\n        }\n    }\n\n    public interface PhonemeExpr {\n        Iterable<Phoneme> getPhonemes();\n    }\n\n    public static final class PhonemeList implements PhonemeExpr {\n        private final List<Phoneme> phonemes;\n\n        public PhonemeList(final List<Phoneme> phonemes) {\n            this.phonemes = phonemes;\n        }\n\n        @Override\n        public List<Phoneme> getPhonemes() {\n            return this.phonemes;\n        }\n    }\n\n    /**\n     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n     */\n    public interface RPattern {\n        boolean isMatch(CharSequence input);\n    }\n\n    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n        @Override\n        public boolean isMatch(final CharSequence input) {\n            return true;\n        }\n    };\n\n    public static final String ALL = \"ALL\";\n\n    private static final String DOUBLE_QUOTE = \"\\\"\";\n\n    private static final String HASH_INCLUDE = \"#include\";\n\n    private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES =\n            new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\n\n    static {\n        for (final NameType s : NameType.values()) {\n            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts =\n                    new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\n\n            for (final RuleType rt : RuleType.values()) {\n                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\n\n                final Languages ls = Languages.getInstance(s);\n                for (final String l : ls.getLanguages()) {\n                    try {\n                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));\n                    } catch (final IllegalStateException e) {\n                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n                    }\n                }\n                if (!rt.equals(RuleType.RULES)) {\n                    rs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\")));\n                }\n\n                rts.put(rt, Collections.unmodifiableMap(rs));\n            }\n\n            RULES.put(s, Collections.unmodifiableMap(rts));\n        }\n    }\n\n    private static boolean contains(final CharSequence chars, final char input) {\n        for (int i = 0; i < chars.length(); i++) {\n            if (chars.charAt(i) == input) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\n        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\n                             nameType.getName(), rt.getName(), lang);\n    }\n\n    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\n        final String resName = createResourceName(nameType, rt, lang);\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\n        if (rulesIS == null) {\n            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n        }\n\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n    }\n\n    private static Scanner createScanner(final String lang) {\n        final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\n        if (rulesIS == null) {\n            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n        }\n\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n    }\n\n    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\n        if (suffix.length() > input.length()) {\n            return false;\n        }\n        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n            if (input.charAt(i) != suffix.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a list of Rules that apply\n     */\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\n                                         final Languages.LanguageSet langs) {\n        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\n        final List<Rule> allRules = new ArrayList<Rule>();\n        for (final List<Rule> rules : ruleMap.values()) {\n            allRules.addAll(rules);\n        }\n        return allRules;\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply\n     */\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     */\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final Languages.LanguageSet langs) {\n        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\n                                     getInstanceMap(nameType, rt, Languages.ANY);\n    }\n\n    /**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     */\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final String lang) {\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n\n        if (rules == null) {\n            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\n                                               nameType.getName(), rt.getName(), lang));\n        }\n\n        return rules;\n    }\n\n    private static Phoneme parsePhoneme(final String ph) {\n        final int open = ph.indexOf(\"[\");\n        if (open >= 0) {\n            if (!ph.endsWith(\"]\")) {\n                throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n            }\n            final String before = ph.substring(0, open);\n            final String in = ph.substring(open + 1, ph.length() - 1);\n            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n\n            return new Phoneme(before, Languages.LanguageSet.from(langs));\n        } else {\n            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n        }\n    }\n\n    private static PhonemeExpr parsePhonemeExpr(final String ph) {\n        if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n            if (!ph.endsWith(\")\")) {\n                throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n            }\n\n            final List<Phoneme> phs = new ArrayList<Phoneme>();\n            final String body = ph.substring(1, ph.length() - 1);\n            for (final String part : body.split(\"[|]\")) {\n                phs.add(parsePhoneme(part));\n            }\n            if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n                phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n            }\n\n            return new PhonemeList(phs);\n        } else {\n            return parsePhoneme(ph);\n        }\n    }\n\n    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\n        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\n        int currentLine = 0;\n\n        boolean inMultilineComment = false;\n        while (scanner.hasNextLine()) {\n            currentLine++;\n            final String rawLine = scanner.nextLine();\n            String line = rawLine;\n\n            if (inMultilineComment) {\n                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                    inMultilineComment = false;\n                }\n            } else {\n                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                    inMultilineComment = true;\n                } else {\n                    // discard comments\n                    final int cmtI = line.indexOf(ResourceConstants.CMT);\n                    if (cmtI >= 0) {\n                        line = line.substring(0, cmtI);\n                    }\n\n                    // trim leading-trailing whitespace\n                    line = line.trim();\n\n                    if (line.length() == 0) {\n                        continue; // empty lines can be safely skipped\n                    }\n\n                    if (line.startsWith(HASH_INCLUDE)) {\n                        // include statement\n                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\n                        if (incl.contains(\" \")) {\n                            throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\n                                                               location);\n                        } else {\n                            lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                        }\n                    } else {\n                        // rule\n                        final String[] parts = line.split(\"\\\\s+\");\n                        if (parts.length != 4) {\n                            throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n                                                               \" parts: \" + rawLine + \" in \" + location);\n                        } else {\n                            try {\n                                final String pat = stripQuotes(parts[0]);\n                                final String lCon = stripQuotes(parts[1]);\n                                final String rCon = stripQuotes(parts[2]);\n                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n                                final int cLine = currentLine;\n                                final Rule r = new Rule(pat, lCon, rCon, ph) {\n                                    private final int myLine = cLine;\n                                    private final String loc = location;\n\n                                    @Override\n                                    public String toString() {\n                                        final StringBuilder sb = new StringBuilder();\n                                        sb.append(\"Rule\");\n                                        sb.append(\"{line=\").append(myLine);\n                                        sb.append(\", loc='\").append(loc).append('\\'');\n                                        sb.append(\", pat='\").append(pat).append('\\'');\n                                        sb.append(\", lcon='\").append(lCon).append('\\'');\n                                        sb.append(\", rcon='\").append(rCon).append('\\'');\n                                        sb.append('}');\n                                        return sb.toString();\n                                    }\n                                };\n                                final String patternKey = r.pattern.substring(0,1);\n                                List<Rule> rules = lines.get(patternKey);\n                                if (rules == null) {\n                                    rules = new ArrayList<Rule>();\n                                    lines.put(patternKey, rules);\n                                }\n                                rules.add(r);\n                            } catch (final IllegalArgumentException e) {\n                                throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n                                                                location, e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return lines;\n    }\n\n    /**\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex\n     */\n    private static RPattern pattern(final String regex) {\n        final boolean startsWith = regex.startsWith(\"^\");\n        final boolean endsWith = regex.endsWith(\"$\");\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n        final boolean boxes = content.contains(\"[\");\n\n        if (!boxes) {\n            if (startsWith && endsWith) {\n                // exact match\n                if (content.length() == 0) {\n                    // empty\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.length() == 0;\n                        }\n                    };\n                } else {\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.equals(content);\n                        }\n                    };\n                }\n            } else if ((startsWith || endsWith) && content.length() == 0) {\n                // matches every string\n                return ALL_STRINGS_RMATCHER;\n            } else if (startsWith) {\n                // matches from start\n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return startsWith(input, content);\n                    }\n                };\n            } else if (endsWith) {\n                // matches from start\n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return endsWith(input, content);\n                    }\n                };\n            }\n        } else {\n            final boolean startsWithBox = content.startsWith(\"[\");\n            final boolean endsWithBox = content.endsWith(\"]\");\n\n            if (startsWithBox && endsWithBox) {\n                String boxContent = content.substring(1, content.length() - 1);\n                if (!boxContent.contains(\"[\")) {\n                    // box containing alternatives\n                    final boolean negate = boxContent.startsWith(\"^\");\n                    if (negate) {\n                        boxContent = boxContent.substring(1);\n                    }\n                    final String bContent = boxContent;\n                    final boolean shouldMatch = !negate;\n\n                    if (startsWith && endsWith) {\n                        // exact match\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (startsWith) {\n                        // first char\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (endsWith) {\n                        // last char\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 &&\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        return new RPattern() {\n            Pattern pattern = Pattern.compile(regex);\n\n            @Override\n            public boolean isMatch(final CharSequence input) {\n                final Matcher matcher = pattern.matcher(input);\n                return matcher.find();\n            }\n        };\n    }\n\n    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\n        if (prefix.length() > input.length()) {\n            return false;\n        }\n        for (int i = 0; i < prefix.length(); i++) {\n            if (input.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static String stripQuotes(String str) {\n        if (str.startsWith(DOUBLE_QUOTE)) {\n            str = str.substring(1);\n        }\n\n        if (str.endsWith(DOUBLE_QUOTE)) {\n            str = str.substring(0, str.length() - 1);\n        }\n\n        return str;\n    }\n\n    private final RPattern lContext;\n\n    private final String pattern;\n\n    private final PhonemeExpr phoneme;\n\n    private final RPattern rContext;\n\n    /**\n     * Creates a new rule.\n     *\n     * @param pattern\n     *            the pattern\n     * @param lContext\n     *            the left context\n     * @param rContext\n     *            the right context\n     * @param phoneme\n     *            the resulting phoneme\n     */\n    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\n        this.pattern = pattern;\n        this.lContext = pattern(lContext + \"$\");\n        this.rContext = pattern(\"^\" + rContext);\n        this.phoneme = phoneme;\n    }\n\n    /**\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern\n     */\n    public RPattern getLContext() {\n        return this.lContext;\n    }\n\n    /**\n     * Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern\n     */\n    public String getPattern() {\n        return this.pattern;\n    }\n\n    /**\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme\n     */\n    public PhonemeExpr getPhoneme() {\n        return this.phoneme;\n    }\n\n    /**\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern\n     */\n    public RPattern getRContext() {\n        return this.rContext;\n    }\n\n    /**\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise\n     */\n    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n        if (i < 0) {\n            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n        }\n\n        final int patternLength = this.pattern.length();\n        final int ipl = i + patternLength;\n\n        if (ipl > input.length()) {\n            // not enough room for the pattern to match\n            return false;\n        }\n\n        // evaluate the pattern, left context and right context\n        // fail early if any of the evaluations is not successful\n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\n            return false;\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\n            return false;\n        }\n        return this.lContext.isMatch(input.subSequence(0, i));\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 15, "classes_modified": [{"class_name": "org.apache.commons.codec.language.Soundex", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a\n * general purpose scheme to find word with similar phonemes.\n *\n * This class is thread-safe.\n * Although not strictly immutable, the {@link #maxLength} field is not actually used.\n *\n * @version $Id$\n */\npublic class Soundex implements StringEncoder {\n\n    /**\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n     * means do not encode.\n     * <p>\n     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick\n     * up the value for the constant values page.)\n     * </p>\n     *\n     * @see #US_ENGLISH_MAPPING\n     */\n    public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\n\n    /**\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n     * means do not encode.\n     *\n     * @see Soundex#Soundex(char[])\n     */\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n\n    /**\n     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n     *\n     * @see #US_ENGLISH_MAPPING\n     */\n    public static final Soundex US_ENGLISH = new Soundex();\n\n    /**\n     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     */\n    @Deprecated\n    private int maxLength = 4;\n\n    /**\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     */\n    private final char[] soundexMapping;\n\n    /**\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     */\n    public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }\n\n    /**\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     */\n    public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }\n\n    /**\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */\n    public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }\n\n    /**\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */\n    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }\n\n    /**\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) obj);\n    }\n\n    /**\n     * Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public String encode(final String str) {\n        return soundex(str);\n    }\n\n    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            final char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }\n\n    /**\n     * Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     */\n    @Deprecated\n    public int getMaxLength() {\n        return this.maxLength;\n    }\n\n    /**\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     */\n    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }\n\n    /**\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     */\n    private char map(final char ch) {\n        final int index = ch - 'A';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }\n\n    /**\n     * Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     */\n    @Deprecated\n    public void setMaxLength(final int maxLength) {\n        this.maxLength = maxLength;\n    }\n\n    /**\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char out[] = {'0', '0', '0', '0'};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        // getMappingCode() throws IllegalArgumentException\n        last = getMappingCode(str, 0);\n        while (incount < str.length() && count < out.length) {\n            mapped = getMappingCode(str, incount++);\n            if (mapped != 0) {\n                if (mapped != '0' && mapped != last) {\n                    out[count++] = mapped;\n                }\n                last = mapped;\n            }\n        }\n        return new String(out);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.language;\n\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\n\n/**\n * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a\n * general purpose scheme to find word with similar phonemes.\n *\n * This class is thread-safe.\n * Although not strictly immutable, the {@link #maxLength} field is not actually used.\n *\n * @version $Id$\n */\npublic class Soundex implements StringEncoder {\n\n    /**\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n     * means do not encode.\n     * <p>\n     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick\n     * up the value for the constant values page.)\n     * </p>\n     *\n     * @see #US_ENGLISH_MAPPING\n     */\n    public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\n\n    /**\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n     * means do not encode.\n     *\n     * @see Soundex#Soundex(char[])\n     */\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n\n    /**\n     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n     *\n     * @see #US_ENGLISH_MAPPING\n     */\n    public static final Soundex US_ENGLISH = new Soundex();\n\n    /**\n     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     */\n    @Deprecated\n    private int maxLength = 4;\n\n    /**\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     */\n    private final char[] soundexMapping;\n\n    /**\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     */\n    public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }\n\n    /**\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     */\n    public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }\n\n    /**\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */\n    public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }\n\n    /**\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */\n    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }\n\n    /**\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) obj);\n    }\n\n    /**\n     * Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public String encode(final String str) {\n        return soundex(str);\n    }\n\n    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            for (int i=index-1 ; i>=0 ; i--) {\n                final char prevChar = str.charAt(i);\n                if (this.map(prevChar)==mappedChar) {\n                    return 0;\n                }\n                if ('H'!=prevChar && 'W'!=prevChar) {\n                    break;\n                }\n            }\n        }\n        return mappedChar;\n    }\n\n    /**\n     * Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     */\n    @Deprecated\n    public int getMaxLength() {\n        return this.maxLength;\n    }\n\n    /**\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     */\n    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }\n\n    /**\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     */\n    private char map(final char ch) {\n        final int index = ch - 'A';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }\n\n    /**\n     * Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     */\n    @Deprecated\n    public void setMaxLength(final int maxLength) {\n        this.maxLength = maxLength;\n    }\n\n    /**\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char out[] = {'0', '0', '0', '0'};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        // getMappingCode() throws IllegalArgumentException\n        last = getMappingCode(str, 0);\n        while (incount < str.length() && count < out.length) {\n            mapped = getMappingCode(str, incount++);\n            if (mapped != 0) {\n                if (mapped != '0' && mapped != last) {\n                    out[count++] = mapped;\n                }\n                last = mapped;\n            }\n        }\n        return new String(out);\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 16, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.Base32", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\n/**\n * Provides Base32 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>.\n *\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * </p>\n * <ul>\n * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\n * 8 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * <p>\n * This class operates directly on byte streams, and not character streams.\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n *\n * @since 1.5\n * @version $Id$\n */\npublic class Base32 extends BaseNCodec {\n\n    /**\n     * BASE32 characters are 5 bits in length.\n     * They are formed by taking a block of five octets to form a 40-bit string,\n     * which is converted into eight BASE32 characters.\n     */\n    private static final int BITS_PER_ENCODED_BYTE = 5;\n    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified\n     * in Table 3 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n     * alphabet but fall within the bounds of the array are translated to -1.\n     */\n    private static final byte[] DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a P-Z\n    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n     * equivalents as specified in Table 3 of RFC 4648.\n     */\n    private static final byte[] ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '2', '3', '4', '5', '6', '7',\n    };\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Hex Alphabet\" (as\n     * specified in Table 4 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the\n     * Base32 Hex alphabet but fall within the bounds of the array are translated to -1.\n     */\n    private static final byte[] HEX_DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n            25, 26, 27, 28, 29, 30, 31, 32,\n    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their\n     * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n     */\n    private static final byte[] HEX_ENCODE_TABLE = {\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n    };\n\n    /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n    private static final int MASK_5BITS = 0x1f;\n\n    // The static final fields above are used for the original static byte[] methods on Base32.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Place holder for the bytes we're dealing with for our based logic.\n     * Bitwise operations store and extract the encoding or decoding from this variable.\n     */\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Decode table to use.\n     */\n    private final byte[] decodeTable;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = {@link #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Encode table to use.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     */\n    public Base32() {\n        this(false);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param pad byte used as padding byte.\n     */\n    public Base32(final byte pad) {\n        this(false, pad);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     */\n    public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     * @param pad byte used as padding byte.\n     */\n    public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     */\n    public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n     */\n    public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }\n\n    /**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }\n\n    /**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param pad byte used as padding byte.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n            }\n            // Must be done after initializing the tables\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to Base32 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     *\n     * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\n     */\n    @Override\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        // package protected for access from I/O streams\n\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte b = in[inPos++];\n            if (b == pad) {\n                // We're done.\n                context.eof = true;\n                break;\n            } else {\n                final byte[] buffer = ensureBufferSize(decodeSize, context);\n                if (b >= 0 && b < this.decodeTable.length) {\n                    final int result = this.decodeTable[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                        // collect decoded bytes\n                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) { // we can output the 5 bytes\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            //  we ignore partial bytes, i.e. only multiples of 8 count\n            switch (context.modulus) {\n                case 2 : // 10 bits, drop 2 and output one byte\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\n                    break;\n                case 3 : // 15 bits, drop 7 and output 1 byte\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\n                    break;\n                case 4 : // 20 bits = 2*8 + 4\n                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 5 : // 25bits = 3*8 + 1\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 6 : // 30bits = 3*8 + 6\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 7 : // 35 = 4*8 +3\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                default:\n                    // modulus can be 0-7, and we excluded 0,1 already\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 5).\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to Base32 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     */\n    @Override\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        // package protected for access from I/O streams\n\n        if (context.eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            context.eof = true;\n            if (0 == context.modulus && lineLength == 0) {\n                return; // no leftovers to process and not using chunking\n            }\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\n            final int savedPos = context.pos;\n            switch (context.modulus) { // % 5\n                case 0 :\n                    break;\n                case 1 : // Only 1 octet; take top 5 bits then remainder\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 2 : // 2 octets = 16 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 3 : // 3 octets = 24 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 4 : // 4 octets = 32 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n                    buffer[context.pos++] = pad;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                context.pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\n                if (0 == context.modulus) { // we have enough bytes to create our output\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                        context.pos += lineSeparator.length;\n                        context.currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the {@code octet} is in the Base32 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\n     */\n    @Override\n    public boolean isInAlphabet(final byte octet) {\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\n/**\n * Provides Base32 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>.\n *\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * </p>\n * <ul>\n * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\n * 8 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * <p>\n * This class operates directly on byte streams, and not character streams.\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n *\n * @since 1.5\n * @version $Id$\n */\npublic class Base32 extends BaseNCodec {\n\n    /**\n     * BASE32 characters are 5 bits in length.\n     * They are formed by taking a block of five octets to form a 40-bit string,\n     * which is converted into eight BASE32 characters.\n     */\n    private static final int BITS_PER_ENCODED_BYTE = 5;\n    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n\n    /**\n     * Chunk separator per RFC 2045 section 2.1.\n     *\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     */\n    private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified\n     * in Table 3 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n     * alphabet but fall within the bounds of the array are translated to -1.\n     */\n    private static final byte[] DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a P-Z\n    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n     * equivalents as specified in Table 3 of RFC 4648.\n     */\n    private static final byte[] ENCODE_TABLE = {\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '2', '3', '4', '5', '6', '7',\n    };\n\n    /**\n     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Hex Alphabet\" (as\n     * specified in Table 4 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the\n     * Base32 Hex alphabet but fall within the bounds of the array are translated to -1.\n     */\n    private static final byte[] HEX_DECODE_TABLE = {\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n            25, 26, 27, 28, 29, 30, 31,                                     // 50-57 P-V\n    };\n\n    /**\n     * This array is a lookup table that translates 5-bit positive integer index values into their\n     * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n     */\n    private static final byte[] HEX_ENCODE_TABLE = {\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n    };\n\n    /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n    private static final int MASK_5BITS = 0x1f;\n\n    // The static final fields above are used for the original static byte[] methods on Base32.\n    // The private member fields below are used with the new streaming approach, which requires\n    // some state be preserved between calls of encode() and decode().\n\n    /**\n     * Place holder for the bytes we're dealing with for our based logic.\n     * Bitwise operations store and extract the encoding or decoding from this variable.\n     */\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\n     */\n    private final int decodeSize;\n\n    /**\n     * Decode table to use.\n     */\n    private final byte[] decodeTable;\n\n    /**\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     * <code>encodeSize = {@link #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\n     */\n    private final int encodeSize;\n\n    /**\n     * Encode table to use.\n     */\n    private final byte[] encodeTable;\n\n    /**\n     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\n     */\n    private final byte[] lineSeparator;\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     */\n    public Base32() {\n        this(false);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param pad byte used as padding byte.\n     */\n    public Base32(final byte pad) {\n        this(false, pad);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     */\n    public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     * @param pad byte used as padding byte.\n     */\n    public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     */\n    public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }\n\n    /**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n     */\n    public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }\n\n    /**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }\n\n    /**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param pad byte used as padding byte.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n            }\n            // Must be done after initializing the tables\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n        }\n    }\n\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to Base32 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     *\n     * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\n     */\n    @Override\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        // package protected for access from I/O streams\n\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte b = in[inPos++];\n            if (b == pad) {\n                // We're done.\n                context.eof = true;\n                break;\n            } else {\n                final byte[] buffer = ensureBufferSize(decodeSize, context);\n                if (b >= 0 && b < this.decodeTable.length) {\n                    final int result = this.decodeTable[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                        // collect decoded bytes\n                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) { // we can output the 5 bytes\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            //  we ignore partial bytes, i.e. only multiples of 8 count\n            switch (context.modulus) {\n                case 2 : // 10 bits, drop 2 and output one byte\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\n                    break;\n                case 3 : // 15 bits, drop 7 and output 1 byte\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\n                    break;\n                case 4 : // 20 bits = 2*8 + 4\n                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 5 : // 25bits = 3*8 + 1\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 6 : // 30bits = 3*8 + 6\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 7 : // 35 = 4*8 +3\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                default:\n                    // modulus can be 0-7, and we excluded 0,1 already\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 5).\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to Base32 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     */\n    @Override\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        // package protected for access from I/O streams\n\n        if (context.eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            context.eof = true;\n            if (0 == context.modulus && lineLength == 0) {\n                return; // no leftovers to process and not using chunking\n            }\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\n            final int savedPos = context.pos;\n            switch (context.modulus) { // % 5\n                case 0 :\n                    break;\n                case 1 : // Only 1 octet; take top 5 bits then remainder\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 2 : // 2 octets = 16 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 3 : // 3 octets = 24 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 4 : // 4 octets = 32 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n                    buffer[context.pos++] = pad;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                context.pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\n                if (0 == context.modulus) { // we have enough bytes to create our output\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                        context.pos += lineSeparator.length;\n                        context.currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the {@code octet} is in the Base32 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\n     */\n    @Override\n    public boolean isInAlphabet(final byte octet) {\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n    }\n}\n"}]}
{"project": "Codec", "bug_id": 17, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.StringUtils", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.Charsets;\n\n/**\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @version $Id$\n * @since 1.4\n */\npublic class StringUtils {\n\n    /**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     * @since 1.11\n     */\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return ByteBuffer.wrap(string.getBytes(charset));\n    }\n\n    /**\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     * @since 1.11\n     */\n    public static ByteBuffer getByteBufferUtf8(final String string) {\n        return getByteBuffer(string, Charsets.UTF_8);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }\n\n\n    /**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }\n\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     */\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */\n    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.Charsets;\n\n/**\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @version $Id$\n * @since 1.4\n */\npublic class StringUtils {\n\n    /**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     * @since 1.11\n     */\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return ByteBuffer.wrap(string.getBytes(charset));\n    }\n\n    /**\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     * @since 1.11\n     */\n    public static ByteBuffer getByteBufferUtf8(final String string) {\n        return getByteBuffer(string, Charsets.UTF_8);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }\n\n\n    /**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }\n\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     */\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */\n    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }\n\n}\n"}]}
{"project": "Codec", "bug_id": 18, "classes_modified": [{"class_name": "org.apache.commons.codec.binary.StringUtils", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.Charsets;\n\n/**\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @version $Id$\n * @since 1.4\n */\npublic class StringUtils {\n\n    /**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     * @since 1.11\n     */\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return ByteBuffer.wrap(string.getBytes(charset));\n    }\n\n    /**\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     * @since 1.11\n     */\n    public static ByteBuffer getByteBufferUtf8(final String string) {\n        return getByteBuffer(string, Charsets.UTF_8);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }\n\n\n    /**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }\n\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>; not {@code null}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if charset is {@code null}\n     */\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */\n    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.codec.binary;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.Charsets;\n\n/**\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @version $Id$\n * @since 1.4\n */\npublic class StringUtils {\n\n    /**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     * @since 1.11\n     */\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return ByteBuffer.wrap(string.getBytes(charset));\n    }\n\n    /**\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     * @since 1.11\n     */\n    public static ByteBuffer getByteBufferUtf8(final String string) {\n        return getByteBuffer(string, Charsets.UTF_8);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }\n\n\n    /**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }\n\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>; not {@code null}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if charset is {@code null}\n     */\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */\n    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16BE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16LE);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }\n\n}\n"}]}
