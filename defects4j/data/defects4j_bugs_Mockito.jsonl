{"project": "Mockito", "bug_id": 1, "classes_modified": [{"class_name": "org.mockito.internal.invocation.InvocationMatcher", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.matchers.MatcherDecorator;\nimport org.mockito.internal.matchers.VarargMatcher;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.invocation.DescribedInvocation;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.Location;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return new PrintSettings().print(matchers, invocation);\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n            /* Avoid unnecessary cloning */\n            Class[] params1 = m1.getParameterTypes();\n            Class[] params2 = m2.getParameterTypes();\n            if (params1.length == params2.length) {\n                for (int i = 0; i < params1.length; i++) {\n                if (params1[i] != params2[i])\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            throw new UnsupportedOperationException();\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }\n\n    private boolean isVarargMatcher(Matcher matcher) {\n        Matcher actualMatcher = matcher;\n        if (actualMatcher instanceof MatcherDecorator) {\n            actualMatcher = ((MatcherDecorator) actualMatcher).getActualMatcher();\n        }\n        return actualMatcher instanceof VarargMatcher;\n    }\n\n    private boolean isVariableArgument(Invocation invocation, int position) {\n        return invocation.getRawArguments().length - 1 == position\n                && invocation.getRawArguments()[position] != null\n                && invocation.getRawArguments()[position].getClass().isArray()\n                && invocation.getMethod().isVarArgs();\n    }\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.matchers.MatcherDecorator;\nimport org.mockito.internal.matchers.VarargMatcher;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.invocation.DescribedInvocation;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.Location;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return new PrintSettings().print(matchers, invocation);\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n            /* Avoid unnecessary cloning */\n            Class[] params1 = m1.getParameterTypes();\n            Class[] params2 = m2.getParameterTypes();\n            if (params1.length == params2.length) {\n                for (int i = 0; i < params1.length; i++) {\n                if (params1[i] != params2[i])\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }\n\n    private boolean isVarargMatcher(Matcher matcher) {\n        Matcher actualMatcher = matcher;\n        if (actualMatcher instanceof MatcherDecorator) {\n            actualMatcher = ((MatcherDecorator) actualMatcher).getActualMatcher();\n        }\n        return actualMatcher instanceof VarargMatcher;\n    }\n\n    private boolean isVariableArgument(Invocation invocation, int position) {\n        return invocation.getRawArguments().length - 1 == position\n                && invocation.getRawArguments()[position] != null\n                && invocation.getRawArguments()[position].getClass().isArray()\n                && invocation.getMethod().isVarArgs();\n    }\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 2, "classes_modified": [{"class_name": "org.mockito.internal.util.Timer", "buggy_version": "package org.mockito.internal.util;\n\n\npublic class Timer {\n\n    private final long durationMillis;\n    private long startTime = -1;\n\n    public Timer(long durationMillis) {\n        this.durationMillis = durationMillis;\n    }\n\n    /**\n     * Informs whether the timer is still counting down.\n     */\n    public boolean isCounting() {\n        assert startTime != -1;\n        return System.currentTimeMillis() - startTime <= durationMillis;\n    }\n\n    /**\n     * Starts the timer count down.\n     */\n    public void start() {\n        startTime = System.currentTimeMillis();\n    }\n\n}\n", "fixed_version": "package org.mockito.internal.util;\n\nimport org.mockito.exceptions.Reporter;\n\npublic class Timer {\n\n    private final long durationMillis;\n    private long startTime = -1;\n\n    public Timer(long durationMillis) {\n        validateInput(durationMillis);\n        this.durationMillis = durationMillis;\n    }\n\n    /**\n     * Informs whether the timer is still counting down.\n     */\n    public boolean isCounting() {\n        assert startTime != -1;\n        return System.currentTimeMillis() - startTime <= durationMillis;\n    }\n\n    /**\n     * Starts the timer count down.\n     */\n    public void start() {\n        startTime = System.currentTimeMillis();\n    }\n\n    private void validateInput(long durationMillis) {\n        if (durationMillis < 0) {\n            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n        }\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 3, "classes_modified": [{"class_name": "org.mockito.internal.invocation.InvocationMatcher", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.matchers.MatcherDecorator;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.invocation.DescribedInvocation;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.Location;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return new PrintSettings().print(matchers, invocation);\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }\n\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n        return out;\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.matchers.MatcherDecorator;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.invocation.DescribedInvocation;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.Location;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return new PrintSettings().print(matchers, invocation);\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {\n                if (m instanceof CapturesArguments) {\n                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];\n                    for (int i = 0; i < Array.getLength(rawArgument); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));\n                    }\n                }\n            }\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }\n\n    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {\n        HashSet<Matcher> set = new HashSet<Matcher>();\n        for (int position = indexOfVararg; position < matchers.size(); position++) {\n            Matcher matcher = matchers.get(position);\n            if(matcher instanceof MatcherDecorator) {\n                set.add(((MatcherDecorator) matcher).getActualMatcher());\n            } else {\n                set.add(matcher);\n            }\n        }\n        return set;\n    }\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n        return out;\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 4, "classes_modified": [{"class_name": "org.mockito.exceptions.Reporter", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.exceptions;\n\nimport org.mockito.exceptions.base.MockitoAssertionError;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.exceptions.misusing.*;\nimport org.mockito.exceptions.verification.*;\nimport org.mockito.internal.debugging.LocationImpl;\nimport org.mockito.internal.exceptions.MockitoLimitations;\nimport org.mockito.internal.exceptions.VerificationAwareInvocation;\nimport org.mockito.internal.exceptions.util.ScenarioPrinter;\nimport org.mockito.internal.junit.JUnitTool;\nimport org.mockito.internal.matchers.LocalizedMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.StringJoiner;\nimport org.mockito.invocation.DescribedInvocation;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.invocation.Location;\nimport org.mockito.listeners.InvocationListener;\nimport org.mockito.mock.MockName;\nimport org.mockito.mock.SerializableMode;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.mockito.internal.reporting.Pluralizer.pluralize;\nimport static org.mockito.internal.util.StringJoiner.join;\n\n/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n\n    public void checkedExceptionInvalid(Throwable t) {\n        throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n        ));\n    }\n\n    public void cannotStubWithNullThrowable() {\n        throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n        ));\n\n    }\n\n    public void unfinishedStubbing(Location location) {\n        throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \" 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed\",\n                \"\"\n        ));\n    }\n\n    public void incorrectUseOfApi() {\n        throw new MockitoException(join(\n                \"Incorrect use of API detected here:\",\n                new LocationImpl(),\n                \"\",\n                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                \"Examples of correct usage:\",\n                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n                \"\"\n        ));\n    }\n\n    public void missingMethodInvocation() {\n        throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"   \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"2. inside when() you don't call method on mock but on some other object.\",\n                \"\"\n        ));\n    }\n\n    public void unfinishedVerificationException(Location location) {\n        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n\n        throw exception;\n    }\n\n    public void notAMockPassedToVerify(Class type) {\n        throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToVerify() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"    not: verify(mock.someMethod());\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void notAMockPassedToWhenMethod() {\n        throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToWhenMethod() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }\n\n    public void notAMockPassedToVerifyNoMoreInteractions() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }\n\n    public void nullPassedToVerifyNoMoreInteractions() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void notAMockPassedWhenCreatingInOrder() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void nullPassedWhenCreatingInOrder() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void mocksHaveToBePassedWhenCreatingInOrder() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void inOrderRequiresFamiliarMock() {\n        throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n        ));\n    }\n\n    public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n                        locationsOf(recordedMatchers),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\",\n                \"\"\n        ));\n    }\n\n    public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n                new LocationImpl(),\n                \"\",\n                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                locationsOf(matcherStack),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n                \"\"\n        ));\n    }\n\n    public void stubPassedToVerify() {\n        throw new CannotVerifyStubOnlyMock(join(\n                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n        ));\n    }\n\n    public void reportNoSubMatchersFound(String additionalMatcherName) {\n        throw new InvalidUseOfMatchersException(join(\n                \"No matchers found for additional matcher \" + additionalMatcherName,\n                new LocationImpl(),\n                \"\"\n        ));\n    }\n\n\n    private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n        List<String> description = new ArrayList<String>();\n        for (LocalizedMatcher matcher : matchers)\n            description.add(matcher.getLocation().toString());\n        return join(description.toArray());\n    }\n\n    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new LocationImpl(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n        );\n\n        throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n    }\n\n    public void wantedButNotInvoked(DescribedInvocation wanted) {\n        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n    }\n\n    public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {\n        String allInvocations;\n        if (invocations.isEmpty()) {\n            allInvocations = \"Actually, there were zero interactions with this mock.\\n\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n            for (DescribedInvocation i : invocations) {\n                sb.append(i.toString())\n                        .append(\"\\n\")\n                        .append(i.getLocation())\n                        .append(\"\\n\\n\");\n            }\n            allInvocations = sb.toString();\n        }\n\n        String message = createWantedButNotInvokedMessage(wanted);\n        throw new WantedButNotInvoked(message + allInvocations);\n    }\n\n    private String createWantedButNotInvokedMessage(DescribedInvocation wanted) {\n        return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"\"\n        );\n    }\n\n    public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure\",\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"Wanted anywhere AFTER following interaction:\",\n                previous.toString(),\n                previous.getLocation(),\n                \"\"\n        ));\n    }\n\n    public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new TooManyActualInvocations(message);\n    }\n\n    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n                                                   Location firstUndesired) {\n        return join(\n                wanted.toString(),\n                \"Wanted \" + pluralize(wantedCount) + \":\",\n                new LocationImpl(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );\n    }\n\n    public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {\n        throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new LocationImpl(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));\n    }\n\n    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }\n\n    private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n                                                     Location lastActualInvocation) {\n        String ending =\n                (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n\n        String message = join(\n                wanted.toString(),\n                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                new LocationImpl(),\n                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                ending\n        );\n        return message;\n    }\n\n    public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new TooLittleActualInvocations(message);\n    }\n\n    public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }\n\n    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n        String scenario = scenarioPrinter.print(invocations);\n\n        throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                undesired.getLocation(),\n                scenario\n        ));\n    }\n\n    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n        throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                undesired.getLocation()\n        ));\n    }\n\n    public void cannotMockFinalClass(Class<?> clazz) {\n        throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));\n    }\n\n    public void cannotStubVoidMethodWithAReturnValue(String methodName) {\n        throw new CannotStubVoidMethodWithReturnValue(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.\",\n                \"2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.\",\n                \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"4. \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }\n\n    public void onlyVoidMethodsCanBeSetToDoNothing() {\n        throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n        ));\n    }\n\n    public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }\n\n    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n    }\n\n    public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                locationsOf(lastMatchers),\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }\n\n    public void smartNullPointerException(String invocation, Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new LocationImpl(),\n                \"because this method call was *not* stubbed correctly:\",\n                location,\n                invocation,\n                \"\"\n        ));\n    }\n\n    public void noArgumentValueWasCaptured() {\n        throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n        ));\n    }\n\n    public void extraInterfacesDoesNotAcceptNullParameters() {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n        ));\n    }\n\n    public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));\n    }\n\n    public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));\n    }\n\n    public void extraInterfacesRequiresAtLeastOneInterface() {\n        throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));\n    }\n\n    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));\n    }\n\n    public void cannotCallAbstractRealMethod() {\n        throw new MockitoException(join(\n                \"Cannot call abstract real method on java object!\",\n                \"Calling real methods is only possible when mocking non abstract method.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n        ));\n    }\n\n    public void cannotVerifyToString() {\n        throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));\n    }\n\n    public void moreThanOneAnnotationNotAllowed(String fieldName) {\n        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n    }\n\n    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n    }\n\n    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @Spy:\",\n                \"   @Spy List mock = new LinkedList();\",\n                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);\n    }\n\n    public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @InjectMocks:\",\n                \"   @InjectMocks Service service = new Service();\",\n                \"   @InjectMocks Service service;\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);\n    }\n\n    public void atMostAndNeverShouldNotBeUsedWithTimeout() {\n        throw new FriendlyReminderException(join(\"\",\n                \"Don't panic! I'm just a friendly reminder!\",\n                \"timeout() should not be used with atMost() or never() because...\",\n                \"...it does not make much sense - the test would have passed immediately in concurency\",\n                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n                \"If you want to find out more please refer to issue 235\",\n                \"\"));\n    }\n\n    public void fieldInitialisationThrewException(Field field, Throwable details) {\n        throw new MockitoException(join(\n                \"Cannot instantiate @InjectMocks field named '\" + field.getName() + \"' of type '\" + field.getType() +  \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n                \"\"), details);\n\n    }\n\n    public void invocationListenerDoesNotAcceptNullParameters() {\n        throw new MockitoException(\"invocationListeners() does not accept null parameters\");\n    }\n\n    public void invocationListenersRequiresAtLeastOneListener() {\n        throw new MockitoException(\"invocationListeners() requires at least one listener\");\n    }\n\n    public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {\n        throw new MockitoException(StringJoiner.join(\n                \"The invocation listener with type \" + listener.getClass().getName(),\n                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n    }\n\n    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {\n        throw new MockitoException(join(\n                \"Mockito couldn't inject mock dependency '\" + safelyGetMockName(matchingMock) + \"' on field \",\n                \"'\" + field + \"'\",\n                \"whose type '\" + field.getDeclaringClass().getCanonicalName() + \"' was annotated by @InjectMocks in your test.\",\n                \"Also I failed because: \" + exceptionCauseMessageIfAvailable(details),\n                \"\"\n        ), details);\n    }\n\n    private String exceptionCauseMessageIfAvailable(Exception details) {\n        return details.getCause().getMessage();\n    }\n\n    public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your delegated instance.\",\n                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct delegate:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n        ));\n    }\n\n    public void spyAndDelegateAreMutuallyExclusive() {\n        throw new MockitoException(join(\n                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n        )) ;\n    }\n\n    public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n        throw new MockitoException(join(\"Invalid argument index.\",\n                \"The index need to be a positive number that indicates the position of the argument to return.\",\n                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n                \"returned.\"));\n    }\n\n    public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n        throw new MockitoException(\n                join(\"Invalid argument index for the current invocation of method : \",\n                        \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                        \"\",\n                        (willReturnLastParameter ?\n                                \"Last parameter wanted\" :\n                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                        \"\"));\n    }\n\n    private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n        if (parameterTypes.length == 0) {\n            return new StringBuilder(\"the method has no arguments.\\n\");\n        }\n\n        StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");\n        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {\n            stringBuilder.append(\"    [\").append(i);\n\n            if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1) {\n                stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");\n            } else {\n                stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n            }\n        }\n        return stringBuilder;\n    }\n\n    public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {\n        throw new WrongTypeOfReturnValue(join(\n                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n                \"method should return the type '\" + expectedType + \"'\",\n                \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                \"\",\n                \"The reason for this error can be :\",\n                \"1. The wanted argument position is incorrect.\",\n                \"2. The answer is used on the wrong interaction.\",\n                \"\",\n                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n                \"***\",\n                \"However if you're still unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }\n\n    public void defaultAnswerDoesNotAcceptNullParameter() {\n        throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n    }\n\n    public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n        throw new MockitoException(join(\n                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                \"\",\n                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n                \"i.e. the top-most superclass has to implements Serializable.\",\n                \"\"\n        ));\n    }\n\n    public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {\n    \tthrow new MockitoException(join(\n    \t        \"Methods called on delegated instance must have compatible return types with the mock.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));\n    }\n\n\tpublic void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {\n\t\tthrow new MockitoException(join(\n    \t        \"Methods called on mock must exist in delegated instance.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"no such method was found.\",\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));\n\t}\n\n    public void usingConstructorWithFancySerializable(SerializableMode mode) {\n        throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");\n    }\n\n    private MockName safelyGetMockName(Object mock) {\n        return new MockUtil().getMockName(mock);\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.exceptions;\n\nimport org.mockito.exceptions.base.MockitoAssertionError;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.exceptions.misusing.*;\nimport org.mockito.exceptions.verification.*;\nimport org.mockito.internal.debugging.LocationImpl;\nimport org.mockito.internal.exceptions.MockitoLimitations;\nimport org.mockito.internal.exceptions.VerificationAwareInvocation;\nimport org.mockito.internal.exceptions.util.ScenarioPrinter;\nimport org.mockito.internal.junit.JUnitTool;\nimport org.mockito.internal.matchers.LocalizedMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.StringJoiner;\nimport org.mockito.invocation.DescribedInvocation;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.invocation.Location;\nimport org.mockito.listeners.InvocationListener;\nimport org.mockito.mock.MockName;\nimport org.mockito.mock.SerializableMode;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.mockito.internal.reporting.Pluralizer.pluralize;\nimport static org.mockito.internal.util.StringJoiner.join;\n\n/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n\n    public void checkedExceptionInvalid(Throwable t) {\n        throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n        ));\n    }\n\n    public void cannotStubWithNullThrowable() {\n        throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n        ));\n\n    }\n\n    public void unfinishedStubbing(Location location) {\n        throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \" 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed\",\n                \"\"\n        ));\n    }\n\n    public void incorrectUseOfApi() {\n        throw new MockitoException(join(\n                \"Incorrect use of API detected here:\",\n                new LocationImpl(),\n                \"\",\n                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                \"Examples of correct usage:\",\n                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n                \"\"\n        ));\n    }\n\n    public void missingMethodInvocation() {\n        throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"   \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"2. inside when() you don't call method on mock but on some other object.\",\n                \"\"\n        ));\n    }\n\n    public void unfinishedVerificationException(Location location) {\n        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n\n        throw exception;\n    }\n\n    public void notAMockPassedToVerify(Class type) {\n        throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToVerify() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"    not: verify(mock.someMethod());\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void notAMockPassedToWhenMethod() {\n        throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToWhenMethod() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }\n\n    public void notAMockPassedToVerifyNoMoreInteractions() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }\n\n    public void nullPassedToVerifyNoMoreInteractions() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void notAMockPassedWhenCreatingInOrder() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void nullPassedWhenCreatingInOrder() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void mocksHaveToBePassedWhenCreatingInOrder() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void inOrderRequiresFamiliarMock() {\n        throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n        ));\n    }\n\n    public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n                        locationsOf(recordedMatchers),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\",\n                \"\"\n        ));\n    }\n\n    public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n                new LocationImpl(),\n                \"\",\n                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                locationsOf(matcherStack),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n                \"\"\n        ));\n    }\n\n    public void stubPassedToVerify() {\n        throw new CannotVerifyStubOnlyMock(join(\n                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n        ));\n    }\n\n    public void reportNoSubMatchersFound(String additionalMatcherName) {\n        throw new InvalidUseOfMatchersException(join(\n                \"No matchers found for additional matcher \" + additionalMatcherName,\n                new LocationImpl(),\n                \"\"\n        ));\n    }\n\n\n    private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n        List<String> description = new ArrayList<String>();\n        for (LocalizedMatcher matcher : matchers)\n            description.add(matcher.getLocation().toString());\n        return join(description.toArray());\n    }\n\n    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new LocationImpl(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n        );\n\n        throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n    }\n\n    public void wantedButNotInvoked(DescribedInvocation wanted) {\n        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n    }\n\n    public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {\n        String allInvocations;\n        if (invocations.isEmpty()) {\n            allInvocations = \"Actually, there were zero interactions with this mock.\\n\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n            for (DescribedInvocation i : invocations) {\n                sb.append(i.toString())\n                        .append(\"\\n\")\n                        .append(i.getLocation())\n                        .append(\"\\n\\n\");\n            }\n            allInvocations = sb.toString();\n        }\n\n        String message = createWantedButNotInvokedMessage(wanted);\n        throw new WantedButNotInvoked(message + allInvocations);\n    }\n\n    private String createWantedButNotInvokedMessage(DescribedInvocation wanted) {\n        return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"\"\n        );\n    }\n\n    public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure\",\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"Wanted anywhere AFTER following interaction:\",\n                previous.toString(),\n                previous.getLocation(),\n                \"\"\n        ));\n    }\n\n    public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new TooManyActualInvocations(message);\n    }\n\n    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n                                                   Location firstUndesired) {\n        return join(\n                wanted.toString(),\n                \"Wanted \" + pluralize(wantedCount) + \":\",\n                new LocationImpl(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );\n    }\n\n    public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {\n        throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new LocationImpl(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));\n    }\n\n    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }\n\n    private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n                                                     Location lastActualInvocation) {\n        String ending =\n                (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n\n        String message = join(\n                wanted.toString(),\n                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                new LocationImpl(),\n                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                ending\n        );\n        return message;\n    }\n\n    public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new TooLittleActualInvocations(message);\n    }\n\n    public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }\n\n    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n        String scenario = scenarioPrinter.print(invocations);\n\n        throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                undesired.getLocation(),\n                scenario\n        ));\n    }\n\n    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n        throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                undesired.getLocation()\n        ));\n    }\n\n    public void cannotMockFinalClass(Class<?> clazz) {\n        throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));\n    }\n\n    public void cannotStubVoidMethodWithAReturnValue(String methodName) {\n        throw new CannotStubVoidMethodWithReturnValue(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.\",\n                \"2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.\",\n                \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"4. \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }\n\n    public void onlyVoidMethodsCanBeSetToDoNothing() {\n        throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n        ));\n    }\n\n    public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }\n\n    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n    }\n\n    public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                locationsOf(lastMatchers),\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }\n\n    public void smartNullPointerException(String invocation, Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new LocationImpl(),\n                \"because this method call was *not* stubbed correctly:\",\n                location,\n                invocation,\n                \"\"\n        ));\n    }\n\n    public void noArgumentValueWasCaptured() {\n        throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n        ));\n    }\n\n    public void extraInterfacesDoesNotAcceptNullParameters() {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n        ));\n    }\n\n    public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));\n    }\n\n    public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));\n    }\n\n    public void extraInterfacesRequiresAtLeastOneInterface() {\n        throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));\n    }\n\n    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));\n    }\n\n    public void cannotCallAbstractRealMethod() {\n        throw new MockitoException(join(\n                \"Cannot call abstract real method on java object!\",\n                \"Calling real methods is only possible when mocking non abstract method.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n        ));\n    }\n\n    public void cannotVerifyToString() {\n        throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));\n    }\n\n    public void moreThanOneAnnotationNotAllowed(String fieldName) {\n        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n    }\n\n    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n    }\n\n    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @Spy:\",\n                \"   @Spy List mock = new LinkedList();\",\n                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);\n    }\n\n    public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @InjectMocks:\",\n                \"   @InjectMocks Service service = new Service();\",\n                \"   @InjectMocks Service service;\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);\n    }\n\n    public void atMostAndNeverShouldNotBeUsedWithTimeout() {\n        throw new FriendlyReminderException(join(\"\",\n                \"Don't panic! I'm just a friendly reminder!\",\n                \"timeout() should not be used with atMost() or never() because...\",\n                \"...it does not make much sense - the test would have passed immediately in concurency\",\n                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n                \"If you want to find out more please refer to issue 235\",\n                \"\"));\n    }\n\n    public void fieldInitialisationThrewException(Field field, Throwable details) {\n        throw new MockitoException(join(\n                \"Cannot instantiate @InjectMocks field named '\" + field.getName() + \"' of type '\" + field.getType() +  \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n                \"\"), details);\n\n    }\n\n    public void invocationListenerDoesNotAcceptNullParameters() {\n        throw new MockitoException(\"invocationListeners() does not accept null parameters\");\n    }\n\n    public void invocationListenersRequiresAtLeastOneListener() {\n        throw new MockitoException(\"invocationListeners() requires at least one listener\");\n    }\n\n    public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {\n        throw new MockitoException(StringJoiner.join(\n                \"The invocation listener with type \" + listener.getClass().getName(),\n                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n    }\n\n    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {\n        throw new MockitoException(join(\n                \"Mockito couldn't inject mock dependency '\" + safelyGetMockName(matchingMock) + \"' on field \",\n                \"'\" + field + \"'\",\n                \"whose type '\" + field.getDeclaringClass().getCanonicalName() + \"' was annotated by @InjectMocks in your test.\",\n                \"Also I failed because: \" + exceptionCauseMessageIfAvailable(details),\n                \"\"\n        ), details);\n    }\n\n    private String exceptionCauseMessageIfAvailable(Exception details) {\n        if (details.getCause() == null) {\n            return details.getMessage();\n        }\n        return details.getCause().getMessage();\n    }\n\n    public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your delegated instance.\",\n                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct delegate:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n        ));\n    }\n\n    public void spyAndDelegateAreMutuallyExclusive() {\n        throw new MockitoException(join(\n                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n        )) ;\n    }\n\n    public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n        throw new MockitoException(join(\"Invalid argument index.\",\n                \"The index need to be a positive number that indicates the position of the argument to return.\",\n                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n                \"returned.\"));\n    }\n\n    public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n        throw new MockitoException(\n                join(\"Invalid argument index for the current invocation of method : \",\n                        \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                        \"\",\n                        (willReturnLastParameter ?\n                                \"Last parameter wanted\" :\n                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                        \"\"));\n    }\n\n    private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n        if (parameterTypes.length == 0) {\n            return new StringBuilder(\"the method has no arguments.\\n\");\n        }\n\n        StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");\n        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {\n            stringBuilder.append(\"    [\").append(i);\n\n            if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1) {\n                stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");\n            } else {\n                stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n            }\n        }\n        return stringBuilder;\n    }\n\n    public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {\n        throw new WrongTypeOfReturnValue(join(\n                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n                \"method should return the type '\" + expectedType + \"'\",\n                \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                \"\",\n                \"The reason for this error can be :\",\n                \"1. The wanted argument position is incorrect.\",\n                \"2. The answer is used on the wrong interaction.\",\n                \"\",\n                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n                \"***\",\n                \"However if you're still unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }\n\n    public void defaultAnswerDoesNotAcceptNullParameter() {\n        throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n    }\n\n    public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n        throw new MockitoException(join(\n                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                \"\",\n                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n                \"i.e. the top-most superclass has to implements Serializable.\",\n                \"\"\n        ));\n    }\n\n    public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {\n    \tthrow new MockitoException(join(\n    \t        \"Methods called on delegated instance must have compatible return types with the mock.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));\n    }\n\n\tpublic void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {\n\t\tthrow new MockitoException(join(\n    \t        \"Methods called on mock must exist in delegated instance.\",\n    \t        \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n    \t        \"no such method was found.\",\n    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n    \t));\n\t}\n\n    public void usingConstructorWithFancySerializable(SerializableMode mode) {\n        throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");\n    }\n\n    private MockName safelyGetMockName(Object mock) {\n        return new MockUtil().getMockName(mock);\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 5, "classes_modified": [{"class_name": "org.mockito.internal.verification.VerificationOverTimeImpl", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification;\n\nimport org.mockito.exceptions.base.MockitoAssertionError;\nimport org.mockito.internal.util.Timer;\nimport org.mockito.internal.verification.api.VerificationData;\nimport org.mockito.verification.VerificationMode;\n\n/**\n * Verifies that another verification mode (the delegate) is satisfied within a certain timeframe\n * (before timeoutMillis has passed, measured from the call to verify()), and either returns immediately\n * once it does, or waits until it is definitely satisfied once the full time has passed.\n */\npublic class VerificationOverTimeImpl implements VerificationMode {\n\n    private final long pollingPeriodMillis;\n    private final long durationMillis;\n    private final VerificationMode delegate;\n    private final boolean returnOnSuccess;\n    private final Timer timer;\n\n    /**\n     * Create this verification mode, to be used to verify invocation ongoing data later.\n     *\n     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n     * @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied\n     * @param delegate The verification mode to delegate overall success or failure to\n     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n     *                        the delegate is satisfied and the full duration has passed (as in\n     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n     */\n    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess) {\n        this(pollingPeriodMillis, durationMillis, delegate, returnOnSuccess, new Timer(durationMillis));\n    }\n\n    /**\n     * Create this verification mode, to be used to verify invocation ongoing data later.\n     *\n     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n     * @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied\n     * @param delegate The verification mode to delegate overall success or failure to\n     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n     *                        the delegate is satisfied and the full duration has passed (as in\n     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n     * @param timer Checker of whether the duration of the verification is still acceptable\n     */\n    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {\n        this.pollingPeriodMillis = pollingPeriodMillis;\n        this.durationMillis = durationMillis;\n        this.delegate = delegate;\n        this.returnOnSuccess = returnOnSuccess;\n        this.timer = timer;\n    }\n\n    /**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    private AssertionError handleVerifyException(AssertionError e) {\n        if (canRecoverFromFailure(delegate)) {\n            sleep(pollingPeriodMillis);\n            return e;\n        } else {\n            throw e;\n        }\n    }\n\n    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n    }\n\n    private void sleep(long sleep) {\n        try {\n            Thread.sleep(sleep);\n        } catch (InterruptedException ie) {\n            // oups. not much luck.\n        }\n    }\n\n    public long getPollingPeriod() {\n        return pollingPeriodMillis;\n    }\n\n    public long getDuration() {\n        return durationMillis;\n    }\n\n    public VerificationMode getDelegate() {\n        return delegate;\n    }\n\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification;\n\nimport org.mockito.exceptions.base.MockitoAssertionError;\nimport org.mockito.internal.util.Timer;\nimport org.mockito.internal.verification.api.VerificationData;\nimport org.mockito.verification.VerificationMode;\n\n/**\n * Verifies that another verification mode (the delegate) is satisfied within a certain timeframe\n * (before timeoutMillis has passed, measured from the call to verify()), and either returns immediately\n * once it does, or waits until it is definitely satisfied once the full time has passed.\n */\npublic class VerificationOverTimeImpl implements VerificationMode {\n\n    private final long pollingPeriodMillis;\n    private final long durationMillis;\n    private final VerificationMode delegate;\n    private final boolean returnOnSuccess;\n    private final Timer timer;\n\n    /**\n     * Create this verification mode, to be used to verify invocation ongoing data later.\n     *\n     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n     * @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied\n     * @param delegate The verification mode to delegate overall success or failure to\n     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n     *                        the delegate is satisfied and the full duration has passed (as in\n     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n     */\n    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess) {\n        this(pollingPeriodMillis, durationMillis, delegate, returnOnSuccess, new Timer(durationMillis));\n    }\n\n    /**\n     * Create this verification mode, to be used to verify invocation ongoing data later.\n     *\n     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n     * @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied\n     * @param delegate The verification mode to delegate overall success or failure to\n     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n     *                        the delegate is satisfied and the full duration has passed (as in\n     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n     * @param timer Checker of whether the duration of the verification is still acceptable\n     */\n    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {\n        this.pollingPeriodMillis = pollingPeriodMillis;\n        this.durationMillis = durationMillis;\n        this.delegate = delegate;\n        this.returnOnSuccess = returnOnSuccess;\n        this.timer = timer;\n    }\n\n    /**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (AssertionError e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    private AssertionError handleVerifyException(AssertionError e) {\n        if (canRecoverFromFailure(delegate)) {\n            sleep(pollingPeriodMillis);\n            return e;\n        } else {\n            throw e;\n        }\n    }\n\n    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n    }\n\n    private void sleep(long sleep) {\n        try {\n            Thread.sleep(sleep);\n        } catch (InterruptedException ie) {\n            // oups. not much luck.\n        }\n    }\n\n    public long getPollingPeriod() {\n        return pollingPeriodMillis;\n    }\n\n    public long getDuration() {\n        return durationMillis;\n    }\n\n    public VerificationMode getDelegate() {\n        return delegate;\n    }\n\n}\n"}]}
{"project": "Mockito", "bug_id": 6, "classes_modified": [{"class_name": "org.mockito.Matchers", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.core.IsNull;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.matchers.apachecommons.ReflectionEquals;\nimport org.mockito.internal.progress.HandyReturnValues;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre class=\"code\"><code class=\"java\">\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </code></pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </code></pre>\n * <p>\n * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n * Internally, they record a matcher on a stack and return a dummy value (usually null).\n * This implementation is due static type safety imposed by java compiler.\n * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.\n *\n * <p>\n * <b>Warning 2:</b>\n * <p>\n * The any family methods <b>*doesn't do any type checks*</b>, those are only here to avoid casting\n * in your code. If you want to perform type checks use the {@link #isA(Class)} method.\n * This <b>might</b> however change (type checks could be added) in a future major release.\n *\n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre class=\"code\"><code class=\"java\">\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </code></pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </code></pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\n@SuppressWarnings(\"unchecked\")\npublic class Matchers {\n    \n    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n\n    /**\n     * Any <code>boolean</code>, <code>Boolean</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean() {\n        return reportMatcher(Any.ANY).returnFalse();\n    }\n\n    /**\n     * Any <code>byte</code>, <code>Byte</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static byte anyByte() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * Any <code>char</code>, <code>Character</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static char anyChar() {\n        return reportMatcher(Any.ANY).returnChar();\n    }\n\n    /**\n     * Any int, Integer or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static int anyInt() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * Any <code>long</code>, <code>Long</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static long anyLong() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * Any <code>float</code>, <code>Float</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static float anyFloat() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * Any <code>double</code>, <code>Double</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static double anyDouble() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * Any <code>short</code>, <code>Short</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static short anyShort() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * Any <code>Object</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * Has aliases: {@link #any()} and {@link #any(Class clazz)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T anyObject() {\n        return (T) reportMatcher(Any.ANY).returnNull();\n    }\n\n    /**\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </code></pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     */\n    public static <T> T anyVararg() {\n        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();\n    }\n    \n    /**\n     * Any kind object, not necessary of the given class.\n     * The class argument is provided only to avoid casting.\n     * <p>\n     * Sometimes looks better than <code>anyObject()</code> - especially when explicit casting is required\n     * <p>\n     * Alias to {@link Matchers#anyObject()}\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz The type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T any(Class<T> clazz) {\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\n    }\n    \n    /**\n     * Any object or <code>null</code>.\n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any() {\n        return (T) anyObject();\n    }\n\n    /**\n     * Any <code>String</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     */\n    public static String anyString() {\n        return reportMatcher(Any.ANY).returnString();\n    }\n    \n    /**\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static List anyList() {\n        return reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * Generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the list to avoid casting\n     * @return empty List.\n     */\n    public static <T> List<T> anyListOf(Class<T> clazz) {\n        return (List) reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * Any <code>Set</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static Set anySet() {\n        return reportMatcher(Any.ANY).returnSet();\n    }\n    \n    /**\n     * Generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Set</code> or <code>null</code>\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type owned by the Set to avoid casting\n     * @return empty Set\n     */\n    public static <T> Set<T> anySetOf(Class<T> clazz) {\n        return (Set) reportMatcher(Any.ANY).returnSet();\n    }\n\n    /**\n     * Any <code>Map</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     */\n    public static Map anyMap() {\n        return reportMatcher(Any.ANY).returnMap();\n    }\n\n    /**\n     * Generic friendly alias to {@link Matchers#anyMap()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Map</code> or <code>null</code>\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param keyClazz Type of the map key to avoid casting\n     * @param valueClazz Type of the value to avoid casting\n     * @return empty Map.\n     */\n    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\n        return reportMatcher(Any.ANY).returnMap();\n    }\n    \n    /**\n     * Any <code>Collection</code> or <code>null</code>.\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static Collection anyCollection() {\n        return reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * Generic friendly alias to {@link Matchers#anyCollection()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.     \n     * <p>\n     * Any <code>Collection</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the collection to avoid casting\n     * @return empty Collection.\n     */\n    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n        return (Collection) reportMatcher(Any.ANY).returnList();\n    }    \n\n    /**\n     * <code>Object</code> argument that implements the given class.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the accepted type.\n     * @param clazz\n     *            the class of the accepted type.\n     * @return <code>null</code>.\n     */\n    public static <T> T isA(Class<T> clazz) {\n        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\n    }\n\n    /**\n     * <code>boolean</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static boolean eq(boolean value) {\n        return reportMatcher(new Equals(value)).returnFalse();\n    }\n\n    /**\n     * <code>byte</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static byte eq(byte value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>char</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static char eq(char value) {\n        return reportMatcher(new Equals(value)).returnChar();\n    }\n\n    /**\n     * <code>double</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static double eq(double value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>float</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static float eq(float value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n    \n    /**\n     * <code>int</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static int eq(int value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>long</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static long eq(long value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>short</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static short eq(short value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * Object argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T eq(T value) {\n        return (T) reportMatcher(new Equals(value)).<T>returnFor(value);\n    }\n\n    /**\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * <b>Warning</b> The equality check is shallow!\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     */\n    public static <T> T refEq(T value, String... excludeFields) {\n        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();\n    }\n    \n    /**\n     * Object argument that is the same as the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T same(T value) {\n        return (T) reportMatcher(new Same(value)).<T>returnFor(value);\n    }\n\n    /**\n     * <code>null</code> argument.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNull() {\n        return reportMatcher(Null.NULL).returnNull();\n    }\n\n    /**\n     * <code>null</code> argument.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T isNull(Class<T> clazz) {\n        return (T) reportMatcher(Null.NULL).returnNull();\n    }\n\n    /**\n     * Not <code>null</code> argument.\n     * <p>\n     * alias to {@link Matchers#isNotNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object notNull() {\n        return reportMatcher(NotNull.NOT_NULL).returnNull();\n    }\n\n    /**\n     * Not <code>null</code> argument, not necessary of the given class.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * alias to {@link Matchers#isNotNull(Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T notNull(Class<T> clazz) {\n        return (T) reportMatcher(NotNull.NOT_NULL).returnNull();\n    }\n    \n    /**\n     * Not <code>null</code> argument.\n     * <p>\n     * alias to {@link Matchers#notNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNotNull() {\n        return notNull();\n    }\n\n    /**\n     * Not <code>null</code> argument, not necessary of the given class.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * alias to {@link Matchers#notNull(Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T isNotNull(Class<T> clazz) {\n        return notNull(clazz);\n    }\n\n    /**\n     * <code>String</code> argument that contains the given substring.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param substring\n     *            the substring.\n     * @return empty String (\"\").\n     */\n    public static String contains(String substring) {\n        return reportMatcher(new Contains(substring)).returnString();\n    }\n\n    /**\n     * <code>String</code> argument that matches the given regular expression.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param regex\n     *            the regular expression.\n     * @return empty String (\"\").\n     */\n    public static String matches(String regex) {\n        return reportMatcher(new Matches(regex)).returnString();\n    }\n\n    /**\n     * <code>String</code> argument that ends with the given suffix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param suffix\n     *            the suffix.\n     * @return empty String (\"\").\n     */\n    public static String endsWith(String suffix) {\n        return reportMatcher(new EndsWith(suffix)).returnString();\n    }\n\n    /**\n     * <code>String</code> argument that starts with the given prefix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param prefix\n     *            the prefix.\n     * @return empty String (\"\").\n     */\n    public static String startsWith(String prefix) {\n        return reportMatcher(new StartsWith(prefix)).returnString();\n    }\n\n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * In rare cases when the parameter is a primitive then you <b>*must*</b> use relevant intThat(), floatThat(), etc. method.\n     * This way you will avoid <code>NullPointerException</code> during auto-unboxing.\n     * <p>\n     * See examples in javadoc for {@link ArgumentMatcher} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>null</code>.\n     */\n    public static <T> T argThat(Matcher<T> matcher) {\n        return reportMatcher(matcher).<T>returnNull();\n    }\n    \n    /**\n     * Allows creating custom <code>Character</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static char charThat(Matcher<Character> matcher) {\n        return reportMatcher(matcher).returnChar();\n    }\n    \n    /**\n     * Allows creating custom <code>Boolean</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     */\n    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        return reportMatcher(matcher).returnFalse();\n    }\n    \n    /**\n     * Allows creating custom <code>Byte</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static byte byteThat(Matcher<Byte> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Short</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static short shortThat(Matcher<Short> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Integer</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static int intThat(Matcher<Integer> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    /**\n     * Allows creating custom <code>Long</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static long longThat(Matcher<Long> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Float</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static float floatThat(Matcher<Float> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Double</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static double doubleThat(Matcher<Double> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.core.IsNull;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.matchers.apachecommons.ReflectionEquals;\nimport org.mockito.internal.progress.HandyReturnValues;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre class=\"code\"><code class=\"java\">\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </code></pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </code></pre>\n * <p>\n * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n * Internally, they record a matcher on a stack and return a dummy value (usually null).\n * This implementation is due static type safety imposed by java compiler.\n * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.\n *\n * <p>\n * <b>Warning 2:</b>\n * <p>\n * The any family methods <b>*doesn't do any type checks*</b>, those are only here to avoid casting\n * in your code. If you want to perform type checks use the {@link #isA(Class)} method.\n * This <b>might</b> however change (type checks could be added) in a future major release.\n *\n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre class=\"code\"><code class=\"java\">\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </code></pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </code></pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\n@SuppressWarnings(\"unchecked\")\npublic class Matchers {\n    \n    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n\n    /**\n     * Any <code>boolean</code>, <code>Boolean</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean() {\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\n    }\n\n    /**\n     * Any <code>byte</code>, <code>Byte</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static byte anyByte() {\n        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\n    }\n\n    /**\n     * Any <code>char</code>, <code>Character</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static char anyChar() {\n        return reportMatcher(new InstanceOf(Character.class)).returnChar();\n    }\n\n    /**\n     * Any int, Integer or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static int anyInt() {\n        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\n    }\n\n    /**\n     * Any <code>long</code>, <code>Long</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static long anyLong() {\n        return reportMatcher(new InstanceOf(Long.class)).returnZero();\n    }\n\n    /**\n     * Any <code>float</code>, <code>Float</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static float anyFloat() {\n        return reportMatcher(new InstanceOf(Float.class)).returnZero();\n    }\n\n    /**\n     * Any <code>double</code>, <code>Double</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static double anyDouble() {\n        return reportMatcher(new InstanceOf(Double.class)).returnZero();\n    }\n\n    /**\n     * Any <code>short</code>, <code>Short</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static short anyShort() {\n        return reportMatcher(new InstanceOf(Short.class)).returnZero();\n    }\n\n    /**\n     * Any <code>Object</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * Has aliases: {@link #any()} and {@link #any(Class clazz)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T anyObject() {\n        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\n    }\n\n    /**\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </code></pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     */\n    public static <T> T anyVararg() {\n        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();\n    }\n    \n    /**\n     * Any kind object, not necessary of the given class.\n     * The class argument is provided only to avoid casting.\n     * <p>\n     * Sometimes looks better than <code>anyObject()</code> - especially when explicit casting is required\n     * <p>\n     * Alias to {@link Matchers#anyObject()}\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz The type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T any(Class<T> clazz) {\n        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\n    }\n    \n    /**\n     * Any object or <code>null</code>.\n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any() {\n        return (T) reportMatcher(Any.ANY).returnNull();\n    }\n\n    /**\n     * Any <code>String</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     */\n    public static String anyString() {\n        return reportMatcher(new InstanceOf(String.class)).returnString();\n    }\n    \n    /**\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static List anyList() {\n        return reportMatcher(new InstanceOf(List.class)).returnList();\n    }    \n    \n    /**\n     * Generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the list to avoid casting\n     * @return empty List.\n     */\n    public static <T> List<T> anyListOf(Class<T> clazz) {\n        return anyList();\n    }    \n    \n    /**\n     * Any <code>Set</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static Set anySet() {\n        return reportMatcher(new InstanceOf(Set.class)).returnSet();\n    }\n    \n    /**\n     * Generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Set</code> or <code>null</code>\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type owned by the Set to avoid casting\n     * @return empty Set\n     */\n    public static <T> Set<T> anySetOf(Class<T> clazz) {\n        return anySet();\n    }\n\n    /**\n     * Any <code>Map</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     */\n    public static Map anyMap() {\n        return reportMatcher(new InstanceOf(Map.class)).returnMap();\n    }\n\n    /**\n     * Generic friendly alias to {@link Matchers#anyMap()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Map</code> or <code>null</code>\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param keyClazz Type of the map key to avoid casting\n     * @param valueClazz Type of the value to avoid casting\n     * @return empty Map.\n     */\n    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\n        return anyMap();\n    }\n    \n    /**\n     * Any <code>Collection</code> or <code>null</code>.\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static Collection anyCollection() {\n        return reportMatcher(new InstanceOf(Collection.class)).returnList();\n    }    \n    \n    /**\n     * Generic friendly alias to {@link Matchers#anyCollection()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.     \n     * <p>\n     * Any <code>Collection</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the collection to avoid casting\n     * @return empty Collection.\n     */\n    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n        return anyCollection();\n    }    \n\n    /**\n     * <code>Object</code> argument that implements the given class.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the accepted type.\n     * @param clazz\n     *            the class of the accepted type.\n     * @return <code>null</code>.\n     */\n    public static <T> T isA(Class<T> clazz) {\n        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\n    }\n\n    /**\n     * <code>boolean</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static boolean eq(boolean value) {\n        return reportMatcher(new Equals(value)).returnFalse();\n    }\n\n    /**\n     * <code>byte</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static byte eq(byte value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>char</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static char eq(char value) {\n        return reportMatcher(new Equals(value)).returnChar();\n    }\n\n    /**\n     * <code>double</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static double eq(double value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>float</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static float eq(float value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n    \n    /**\n     * <code>int</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static int eq(int value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>long</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static long eq(long value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * <code>short</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static short eq(short value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * Object argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T eq(T value) {\n        return (T) reportMatcher(new Equals(value)).<T>returnFor(value);\n    }\n\n    /**\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * <b>Warning</b> The equality check is shallow!\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     */\n    public static <T> T refEq(T value, String... excludeFields) {\n        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();\n    }\n    \n    /**\n     * Object argument that is the same as the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T same(T value) {\n        return (T) reportMatcher(new Same(value)).<T>returnFor(value);\n    }\n\n    /**\n     * <code>null</code> argument.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNull() {\n        return reportMatcher(Null.NULL).returnNull();\n    }\n\n    /**\n     * <code>null</code> argument.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T isNull(Class<T> clazz) {\n        return (T) reportMatcher(Null.NULL).returnNull();\n    }\n\n    /**\n     * Not <code>null</code> argument.\n     * <p>\n     * alias to {@link Matchers#isNotNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object notNull() {\n        return reportMatcher(NotNull.NOT_NULL).returnNull();\n    }\n\n    /**\n     * Not <code>null</code> argument, not necessary of the given class.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * alias to {@link Matchers#isNotNull(Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T notNull(Class<T> clazz) {\n        return (T) reportMatcher(NotNull.NOT_NULL).returnNull();\n    }\n    \n    /**\n     * Not <code>null</code> argument.\n     * <p>\n     * alias to {@link Matchers#notNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNotNull() {\n        return notNull();\n    }\n\n    /**\n     * Not <code>null</code> argument, not necessary of the given class.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * alias to {@link Matchers#notNull(Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     */\n    public static <T> T isNotNull(Class<T> clazz) {\n        return notNull(clazz);\n    }\n\n    /**\n     * <code>String</code> argument that contains the given substring.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param substring\n     *            the substring.\n     * @return empty String (\"\").\n     */\n    public static String contains(String substring) {\n        return reportMatcher(new Contains(substring)).returnString();\n    }\n\n    /**\n     * <code>String</code> argument that matches the given regular expression.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param regex\n     *            the regular expression.\n     * @return empty String (\"\").\n     */\n    public static String matches(String regex) {\n        return reportMatcher(new Matches(regex)).returnString();\n    }\n\n    /**\n     * <code>String</code> argument that ends with the given suffix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param suffix\n     *            the suffix.\n     * @return empty String (\"\").\n     */\n    public static String endsWith(String suffix) {\n        return reportMatcher(new EndsWith(suffix)).returnString();\n    }\n\n    /**\n     * <code>String</code> argument that starts with the given prefix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param prefix\n     *            the prefix.\n     * @return empty String (\"\").\n     */\n    public static String startsWith(String prefix) {\n        return reportMatcher(new StartsWith(prefix)).returnString();\n    }\n\n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * In rare cases when the parameter is a primitive then you <b>*must*</b> use relevant intThat(), floatThat(), etc. method.\n     * This way you will avoid <code>NullPointerException</code> during auto-unboxing.\n     * <p>\n     * See examples in javadoc for {@link ArgumentMatcher} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>null</code>.\n     */\n    public static <T> T argThat(Matcher<T> matcher) {\n        return reportMatcher(matcher).<T>returnNull();\n    }\n    \n    /**\n     * Allows creating custom <code>Character</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static char charThat(Matcher<Character> matcher) {\n        return reportMatcher(matcher).returnChar();\n    }\n    \n    /**\n     * Allows creating custom <code>Boolean</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     */\n    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        return reportMatcher(matcher).returnFalse();\n    }\n    \n    /**\n     * Allows creating custom <code>Byte</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static byte byteThat(Matcher<Byte> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Short</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static short shortThat(Matcher<Short> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Integer</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static int intThat(Matcher<Integer> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    /**\n     * Allows creating custom <code>Long</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static long longThat(Matcher<Long> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Float</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static float floatThat(Matcher<Float> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom <code>Double</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static double doubleThat(Matcher<Double> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 7, "classes_modified": [{"class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util.reflection;\n\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.Checks;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n\n/**\n * This class can retrieve generic meta-data that the compiler stores on classes\n * and accessible members.\n *\n * <p>\n *     The main idea of this code is to create a Map that will help to resolve return types.\n *     In order to actually work with nested generics, this map will have to be passed along new instances\n *     as a type context.\n * </p>\n *\n * <p>\n *     Hence :\n *     <ul>\n *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\n *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\n *\n *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n *         {@link #resolveGenericReturnType(Method)}.</li>\n *     </ul>\n * </p>\n *\n * <p>\n * For now this code support the following kind of generic declarations :\n * <pre class=\"code\"><code class=\"java\">\n * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n *     K returningK();\n *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n *     &lt;S, T extends S&gt; T two_type_params();\n *     &lt;O extends K&gt; O typeVar_with_type_params();\n *     Number returningNonGeneric();\n * }\n * </code></pre>\n *\n * @see #inferFrom(Type)\n * @see #resolveGenericReturnType(Method)\n * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n */\npublic abstract class GenericMetadataSupport {\n\n    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable type : typeParameters) {\n            registerTypeVariableIfNotPresent(type);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n     * @param typeParameter The TypeVariable parameter\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n    /**\n     * @param wildCard The WildCard type\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(WildcardType wildCard) {\n        /*\n         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n         */\n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }\n\n\n\n    /**\n     * @return Raw type of the current instance.\n     */\n    public abstract Class<?> rawType();\n\n\n\n    /**\n     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n     */\n    public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }\n\n    /**\n     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }\n\n\n\n    /**\n     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n     */\n    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n        }\n\n        return actualTypeArguments;\n    }\n\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n\n\n    /**\n     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n     *\n     * @param method Method to resolve the return type.\n     * @return {@link GenericMetadataSupport} representing this generic return type.\n     */\n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n    /**\n     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n     *\n     * <p>\n     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n     *     it'll throw a {@link MockitoException}.\n     * </p>\n     *\n     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n     * @return The new {@link GenericMetadataSupport}.\n     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n     */\n    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Generic metadata implementation for {@link Class}.\n     *\n     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n     * the class and its ancestors and interfaces.\n     */\n    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n        private final Class<?> clazz;\n\n        public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }\n    }\n\n\n    /**\n     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n     *\n     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\n     * the related raw type and declared type variable of this parameterized type.\n     *\n     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\n     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\n     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n     * Instead use {@link ParameterizedReturnType}.\n     */\n    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n\n        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }\n\n        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n    }\n\n\n    /**\n     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class ParameterizedReturnType extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n        private final TypeVariable[] typeParameters;\n\n        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n\n    }\n\n\n    /**\n     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class TypeVariableReturnType extends GenericMetadataSupport {\n        private final TypeVariable typeVariable;\n        private final TypeVariable[] typeParameters;\n        private Class<?> rawType;\n\n\n\n        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }\n\n        /**\n         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n         * @see #extractRawTypeOf(java.lang.reflect.Type)\n         */\n        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }\n    }\n\n\n\n    /**\n     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n        private final Class<?> returnType;\n\n        public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }\n    }\n\n\n\n    /**\n     * Type representing bounds of a type\n     *\n     * @see TypeVarBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     * @see WildCardBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n     */\n    public interface BoundedType extends Type {\n        Type firstBound();\n\n        Type[] interfaceBounds();\n    }\n\n    /**\n     * Type representing bounds of a type variable, allows to keep all bounds information.\n     *\n     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n     * one element (Object is always here if no bounds are declared).</p>\n     *\n     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n     * interfacesBound will be an array of the additional interfaces.\n     *\n     * i.e. <code>SomeClass</code>.\n     * <pre class=\"code\"><code class=\"java\">\n     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n     *         E get();\n     *     }\n     *     // will return Comparable type\n     * </code></pre>\n     * </p>\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable;\n\n\n        public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }\n\n        /**\n         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n         */\n        public Type firstBound() {\n            return typeVariable.getBounds()[0]; //\n        }\n\n        /**\n         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n         * containing I_1 and I_2.\n         *\n         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n         * empty array if no other bound declared.\n         */\n        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }\n\n        public TypeVariable typeVariable() {\n            return typeVariable;\n        }\n    }\n\n    /**\n     * Type representing bounds of a wildcard, allows to keep all bounds information.\n     *\n     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n     * are not allowed.\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class WildCardBoundedType implements BoundedType {\n        private final WildcardType wildcard;\n\n\n        public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }\n\n        /**\n         * @return The first bound, either a type or a reference to a TypeVariable\n         */\n        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }\n\n        /**\n         * @return An empty array as, wildcard don't support multiple bounds.\n         */\n        public Type[] interfaceBounds() {\n            return new Type[0];\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }\n\n        public WildcardType wildCard() {\n            return wildcard;\n        }\n    }\n\n}\n\n\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util.reflection;\n\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.Checks;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n\n/**\n * This class can retrieve generic meta-data that the compiler stores on classes\n * and accessible members.\n *\n * <p>\n *     The main idea of this code is to create a Map that will help to resolve return types.\n *     In order to actually work with nested generics, this map will have to be passed along new instances\n *     as a type context.\n * </p>\n *\n * <p>\n *     Hence :\n *     <ul>\n *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\n *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\n *\n *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n *         {@link #resolveGenericReturnType(Method)}.</li>\n *     </ul>\n * </p>\n *\n * <p>\n * For now this code support the following kind of generic declarations :\n * <pre class=\"code\"><code class=\"java\">\n * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n *     K returningK();\n *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n *     &lt;S, T extends S&gt; T two_type_params();\n *     &lt;O extends K&gt; O typeVar_with_type_params();\n *     Number returningNonGeneric();\n * }\n * </code></pre>\n *\n * @see #inferFrom(Type)\n * @see #resolveGenericReturnType(Method)\n * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n */\npublic abstract class GenericMetadataSupport {\n\n    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable type : typeParameters) {\n            registerTypeVariableIfNotPresent(type);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n     * @param typeParameter The TypeVariable parameter\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n    /**\n     * @param wildCard The WildCard type\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(WildcardType wildCard) {\n        /*\n         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n         */\n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }\n\n\n\n    /**\n     * @return Raw type of the current instance.\n     */\n    public abstract Class<?> rawType();\n\n\n\n    /**\n     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n     */\n    public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }\n\n    /**\n     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }\n\n\n\n    /**\n     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n     */\n    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n        }\n\n        return actualTypeArguments;\n    }\n\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n\n\n    /**\n     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n     *\n     * @param method Method to resolve the return type.\n     * @return {@link GenericMetadataSupport} representing this generic return type.\n     */\n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n    /**\n     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n     *\n     * <p>\n     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n     *     it'll throw a {@link MockitoException}.\n     * </p>\n     *\n     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n     * @return The new {@link GenericMetadataSupport}.\n     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n     */\n    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Generic metadata implementation for {@link Class}.\n     *\n     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n     * the class and its ancestors and interfaces.\n     */\n    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n        private final Class<?> clazz;\n\n        public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }\n    }\n\n\n    /**\n     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n     *\n     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\n     * the related raw type and declared type variable of this parameterized type.\n     *\n     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\n     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\n     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n     * Instead use {@link ParameterizedReturnType}.\n     */\n    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n\n        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }\n\n        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n    }\n\n\n    /**\n     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class ParameterizedReturnType extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n        private final TypeVariable[] typeParameters;\n\n        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n\n    }\n\n\n    /**\n     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class TypeVariableReturnType extends GenericMetadataSupport {\n        private final TypeVariable typeVariable;\n        private final TypeVariable[] typeParameters;\n        private Class<?> rawType;\n\n\n\n        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }\n\n        /**\n         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n         * @see #extractRawTypeOf(java.lang.reflect.Type)\n         */\n        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }\n    }\n\n\n\n    /**\n     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n        private final Class<?> returnType;\n\n        public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }\n    }\n\n\n\n    /**\n     * Type representing bounds of a type\n     *\n     * @see TypeVarBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     * @see WildCardBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n     */\n    public interface BoundedType extends Type {\n        Type firstBound();\n\n        Type[] interfaceBounds();\n    }\n\n    /**\n     * Type representing bounds of a type variable, allows to keep all bounds information.\n     *\n     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n     * one element (Object is always here if no bounds are declared).</p>\n     *\n     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n     * interfacesBound will be an array of the additional interfaces.\n     *\n     * i.e. <code>SomeClass</code>.\n     * <pre class=\"code\"><code class=\"java\">\n     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n     *         E get();\n     *     }\n     *     // will return Comparable type\n     * </code></pre>\n     * </p>\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable;\n\n\n        public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }\n\n        /**\n         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n         */\n        public Type firstBound() {\n            return typeVariable.getBounds()[0]; //\n        }\n\n        /**\n         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n         * containing I_1 and I_2.\n         *\n         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n         * empty array if no other bound declared.\n         */\n        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }\n\n        public TypeVariable typeVariable() {\n            return typeVariable;\n        }\n    }\n\n    /**\n     * Type representing bounds of a wildcard, allows to keep all bounds information.\n     *\n     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n     * are not allowed.\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class WildCardBoundedType implements BoundedType {\n        private final WildcardType wildcard;\n\n\n        public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }\n\n        /**\n         * @return The first bound, either a type or a reference to a TypeVariable\n         */\n        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }\n\n        /**\n         * @return An empty array as, wildcard don't support multiple bounds.\n         */\n        public Type[] interfaceBounds() {\n            return new Type[0];\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }\n\n        public WildcardType wildCard() {\n            return wildcard;\n        }\n    }\n\n}\n\n\n"}]}
{"project": "Mockito", "bug_id": 8, "classes_modified": [{"class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util.reflection;\n\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.Checks;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n\n/**\n * This class can retrieve generic meta-data that the compiler stores on classes\n * and accessible members.\n *\n * <p>\n *     The main idea of this code is to create a Map that will help to resolve return types.\n *     In order to actually work with nested generics, this map will have to be passed along new instances\n *     as a type context.\n * </p>\n *\n * <p>\n *     Hence :\n *     <ul>\n *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\n *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\n *\n *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n *         {@link #resolveGenericReturnType(Method)}.</li>\n *     </ul>\n * </p>\n *\n * <p>\n * For now this code support the following kind of generic declarations :\n * <pre class=\"code\"><code class=\"java\">\n * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n *     K returningK();\n *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n *     &lt;S, T extends S&gt; T two_type_params();\n *     &lt;O extends K&gt; O typeVar_with_type_params();\n *     Number returningNonGeneric();\n * }\n * </code></pre>\n *\n * @see #inferFrom(Type)\n * @see #resolveGenericReturnType(Method)\n * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n */\npublic abstract class GenericMetadataSupport {\n\n    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable typeVariable : typeParameters) {\n            registerTypeVariableIfNotPresent(typeVariable);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n     * @param typeParameter The TypeVariable parameter\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n    /**\n     * @param wildCard The WildCard type\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(WildcardType wildCard) {\n        /*\n         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n         */\n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }\n\n\n\n    /**\n     * @return Raw type of the current instance.\n     */\n    public abstract Class<?> rawType();\n\n\n\n    /**\n     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n     */\n    public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }\n\n    /**\n     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }\n\n\n\n    /**\n     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n     */\n    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n        }\n\n        return actualTypeArguments;\n    }\n\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n\n\n    /**\n     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n     *\n     * @param method Method to resolve the return type.\n     * @return {@link GenericMetadataSupport} representing this generic return type.\n     */\n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n    /**\n     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n     *\n     * <p>\n     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n     *     it'll throw a {@link MockitoException}.\n     * </p>\n     *\n     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n     * @return The new {@link GenericMetadataSupport}.\n     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n     */\n    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Generic metadata implementation for {@link Class}.\n     *\n     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n     * the class and its ancestors and interfaces.\n     */\n    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n        private final Class<?> clazz;\n\n        public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }\n    }\n\n\n    /**\n     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n     *\n     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\n     * the related raw type and declared type variable of this parameterized type.\n     *\n     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\n     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\n     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n     * Instead use {@link ParameterizedReturnType}.\n     */\n    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n\n        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }\n\n        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n    }\n\n\n    /**\n     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class ParameterizedReturnType extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n        private final TypeVariable[] typeParameters;\n\n        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n\n    }\n\n\n    /**\n     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class TypeVariableReturnType extends GenericMetadataSupport {\n        private final TypeVariable typeVariable;\n        private final TypeVariable[] typeParameters;\n        private Class<?> rawType;\n\n\n\n        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }\n\n        /**\n         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n         * @see #extractRawTypeOf(java.lang.reflect.Type)\n         */\n        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }\n    }\n\n\n\n    /**\n     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n        private final Class<?> returnType;\n\n        public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }\n    }\n\n\n\n    /**\n     * Type representing bounds of a type\n     *\n     * @see TypeVarBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     * @see WildCardBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n     */\n    public interface BoundedType extends Type {\n        Type firstBound();\n\n        Type[] interfaceBounds();\n    }\n\n    /**\n     * Type representing bounds of a type variable, allows to keep all bounds information.\n     *\n     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n     * one element (Object is always here if no bounds are declared).</p>\n     *\n     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n     * interfacesBound will be an array of the additional interfaces.\n     *\n     * i.e. <code>SomeClass</code>.\n     * <pre class=\"code\"><code class=\"java\">\n     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n     *         E get();\n     *     }\n     *     // will return Comparable type\n     * </code></pre>\n     * </p>\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable;\n\n\n        public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }\n\n        /**\n         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n         */\n        public Type firstBound() {\n            return typeVariable.getBounds()[0]; //\n        }\n\n        /**\n         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n         * containing I_1 and I_2.\n         *\n         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n         * empty array if no other bound declared.\n         */\n        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }\n\n        public TypeVariable typeVariable() {\n            return typeVariable;\n        }\n    }\n\n    /**\n     * Type representing bounds of a wildcard, allows to keep all bounds information.\n     *\n     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n     * are not allowed.\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class WildCardBoundedType implements BoundedType {\n        private final WildcardType wildcard;\n\n\n        public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }\n\n        /**\n         * @return The first bound, either a type or a reference to a TypeVariable\n         */\n        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }\n\n        /**\n         * @return An empty array as, wildcard don't support multiple bounds.\n         */\n        public Type[] interfaceBounds() {\n            return new Type[0];\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }\n\n        public WildcardType wildCard() {\n            return wildcard;\n        }\n    }\n\n}\n\n\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util.reflection;\n\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.Checks;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\n\n/**\n * This class can retrieve generic meta-data that the compiler stores on classes\n * and accessible members.\n *\n * <p>\n *     The main idea of this code is to create a Map that will help to resolve return types.\n *     In order to actually work with nested generics, this map will have to be passed along new instances\n *     as a type context.\n * </p>\n *\n * <p>\n *     Hence :\n *     <ul>\n *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\n *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\n *\n *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n *         {@link #resolveGenericReturnType(Method)}.</li>\n *     </ul>\n * </p>\n *\n * <p>\n * For now this code support the following kind of generic declarations :\n * <pre class=\"code\"><code class=\"java\">\n * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n *     K returningK();\n *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n *     &lt;S, T extends S&gt; T two_type_params();\n *     &lt;O extends K&gt; O typeVar_with_type_params();\n *     Number returningNonGeneric();\n * }\n * </code></pre>\n *\n * @see #inferFrom(Type)\n * @see #resolveGenericReturnType(Method)\n * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n */\npublic abstract class GenericMetadataSupport {\n\n    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n\n    /**\n     * Represents actual type variables resolved for current class.\n     */\n    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n\n\n    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n\n    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable typeVariable : typeParameters) {\n            registerTypeVariableIfNotPresent(typeVariable);\n        }\n    }\n\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n    /**\n     * @param typeParameter The TypeVariable parameter\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n    /**\n     * @param wildCard The WildCard type\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     */\n    private BoundedType boundsOf(WildcardType wildCard) {\n        /*\n         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n         */\n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }\n\n\n\n    /**\n     * @return Raw type of the current instance.\n     */\n    public abstract Class<?> rawType();\n\n\n\n    /**\n     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n     */\n    public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }\n\n    /**\n     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n     */\n    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }\n\n\n\n    /**\n     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n     */\n    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n        }\n\n        return actualTypeArguments;\n    }\n\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n\n\n    /**\n     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n     *\n     * @param method Method to resolve the return type.\n     * @return {@link GenericMetadataSupport} representing this generic return type.\n     */\n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n    /**\n     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n     *\n     * <p>\n     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n     *     it'll throw a {@link MockitoException}.\n     * </p>\n     *\n     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n     * @return The new {@link GenericMetadataSupport}.\n     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n     */\n    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Generic metadata implementation for {@link Class}.\n     *\n     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n     * the class and its ancestors and interfaces.\n     */\n    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n        private final Class<?> clazz;\n\n        public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }\n    }\n\n\n    /**\n     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n     *\n     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\n     * the related raw type and declared type variable of this parameterized type.\n     *\n     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\n     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\n     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n     * Instead use {@link ParameterizedReturnType}.\n     */\n    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n\n        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }\n\n        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n    }\n\n\n    /**\n     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class ParameterizedReturnType extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n        private final TypeVariable[] typeParameters;\n\n        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }\n\n    }\n\n\n    /**\n     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class TypeVariableReturnType extends GenericMetadataSupport {\n        private final TypeVariable typeVariable;\n        private final TypeVariable[] typeParameters;\n        private Class<?> rawType;\n\n\n\n        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }\n\n        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }\n\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }\n\n        /**\n         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n         * @see #extractRawTypeOf(java.lang.reflect.Type)\n         */\n        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }\n    }\n\n\n\n    /**\n     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\n     */\n    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n        private final Class<?> returnType;\n\n        public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }\n\n        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }\n    }\n\n\n\n    /**\n     * Type representing bounds of a type\n     *\n     * @see TypeVarBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     * @see WildCardBoundedType\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n     */\n    public interface BoundedType extends Type {\n        Type firstBound();\n\n        Type[] interfaceBounds();\n    }\n\n    /**\n     * Type representing bounds of a type variable, allows to keep all bounds information.\n     *\n     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n     * one element (Object is always here if no bounds are declared).</p>\n     *\n     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n     * interfacesBound will be an array of the additional interfaces.\n     *\n     * i.e. <code>SomeClass</code>.\n     * <pre class=\"code\"><code class=\"java\">\n     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n     *         E get();\n     *     }\n     *     // will return Comparable type\n     * </code></pre>\n     * </p>\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable;\n\n\n        public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }\n\n        /**\n         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n         */\n        public Type firstBound() {\n            return typeVariable.getBounds()[0]; //\n        }\n\n        /**\n         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n         * containing I_1 and I_2.\n         *\n         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n         * empty array if no other bound declared.\n         */\n        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }\n\n        public TypeVariable typeVariable() {\n            return typeVariable;\n        }\n    }\n\n    /**\n     * Type representing bounds of a wildcard, allows to keep all bounds information.\n     *\n     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n     * are not allowed.\n     *\n     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n     */\n    public static class WildCardBoundedType implements BoundedType {\n        private final WildcardType wildcard;\n\n\n        public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }\n\n        /**\n         * @return The first bound, either a type or a reference to a TypeVariable\n         */\n        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }\n\n        /**\n         * @return An empty array as, wildcard don't support multiple bounds.\n         */\n        public Type[] interfaceBounds() {\n            return new Type[0];\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }\n\n        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }\n\n        public WildcardType wildCard() {\n            return wildcard;\n        }\n    }\n\n}\n\n\n"}]}
{"project": "Mockito", "bug_id": 9, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.answers.CallsRealMethods", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.answers;\n\nimport java.io.Serializable;\n\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Optional Answer that adds partial mocking support\n * <p>\n * {@link Answer} can be used to define the return values of unstubbed invocations.\n * <p>\n * This implementation can be helpful when working with legacy code.\n * When this implementation is used, unstubbed methods will delegate to the real implementation.\n * This is a way to create a partial mock object that calls real methods by default.\n * <p>\n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n * <p>\n */\npublic class CallsRealMethods implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 9057165148930624087L;\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return invocation.callRealMethod();\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.answers;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Modifier;\n\nimport org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Optional Answer that adds partial mocking support\n * <p>\n * {@link Answer} can be used to define the return values of unstubbed invocations.\n * <p>\n * This implementation can be helpful when working with legacy code.\n * When this implementation is used, unstubbed methods will delegate to the real implementation.\n * This is a way to create a partial mock object that calls real methods by default.\n * <p>\n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n * <p>\n */\npublic class CallsRealMethods implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 9057165148930624087L;\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n    \t}\n        return invocation.callRealMethod();\n    }\n}"}]}
{"project": "Mockito", "bug_id": 10, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.MockSettings;\nimport org.mockito.Mockito;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.MockitoCore;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.IOException;\nimport java.io.Serializable;\n\nimport static org.mockito.Mockito.withSettings;\n\n/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = -7105341425736035847L;\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!mockitoCore().isTypeMockable(rawType)) {\n            return delegate().returnValueFor(rawType);\n        }\n\n        return deepStub(invocation, returnTypeGenericMetadata);\n    }\n\n    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n                return stubbedInvocationMatcher.answer(invocation);\n            }\n        }\n\n        // record deep stub answer\n        return recordDeepStubAnswer(\n                newDeepStubMock(returnTypeGenericMetadata),\n                container\n        );\n    }\n\n    /**\n     * Creates a mock using the Generics Metadata.\n     *\n     * <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n     * that was resolved for the current return type, for this to happen we associate to the mock an new instance of\n     * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @param parentMock The parent of the current deep stub mock.\n     * @return The mock\n     */\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n        return mockitoCore().mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata)\n        );\n    }\n\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n        MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return mockSettings.serializable()\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }\n\n\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\n    }\n\n    private Object recordDeepStubAnswer(final Object mock, InvocationContainerImpl container) throws Throwable {\n        container.addAnswer(new DeeplyStubbedAnswer(mock), false);\n        return mock;\n    }\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n\n\n    private static class ReturnsDeepStubsSerializationFallback extends ReturnsDeepStubs implements Serializable {\n        @SuppressWarnings(\"serial\") // not gonna be serialized\n        private final GenericMetadataSupport returnTypeGenericMetadata;\n\n        public ReturnsDeepStubsSerializationFallback(GenericMetadataSupport returnTypeGenericMetadata) {\n            this.returnTypeGenericMetadata = returnTypeGenericMetadata;\n        }\n\n        @Override\n        protected GenericMetadataSupport actualParameterizedType(Object mock) {\n            return returnTypeGenericMetadata;\n        }\n        private Object writeReplace() throws IOException {\n            return Mockito.RETURNS_DEEP_STUBS;\n        }\n    }\n\n\n    private static class DeeplyStubbedAnswer implements Answer<Object>, Serializable {\n        @SuppressWarnings(\"serial\") // serialization will fail with a nice message if mock not serializable\n        private final Object mock;\n\n        DeeplyStubbedAnswer(Object mock) {\n            this.mock = mock;\n        }\n        public Object answer(InvocationOnMock invocation) throws Throwable {\n            return mock;\n        }\n    }\n\n\n    private static MockitoCore mockitoCore() {\n        return LazyHolder.MOCKITO_CORE;\n    }\n\n    private static ReturnsEmptyValues delegate() {\n        return LazyHolder.DELEGATE;\n    }\n\n    private static class LazyHolder {\n        private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n        private static final ReturnsEmptyValues DELEGATE = new ReturnsEmptyValues();\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.MockSettings;\nimport org.mockito.Mockito;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.MockitoCore;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.IOException;\nimport java.io.Serializable;\n\nimport static org.mockito.Mockito.withSettings;\n\n/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = -7105341425736035847L;\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!mockitoCore().isTypeMockable(rawType)) {\n            return delegate().returnValueFor(rawType);\n        }\n\n        return deepStub(invocation, returnTypeGenericMetadata);\n    }\n\n    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n                return stubbedInvocationMatcher.answer(invocation);\n            }\n        }\n\n        // record deep stub answer\n        return recordDeepStubAnswer(\n                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\n                container\n        );\n    }\n\n    /**\n     * Creates a mock using the Generics Metadata.\n     *\n     * <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n     * that was resolved for the current return type, for this to happen we associate to the mock an new instance of\n     * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @param parentMock The parent of the current deep stub mock.\n     * @return The mock\n     */\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\n        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\n        return mockitoCore().mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\n        );\n    }\n\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n        MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return propagateSerializationSettings(mockSettings, parentMockSettings)\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }\n\n    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\n        return mockSettings.serializable(parentMockSettings.getSerializableMode());\n    }\n\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\n    }\n\n    private Object recordDeepStubAnswer(final Object mock, InvocationContainerImpl container) throws Throwable {\n        container.addAnswer(new DeeplyStubbedAnswer(mock), false);\n        return mock;\n    }\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n\n\n    private static class ReturnsDeepStubsSerializationFallback extends ReturnsDeepStubs implements Serializable {\n        @SuppressWarnings(\"serial\") // not gonna be serialized\n        private final GenericMetadataSupport returnTypeGenericMetadata;\n\n        public ReturnsDeepStubsSerializationFallback(GenericMetadataSupport returnTypeGenericMetadata) {\n            this.returnTypeGenericMetadata = returnTypeGenericMetadata;\n        }\n\n        @Override\n        protected GenericMetadataSupport actualParameterizedType(Object mock) {\n            return returnTypeGenericMetadata;\n        }\n        private Object writeReplace() throws IOException {\n            return Mockito.RETURNS_DEEP_STUBS;\n        }\n    }\n\n\n    private static class DeeplyStubbedAnswer implements Answer<Object>, Serializable {\n        @SuppressWarnings(\"serial\") // serialization will fail with a nice message if mock not serializable\n        private final Object mock;\n\n        DeeplyStubbedAnswer(Object mock) {\n            this.mock = mock;\n        }\n        public Object answer(InvocationOnMock invocation) throws Throwable {\n            return mock;\n        }\n    }\n\n\n    private static MockitoCore mockitoCore() {\n        return LazyHolder.MOCKITO_CORE;\n    }\n\n    private static ReturnsEmptyValues delegate() {\n        return LazyHolder.DELEGATE;\n    }\n\n    private static class LazyHolder {\n        private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n        private static final ReturnsEmptyValues DELEGATE = new ReturnsEmptyValues();\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 11, "classes_modified": [{"class_name": "org.mockito.internal.creation.DelegatingMethod", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.creation;\n\nimport org.mockito.internal.invocation.MockitoMethod;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\npublic class DelegatingMethod implements MockitoMethod {\n\n    private final Method method;\n\n    public DelegatingMethod(Method method) {\n        assert method != null : \"Method cannot be null\";\n        this.method = method;\n    }\n\n    public Class<?>[] getExceptionTypes() {\n        return method.getExceptionTypes();\n    }\n\n    public Method getJavaMethod() {\n        return method;\n    }\n\n    public String getName() {\n        return method.getName();\n    }\n\n    public Class<?>[] getParameterTypes() {\n        return method.getParameterTypes();\n    }\n\n    public Class<?> getReturnType() {\n        return method.getReturnType();\n    }\n\n    public boolean isVarArgs() {\n        return method.isVarArgs();\n    }\n\n    public boolean isAbstract() {\n        return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n    }\n\n    /**\n     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,\n     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.\n     */\n    @Override\n    public boolean equals(Object o) {\n            return method.equals(o);\n    }\n\n    @Override\n    public int hashCode() {\n        return 1;\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.creation;\n\nimport org.mockito.internal.invocation.MockitoMethod;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\npublic class DelegatingMethod implements MockitoMethod {\n\n    private final Method method;\n\n    public DelegatingMethod(Method method) {\n        assert method != null : \"Method cannot be null\";\n        this.method = method;\n    }\n\n    public Class<?>[] getExceptionTypes() {\n        return method.getExceptionTypes();\n    }\n\n    public Method getJavaMethod() {\n        return method;\n    }\n\n    public String getName() {\n        return method.getName();\n    }\n\n    public Class<?>[] getParameterTypes() {\n        return method.getParameterTypes();\n    }\n\n    public Class<?> getReturnType() {\n        return method.getReturnType();\n    }\n\n    public boolean isVarArgs() {\n        return method.isVarArgs();\n    }\n\n    public boolean isAbstract() {\n        return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n    }\n\n    /**\n     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,\n     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o instanceof DelegatingMethod) {\n            DelegatingMethod that = (DelegatingMethod) o;\n            return method.equals(that.method);\n        } else {\n            return method.equals(o);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return method.hashCode();\n    }\n}"}]}
{"project": "Mockito", "bug_id": 12, "classes_modified": [{"class_name": "org.mockito.internal.util.reflection.GenericMaster", "buggy_version": "package org.mockito.internal.util.reflection;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\n@SuppressWarnings(\"unchecked\")\npublic class GenericMaster {\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n                return (Class) actual;\n                //in case of nested generics we don't go deep\n        }\n        \n        return Object.class;\n    }\n}\n", "fixed_version": "package org.mockito.internal.util.reflection;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\n@SuppressWarnings(\"unchecked\")\npublic class GenericMaster {\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class) actual;\n            } else if (actual instanceof ParameterizedType) {\n                //in case of nested generics we don't go deep\n                return (Class) ((ParameterizedType) actual).getRawType();\n            }\n        }\n        \n        return Object.class;\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 13, "classes_modified": [{"class_name": "org.mockito.internal.MockHandler", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport java.util.List;\n\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.invocation.InvocationMatcher;\nimport org.mockito.internal.invocation.MatchersBinder;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.InvocationContainer;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.stubbing.VoidMethodStubbableImpl;\nimport org.mockito.internal.verification.MockAwareVerificationMode;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n\n    private static final long serialVersionUID = -2917871070982574165L;\n\n    InvocationContainerImpl invocationContainerImpl;\n    MatchersBinder matchersBinder = new MatchersBinder();\n    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    private final MockSettingsImpl mockSettings;\n\n    public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }\n\n    // for tests\n    MockHandler() {\n        this(new MockSettingsImpl());\n    }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n        this(oldMockHandler.getMockSettings());\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }\n\n    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }\n\n    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport java.util.List;\n\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.invocation.InvocationMatcher;\nimport org.mockito.internal.invocation.MatchersBinder;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.InvocationContainer;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.stubbing.VoidMethodStubbableImpl;\nimport org.mockito.internal.verification.MockAwareVerificationMode;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n\n    private static final long serialVersionUID = -2917871070982574165L;\n\n    InvocationContainerImpl invocationContainerImpl;\n    MatchersBinder matchersBinder = new MatchersBinder();\n    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    private final MockSettingsImpl mockSettings;\n\n    public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }\n\n    // for tests\n    MockHandler() {\n        this(new MockSettingsImpl());\n    }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n        this(oldMockHandler.getMockSettings());\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }\n\n    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }\n\n    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }\n}"}]}
{"project": "Mockito", "bug_id": 14, "classes_modified": [{"class_name": "org.mockito.internal.MockHandler", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport java.util.List;\n\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.invocation.InvocationMatcher;\nimport org.mockito.internal.invocation.MatchersBinder;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.InvocationContainer;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.stubbing.VoidMethodStubbableImpl;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n\n    private static final long serialVersionUID = -2917871070982574165L;\n\n    InvocationContainerImpl invocationContainerImpl;\n    MatchersBinder matchersBinder = new MatchersBinder();\n    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    private final MockSettingsImpl mockSettings;\n\n    public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }\n\n    // for tests\n    MockHandler() {\n        this(new MockSettingsImpl());\n    }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n        this(oldMockHandler.getMockSettings());\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }\n\n    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }\n\n    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport java.util.List;\n\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.invocation.InvocationMatcher;\nimport org.mockito.internal.invocation.MatchersBinder;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.InvocationContainer;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.stubbing.VoidMethodStubbableImpl;\nimport org.mockito.internal.verification.MockAwareVerificationMode;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n\n    private static final long serialVersionUID = -2917871070982574165L;\n\n    InvocationContainerImpl invocationContainerImpl;\n    MatchersBinder matchersBinder = new MatchersBinder();\n    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    private final MockSettingsImpl mockSettings;\n\n    public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }\n\n    // for tests\n    MockHandler() {\n        this(new MockSettingsImpl());\n    }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n        this(oldMockHandler.getMockSettings());\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }\n\n    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }\n\n    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }\n}"}, {"class_name": "org.mockito.internal.MockitoCore", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.mockito.InOrder;\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.AllInvocationsFinder;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.progress.IOngoingStubbing;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubberImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.internal.verification.VerificationModeFactory;\nimport org.mockito.internal.verification.api.InOrderContext;\nimport org.mockito.internal.verification.api.VerificationDataInOrder;\nimport org.mockito.internal.verification.api.VerificationDataInOrderImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.DeprecatedOngoingStubbing;\nimport org.mockito.stubbing.OngoingStubbing;\nimport org.mockito.stubbing.Stubber;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockitoCore {\n\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    \n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n        return mock;\n    }\n    \n    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }\n\n    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }\n\n    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }\n    \n    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(mode);\n        return mock;\n    }\n    \n    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }\n    \n    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                List<Invocation> invocations = mockUtil.getMockHandler(mock).getInvocationContainer().getInvocations();\n                VerificationDataImpl data = new VerificationDataImpl(invocations, null);\n                VerificationModeFactory.noMoreInteractions().verify(data);\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }\n\n    public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {\n        mockingProgress.validateState();\n        AllInvocationsFinder finder = new AllInvocationsFinder();\n        VerificationDataInOrder data = new VerificationDataInOrderImpl(inOrderContext, finder.find(mocks), null);\n        VerificationModeFactory.noMoreInteractions().verifyInOrder(data);\n    }    \n    \n    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }\n    \n    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }\n    \n    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }\n    \n    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }\n\n    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }\n\n    /**\n     * For testing purposes only. Is not the part of main API.\n     * @return last invocation\n     */\n    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.mockito.InOrder;\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.AllInvocationsFinder;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.progress.IOngoingStubbing;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubberImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.verification.MockAwareVerificationMode;\nimport org.mockito.internal.verification.VerificationDataImpl;\nimport org.mockito.internal.verification.VerificationModeFactory;\nimport org.mockito.internal.verification.api.InOrderContext;\nimport org.mockito.internal.verification.api.VerificationDataInOrder;\nimport org.mockito.internal.verification.api.VerificationDataInOrderImpl;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.DeprecatedOngoingStubbing;\nimport org.mockito.stubbing.OngoingStubbing;\nimport org.mockito.stubbing.Stubber;\nimport org.mockito.stubbing.VoidMethodStubbable;\nimport org.mockito.verification.VerificationMode;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockitoCore {\n\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    \n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n        return mock;\n    }\n    \n    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }\n\n    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }\n\n    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }\n    \n    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n        return mock;\n    }\n    \n    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }\n    \n    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                List<Invocation> invocations = mockUtil.getMockHandler(mock).getInvocationContainer().getInvocations();\n                VerificationDataImpl data = new VerificationDataImpl(invocations, null);\n                VerificationModeFactory.noMoreInteractions().verify(data);\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }\n\n    public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {\n        mockingProgress.validateState();\n        AllInvocationsFinder finder = new AllInvocationsFinder();\n        VerificationDataInOrder data = new VerificationDataInOrderImpl(inOrderContext, finder.find(mocks), null);\n        VerificationModeFactory.noMoreInteractions().verifyInOrder(data);\n    }    \n    \n    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }\n    \n    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }\n    \n    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }\n    \n    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }\n\n    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }\n\n    /**\n     * For testing purposes only. Is not the part of main API.\n     * @return last invocation\n     */\n    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n}"}]}
{"project": "Mockito", "bug_id": 15, "classes_modified": [{"class_name": "org.mockito.internal.configuration.injection.FinalMockCandidateFilter", "buggy_version": "package org.mockito.internal.configuration.injection;\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.reflection.FieldSetter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public boolean thenInject() {\n                    try {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                    }\n                    return true;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public boolean thenInject() {\n                return false;\n            }\n        };\n\n    }\n}\n", "fixed_version": "package org.mockito.internal.configuration.injection;\n\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.reflection.BeanPropertySetter;\nimport org.mockito.internal.util.reflection.FieldSetter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public boolean thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                    }\n                    return true;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public boolean thenInject() {\n                return false;\n            }\n        };\n\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 16, "classes_modified": [{"class_name": "org.mockito.internal.MockitoCore", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport org.mockito.InOrder;\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.progress.IOngoingStubbing;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubberImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.verification.api.VerificationMode;\nimport org.mockito.stubbing.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockitoCore {\n\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    \n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        mockingProgress.validateState();\n            mockingProgress.resetOngoingStubbing();\n        return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n    }\n    \n    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }\n\n    @Deprecated\n    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }\n\n    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }\n    \n    \n    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(mode);\n        return mock;\n    }\n    \n    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }\n    \n    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                mockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }\n    \n    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }\n    \n    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }\n    \n    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }\n    \n    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }\n\n    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }\n\n    /**\n     * For testing purposes only. Is not the part of main API.\n     * @return last invocation\n     */\n    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal;\n\nimport org.mockito.InOrder;\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.internal.progress.IOngoingStubbing;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.OngoingStubbingImpl;\nimport org.mockito.internal.stubbing.StubberImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.verification.api.VerificationMode;\nimport org.mockito.stubbing.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockitoCore {\n\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    \n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {\n        mockingProgress.validateState();\n        if (shouldResetOngoingStubbing) {\n            mockingProgress.resetOngoingStubbing();\n        }\n        return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n    }\n    \n    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }\n\n    @Deprecated\n    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }\n\n    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }\n    \n    \n    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(mode);\n        return mock;\n    }\n    \n    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }\n    \n    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                mockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }\n    \n    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }\n    \n    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }\n    \n    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }\n    \n    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }\n\n    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }\n\n    /**\n     * For testing purposes only. Is not the part of main API.\n     * @return last invocation\n     */\n    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }\n}"}, {"class_name": "org.mockito.Mockito", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito;\n\nimport org.mockito.internal.MockitoCore;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.debugging.MockitoDebuggerImpl;\nimport org.mockito.internal.stubbing.answers.*;\nimport org.mockito.internal.stubbing.defaultanswers.*;\nimport org.mockito.internal.verification.VerificationModeFactory;\nimport org.mockito.internal.verification.api.VerificationMode;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.mockito.stubbing.*;\n\n/**\n * <p align=\"left\"><img src=\"logo.jpg\"/></p>\n * Mockito library enables mocks creation, verification and stubbing.\n * <p>\n * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page. \n * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.\n * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \n * \n * <h1>Contents</h1>\n * \n * <b> \n *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \n *      <a href=\"#2\">2. How about some stubbing? </a><br/>\n *      <a href=\"#3\">3. Argument matchers </a><br/>\n *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \n *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \n *      <a href=\"#6\">6. Verification in order </a><br/> \n *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \n *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \n *      <a href=\"#9\">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> \n *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n *      <a href=\"#12\">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>\n *      <a href=\"#13\">13. Spying on real objects </a><br/>\n *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\n *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\n *      <a href=\"#16\">16. Real partial mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#17\">17. Resetting mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>\n *      <a href=\"#19\">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>\n *      <a href=\"#20\">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>\n * </b>\n * \n * <p>\n * Following examples mock a List, because everyone knows its interface (methods\n * like add(), get(), clear() will be used). <br>\n * You probably wouldn't mock List class 'in real'.\n * \n * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n * \n * <pre>\n * //Let's import Mockito statically so that the code looks clearer\n * import static org.mockito.Mockito.*;\n * \n * //mock creation\n * List mockedList = mock(List.class);\n *\n * //using mock object\n * mockedList.add(\"one\");\n * mockedList.clear();\n *\n * //verification\n * verify(mockedList).add(\"one\");\n * verify(mockedList).clear();\n * </pre>\n * \n * <p>\n * Once created, mock will remember all interactions. Then you can selectively\n * verify whatever interaction you are interested in.\n * \n * <h3 id=\"2\">2. How about some stubbing?</h3>\n * \n * <pre>\n * //You can mock concrete classes, not only interfaces\n * LinkedList mockedList = mock(LinkedList.class);\n * \n * //stubbing\n * when(mockedList.get(0)).thenReturn(\"first\");\n * when(mockedList.get(1)).thenThrow(new RuntimeException());\n * \n * //following prints \"first\"\n * System.out.println(mockedList.get(0));\n * \n * //following throws runtime exception\n * System.out.println(mockedList.get(1));\n * \n * //following prints \"null\" because get(999) was not stubbed\n * System.out.println(mockedList.get(999));\n *  \n * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n * verify(mockedList).get(0);\n * </pre>\n * \n * <ul>\n * <li> By default, for all methods that return value, mock returns null, an\n * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n * false, ... for int/Integer, boolean/Boolean, ...). </li>\n * \n * <li> Stubbing can be overridden: for example common stubbing can go to\n * fixture setup but the test methods can override it.\n * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>\n * \n * <li> Once stubbed, the method will always return stubbed value regardless\n * of how many times it is called. </li>\n * \n * <li> Last stubbing is more important - when you stubbed the same method with\n * the same arguments many times. </li>\n * \n * </ul>\n * \n * <h3 id=\"3\">3. Argument matchers</h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * Sometimes, when extra flexibility is required then you might use argument matchers:  \n * \n * <pre>\n * //stubbing using built-in anyInt() argument matcher\n * when(mockedList.get(anyInt())).thenReturn(\"element\");\n * \n * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n * \n * //following prints \"element\"\n * System.out.println(mockedList.get(999));\n * \n * //<b>you can also verify using an argument matcher</b>\n * verify(mockedList).get(anyInt());\n * </pre>\n * \n * <p>\n * Argument matchers allow flexible verification or stubbing. \n * {@link Matchers Click here to see} more built-in matchers \n * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n * <p>\n * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\n * <p>\n * Be reasonable with using complicated argument matching.\n * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.\n * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\n * <p>\n * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\n * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \n * <p>\n * <b>Warning on argument matchers:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided\n * by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * \n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n * </pre>\n * \n * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n * \n * <pre>\n * //using mock \n * mockedList.add(\"once\");\n * \n * mockedList.add(\"twice\");\n * mockedList.add(\"twice\");\n * \n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * \n * //following two verifications work exactly the same - times(1) is used by default\n * verify(mockedList).add(\"once\");\n * verify(mockedList, times(1)).add(\"once\");\n * \n * //exact number of invocations verification\n * verify(mockedList, times(2)).add(\"twice\");\n * verify(mockedList, times(3)).add(\"three times\");\n * \n * //verification using never(). never() is an alias to times(0)\n * verify(mockedList, never()).add(\"never happened\");\n * \n * //verification using atLeast()/atMost()\n * verify(mockedList, atLeastOnce()).add(\"three times\");\n * verify(mockedList, atLeast(2)).add(\"five times\");\n * verify(mockedList, atMost(5)).add(\"three times\");\n * \n * </pre>\n * \n * <p>\n * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n * omitted.\n * \n * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n * \n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about doThrow|doAnswer family of methods in paragraph 12.\n * <p>\n * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n * \n * <h3 id=\"6\">6. Verification in order</h3>\n * \n * <pre>\n * List firstMock = mock(List.class);\n * List secondMock = mock(List.class);\n * \n * //using mocks\n * firstMock.add(\"was called first\");\n * secondMock.add(\"was called second\");\n * \n * //create inOrder object passing any mocks that need to be verified in order\n * InOrder inOrder = inOrder(firstMock, secondMock);\n * \n * //following will make sure that firstMock was called before secondMock\n * inOrder.verify(firstMock).add(\"was called first\");\n * inOrder.verify(secondMock).add(\"was called second\");\n * </pre>\n * \n * Verification in order is flexible - <b>you don't have to verify all\n * interactions</b> one-by-one but only those that you are interested in\n * testing in order.\n * <p>\n * Also, you can create InOrder object passing only mocks that are relevant for\n * in-order verification.\n * \n * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n * \n * <pre>\n * //using mocks - only mockOne is interacted\n * mockOne.add(\"one\");\n * \n * //ordinary verification\n * verify(mockOne).add(\"one\");\n * \n * //verify that method was never called on a mock\n * verify(mockOne, never()).add(\"two\");\n * \n * //verify that other mocks were not interacted\n * verifyZeroInteractions(mockTwo, mockThree);\n * \n * </pre>\n * \n * <h3 id=\"8\">8. Finding redundant invocations</h3>\n * \n * <pre>\n * //using mocks\n * mockedList.add(\"one\");\n * mockedList.add(\"two\");\n * \n * verify(mockedList).add(\"one\");\n * \n * //following verification will fail \n * verifyNoMoreInteractions(mockedList);\n * </pre>\n * \n * A word of <b>warning</b>: \n * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n * verifyNoMoreInteractions() is not recommended to use in every test method. \n * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n * \n * <p>   \n * See also {@link Mockito#never()} - it is more explicit and\n * communicates the intent well.\n * <p>\n * \n * <h3 id=\"9\">9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n * \n * <ul>\n * <li>Minimizes repetitive mock creation code.</li>\n * <li>Makes the test class more readable.</li>\n * <li>Makes the verification error easier to read because the <b>field name</b>\n * is used to identify the mock.</li>\n * </ul>\n * \n * <pre>\n *   public class ArticleManagerTest { \n *     \n *       &#064;Mock private ArticleCalculator calculator;\n *       &#064;Mock private ArticleDatabase database;\n *       &#064;Mock private UserProvider userProvider;\n *     \n *       private ArticleManager manager;\n * </pre>\n * \n * <b>Important!</b> This needs to be somewhere in the base class or a test\n * runner:\n * \n * <pre>\n * MockitoAnnotations.initMocks(testClass);\n * </pre>\n * \n * You can use built-in runner: {@link MockitoJUnitRunner}.\n * <p>\n * Read more here: {@link MockitoAnnotations}\n * \n * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n * \n * Sometimes we need to stub with different return value/exception for the same\n * method call. Typical use case could be mocking iterators. \n * Original version of Mockito did not have this feature to promote simple mocking. \n * For example, instead of iterators one could use {@link Iterable} or simply\n * collections. Those offer natural ways of stubbing (e.g. using real\n * collections). In rare scenarios stubbing consecutive calls could be useful,\n * though:\n * <p>\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenThrow(new RuntimeException())\n *   .thenReturn(\"foo\");\n * \n * //First call: throws runtime exception:\n * mock.someMethod(\"some arg\");\n * \n * //Second call: prints \"foo\"\n * System.out.println(mock.someMethod(\"some arg\"));\n * \n * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n * System.out.println(mock.someMethod(\"some arg\"));\n * </pre>\n * \n * Alternative, shorter version of consecutive stubbing:\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenReturn(\"one\", \"two\", \"three\");\n * </pre>\n * \n * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n * \n * Allows stubbing with generic {@link Answer} interface.\n*  <p>\n * Yet another controversial feature which was not included in Mockito\n * originally. We recommend using simple stubbing with thenReturn() or\n * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive\n * any clean & simple code.\n * \n * <pre>\n * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n *     Object answer(InvocationOnMock invocation) {\n *         Object[] args = invocation.getArguments();\n *         Object mock = invocation.getMock();\n *         return \"called with arguments: \" + args;\n *     }\n * });\n * \n * //Following prints \"called with arguments: foo\"\n * System.out.println(mock.someMethod(\"foo\"));\n * </pre>\n * \n * <h3 id=\"12\"> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n * \n * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n * <p>\n * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n * The main reason is improved readability and consistency with the family of doAnswer() methods.\n * <p>\n * Use doThrow() when you want to stub a void method with an exception:\n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about other methods:\n * <p>\n * {@link Mockito#doThrow(Throwable)}\n * <p>\n * {@link Mockito#doAnswer(Answer)}\n * <p>\n * {@link Mockito#doNothing()}\n * <p>\n * {@link Mockito#doReturn(Object)}\n * \n * <h3 id=\"13\"> 13. Spying on real objects</h3>\n * \n * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n * <p>\n * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n * \n * <p>\n * Spying on real objects can be associated with \"partial mocking\" concept. \n * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \n * The reason was we thought partial mock is a code smell. \n * At some point we found legitimate use cases for partial mocks \n * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\n * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\n * >here</a>)\n * <p>\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n * \n *   //optionally, you can stub out some methods:\n *   when(spy.size()).thenReturn(100);\n * \n *   //using the spy calls <b>real</b> methods\n *   spy.add(\"one\");\n *   spy.add(\"two\");\n * \n *   //prints \"one\" - the first element of a list\n *   System.out.println(spy.get(0));\n * \n *   //size() method was stubbed - 100 is printed\n *   System.out.println(spy.size());\n * \n *   //optionally, you can verify\n *   verify(spy).add(\"one\");\n *   verify(spy).add(\"two\");\n * </pre>\n * \n * <h4>Important gotcha on spying real objects!</h4>\n * \n * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n * \n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *   \n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n *   when(spy.get(0)).thenReturn(\"foo\");\n *   \n *   //You have to use doReturn() for stubbing\n *   doReturn(\"foo\").when(spy).get(0);\n * </pre>\n * \n * 2. Watch out for final methods. \n * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n * \n * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n * \n * You can create a mock with specified strategy for its return values.\n * It's quite advanced feature and typically you don't need it to write decent tests.\n * However, it can be helpful for working with <b>legacy systems</b>.\n * <p>\n * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n * \n * <pre>\n *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n * </pre>\n * \n * <p>\n * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n * \n * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * This is also the recommended way of matching arguments because it makes tests clean & simple.\n * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n * For example:\n * <pre>\n *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n *   verify(mock).doSomething(argument.capture());\n *   assertEquals(\"John\", argument.getValue().getName());\n * </pre>\n * \n * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n * <p>\n * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n * Both techniques can be used for making sure certain arguments where passed to mocks. \n * However, ArgumentCaptor may be a better fit if:\n * <ul>  \n * <li>custom argument matcher is not likely to be reused</li>\n * <li>you just need it to assert on argument values to complete verification</li>\n * </ul>\n * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n * \n * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\n *  \n *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\n *  <p>\n *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.\n *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n *  <p>\n *  <pre>\n *    //you can create partial mock with spy() method:    \n *    List list = spy(new LinkedList());\n *    \n *    //you can enable partial mock capabilities selectively on mocks:\n *    Foo mock = mock(Foo.class);\n *    //Be sure the real implementation is 'safe'.\n *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n *    when(mock.someMethod()).thenCallRealMethod();\n *  </pre>\n *  \n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n *  \n * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\n *  \n * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n * <p>\n * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\n * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \n * There are several threads about it on mockito mailing list.\n * <p>\n * The only reason we added reset() method is to\n * make it possible to work with container-injected mocks.\n * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n * <p>\n * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). \n * <pre>\n *   List mock = mock(List.class);\n *   when(mock.size()).thenReturn(10);\n *   mock.add(1);\n *   \n *   reset(mock);\n *   //at this point the mock forgot any interactions & stubbing\n * </pre>\n *  \n * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n * \n * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n * <p>\n * In case of questions you may also post to mockito mailing list: \n * <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n * <p>\n * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n * \n * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\n * \n * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n * This is exactly how we write our tests and we warmly encourage you to do so!\n * <p>\n * Start learning about BDD here: <a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>\n * <p>\n * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.\n * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. \n * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. \n * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \n * <p>\n * Here is how the test might look like: \n * <pre>\n * import static org.mockito.BDDMockito.*;\n * \n * Seller seller = mock(Seller.class);\n * Shop shop = new Shop(seller);\n * \n * public void shouldBuyBread() throws Exception {\n *   //given  \n *   given(seller.askForBread()).willReturn(new Bread());\n *   \n *   //when\n *   Goods goods = shop.buyBread();\n *   \n *   //then\n *   assertThat(goods, containBread());\n * }  \n * </pre>\n * \n * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n * \n * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n * <p>\n * WARNING: This should be rarely used in unit testing. \n * <p>\n * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \n * <p>\n * To create serializable mock use {@link MockSettings#serializable()}:\n * <pre>\n *   List serializableMock = mock(List.class, withSettings().serializable());\n * </pre>\n * <p>\n * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\n * serialization requirements</a> are met by the class.\n * <p>\n * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \n * which accepts MockSettings. No worries, you will hardly ever use it.\n * \n * <pre>\n * List<Object> list = new ArrayList<Object>();\n * List<Object> spy = mock(ArrayList.class, withSettings()\n *                 .spiedInstance(list)\n *                 .defaultAnswer(CALLS_REAL_METHODS)\n *                 .serializable());\n * </pre>\n */\n@SuppressWarnings(\"unchecked\")\npublic class Mockito extends Matchers {\n    \n    private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n    \n    /**\n     * The default Answer of every mock <b>if</b> the mock was not stubbed. \n     * Typically it just returns some empty value. \n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations. \n     * <p>\n     * This implementation first tries the global configuration. \n     * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\n     */\n    public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();\n    \n    /**\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\n     * <p>\n     * This implementation can be helpful when working with legacy code.\n     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n     * This implementation of Answer <b>returns SmartNull instead of null</b>.\n     * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\n     * <p>\n     * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\n     * then it tries to return SmartNull. If the return type is final then plain null is returned.\n     * <p>\n     * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0\n     * <p>\n     * Example:\n     * <pre>\n     *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\n     *   \n     *   //calling unstubbed method here:\n     *   Stuff stuff = mock.getStuff();\n     *   \n     *   //using object returned by unstubbed call:\n     *   stuff.doSomething();\n     *   \n     *   //Above doesn't yield NullPointerException this time!\n     *   //Instead, SmartNullPointerException is thrown. \n     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n     * </pre>\n     */\n    public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();\n    \n    /**\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\n     * <p>\n     * This implementation can be helpful when working with legacy code. \n     * <p>\n     * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\n     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\n     * <p>\n     */\n    public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();\n\n    /**\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\n     * <p>\n     * This implementation can be helpful when working with legacy code.\n     * When this implementation is used, unstubbed methods will delegate to the real implementation.\n     * This is a way to create a partial mock object that calls real methods by default.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * <pre>\n     * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);\n     *\n     * // this calls the real implementation of Foo.getSomething()\n     * value = mock.getSomething();\n     *\n     * when(mock.getSomething()).thenReturn(fakeValue);\n     *\n     * // now fakeValue is returned\n     * value = mock.getSomething();\n     * </pre>\n     */\n    public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();\n    \n    /**\n     * Creates mock object of given class or interface.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock) {\n        return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\n    }\n    \n    /**\n     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \n     * <p>\n     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n     * <p>\n     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n     * <p>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @param name of the mock \n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock, String name) {\n        return mock(classToMock, withSettings()\n                .name(name)\n                .defaultAnswer(RETURNS_DEFAULTS));\n    }\n    \n    /**\n     * @deprecated\n     * <b>Please use mock(Foo.class, defaultAnswer);</b>\n     * <p>\n     * See {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * Why it is deprecated? ReturnValues is being replaced by Answer\n     * for better consistency & interoperability of the framework. \n     * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.\n     * There's no point in mainting exactly the same interfaces.\n     * <p>\n     * Creates mock with a specified strategy for its return values. \n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * Obviously return values are used only when you don't stub the method call.\n     *\n     * <pre>\n     *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n     * </pre>\n     * \n     * <p>See examples in javadoc for {@link Mockito} class</p>\n     * \n     * @param classToMock class or interface to mock\n     * @param returnValues default return values for unstubbed methods\n     *\n     * @return mock object\n     */\n    @Deprecated\n    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n        return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));\n    }\n    \n    /**\n     * Creates mock with a specified strategy for its answers to interactions. \n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n     *\n     * <pre>\n     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n     * </pre>\n     * \n     * <p>See examples in javadoc for {@link Mockito} class</p>\n     * \n     * @param classToMock class or interface to mock\n     * @param defaultAnswer default answer for unstubbed methods\n     *\n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {\n        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));\n    }\n    \n    /**\n     * Creates a mock with some non-standard settings.\n     * <p>\n     * The number of configuration points for a mock grows \n     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \n     * Hence {@link MockSettings}.\n     * <pre>\n     *   Listener mock = mock(Listener.class, withSettings()\n     *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n     *   );  \n     * </pre>\n     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? \n     * Is the code under test so complicated that it requires non-standard mocks? \n     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n     * <p>\n     * See also {@link Mockito#withSettings()}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @param mockSettings additional mock settings\n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }\n    \n    /**\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     * \n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     * \n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     * \n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     * \n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     * \n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </pre>\n     * \n     * <h4>Important gotcha on spying real objects!</h4>\n     * \n     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Watch out for final methods. \n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     */\n    public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS)); \n    }\n\n    /**\n     * <pre>\n     *   //Instead of:\n     *   stub(mock.count()).toReturn(10);\n     * \n     *   //Please do:\n     *   when(mock.count()).thenReturn(10);\n     * </pre> \n     * \n     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n     * <p>\n     * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n     * <pre>\n     *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n     *   stub(          <i>replace with:</i>  when(\n     *   .toReturn(     <i>replace with:</i>  .thenReturn(\n     *   .toThrow(      <i>replace with:</i>  .thenThrow(\n     *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n     * </pre>\n     * If you're an existing user then sorry for making your code littered with deprecation warnings. \n     * This change was required to make Mockito better.\n     * \n     * @param methodCall\n     *            method call\n     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n     */\n    @Deprecated\n    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        return MOCKITO_CORE.stub(methodCall);\n    }\n    \n    /**\n     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n     * <p>\n     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n     * <p>\n     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n     * <p>\n     * Examples:\n     * \n     * <pre>\n     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n     *\n     * //you can use flexible argument matchers, e.g:\n     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n     *\n     * //setting exception to be thrown:\n     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n     *\n     * //you can set different behavior for consecutive method calls.\n     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException())\n     *  .thenReturn(\"foo\");\n     *  \n     * //Alternative, shorter version for consecutive stubbing:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\", \"two\");\n     * //is the same as:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\")\n     *  .thenReturn(\"two\");\n     *\n     * //shorter version for consecutive method calls throwing exceptions:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException(), new NullPointerException();\n     *   \n     * </pre>\n     * \n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * Stubbing can be overridden: for example common stubbing can go to fixture\n     * setup but the test methods can override it.\n     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * Once stubbed, the method will always return stubbed value regardless\n     * of how many times it is called.\n     * <p>\n     * Last stubbing is more important - when you stubbed the same method with\n     * the same arguments many times.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar(). \n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed. \n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * @param methodCall method to be stubbed\n     */\n    public static <T> OngoingStubbing<T> when(T methodCall) {\n        return MOCKITO_CORE.when(methodCall);\n    }\n\n    /**\n     * Verifies certain behavior <b>happened once</b> \n     * <p>\n     * Alias to <code>verify(mock, times(1))</code> E.g:\n     * <pre>\n     *   verify(mock).someMethod(\"some arg\");\n     * </pre>\n     * Above is equivalent to:\n     * <pre>\n     *   verify(mock, times(1)).someMethod(\"some arg\");\n     * </pre>\n     * <p>\n     * Arguments passed are compared using equals() method.\n     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar(). \n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed. \n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mock to be verified\n     * @return mock object itself\n     */\n    public static <T> T verify(T mock) {\n        return MOCKITO_CORE.verify(mock, times(1));\n    }\n\n    /**\n     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n     * <pre>\n     *   verify(mock, times(5)).someMethod(\"was called five times\");\n     *\n     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n     *\n     *   //you can use flexible argument matchers, e.g:\n     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n     * </pre>\n     *\n     * <b>times(1) is the default</b> and can be omitted\n     * <p>\n     * Arguments passed are compared using equals() method.\n     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n     * <p>\n     *\n     * @param mock to be verified\n     * @param mode times(x), atLeastOnce() or never()\n     *\n     * @return mock object itself\n     */\n    public static <T> T verify(T mock, VerificationMode mode) {\n        return MOCKITO_CORE.verify(mock, mode);\n    }\n\n    /**\n     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n     * Normally, you don't need to reset your mocks, just create new mocks for each test method.\n     * <p>\n     * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n     * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\n     * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\".\n     * There are several threads about it on mockito mailing list.\n     * <p>\n     * The only reason we added reset() method is to\n     * make it possible to work with container-injected mocks.\n     * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n     * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n     * <p>\n     * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much).\n     * <pre>\n     *   List mock = mock(List.class);\n     *   when(mock.size()).thenReturn(10);\n     *   mock.add(1);\n     *\n     *   reset(mock);\n     *   //at this point the mock forgot any interactions & stubbing\n     * </pre>\n     *\n     * @param <T>\n     * @param mocks to be reset\n     */\n    public static <T> void reset(T ... mocks) {\n        MOCKITO_CORE.reset(mocks);\n    }\n\n    /**\n     * Checks if any of given mocks has any unverified interaction.\n     * <p>\n     * You can use this method after you verified your mocks - to make sure that nothing\n     * else was invoked on your mocks.\n     * <p>\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n     * <p>\n     * Stubbed invocations (if called) are also treated as interactions.\n     * <p>\n     * A word of <b>warning</b>: \n     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n     * verifyNoMoreInteractions() is not recommended to use in every test method. \n     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n     * <p>\n     * This method will also detect unverified invocations that occurred before the test method,\n     * for example: in setUp(), &#064;Before method or in constructor.\n     * Consider writing nice code that makes interactions only in test methods.\n     * \n     * <p>\n     * Example:\n     * \n     * <pre>\n     * //interactions\n     * mock.doSomething();\n     * mock.doSomethingUnexpected();\n     * \n     * //verification\n     * verify(mock).doSomething();\n     * \n     * //following will fail because 'doSomethingUnexpected()' is unexpected\n     * verifyNoMoreInteractions(mock);\n     * \n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mocks to be verified\n     */\n    public static void verifyNoMoreInteractions(Object... mocks) {\n        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n    }\n\n    /**\n     * Verifies that no interactions happened on given mocks.\n     * <pre>\n     *   verifyZeroInteractions(mockOne, mockTwo);\n     * </pre>\n     * This method will also detect invocations \n     * that occurred before the test method, for example: in setUp(), &#064;Before method or in constructor.\n     * Consider writing nice code that makes interactions only in test methods.  \n     * <p>\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mocks to be verified\n     */\n    public static void verifyZeroInteractions(Object... mocks) {\n        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n    }\n\n    /**\n     * <pre>\n     *   //Instead of:\n     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n     * \n     *   //Please do:\n     *   doThrow(e).when(mock).someVoidMethod();\n     * </pre> \n     * \n     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n     * <p>\n     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n     * \n     * <pre>\n     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n     * \n     * //you can stub with different behavior for consecutive calls.\n     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n     * stubVoid(mock)\n     *   .toThrow(new RuntimeException())\n     *   .toReturn()\n     *   .on().someMethod();\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n     * \n     * @param mock\n     *            to stub\n     * @return stubbable object that allows stubbing with throwable\n     */\n    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        return MOCKITO_CORE.stubVoid(mock);\n    }\n    \n    /**\n     * Use doThrow() when you want to stub the void method with an exception.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n     * </pre>\n     * \n     * @param toBeThrown to be thrown when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doThrow(Throwable toBeThrown) {\n        return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));\n    }\n\n    /**\n     * Use doCallRealMethod() when you want to call the real implementation of a method.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n     * <p>\n     * Example:\n     * <pre>\n     *   Foo mock = mock(Foo.class);\n     *   doCallRealMethod().when(mock).someVoidMethod();\n     *\n     *   // this will call the real implementation of Foo.someVoidMethod()\n     *   mock.someVoidMethod();\n     * </pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doCallRealMethod() {\n        return MOCKITO_CORE.doAnswer(new CallsRealMethods());\n    }\n    \n    /**\n     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *  doAnswer(new Answer() {\n     *      public Object answer(InvocationOnMock invocation) {\n     *          Object[] args = invocation.getArguments();\n     *          Mock mock = invocation.getMock();\n     *          return null;\n     *      }})\n     *  .when(mock).someMethod();\n     * </pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param answer to answer when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doAnswer(Answer answer) {\n        return MOCKITO_CORE.doAnswer(answer);\n    }  \n    \n    /**\n     * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b> \n     * However, there are rare situations when doNothing() comes handy:  \n     * <p>\n     * 1. Stubbing consecutive calls on a void method:\n     * <pre>\n     *   doNothing().\n     *   doThrow(new RuntimeException())\n     *   .when(mock).someVoidMethod();\n     *   \n     *   //does nothing the first time:\n     *   mock.someVoidMethod();\n     *   \n     *   //throws RuntimeException the next time:\n     *   mock.someVoidMethod();\n     * </pre>\n     * \n     * 2. When you spy real objects and you want the void method to do nothing:\n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //let's make clear() do nothing\n     *   doNothing().when(spy).clear();\n     *   \n     *   spy.add(\"one\");\n     *   \n     *   //clear() does nothing, so the list still contains \"one\"\n     *   spy.clear();\n     * </pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *   \n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doNothing() {\n        return MOCKITO_CORE.doAnswer(new DoesNothing());\n    }    \n    \n    /**\n     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n     * <p>\n     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe \n     * and more readable</b> (especially when stubbing consecutive calls). \n     * <p>\n     * Here are those rare occasions when doReturn() comes handy:\n     * <p>\n     * \n     * 1. When spying real objects and calling real methods on a spy brings side effects  \n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing:\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Overriding a previous exception-stubbing:\n     * \n     * <pre>\n     *   when(mock.foo()).thenThrow(new RuntimeException());\n     *   \n     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown. \n     *   when(mock.foo()).thenReturn(\"bar\");\n     *   \n     *   //You have to use doReturn() for stubbing:\n     *   doReturn(\"bar\").when(mock).foo();\n     * </pre>\n     * \n     * Above scenarios shows a tradeoff of Mockito's ellegant syntax. Note that the scenarios are very rare, though. \n     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general\n     * overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param toBeReturned to be returned when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doReturn(Object toBeReturned) {\n        return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));\n    }\n \n    /**\n     * Creates InOrder object that allows verifying mocks in order.\n     * \n     * <pre>\n     *   InOrder inOrder = inOrder(firstMock, secondMock);\n     *   \n     *   inOrder.verify(firstMock).add(\"was called first\");\n     *   inOrder.verify(secondMock).add(\"was called second\");\n     * </pre>\n     * \n     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n     * but only those that you are interested in testing in order.\n     * <p>\n     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mocks to be verified in order\n     * \n     * @return InOrder object to be used to verify in order\n     */\n    public static InOrder inOrder(Object... mocks) {\n        return MOCKITO_CORE.inOrder(mocks);\n    }\n  \n    /**\n     * Allows verifying exact number of invocations. E.g:\n     * <pre>\n     *   verify(mock, times(2)).someMethod(\"some arg\");\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param wantedNumberOfInvocations wanted number of invocations \n     * \n     * @return verification mode\n     */\n    public static VerificationMode times(int wantedNumberOfInvocations) {\n        return VerificationModeFactory.times(wantedNumberOfInvocations);\n    }\n    \n    /**\n     * Alias to times(0), see {@link Mockito#times(int)}\n     * <p>\n     * Verifies that interaction did not happen. E.g:\n     * <pre>\n     *   verify(mock, never()).someMethod();\n     * </pre>\n     * \n     * <p>\n     * If you want to verify there were NO interactions with the mock \n     * check out {@link Mockito#verifyZeroInteractions(Object...)}\n     * or {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     */\n    public static VerificationMode never() {\n        return times(0);\n    }\n    \n    /**\n     * Allows at-least-once verification. E.g:\n     * <pre>\n     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n     * </pre>\n     * Alias to atLeast(1)\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     */\n    public static VerificationMode atLeastOnce() {\n        return VerificationModeFactory.atLeastOnce();\n    }\n\n    /**\n     * Allows at-least-x verification. E.g:\n     * <pre>\n     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param minNumberOfInvocations minimum number of invocations \n     * \n     * @return verification mode\n     */\n    public static VerificationMode atLeast(int minNumberOfInvocations) {\n        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n    }\n\n    /**\n     * Allows at-most-x verification. E.g:\n     * <pre>\n     *   verify(mock, atMost(3)).someMethod(\"some arg\");\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param maxNumberOfInvocations max number of invocations \n     * \n     * @return verification mode\n     */\n    public static VerificationMode atMost(int maxNumberOfInvocations) {\n        return VerificationModeFactory.atMost(maxNumberOfInvocations);\n    }\n\n    /**\n     * Allows checking if given method was the only one invoked. E.g:\n     * <pre>\n     *   verify(mock, only()).someMethod();\n     *   //above is a shorthand for following 2 lines of code:\n     *   verify(mock).someMethod();\n     *   verifyNoMoreInvocations(mock);\n     * </pre>\n     * \n     * <p>\n     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     */\n    public static VerificationMode only() {\n    \treturn VerificationModeFactory.only();\n    }\n    \n    /**\n     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n     * <p>\n     * In case of questions you may also post to mockito mailing list: <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a> \n     * <p>\n     * validateMockitoUsage() <b>explicitly validates</b> the framework state to detect invalid use of Mockito.\n     * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.\n     * <p>\n     * Examples of incorrect use:\n     * <pre>\n     * //Oups, someone forgot thenReturn() part:\n     * when(mock.get());\n     * \n     * //Oups, someone put the verified method call inside verify() where it should be outside:\n     * verify(mock.execute());\n     * \n     * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:\n     * verify(mock);\n     * </pre>\n     * \n     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly. \n     * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.). \n     * But even though the exception might be thrown in the next test, \n     * the exception <b>message contains a navigable stack trace element</b> with location of the defect. \n     * Hence you can click and find the place where Mockito was misused.\n     * <p>\n     * Sometimes though, you might want to validate the framework usage explicitly. \n     * For example, one of the users wanted to put validateMockitoUsage() in his &#064;After method\n     * so that he knows immediately when he misused Mockito. \n     * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.\n     * One more benefit of having validateMockitoUsage() in &#064;After is that jUnit runner will always fail in the test method with defect\n     * whereas ordinary 'next-time' validation might fail the <b>next</b> test method. \n     * But even though JUnit might report next test as red, don't worry about it \n     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.   \n     * <p>\n     * <b>Built-in runner: {@link MockitoJUnitRunner}</b> does validateMockitoUsage() after each test method.\n     * <p>\n     * Bear in mind that <b>usually you don't have to validateMockitoUsage()</b> \n     * and framework validation triggered on next-time basis should be just enough,\n     * mainly because of enhanced exception message with clickable location of defect.\n     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure\n     * (like your own runner or base class for all tests) because adding a special action to &#064;After has zero cost.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     */\n    public static void validateMockitoUsage() {\n        MOCKITO_CORE.validateMockitoUsage();\n    }\n\n    /**\n     * Allows mock creation with additional mock settings. \n     * <p>\n     * Don't use it too often. \n     * Consider writing simple tests that use simple mocks. \n     * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n     * If you cannot write a test in a simple way - refactor the code under test.\n     * <p>\n     * Examples of mock settings:\n     * <pre>\n     *   //Creates mock with different default answer & name\n     *   Foo mock = mock(Foo.class, withSettings()\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\n     *       .name(\"cool mockie\"));\n     *       \n     *   //Creates mock with different default answer, descriptive name and extra interfaces\n     *   Foo mock = mock(Foo.class, withSettings()\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\n     *       .name(\"cool mockie\")\n     *       .extraInterfaces(Bar.class));    \n     * </pre>\n     * {@link MockSettings} has been introduced for two reasons. \n     * Firstly, to make it easy to add another mock settings when the demand comes.\n     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.\n     * <p>\n     * See javadoc for {@link MockSettings} to learn about possible mock settings.\n     * <p>\n     * \n     * @return mock settings instance with defaults.\n     */\n    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }\n\n    /*\n     * Helps debugging failing tests.\n     * <p>\n     * TODO: add more info & examples.\n     */\n    public static MockitoDebugger debug() {\n        return new MockitoDebuggerImpl();\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito;\n\nimport org.mockito.internal.MockitoCore;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.debugging.MockitoDebuggerImpl;\nimport org.mockito.internal.stubbing.answers.*;\nimport org.mockito.internal.stubbing.defaultanswers.*;\nimport org.mockito.internal.verification.VerificationModeFactory;\nimport org.mockito.internal.verification.api.VerificationMode;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.mockito.stubbing.*;\n\n/**\n * <p align=\"left\"><img src=\"logo.jpg\"/></p>\n * Mockito library enables mocks creation, verification and stubbing.\n * <p>\n * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page. \n * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.\n * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \n * \n * <h1>Contents</h1>\n * \n * <b> \n *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \n *      <a href=\"#2\">2. How about some stubbing? </a><br/>\n *      <a href=\"#3\">3. Argument matchers </a><br/>\n *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \n *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \n *      <a href=\"#6\">6. Verification in order </a><br/> \n *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \n *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \n *      <a href=\"#9\">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> \n *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n *      <a href=\"#12\">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>\n *      <a href=\"#13\">13. Spying on real objects </a><br/>\n *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\n *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\n *      <a href=\"#16\">16. Real partial mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#17\">17. Resetting mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>\n *      <a href=\"#19\">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>\n *      <a href=\"#20\">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>\n * </b>\n * \n * <p>\n * Following examples mock a List, because everyone knows its interface (methods\n * like add(), get(), clear() will be used). <br>\n * You probably wouldn't mock List class 'in real'.\n * \n * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n * \n * <pre>\n * //Let's import Mockito statically so that the code looks clearer\n * import static org.mockito.Mockito.*;\n * \n * //mock creation\n * List mockedList = mock(List.class);\n *\n * //using mock object\n * mockedList.add(\"one\");\n * mockedList.clear();\n *\n * //verification\n * verify(mockedList).add(\"one\");\n * verify(mockedList).clear();\n * </pre>\n * \n * <p>\n * Once created, mock will remember all interactions. Then you can selectively\n * verify whatever interaction you are interested in.\n * \n * <h3 id=\"2\">2. How about some stubbing?</h3>\n * \n * <pre>\n * //You can mock concrete classes, not only interfaces\n * LinkedList mockedList = mock(LinkedList.class);\n * \n * //stubbing\n * when(mockedList.get(0)).thenReturn(\"first\");\n * when(mockedList.get(1)).thenThrow(new RuntimeException());\n * \n * //following prints \"first\"\n * System.out.println(mockedList.get(0));\n * \n * //following throws runtime exception\n * System.out.println(mockedList.get(1));\n * \n * //following prints \"null\" because get(999) was not stubbed\n * System.out.println(mockedList.get(999));\n *  \n * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n * verify(mockedList).get(0);\n * </pre>\n * \n * <ul>\n * <li> By default, for all methods that return value, mock returns null, an\n * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n * false, ... for int/Integer, boolean/Boolean, ...). </li>\n * \n * <li> Stubbing can be overridden: for example common stubbing can go to\n * fixture setup but the test methods can override it.\n * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>\n * \n * <li> Once stubbed, the method will always return stubbed value regardless\n * of how many times it is called. </li>\n * \n * <li> Last stubbing is more important - when you stubbed the same method with\n * the same arguments many times. </li>\n * \n * </ul>\n * \n * <h3 id=\"3\">3. Argument matchers</h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * Sometimes, when extra flexibility is required then you might use argument matchers:  \n * \n * <pre>\n * //stubbing using built-in anyInt() argument matcher\n * when(mockedList.get(anyInt())).thenReturn(\"element\");\n * \n * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n * \n * //following prints \"element\"\n * System.out.println(mockedList.get(999));\n * \n * //<b>you can also verify using an argument matcher</b>\n * verify(mockedList).get(anyInt());\n * </pre>\n * \n * <p>\n * Argument matchers allow flexible verification or stubbing. \n * {@link Matchers Click here to see} more built-in matchers \n * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n * <p>\n * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\n * <p>\n * Be reasonable with using complicated argument matching.\n * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.\n * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\n * <p>\n * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\n * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \n * <p>\n * <b>Warning on argument matchers:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided\n * by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * \n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n * </pre>\n * \n * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n * \n * <pre>\n * //using mock \n * mockedList.add(\"once\");\n * \n * mockedList.add(\"twice\");\n * mockedList.add(\"twice\");\n * \n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * \n * //following two verifications work exactly the same - times(1) is used by default\n * verify(mockedList).add(\"once\");\n * verify(mockedList, times(1)).add(\"once\");\n * \n * //exact number of invocations verification\n * verify(mockedList, times(2)).add(\"twice\");\n * verify(mockedList, times(3)).add(\"three times\");\n * \n * //verification using never(). never() is an alias to times(0)\n * verify(mockedList, never()).add(\"never happened\");\n * \n * //verification using atLeast()/atMost()\n * verify(mockedList, atLeastOnce()).add(\"three times\");\n * verify(mockedList, atLeast(2)).add(\"five times\");\n * verify(mockedList, atMost(5)).add(\"three times\");\n * \n * </pre>\n * \n * <p>\n * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n * omitted.\n * \n * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n * \n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about doThrow|doAnswer family of methods in paragraph 12.\n * <p>\n * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n * \n * <h3 id=\"6\">6. Verification in order</h3>\n * \n * <pre>\n * List firstMock = mock(List.class);\n * List secondMock = mock(List.class);\n * \n * //using mocks\n * firstMock.add(\"was called first\");\n * secondMock.add(\"was called second\");\n * \n * //create inOrder object passing any mocks that need to be verified in order\n * InOrder inOrder = inOrder(firstMock, secondMock);\n * \n * //following will make sure that firstMock was called before secondMock\n * inOrder.verify(firstMock).add(\"was called first\");\n * inOrder.verify(secondMock).add(\"was called second\");\n * </pre>\n * \n * Verification in order is flexible - <b>you don't have to verify all\n * interactions</b> one-by-one but only those that you are interested in\n * testing in order.\n * <p>\n * Also, you can create InOrder object passing only mocks that are relevant for\n * in-order verification.\n * \n * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n * \n * <pre>\n * //using mocks - only mockOne is interacted\n * mockOne.add(\"one\");\n * \n * //ordinary verification\n * verify(mockOne).add(\"one\");\n * \n * //verify that method was never called on a mock\n * verify(mockOne, never()).add(\"two\");\n * \n * //verify that other mocks were not interacted\n * verifyZeroInteractions(mockTwo, mockThree);\n * \n * </pre>\n * \n * <h3 id=\"8\">8. Finding redundant invocations</h3>\n * \n * <pre>\n * //using mocks\n * mockedList.add(\"one\");\n * mockedList.add(\"two\");\n * \n * verify(mockedList).add(\"one\");\n * \n * //following verification will fail \n * verifyNoMoreInteractions(mockedList);\n * </pre>\n * \n * A word of <b>warning</b>: \n * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n * verifyNoMoreInteractions() is not recommended to use in every test method. \n * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n * \n * <p>   \n * See also {@link Mockito#never()} - it is more explicit and\n * communicates the intent well.\n * <p>\n * \n * <h3 id=\"9\">9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n * \n * <ul>\n * <li>Minimizes repetitive mock creation code.</li>\n * <li>Makes the test class more readable.</li>\n * <li>Makes the verification error easier to read because the <b>field name</b>\n * is used to identify the mock.</li>\n * </ul>\n * \n * <pre>\n *   public class ArticleManagerTest { \n *     \n *       &#064;Mock private ArticleCalculator calculator;\n *       &#064;Mock private ArticleDatabase database;\n *       &#064;Mock private UserProvider userProvider;\n *     \n *       private ArticleManager manager;\n * </pre>\n * \n * <b>Important!</b> This needs to be somewhere in the base class or a test\n * runner:\n * \n * <pre>\n * MockitoAnnotations.initMocks(testClass);\n * </pre>\n * \n * You can use built-in runner: {@link MockitoJUnitRunner}.\n * <p>\n * Read more here: {@link MockitoAnnotations}\n * \n * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n * \n * Sometimes we need to stub with different return value/exception for the same\n * method call. Typical use case could be mocking iterators. \n * Original version of Mockito did not have this feature to promote simple mocking. \n * For example, instead of iterators one could use {@link Iterable} or simply\n * collections. Those offer natural ways of stubbing (e.g. using real\n * collections). In rare scenarios stubbing consecutive calls could be useful,\n * though:\n * <p>\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenThrow(new RuntimeException())\n *   .thenReturn(\"foo\");\n * \n * //First call: throws runtime exception:\n * mock.someMethod(\"some arg\");\n * \n * //Second call: prints \"foo\"\n * System.out.println(mock.someMethod(\"some arg\"));\n * \n * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n * System.out.println(mock.someMethod(\"some arg\"));\n * </pre>\n * \n * Alternative, shorter version of consecutive stubbing:\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenReturn(\"one\", \"two\", \"three\");\n * </pre>\n * \n * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n * \n * Allows stubbing with generic {@link Answer} interface.\n*  <p>\n * Yet another controversial feature which was not included in Mockito\n * originally. We recommend using simple stubbing with thenReturn() or\n * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive\n * any clean & simple code.\n * \n * <pre>\n * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n *     Object answer(InvocationOnMock invocation) {\n *         Object[] args = invocation.getArguments();\n *         Object mock = invocation.getMock();\n *         return \"called with arguments: \" + args;\n *     }\n * });\n * \n * //Following prints \"called with arguments: foo\"\n * System.out.println(mock.someMethod(\"foo\"));\n * </pre>\n * \n * <h3 id=\"12\"> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n * \n * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n * <p>\n * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n * The main reason is improved readability and consistency with the family of doAnswer() methods.\n * <p>\n * Use doThrow() when you want to stub a void method with an exception:\n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about other methods:\n * <p>\n * {@link Mockito#doThrow(Throwable)}\n * <p>\n * {@link Mockito#doAnswer(Answer)}\n * <p>\n * {@link Mockito#doNothing()}\n * <p>\n * {@link Mockito#doReturn(Object)}\n * \n * <h3 id=\"13\"> 13. Spying on real objects</h3>\n * \n * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n * <p>\n * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n * \n * <p>\n * Spying on real objects can be associated with \"partial mocking\" concept. \n * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \n * The reason was we thought partial mock is a code smell. \n * At some point we found legitimate use cases for partial mocks \n * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\n * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\n * >here</a>)\n * <p>\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n * \n *   //optionally, you can stub out some methods:\n *   when(spy.size()).thenReturn(100);\n * \n *   //using the spy calls <b>real</b> methods\n *   spy.add(\"one\");\n *   spy.add(\"two\");\n * \n *   //prints \"one\" - the first element of a list\n *   System.out.println(spy.get(0));\n * \n *   //size() method was stubbed - 100 is printed\n *   System.out.println(spy.size());\n * \n *   //optionally, you can verify\n *   verify(spy).add(\"one\");\n *   verify(spy).add(\"two\");\n * </pre>\n * \n * <h4>Important gotcha on spying real objects!</h4>\n * \n * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n * \n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *   \n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n *   when(spy.get(0)).thenReturn(\"foo\");\n *   \n *   //You have to use doReturn() for stubbing\n *   doReturn(\"foo\").when(spy).get(0);\n * </pre>\n * \n * 2. Watch out for final methods. \n * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n * \n * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n * \n * You can create a mock with specified strategy for its return values.\n * It's quite advanced feature and typically you don't need it to write decent tests.\n * However, it can be helpful for working with <b>legacy systems</b>.\n * <p>\n * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n * \n * <pre>\n *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n * </pre>\n * \n * <p>\n * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n * \n * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * This is also the recommended way of matching arguments because it makes tests clean & simple.\n * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n * For example:\n * <pre>\n *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n *   verify(mock).doSomething(argument.capture());\n *   assertEquals(\"John\", argument.getValue().getName());\n * </pre>\n * \n * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n * <p>\n * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n * Both techniques can be used for making sure certain arguments where passed to mocks. \n * However, ArgumentCaptor may be a better fit if:\n * <ul>  \n * <li>custom argument matcher is not likely to be reused</li>\n * <li>you just need it to assert on argument values to complete verification</li>\n * </ul>\n * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n * \n * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\n *  \n *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\n *  <p>\n *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.\n *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n *  <p>\n *  <pre>\n *    //you can create partial mock with spy() method:    \n *    List list = spy(new LinkedList());\n *    \n *    //you can enable partial mock capabilities selectively on mocks:\n *    Foo mock = mock(Foo.class);\n *    //Be sure the real implementation is 'safe'.\n *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n *    when(mock.someMethod()).thenCallRealMethod();\n *  </pre>\n *  \n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n *  \n * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\n *  \n * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n * <p>\n * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\n * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \n * There are several threads about it on mockito mailing list.\n * <p>\n * The only reason we added reset() method is to\n * make it possible to work with container-injected mocks.\n * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n * <p>\n * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). \n * <pre>\n *   List mock = mock(List.class);\n *   when(mock.size()).thenReturn(10);\n *   mock.add(1);\n *   \n *   reset(mock);\n *   //at this point the mock forgot any interactions & stubbing\n * </pre>\n *  \n * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n * \n * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n * <p>\n * In case of questions you may also post to mockito mailing list: \n * <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n * <p>\n * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n * \n * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\n * \n * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n * This is exactly how we write our tests and we warmly encourage you to do so!\n * <p>\n * Start learning about BDD here: <a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>\n * <p>\n * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.\n * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. \n * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. \n * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \n * <p>\n * Here is how the test might look like: \n * <pre>\n * import static org.mockito.BDDMockito.*;\n * \n * Seller seller = mock(Seller.class);\n * Shop shop = new Shop(seller);\n * \n * public void shouldBuyBread() throws Exception {\n *   //given  \n *   given(seller.askForBread()).willReturn(new Bread());\n *   \n *   //when\n *   Goods goods = shop.buyBread();\n *   \n *   //then\n *   assertThat(goods, containBread());\n * }  \n * </pre>\n * \n * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n * \n * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n * <p>\n * WARNING: This should be rarely used in unit testing. \n * <p>\n * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \n * <p>\n * To create serializable mock use {@link MockSettings#serializable()}:\n * <pre>\n *   List serializableMock = mock(List.class, withSettings().serializable());\n * </pre>\n * <p>\n * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\n * serialization requirements</a> are met by the class.\n * <p>\n * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \n * which accepts MockSettings. No worries, you will hardly ever use it.\n * \n * <pre>\n * List<Object> list = new ArrayList<Object>();\n * List<Object> spy = mock(ArrayList.class, withSettings()\n *                 .spiedInstance(list)\n *                 .defaultAnswer(CALLS_REAL_METHODS)\n *                 .serializable());\n * </pre>\n */\n@SuppressWarnings(\"unchecked\")\npublic class Mockito extends Matchers {\n    \n    private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n    \n    /**\n     * The default Answer of every mock <b>if</b> the mock was not stubbed. \n     * Typically it just returns some empty value. \n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations. \n     * <p>\n     * This implementation first tries the global configuration. \n     * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\n     */\n    public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();\n    \n    /**\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\n     * <p>\n     * This implementation can be helpful when working with legacy code.\n     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n     * This implementation of Answer <b>returns SmartNull instead of null</b>.\n     * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\n     * <p>\n     * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\n     * then it tries to return SmartNull. If the return type is final then plain null is returned.\n     * <p>\n     * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0\n     * <p>\n     * Example:\n     * <pre>\n     *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\n     *   \n     *   //calling unstubbed method here:\n     *   Stuff stuff = mock.getStuff();\n     *   \n     *   //using object returned by unstubbed call:\n     *   stuff.doSomething();\n     *   \n     *   //Above doesn't yield NullPointerException this time!\n     *   //Instead, SmartNullPointerException is thrown. \n     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n     * </pre>\n     */\n    public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();\n    \n    /**\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\n     * <p>\n     * This implementation can be helpful when working with legacy code. \n     * <p>\n     * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\n     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\n     * <p>\n     */\n    public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();\n\n    /**\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\n     * <p>\n     * This implementation can be helpful when working with legacy code.\n     * When this implementation is used, unstubbed methods will delegate to the real implementation.\n     * This is a way to create a partial mock object that calls real methods by default.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * <pre>\n     * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);\n     *\n     * // this calls the real implementation of Foo.getSomething()\n     * value = mock.getSomething();\n     *\n     * when(mock.getSomething()).thenReturn(fakeValue);\n     *\n     * // now fakeValue is returned\n     * value = mock.getSomething();\n     * </pre>\n     */\n    public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();\n    \n    /**\n     * Creates mock object of given class or interface.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock) {\n        return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\n    }\n    \n    /**\n     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \n     * <p>\n     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n     * <p>\n     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n     * <p>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @param name of the mock \n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock, String name) {\n        return mock(classToMock, withSettings()\n                .name(name)\n                .defaultAnswer(RETURNS_DEFAULTS));\n    }\n    \n    /**\n     * @deprecated\n     * <b>Please use mock(Foo.class, defaultAnswer);</b>\n     * <p>\n     * See {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * Why it is deprecated? ReturnValues is being replaced by Answer\n     * for better consistency & interoperability of the framework. \n     * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.\n     * There's no point in mainting exactly the same interfaces.\n     * <p>\n     * Creates mock with a specified strategy for its return values. \n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * Obviously return values are used only when you don't stub the method call.\n     *\n     * <pre>\n     *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n     * </pre>\n     * \n     * <p>See examples in javadoc for {@link Mockito} class</p>\n     * \n     * @param classToMock class or interface to mock\n     * @param returnValues default return values for unstubbed methods\n     *\n     * @return mock object\n     */\n    @Deprecated\n    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n        return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));\n    }\n    \n    /**\n     * Creates mock with a specified strategy for its answers to interactions. \n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n     *\n     * <pre>\n     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n     * </pre>\n     * \n     * <p>See examples in javadoc for {@link Mockito} class</p>\n     * \n     * @param classToMock class or interface to mock\n     * @param defaultAnswer default answer for unstubbed methods\n     *\n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {\n        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));\n    }\n    \n    /**\n     * Creates a mock with some non-standard settings.\n     * <p>\n     * The number of configuration points for a mock grows \n     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \n     * Hence {@link MockSettings}.\n     * <pre>\n     *   Listener mock = mock(Listener.class, withSettings()\n     *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n     *   );  \n     * </pre>\n     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? \n     * Is the code under test so complicated that it requires non-standard mocks? \n     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n     * <p>\n     * See also {@link Mockito#withSettings()}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param classToMock class or interface to mock\n     * @param mockSettings additional mock settings\n     * @return mock object\n     */\n    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings, true);\n    }\n    \n    /**\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     * \n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     * \n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     * \n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     * \n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     * \n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </pre>\n     * \n     * <h4>Important gotcha on spying real objects!</h4>\n     * \n     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Watch out for final methods. \n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     */\n    public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS), true); \n    }\n\n    /**\n     * <pre>\n     *   //Instead of:\n     *   stub(mock.count()).toReturn(10);\n     * \n     *   //Please do:\n     *   when(mock.count()).thenReturn(10);\n     * </pre> \n     * \n     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n     * <p>\n     * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n     * <pre>\n     *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n     *   stub(          <i>replace with:</i>  when(\n     *   .toReturn(     <i>replace with:</i>  .thenReturn(\n     *   .toThrow(      <i>replace with:</i>  .thenThrow(\n     *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n     * </pre>\n     * If you're an existing user then sorry for making your code littered with deprecation warnings. \n     * This change was required to make Mockito better.\n     * \n     * @param methodCall\n     *            method call\n     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n     */\n    @Deprecated\n    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        return MOCKITO_CORE.stub(methodCall);\n    }\n    \n    /**\n     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n     * <p>\n     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n     * <p>\n     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n     * <p>\n     * Examples:\n     * \n     * <pre>\n     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n     *\n     * //you can use flexible argument matchers, e.g:\n     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n     *\n     * //setting exception to be thrown:\n     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n     *\n     * //you can set different behavior for consecutive method calls.\n     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException())\n     *  .thenReturn(\"foo\");\n     *  \n     * //Alternative, shorter version for consecutive stubbing:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\", \"two\");\n     * //is the same as:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\")\n     *  .thenReturn(\"two\");\n     *\n     * //shorter version for consecutive method calls throwing exceptions:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException(), new NullPointerException();\n     *   \n     * </pre>\n     * \n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * Stubbing can be overridden: for example common stubbing can go to fixture\n     * setup but the test methods can override it.\n     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * Once stubbed, the method will always return stubbed value regardless\n     * of how many times it is called.\n     * <p>\n     * Last stubbing is more important - when you stubbed the same method with\n     * the same arguments many times.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar(). \n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed. \n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * @param methodCall method to be stubbed\n     */\n    public static <T> OngoingStubbing<T> when(T methodCall) {\n        return MOCKITO_CORE.when(methodCall);\n    }\n\n    /**\n     * Verifies certain behavior <b>happened once</b> \n     * <p>\n     * Alias to <code>verify(mock, times(1))</code> E.g:\n     * <pre>\n     *   verify(mock).someMethod(\"some arg\");\n     * </pre>\n     * Above is equivalent to:\n     * <pre>\n     *   verify(mock, times(1)).someMethod(\"some arg\");\n     * </pre>\n     * <p>\n     * Arguments passed are compared using equals() method.\n     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar(). \n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed. \n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mock to be verified\n     * @return mock object itself\n     */\n    public static <T> T verify(T mock) {\n        return MOCKITO_CORE.verify(mock, times(1));\n    }\n\n    /**\n     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n     * <pre>\n     *   verify(mock, times(5)).someMethod(\"was called five times\");\n     *\n     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n     *\n     *   //you can use flexible argument matchers, e.g:\n     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n     * </pre>\n     *\n     * <b>times(1) is the default</b> and can be omitted\n     * <p>\n     * Arguments passed are compared using equals() method.\n     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n     * <p>\n     *\n     * @param mock to be verified\n     * @param mode times(x), atLeastOnce() or never()\n     *\n     * @return mock object itself\n     */\n    public static <T> T verify(T mock, VerificationMode mode) {\n        return MOCKITO_CORE.verify(mock, mode);\n    }\n\n    /**\n     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n     * Normally, you don't need to reset your mocks, just create new mocks for each test method.\n     * <p>\n     * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n     * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\n     * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\".\n     * There are several threads about it on mockito mailing list.\n     * <p>\n     * The only reason we added reset() method is to\n     * make it possible to work with container-injected mocks.\n     * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n     * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n     * <p>\n     * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much).\n     * <pre>\n     *   List mock = mock(List.class);\n     *   when(mock.size()).thenReturn(10);\n     *   mock.add(1);\n     *\n     *   reset(mock);\n     *   //at this point the mock forgot any interactions & stubbing\n     * </pre>\n     *\n     * @param <T>\n     * @param mocks to be reset\n     */\n    public static <T> void reset(T ... mocks) {\n        MOCKITO_CORE.reset(mocks);\n    }\n\n    /**\n     * Checks if any of given mocks has any unverified interaction.\n     * <p>\n     * You can use this method after you verified your mocks - to make sure that nothing\n     * else was invoked on your mocks.\n     * <p>\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n     * <p>\n     * Stubbed invocations (if called) are also treated as interactions.\n     * <p>\n     * A word of <b>warning</b>: \n     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n     * verifyNoMoreInteractions() is not recommended to use in every test method. \n     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n     * <p>\n     * This method will also detect unverified invocations that occurred before the test method,\n     * for example: in setUp(), &#064;Before method or in constructor.\n     * Consider writing nice code that makes interactions only in test methods.\n     * \n     * <p>\n     * Example:\n     * \n     * <pre>\n     * //interactions\n     * mock.doSomething();\n     * mock.doSomethingUnexpected();\n     * \n     * //verification\n     * verify(mock).doSomething();\n     * \n     * //following will fail because 'doSomethingUnexpected()' is unexpected\n     * verifyNoMoreInteractions(mock);\n     * \n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mocks to be verified\n     */\n    public static void verifyNoMoreInteractions(Object... mocks) {\n        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n    }\n\n    /**\n     * Verifies that no interactions happened on given mocks.\n     * <pre>\n     *   verifyZeroInteractions(mockOne, mockTwo);\n     * </pre>\n     * This method will also detect invocations \n     * that occurred before the test method, for example: in setUp(), &#064;Before method or in constructor.\n     * Consider writing nice code that makes interactions only in test methods.  \n     * <p>\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mocks to be verified\n     */\n    public static void verifyZeroInteractions(Object... mocks) {\n        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n    }\n\n    /**\n     * <pre>\n     *   //Instead of:\n     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n     * \n     *   //Please do:\n     *   doThrow(e).when(mock).someVoidMethod();\n     * </pre> \n     * \n     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n     * <p>\n     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n     * \n     * <pre>\n     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n     * \n     * //you can stub with different behavior for consecutive calls.\n     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n     * stubVoid(mock)\n     *   .toThrow(new RuntimeException())\n     *   .toReturn()\n     *   .on().someMethod();\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n     * \n     * @param mock\n     *            to stub\n     * @return stubbable object that allows stubbing with throwable\n     */\n    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        return MOCKITO_CORE.stubVoid(mock);\n    }\n    \n    /**\n     * Use doThrow() when you want to stub the void method with an exception.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n     * </pre>\n     * \n     * @param toBeThrown to be thrown when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doThrow(Throwable toBeThrown) {\n        return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));\n    }\n\n    /**\n     * Use doCallRealMethod() when you want to call the real implementation of a method.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n     * <p>\n     * Example:\n     * <pre>\n     *   Foo mock = mock(Foo.class);\n     *   doCallRealMethod().when(mock).someVoidMethod();\n     *\n     *   // this will call the real implementation of Foo.someVoidMethod()\n     *   mock.someVoidMethod();\n     * </pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doCallRealMethod() {\n        return MOCKITO_CORE.doAnswer(new CallsRealMethods());\n    }\n    \n    /**\n     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *  doAnswer(new Answer() {\n     *      public Object answer(InvocationOnMock invocation) {\n     *          Object[] args = invocation.getArguments();\n     *          Mock mock = invocation.getMock();\n     *          return null;\n     *      }})\n     *  .when(mock).someMethod();\n     * </pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param answer to answer when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doAnswer(Answer answer) {\n        return MOCKITO_CORE.doAnswer(answer);\n    }  \n    \n    /**\n     * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b> \n     * However, there are rare situations when doNothing() comes handy:  \n     * <p>\n     * 1. Stubbing consecutive calls on a void method:\n     * <pre>\n     *   doNothing().\n     *   doThrow(new RuntimeException())\n     *   .when(mock).someVoidMethod();\n     *   \n     *   //does nothing the first time:\n     *   mock.someVoidMethod();\n     *   \n     *   //throws RuntimeException the next time:\n     *   mock.someVoidMethod();\n     * </pre>\n     * \n     * 2. When you spy real objects and you want the void method to do nothing:\n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //let's make clear() do nothing\n     *   doNothing().when(spy).clear();\n     *   \n     *   spy.add(\"one\");\n     *   \n     *   //clear() does nothing, so the list still contains \"one\"\n     *   spy.clear();\n     * </pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *   \n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doNothing() {\n        return MOCKITO_CORE.doAnswer(new DoesNothing());\n    }    \n    \n    /**\n     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n     * <p>\n     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe \n     * and more readable</b> (especially when stubbing consecutive calls). \n     * <p>\n     * Here are those rare occasions when doReturn() comes handy:\n     * <p>\n     * \n     * 1. When spying real objects and calling real methods on a spy brings side effects  \n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing:\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Overriding a previous exception-stubbing:\n     * \n     * <pre>\n     *   when(mock.foo()).thenThrow(new RuntimeException());\n     *   \n     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown. \n     *   when(mock.foo()).thenReturn(\"bar\");\n     *   \n     *   //You have to use doReturn() for stubbing:\n     *   doReturn(\"bar\").when(mock).foo();\n     * </pre>\n     * \n     * Above scenarios shows a tradeoff of Mockito's ellegant syntax. Note that the scenarios are very rare, though. \n     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general\n     * overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param toBeReturned to be returned when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     */\n    public static Stubber doReturn(Object toBeReturned) {\n        return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));\n    }\n \n    /**\n     * Creates InOrder object that allows verifying mocks in order.\n     * \n     * <pre>\n     *   InOrder inOrder = inOrder(firstMock, secondMock);\n     *   \n     *   inOrder.verify(firstMock).add(\"was called first\");\n     *   inOrder.verify(secondMock).add(\"was called second\");\n     * </pre>\n     * \n     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n     * but only those that you are interested in testing in order.\n     * <p>\n     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mocks to be verified in order\n     * \n     * @return InOrder object to be used to verify in order\n     */\n    public static InOrder inOrder(Object... mocks) {\n        return MOCKITO_CORE.inOrder(mocks);\n    }\n  \n    /**\n     * Allows verifying exact number of invocations. E.g:\n     * <pre>\n     *   verify(mock, times(2)).someMethod(\"some arg\");\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param wantedNumberOfInvocations wanted number of invocations \n     * \n     * @return verification mode\n     */\n    public static VerificationMode times(int wantedNumberOfInvocations) {\n        return VerificationModeFactory.times(wantedNumberOfInvocations);\n    }\n    \n    /**\n     * Alias to times(0), see {@link Mockito#times(int)}\n     * <p>\n     * Verifies that interaction did not happen. E.g:\n     * <pre>\n     *   verify(mock, never()).someMethod();\n     * </pre>\n     * \n     * <p>\n     * If you want to verify there were NO interactions with the mock \n     * check out {@link Mockito#verifyZeroInteractions(Object...)}\n     * or {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     */\n    public static VerificationMode never() {\n        return times(0);\n    }\n    \n    /**\n     * Allows at-least-once verification. E.g:\n     * <pre>\n     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n     * </pre>\n     * Alias to atLeast(1)\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     */\n    public static VerificationMode atLeastOnce() {\n        return VerificationModeFactory.atLeastOnce();\n    }\n\n    /**\n     * Allows at-least-x verification. E.g:\n     * <pre>\n     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param minNumberOfInvocations minimum number of invocations \n     * \n     * @return verification mode\n     */\n    public static VerificationMode atLeast(int minNumberOfInvocations) {\n        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n    }\n\n    /**\n     * Allows at-most-x verification. E.g:\n     * <pre>\n     *   verify(mock, atMost(3)).someMethod(\"some arg\");\n     * </pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param maxNumberOfInvocations max number of invocations \n     * \n     * @return verification mode\n     */\n    public static VerificationMode atMost(int maxNumberOfInvocations) {\n        return VerificationModeFactory.atMost(maxNumberOfInvocations);\n    }\n\n    /**\n     * Allows checking if given method was the only one invoked. E.g:\n     * <pre>\n     *   verify(mock, only()).someMethod();\n     *   //above is a shorthand for following 2 lines of code:\n     *   verify(mock).someMethod();\n     *   verifyNoMoreInvocations(mock);\n     * </pre>\n     * \n     * <p>\n     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     */\n    public static VerificationMode only() {\n    \treturn VerificationModeFactory.only();\n    }\n    \n    /**\n     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n     * <p>\n     * In case of questions you may also post to mockito mailing list: <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a> \n     * <p>\n     * validateMockitoUsage() <b>explicitly validates</b> the framework state to detect invalid use of Mockito.\n     * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.\n     * <p>\n     * Examples of incorrect use:\n     * <pre>\n     * //Oups, someone forgot thenReturn() part:\n     * when(mock.get());\n     * \n     * //Oups, someone put the verified method call inside verify() where it should be outside:\n     * verify(mock.execute());\n     * \n     * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:\n     * verify(mock);\n     * </pre>\n     * \n     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly. \n     * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.). \n     * But even though the exception might be thrown in the next test, \n     * the exception <b>message contains a navigable stack trace element</b> with location of the defect. \n     * Hence you can click and find the place where Mockito was misused.\n     * <p>\n     * Sometimes though, you might want to validate the framework usage explicitly. \n     * For example, one of the users wanted to put validateMockitoUsage() in his &#064;After method\n     * so that he knows immediately when he misused Mockito. \n     * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.\n     * One more benefit of having validateMockitoUsage() in &#064;After is that jUnit runner will always fail in the test method with defect\n     * whereas ordinary 'next-time' validation might fail the <b>next</b> test method. \n     * But even though JUnit might report next test as red, don't worry about it \n     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.   \n     * <p>\n     * <b>Built-in runner: {@link MockitoJUnitRunner}</b> does validateMockitoUsage() after each test method.\n     * <p>\n     * Bear in mind that <b>usually you don't have to validateMockitoUsage()</b> \n     * and framework validation triggered on next-time basis should be just enough,\n     * mainly because of enhanced exception message with clickable location of defect.\n     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure\n     * (like your own runner or base class for all tests) because adding a special action to &#064;After has zero cost.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     */\n    public static void validateMockitoUsage() {\n        MOCKITO_CORE.validateMockitoUsage();\n    }\n\n    /**\n     * Allows mock creation with additional mock settings. \n     * <p>\n     * Don't use it too often. \n     * Consider writing simple tests that use simple mocks. \n     * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n     * If you cannot write a test in a simple way - refactor the code under test.\n     * <p>\n     * Examples of mock settings:\n     * <pre>\n     *   //Creates mock with different default answer & name\n     *   Foo mock = mock(Foo.class, withSettings()\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\n     *       .name(\"cool mockie\"));\n     *       \n     *   //Creates mock with different default answer, descriptive name and extra interfaces\n     *   Foo mock = mock(Foo.class, withSettings()\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\n     *       .name(\"cool mockie\")\n     *       .extraInterfaces(Bar.class));    \n     * </pre>\n     * {@link MockSettings} has been introduced for two reasons. \n     * Firstly, to make it easy to add another mock settings when the demand comes.\n     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.\n     * <p>\n     * See javadoc for {@link MockSettings} to learn about possible mock settings.\n     * <p>\n     * \n     * @return mock settings instance with defaults.\n     */\n    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }\n\n    /*\n     * Helps debugging failing tests.\n     * <p>\n     * TODO: add more info & examples.\n     */\n    public static MockitoDebugger debug() {\n        return new MockitoDebuggerImpl();\n    }\n}"}]}
{"project": "Mockito", "bug_id": 17, "classes_modified": [{"class_name": "org.mockito.internal.creation.MockSettingsImpl", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.creation;\n\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.MockName;\nimport org.mockito.stubbing.Answer;\n\npublic class MockSettingsImpl implements MockSettings {\n\n    private static final long serialVersionUID = 4475297236197939568L;\n    private Class<?>[] extraInterfaces;\n    private String name;\n    private Object spiedInstance;\n    private Answer<Object> defaultAnswer;\n    private MockName mockName;\n\n    public MockSettings serializable() {\n        return this.extraInterfaces(java.io.Serializable.class);\n    }\n\n    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n        if (extraInterfaces == null || extraInterfaces.length == 0) {\n            new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n        }\n            \n        for (Class<?> i : extraInterfaces) {\n            if (i == null) {\n                new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n            } else if (!i.isInterface()) {\n                new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n            }\n        }\n        this.extraInterfaces = extraInterfaces;\n        return this;\n    }\n\n    public MockName getMockName() {\n        return mockName;\n    }\n\n    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }\n\n    public Object getSpiedInstance() {\n        return spiedInstance;\n    }\n\n    public MockSettings name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public MockSettings spiedInstance(Object spiedInstance) {\n        this.spiedInstance = spiedInstance;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }\n\n    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }\n\n    public boolean isSerializable() {\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n    }\n\n    public void initiateMockName(Class classToMock) {\n        mockName = new MockName(name, classToMock);\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.creation;\n\nimport org.mockito.MockSettings;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.MockName;\nimport org.mockito.stubbing.Answer;\n\npublic class MockSettingsImpl implements MockSettings {\n\n    private static final long serialVersionUID = 4475297236197939568L;\n    private Class<?>[] extraInterfaces;\n    private String name;\n    private Object spiedInstance;\n    private Answer<Object> defaultAnswer;\n    private MockName mockName;\n    private boolean serializable;\n\n    public MockSettings serializable() {\n        this.serializable = true;\n        return this;\n    }\n\n    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n        if (extraInterfaces == null || extraInterfaces.length == 0) {\n            new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n        }\n            \n        for (Class<?> i : extraInterfaces) {\n            if (i == null) {\n                new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n            } else if (!i.isInterface()) {\n                new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n            }\n        }\n        this.extraInterfaces = extraInterfaces;\n        return this;\n    }\n\n    public MockName getMockName() {\n        return mockName;\n    }\n\n    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }\n\n    public Object getSpiedInstance() {\n        return spiedInstance;\n    }\n\n    public MockSettings name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public MockSettings spiedInstance(Object spiedInstance) {\n        this.spiedInstance = spiedInstance;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }\n\n    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }\n\n    public boolean isSerializable() {\n        return serializable;\n    }\n\n    public void initiateMockName(Class classToMock) {\n        mockName = new MockName(name, classToMock);\n    }\n}"}, {"class_name": "org.mockito.internal.util.MockUtil", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util;\n\nimport static org.mockito.Mockito.RETURNS_DEFAULTS;\nimport static org.mockito.Mockito.withSettings;\n\nimport org.mockito.cglib.proxy.*;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.MockHandler;\nimport org.mockito.internal.MockHandlerInterface;\nimport org.mockito.internal.creation.MethodInterceptorFilter;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.util.reflection.LenientCopyTool;\n\n\n@SuppressWarnings(\"unchecked\")\npublic class MockUtil {\n    \n    private final CreationValidator creationValidator;\n\n    public MockUtil(CreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }\n    \n    public MockUtil() {\n        this(new CreationValidator());\n    }\n\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n                        (MockSettingsImpl) withSettings().defaultAnswer(RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }\n\n    private <T> boolean isMockitoMock(T mock) {\n        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n    }\n\n    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }\n\n    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }\n\n    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util;\n\nimport static org.mockito.Mockito.RETURNS_DEFAULTS;\nimport static org.mockito.Mockito.withSettings;\n\nimport org.mockito.cglib.proxy.*;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.MockHandler;\nimport org.mockito.internal.MockHandlerInterface;\nimport org.mockito.internal.creation.MethodInterceptorFilter;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.util.reflection.LenientCopyTool;\n\nimport java.io.Serializable;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockUtil {\n    \n    private final CreationValidator creationValidator;\n\n    public MockUtil(CreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }\n    \n    public MockUtil() {\n        this(new CreationValidator());\n    }\n\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n                        (MockSettingsImpl) withSettings().defaultAnswer(RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }\n\n    private <T> boolean isMockitoMock(T mock) {\n        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n    }\n\n    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }\n\n    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }\n\n    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }\n}"}]}
{"project": "Mockito", "bug_id": 18, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = 1998191268711234347L;\n    ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\n    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        //Let's not care about the rest of collections.\n        return null;\n    }\n\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = 1998191268711234347L;\n    ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\n    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        //Let's not care about the rest of collections.\n        return null;\n    }\n\n}\n"}]}
{"project": "Mockito", "bug_id": 19, "classes_modified": [{"class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.reflection.BeanPropertySetter;\nimport org.mockito.internal.util.reflection.FieldSetter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.reflection.BeanPropertySetter;\nimport org.mockito.internal.util.reflection.FieldSetter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }\n}\n"}, {"class_name": "org.mockito.internal.configuration.injection.filter.MockCandidateFilter", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\npublic interface MockCandidateFilter {\n\n    OngoingInjecter filterCandidate(\n            Collection<Object> mocks,\n            Field fieldToBeInjected,\n            Object fieldInstance\n    );\n\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.List;\n\npublic interface MockCandidateFilter {\n\n    OngoingInjecter filterCandidate(\n            Collection<Object> mocks,\n            Field fieldToBeInjected,\n            List<Field> fields, Object instance\n    );\n\n}\n"}, {"class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport org.mockito.internal.util.MockUtil;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class NameBasedCandidateFilter implements MockCandidateFilter {\n\tprivate final MockCandidateFilter next;\n\tprivate final MockUtil mockUtil = new MockUtil();\n\n\tpublic NameBasedCandidateFilter(MockCandidateFilter next) {\n\t\tthis.next = next;\n\t}\n\n\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, Object fieldInstance) {\n\t\tList<Object> mockNameMatches = new ArrayList<Object>();\n\t\tif (mocks.size() > 1) {\n\t\t\tfor (Object mock : mocks) {\n\t\t\t\tif (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n\t\t\t\t\tmockNameMatches.add(mock);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field,\n\t\t\t\t\tfieldInstance);\n\t\t\t/*\n\t\t\t * In this case we have to check whether we have conflicting naming\n\t\t\t * fields. E.g. 2 fields of the same type, but we have to make sure\n\t\t\t * we match on the correct name.\n\t\t\t * \n\t\t\t * Therefore we have to go through all other fields and make sure\n\t\t\t * whenever we find a field that does match its name with the mock\n\t\t\t * name, we should take that field instead.\n\t\t\t */\n\t\t}\n\t\treturn next.filterCandidate(mocks, field, fieldInstance);\n\t}\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport org.mockito.internal.util.MockUtil;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class NameBasedCandidateFilter implements MockCandidateFilter {\n\tprivate final MockCandidateFilter next;\n\tprivate final MockUtil mockUtil = new MockUtil();\n\n\tpublic NameBasedCandidateFilter(MockCandidateFilter next) {\n\t\tthis.next = next;\n\t}\n\n\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, List<Field> fields, Object fieldInstance) {\n\t\tList<Object> mockNameMatches = new ArrayList<Object>();\n\t\tif (mocks.size() > 1) {\n\t\t\tfor (Object mock : mocks) {\n\t\t\t\tif (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n\t\t\t\t\tmockNameMatches.add(mock);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field, fields,\n\t\t\t\t\tfieldInstance);\n\t\t\t/*\n\t\t\t * In this case we have to check whether we have conflicting naming\n\t\t\t * fields. E.g. 2 fields of the same type, but we have to make sure\n\t\t\t * we match on the correct name.\n\t\t\t * \n\t\t\t * Therefore we have to go through all other fields and make sure\n\t\t\t * whenever we find a field that does match its name with the mock\n\t\t\t * name, we should take that field instead.\n\t\t\t */\n\t\t} else if (mocks.size() == 1) {\n\t\t\tString mockName = mockUtil.getMockName(mocks.iterator().next())\n\t\t\t\t\t.toString();\n\n\t\t\tfor (Field otherField : fields) {\n\t\t\t\tif (!otherField.equals(field)\n\t\t\t\t\t\t&& otherField.getType().equals(field.getType())\n\t\t\t\t\t\t&& otherField.getName().equals(mockName)) {\n\n\t\t\t\t\treturn new OngoingInjecter() {\n\t\t\t\t\t\tpublic Object thenInject() {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next.filterCandidate(mocks, field, fields, fieldInstance);\n\t}\n}\n"}, {"class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class TypeBasedCandidateFilter implements MockCandidateFilter {\n\n    MockCandidateFilter next;\n\n    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }\n\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n        List<Object> mockTypeMatches = new ArrayList<Object>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class TypeBasedCandidateFilter implements MockCandidateFilter {\n\n    MockCandidateFilter next;\n\n    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }\n\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n        List<Object> mockTypeMatches = new ArrayList<Object>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n    }\n}\n"}, {"class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.configuration.injection;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\nimport org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\nimport org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\nimport org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\nimport org.mockito.internal.util.collections.ListUtil;\nimport org.mockito.internal.util.reflection.FieldInitializationReport;\nimport org.mockito.internal.util.reflection.FieldInitializer;\nimport org.mockito.internal.util.reflection.SuperTypesLastSorter;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n\n/**\n * Inject mocks using first setters then fields, if no setters available.\n *\n * <p>\n * <u>Algorithm :<br></u>\n * for each field annotated by @InjectMocks\n *   <ul>\n *   <li>initialize field annotated by @InjectMocks\n *   <li>for each fields of a class in @InjectMocks type hierarchy\n *     <ul>\n *     <li>make a copy of mock candidates\n *     <li>order fields from sub-type to super-type, then by field name\n *     <li>for the list of fields in a class try two passes of :\n *         <ul>\n *             <li>find mock candidate by type\n *             <li>if more than <b>*one*</b> candidate find mock candidate on name\n *             <li>if one mock candidate then\n *                 <ul>\n *                     <li>set mock by property setter if possible\n *                     <li>else set mock by field injection\n *                 </ul>\n *             <li>remove mock from mocks copy (mocks are just injected once in a class)\n *             <li>remove injected field from list of class fields\n *         </ul>\n *     <li>else don't fail, user will then provide dependencies\n *     </ul>\n *   </ul>\n * </p>\n *\n * <p>\n * <u>Note:</u> If the field needing injection is not initialized, the strategy tries\n * to create one using a no-arg constructor of the field type.\n * </p>\n */\npublic class PropertyAndSetterInjection extends MockInjectionStrategy {\n\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n\n    private final ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n        public boolean isOut(Field object) {\n            return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());\n        }\n    };\n\n\n    public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {\n        // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n        FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);\n\n        // for each field in the class hierarchy\n        boolean injectionOccurred = false;\n        Class<?> fieldClass = report.fieldClass();\n        Object fieldInstanceNeedingInjection = report.fieldInstance();\n        while (fieldClass != Object.class) {\n            injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n            fieldClass = fieldClass.getSuperclass();\n        }\n        return injectionOccurred;\n    }\n\n    private FieldInitializationReport initializeInjectMocksField(Field field, Object fieldOwner) {\n        FieldInitializationReport report = null;\n        try {\n            report = new FieldInitializer(fieldOwner, field).initialize();\n        } catch (MockitoException e) {\n            if(e.getCause() instanceof InvocationTargetException) {\n                Throwable realCause = e.getCause().getCause();\n                new Reporter().fieldInitialisationThrewException(field, realCause);\n            }\n            new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n        }\n        return report; // never null\n    }\n\n\n    private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n        boolean injectionOccurred = false;\n        List<Field> orderedInstanceFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n        // pass 1\n        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        // pass 2\n        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        return injectionOccurred;\n    }\n\n    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n            Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n            if (injected != null) {\n                injectionOccurred |= true;\n                mocks.remove(injected);\n                it.remove();\n            }\n        }\n        return injectionOccurred;\n    }\n\n    private List<Field> orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());\n        declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);\n\n        return new SuperTypesLastSorter().sort(declaredFields);\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.configuration.injection;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\nimport org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\nimport org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\nimport org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\nimport org.mockito.internal.util.collections.ListUtil;\nimport org.mockito.internal.util.reflection.FieldInitializationReport;\nimport org.mockito.internal.util.reflection.FieldInitializer;\nimport org.mockito.internal.util.reflection.SuperTypesLastSorter;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n\n/**\n * Inject mocks using first setters then fields, if no setters available.\n *\n * <p>\n * <u>Algorithm :<br></u>\n * for each field annotated by @InjectMocks\n *   <ul>\n *   <li>initialize field annotated by @InjectMocks\n *   <li>for each fields of a class in @InjectMocks type hierarchy\n *     <ul>\n *     <li>make a copy of mock candidates\n *     <li>order fields from sub-type to super-type, then by field name\n *     <li>for the list of fields in a class try two passes of :\n *         <ul>\n *             <li>find mock candidate by type\n *             <li>if more than <b>*one*</b> candidate find mock candidate on name\n *             <li>if one mock candidate then\n *                 <ul>\n *                     <li>set mock by property setter if possible\n *                     <li>else set mock by field injection\n *                 </ul>\n *             <li>remove mock from mocks copy (mocks are just injected once in a class)\n *             <li>remove injected field from list of class fields\n *         </ul>\n *     <li>else don't fail, user will then provide dependencies\n *     </ul>\n *   </ul>\n * </p>\n *\n * <p>\n * <u>Note:</u> If the field needing injection is not initialized, the strategy tries\n * to create one using a no-arg constructor of the field type.\n * </p>\n */\npublic class PropertyAndSetterInjection extends MockInjectionStrategy {\n\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n\n    private final ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n        public boolean isOut(Field object) {\n            return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());\n        }\n    };\n\n\n    public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {\n        // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n        FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);\n\n        // for each field in the class hierarchy\n        boolean injectionOccurred = false;\n        Class<?> fieldClass = report.fieldClass();\n        Object fieldInstanceNeedingInjection = report.fieldInstance();\n        while (fieldClass != Object.class) {\n            injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n            fieldClass = fieldClass.getSuperclass();\n        }\n        return injectionOccurred;\n    }\n\n    private FieldInitializationReport initializeInjectMocksField(Field field, Object fieldOwner) {\n        FieldInitializationReport report = null;\n        try {\n            report = new FieldInitializer(fieldOwner, field).initialize();\n        } catch (MockitoException e) {\n            if(e.getCause() instanceof InvocationTargetException) {\n                Throwable realCause = e.getCause().getCause();\n                new Reporter().fieldInitialisationThrewException(field, realCause);\n            }\n            new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n        }\n        return report; // never null\n    }\n\n\n    private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n        boolean injectionOccurred = false;\n        List<Field> orderedInstanceFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n        // pass 1\n        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        // pass 2\n        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        return injectionOccurred;\n    }\n\n    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n            Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();\n            if (injected != null) {\n                injectionOccurred |= true;\n                mocks.remove(injected);\n                it.remove();\n            }\n        }\n        return injectionOccurred;\n    }\n\n    private List<Field> orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());\n        declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);\n\n        return new SuperTypesLastSorter().sort(declaredFields);\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 20, "classes_modified": [{"class_name": "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker", "buggy_version": "package org.mockito.internal.creation.bytebuddy;\n\nimport static org.mockito.internal.util.StringJoiner.join;\nimport java.lang.reflect.Constructor;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.configuration.GlobalConfiguration;\nimport org.mockito.internal.creation.instance.*;\nimport org.mockito.invocation.MockHandler;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.mock.SerializableMode;\nimport org.mockito.plugins.MockMaker;\n\npublic class ByteBuddyMockMaker implements MockMaker {\n\n    private final ClassInstantiator classInstantiator;\n    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator;\n\n    public ByteBuddyMockMaker() {\n        classInstantiator = initializeClassInstantiator();\n        cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n    }\n\n    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        T mockInstance = null;\n        try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n\n    private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {\n        // Force explicit cast to mocked type here, instead of\n        // relying on the JVM to implicitly cast on the client call site.\n        // This allows us to catch the ClassCastException earlier\n        Class<T> typeToMock = settings.getTypeToMock();\n        return typeToMock.cast(mock);\n    }\n\n    private static String describeClass(Class type) {\n        return type == null ? \"null\" : \"'\" + type.getCanonicalName() + \"', loaded by classloader : '\" + type.getClassLoader() + \"'\";\n    }\n\n    private static String describeClass(Object instance) {\n        return instance == null ? \"null\" : describeClass(instance.getClass());\n    }\n\n    public MockHandler getHandler(Object mock) {\n        if (!(mock instanceof MockMethodInterceptor.MockAccess)) {\n            return null;\n        }\n        return ((MockMethodInterceptor.MockAccess) mock).getMockitoInterceptor().getMockHandler();\n    }\n\n    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n        ((MockMethodInterceptor.MockAccess) mock).setMockitoInterceptor(\n                new MockMethodInterceptor(asInternalMockHandler(newHandler), settings)\n        );\n    }\n\n    private static ClassInstantiator initializeClassInstantiator() {\n        try {\n            Class<?> objenesisClassLoader = Class.forName(\"org.mockito.internal.creation.bytebuddy.ClassInstantiator$UsingObjenesis\");\n            Constructor<?> usingClassCacheConstructor = objenesisClassLoader.getDeclaredConstructor(boolean.class);\n            return ClassInstantiator.class.cast(usingClassCacheConstructor.newInstance(new GlobalConfiguration().enableClassCache()));\n        } catch (Throwable throwable) {\n            // MockitoException cannot be used at this point as we are early in the classloading chain and necessary dependencies may not yet be loadable by the classloader\n            throw new IllegalStateException(join(\n                    \"Mockito could not create mock: Objenesis is missing on the classpath.\",\n                    \"Please add Objenesis on the classpath.\",\n                    \"\"\n            ), throwable);\n        }\n    }\n\n    private static InternalMockHandler asInternalMockHandler(MockHandler handler) {\n        if (!(handler instanceof InternalMockHandler)) {\n            throw new MockitoException(join(\n                    \"At the moment you cannot provide own implementations of MockHandler.\",\n                    \"Please see the javadocs for the MockMaker interface.\",\n                    \"\"\n            ));\n        }\n        return (InternalMockHandler) handler;\n    }\n}\n", "fixed_version": "package org.mockito.internal.creation.bytebuddy;\n\nimport static org.mockito.internal.util.StringJoiner.join;\nimport java.lang.reflect.Constructor;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.configuration.GlobalConfiguration;\nimport org.mockito.internal.creation.instance.*;\nimport org.mockito.invocation.MockHandler;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.mock.SerializableMode;\nimport org.mockito.plugins.MockMaker;\n\npublic class ByteBuddyMockMaker implements MockMaker {\n\n    private final ClassInstantiator classInstantiator;\n    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator;\n\n    public ByteBuddyMockMaker() {\n        classInstantiator = initializeClassInstantiator();\n        cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n    }\n\n    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n        T mockInstance = null;\n        try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n\n    private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {\n        // Force explicit cast to mocked type here, instead of\n        // relying on the JVM to implicitly cast on the client call site.\n        // This allows us to catch the ClassCastException earlier\n        Class<T> typeToMock = settings.getTypeToMock();\n        return typeToMock.cast(mock);\n    }\n\n    private static String describeClass(Class type) {\n        return type == null ? \"null\" : \"'\" + type.getCanonicalName() + \"', loaded by classloader : '\" + type.getClassLoader() + \"'\";\n    }\n\n    private static String describeClass(Object instance) {\n        return instance == null ? \"null\" : describeClass(instance.getClass());\n    }\n\n    public MockHandler getHandler(Object mock) {\n        if (!(mock instanceof MockMethodInterceptor.MockAccess)) {\n            return null;\n        }\n        return ((MockMethodInterceptor.MockAccess) mock).getMockitoInterceptor().getMockHandler();\n    }\n\n    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n        ((MockMethodInterceptor.MockAccess) mock).setMockitoInterceptor(\n                new MockMethodInterceptor(asInternalMockHandler(newHandler), settings)\n        );\n    }\n\n    private static ClassInstantiator initializeClassInstantiator() {\n        try {\n            Class<?> objenesisClassLoader = Class.forName(\"org.mockito.internal.creation.bytebuddy.ClassInstantiator$UsingObjenesis\");\n            Constructor<?> usingClassCacheConstructor = objenesisClassLoader.getDeclaredConstructor(boolean.class);\n            return ClassInstantiator.class.cast(usingClassCacheConstructor.newInstance(new GlobalConfiguration().enableClassCache()));\n        } catch (Throwable throwable) {\n            // MockitoException cannot be used at this point as we are early in the classloading chain and necessary dependencies may not yet be loadable by the classloader\n            throw new IllegalStateException(join(\n                    \"Mockito could not create mock: Objenesis is missing on the classpath.\",\n                    \"Please add Objenesis on the classpath.\",\n                    \"\"\n            ), throwable);\n        }\n    }\n\n    private static InternalMockHandler asInternalMockHandler(MockHandler handler) {\n        if (!(handler instanceof InternalMockHandler)) {\n            throw new MockitoException(join(\n                    \"At the moment you cannot provide own implementations of MockHandler.\",\n                    \"Please see the javadocs for the MockMaker interface.\",\n                    \"\"\n            ));\n        }\n        return (InternalMockHandler) handler;\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 21, "classes_modified": [{"class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator", "buggy_version": "package org.mockito.internal.creation.instance;\n\nimport java.lang.reflect.Constructor;\n\npublic class ConstructorInstantiator implements Instantiator {\n\n    private final Object outerClassInstance;\n\n    public ConstructorInstantiator(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n    }\n\n    public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n    }\n\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n        return new InstantationException(\"Unable to create mock instance of '\"\n                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n    }\n\n\n    private static <T> T noArgConstructor(Class<T> cls) {\n        try {\n            return cls.newInstance();\n        } catch (Exception e) {\n            throw new InstantationException(\"Unable to create mock instance of '\"\n                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n        }\n    }\n}\n", "fixed_version": "package org.mockito.internal.creation.instance;\n\nimport java.lang.reflect.Constructor;\n\npublic class ConstructorInstantiator implements Instantiator {\n\n    private final Object outerClassInstance;\n\n    public ConstructorInstantiator(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n    }\n\n    public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withParams(cls, outerClassInstance);\n    }\n\n    private static <T> T withParams(Class<T> cls, Object... params) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return (T) constructor.newInstance(params);\n                }\n            }\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n        throw paramsException(cls, null);\n    }\n\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n        return new InstantationException(\"Unable to create mock instance of '\"\n                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n    }\n\n    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n        if (params.length != types.length) {\n            return false;\n        }\n        for (int i = 0; i < params.length; i++) {\n            if (!types[i].isInstance(params[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static <T> T noArgConstructor(Class<T> cls) {\n        try {\n            return cls.newInstance();\n        } catch (Exception e) {\n            throw new InstantationException(\"Unable to create mock instance of '\"\n                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n        }\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 22, "classes_modified": [{"class_name": "org.mockito.internal.matchers.Equality", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport java.lang.reflect.Array;\n\n//stolen from hamcrest because I didn't want to have more dependency than Matcher class \npublic class Equality {\n\n    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }\n\n    static boolean areArraysEqual(Object o1, Object o2) {\n        return areArrayLengthsEqual(o1, o2)\n                && areArrayElementsEqual(o1, o2);\n    }\n\n    static boolean areArrayLengthsEqual(Object o1, Object o2) {\n        return Array.getLength(o1) == Array.getLength(o2);\n    }\n\n    static boolean areArrayElementsEqual(Object o1, Object o2) {\n        for (int i = 0; i < Array.getLength(o1); i++) {\n            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) return false;\n        }\n        return true;\n    }\n\n    static boolean isArray(Object o) {\n        return o.getClass().isArray();\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport java.lang.reflect.Array;\n\n//stolen from hamcrest because I didn't want to have more dependency than Matcher class \npublic class Equality {\n\n    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2 ) {\n            return true;\n\t} else if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }\n\n    static boolean areArraysEqual(Object o1, Object o2) {\n        return areArrayLengthsEqual(o1, o2)\n                && areArrayElementsEqual(o1, o2);\n    }\n\n    static boolean areArrayLengthsEqual(Object o1, Object o2) {\n        return Array.getLength(o1) == Array.getLength(o2);\n    }\n\n    static boolean areArrayElementsEqual(Object o1, Object o2) {\n        for (int i = 0; i < Array.getLength(o1); i++) {\n            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) return false;\n        }\n        return true;\n    }\n\n    static boolean isArray(Object o) {\n        return o.getClass().isArray();\n    }\n}"}]}
{"project": "Mockito", "bug_id": 23, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport static org.mockito.Mockito.*;\n\nimport java.io.Serializable;\n\nimport org.mockito.MockSettings;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.MockitoCore;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = -7105341425736035847L;\n\n    private MockitoCore mockitoCore = new MockitoCore();\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!mockitoCore.isTypeMockable(rawType)) {\n            return delegate.returnValueFor(rawType);\n        }\n\n        return getMock(invocation, returnTypeGenericMetadata);\n    }\n\n\n\n    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n    \t\t}\n\t\t}\n\n        // deep stub\n        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n    }\n\n    /**\n     * Creates a mock using the Generics Metadata.\n     *\n     * <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n     * that was resolved for the current return type, for this to happen we associate to the mock an new instance of\n     * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @return The mock\n     */\n    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n        return mockitoCore.mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata)\n        );\n    }\n\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n        MockSettings mockSettings =\n                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return mockSettings\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }\n\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubs() {\n            @Override\n            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n                return returnTypeGenericMetadata;\n            }\n        };\n    }\n\n    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n\n        container.addAnswer(new Answer<Object>() {\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return mock;\n            }\n        }, false);\n\n        return mock;\n    }\n\t\n\t\t\n\t\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport static org.mockito.Mockito.*;\n\nimport java.io.Serializable;\n\nimport org.mockito.MockSettings;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.MockitoCore;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = -7105341425736035847L;\n\n    private transient MockitoCore mockitoCore;\n    private transient ReturnsEmptyValues delegate;\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        instantiateMockitoCoreIfNeeded();\n        instantiateDelegateIfNeeded();\n        if (!mockitoCore.isTypeMockable(rawType)) {\n            return delegate.returnValueFor(rawType);\n        }\n\n        return getMock(invocation, returnTypeGenericMetadata);\n    }\n\n    private synchronized void instantiateMockitoCoreIfNeeded() {\n        if (mockitoCore == null) {\n            mockitoCore = new MockitoCore();\n        }\n    }\n\n    private synchronized void instantiateDelegateIfNeeded() {\n        if (delegate == null) {\n            delegate = new ReturnsEmptyValues();\n        }\n    }\n\n    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n    \t\t}\n\t\t}\n\n        // deep stub\n        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n    }\n\n    /**\n     * Creates a mock using the Generics Metadata.\n     *\n     * <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n     * that was resolved for the current return type, for this to happen we associate to the mock an new instance of\n     * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @return The mock\n     */\n    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n        return mockitoCore.mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata)\n        );\n    }\n\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n        MockSettings mockSettings =\n                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return mockSettings\n\t\t        .serializable()\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }\n\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubs() {\n            @Override\n            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n                return returnTypeGenericMetadata;\n            }\n        };\n    }\n\n    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n\n        container.addAnswer(new SerializableAnswer() {\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return mock;\n            }\n        }, false);\n\n        return mock;\n    }\n\t\n\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n\t\t\n\t}\n\t\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 24, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = 1998191268711234347L;\n    ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\n    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        // TODO return empty Iterable ; see issue 175\n\n        //Let's not care about the rest of collections.\n        return null;\n    }\n\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = 1998191268711234347L;\n    ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\n    MockUtil mockUtil = new MockUtil();\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n    \n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        // TODO return empty Iterable ; see issue 175\n\n        //Let's not care about the rest of collections.\n        return null;\n    }\n\n}"}]}
{"project": "Mockito", "bug_id": 25, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockCreationValidator;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.Serializable;\n\n\n/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = -7105341425736035847L;\n\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n            return delegate.returnValueFor(rawType);\n        }\n\n        return getMock(invocation);\n    }\n\n    private Object getMock(InvocationOnMock invocation) throws Throwable {\n    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n    \t\t}\n\t\t}\n\n        // deep stub\n        return recordDeepStubMock(invocation, container);\n    }\n\n    /**\n     * Creates a mock using the Generics Metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @return The mock\n     */\n\n\n\n\n    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n        Class<?> clz = invocation.getMethod().getReturnType();\n        final Object mock = org.mockito.Mockito.mock(clz, this);\n\n        container.addAnswer(new Answer<Object>() {\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return mock;\n            }\n        }, false);\n\n        return mock;\n    }\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport org.mockito.MockSettings;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.creation.settings.CreationSettings;\nimport org.mockito.internal.stubbing.InvocationContainerImpl;\nimport org.mockito.internal.stubbing.StubbedInvocationMatcher;\nimport org.mockito.internal.util.MockCreationValidator;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.reflection.GenericMetadataSupport;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.Serializable;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.withSettings;\n\n/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    \n    private static final long serialVersionUID = -7105341425736035847L;\n\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n            return delegate.returnValueFor(rawType);\n        }\n\n        return getMock(invocation, returnTypeGenericMetadata);\n    }\n\n    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n    \t\t}\n\t\t}\n\n        // deep stub\n        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n    }\n\n    /**\n     * Creates a mock using the Generics Metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @return The mock\n     */\n    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n        return mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata)\n        );\n    }\n\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n        MockSettings mockSettings =\n                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return mockSettings\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }\n\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubs() {\n            @Override\n            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n                return returnTypeGenericMetadata;\n            }\n        };\n    }\n\n    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n\n        container.addAnswer(new Answer<Object>() {\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                return mock;\n            }\n        }, false);\n\n        return mock;\n    }\n\n    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 26, "classes_modified": [{"class_name": "org.mockito.internal.util.Primitives", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@SuppressWarnings(\"unchecked\")\npublic class Primitives {\n    \n    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n        if(clazz.isPrimitive()) {\n            return clazz;\n        }\n        return (Class<T>) primitiveTypes.get(clazz);\n    }\n\n    public static boolean isPrimitiveWrapper(Class<?> type) {\n        return wrapperReturnValues.containsKey(type);\n    }\n\n    public static <T> T primitiveWrapperOf(Class<T> type) {\n        return (T) wrapperReturnValues.get(type);\n    }\n\n    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n        return (T) primitiveValues.get(primitiveType);\n    }\n    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n\n    static {\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n        primitiveTypes.put(Character.class, Character.TYPE);\n        primitiveTypes.put(Byte.class, Byte.TYPE);\n        primitiveTypes.put(Short.class, Short.TYPE);\n        primitiveTypes.put(Integer.class, Integer.TYPE);\n        primitiveTypes.put(Long.class, Long.TYPE);\n        primitiveTypes.put(Float.class, Float.TYPE);\n        primitiveTypes.put(Double.class, Double.TYPE);\n    }\n\n    static {\n        wrapperReturnValues.put(Boolean.class, false);\n        wrapperReturnValues.put(Character.class, '\\u0000');\n        wrapperReturnValues.put(Byte.class, (byte) 0);\n        wrapperReturnValues.put(Short.class, (short) 0);\n        wrapperReturnValues.put(Integer.class, 0);\n        wrapperReturnValues.put(Long.class, 0L);\n        wrapperReturnValues.put(Float.class, 0F);\n        wrapperReturnValues.put(Double.class, 0D);\n    }\n\n    static {\n        primitiveValues.put(boolean.class, false);\n        primitiveValues.put(char.class, '\\u0000');\n        primitiveValues.put(byte.class, (byte) 0);\n        primitiveValues.put(short.class, (short) 0);\n        primitiveValues.put(int.class, 0);\n        primitiveValues.put(long.class, 0L);\n        primitiveValues.put(float.class, 0F);\n        primitiveValues.put(double.class, 0);\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@SuppressWarnings(\"unchecked\")\npublic class Primitives {\n    \n    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n        if(clazz.isPrimitive()) {\n            return clazz;\n        }\n        return (Class<T>) primitiveTypes.get(clazz);\n    }\n\n    public static boolean isPrimitiveWrapper(Class<?> type) {\n        return wrapperReturnValues.containsKey(type);\n    }\n\n    public static <T> T primitiveWrapperOf(Class<T> type) {\n        return (T) wrapperReturnValues.get(type);\n    }\n\n    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n        return (T) primitiveValues.get(primitiveType);\n    }\n    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n\n    static {\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n        primitiveTypes.put(Character.class, Character.TYPE);\n        primitiveTypes.put(Byte.class, Byte.TYPE);\n        primitiveTypes.put(Short.class, Short.TYPE);\n        primitiveTypes.put(Integer.class, Integer.TYPE);\n        primitiveTypes.put(Long.class, Long.TYPE);\n        primitiveTypes.put(Float.class, Float.TYPE);\n        primitiveTypes.put(Double.class, Double.TYPE);\n    }\n\n    static {\n        wrapperReturnValues.put(Boolean.class, false);\n        wrapperReturnValues.put(Character.class, '\\u0000');\n        wrapperReturnValues.put(Byte.class, (byte) 0);\n        wrapperReturnValues.put(Short.class, (short) 0);\n        wrapperReturnValues.put(Integer.class, 0);\n        wrapperReturnValues.put(Long.class, 0L);\n        wrapperReturnValues.put(Float.class, 0F);\n        wrapperReturnValues.put(Double.class, 0D);\n    }\n\n    static {\n        primitiveValues.put(boolean.class, false);\n        primitiveValues.put(char.class, '\\u0000');\n        primitiveValues.put(byte.class, (byte) 0);\n        primitiveValues.put(short.class, (short) 0);\n        primitiveValues.put(int.class, 0);\n        primitiveValues.put(long.class, 0L);\n        primitiveValues.put(float.class, 0F);\n        primitiveValues.put(double.class, 0D);\n    }\n}"}]}
{"project": "Mockito", "bug_id": 27, "classes_modified": [{"class_name": "org.mockito.internal.util.MockUtil", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.util;\n\nimport org.mockito.cglib.proxy.Callback;\nimport org.mockito.cglib.proxy.Factory;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.InvocationNotifierHandler;\nimport org.mockito.internal.MockHandler;\nimport org.mockito.internal.MockHandlerInterface;\nimport org.mockito.internal.creation.MethodInterceptorFilter;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.util.reflection.LenientCopyTool;\n\nimport java.io.Serializable;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockUtil {\n    \n    private final MockCreationValidator creationValidator;\n\n    public MockUtil(MockCreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }\n    \n    public MockUtil() {\n        this(new MockCreationValidator());\n    }\n\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MethodInterceptorFilter filter = newMethodInterceptorFilter(settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n        return new MethodInterceptorFilter(invocationNotifierHandler, settings);\n    }\n\n    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }\n\n    private <T> boolean isMockitoMock(T mock) {\n        return getInterceptor(mock) != null;\n    }\n\n    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }\n\n    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        if (!(mock instanceof Factory)) {\n            return null;\n        }\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }\n\n    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\n\npackage org.mockito.internal.util;\n\nimport org.mockito.cglib.proxy.Callback;\nimport org.mockito.cglib.proxy.Factory;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.internal.InvocationNotifierHandler;\nimport org.mockito.internal.MockHandler;\nimport org.mockito.internal.MockHandlerInterface;\nimport org.mockito.internal.creation.MethodInterceptorFilter;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.util.reflection.LenientCopyTool;\n\nimport java.io.Serializable;\n\n@SuppressWarnings(\"unchecked\")\npublic class MockUtil {\n    \n    private final MockCreationValidator creationValidator;\n\n    public MockUtil(MockCreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }\n    \n    public MockUtil() {\n        this(new MockCreationValidator());\n    }\n\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MethodInterceptorFilter filter = newMethodInterceptorFilter(settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n        return new MethodInterceptorFilter(invocationNotifierHandler, settings);\n    }\n\n    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }\n\n    private <T> boolean isMockitoMock(T mock) {\n        return getInterceptor(mock) != null;\n    }\n\n    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }\n\n    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        if (!(mock instanceof Factory)) {\n            return null;\n        }\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }\n\n    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 28, "classes_modified": [{"class_name": "org.mockito.internal.configuration.DefaultInjectionEngine", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\nimport org.mockito.internal.configuration.injection.MockCandidateFilter;\nimport org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\nimport org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\nimport org.mockito.internal.util.reflection.FieldInitializer;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n * <p/>\n * See {@link org.mockito.MockitoAnnotations}\n */\npublic class DefaultInjectionEngine {\n\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n        public int compare(Field field1, Field field2) {\n            Class<?> field1Type = field1.getType();\n            Class<?> field2Type = field2.getType();\n\n            if(field1Type.isAssignableFrom(field2Type)) {\n                return 1;\n            }\n            if(field2Type.isAssignableFrom(field1Type)) {\n                return -1;\n            }\n            return 0;\n        }\n    };\n\n    /**\n     * Inject mocks in injectMocksFields, and initialize them if needed.\n     *\n     * <p>\n     * <u>Algorithm :<br></u>\n     * for each field annotated by @InjectMocks\n     *   <ul>\n     *   <li>copy mocks set\n     *   <li>initialize field annotated by @InjectMocks\n     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n     *     <ul>\n     *     <li>find mock candidate by type\n     *     <li>if more than *one* candidate find mock candidate on name\n     *     <li>if one mock candidate then\n     *       <ul>\n     *       <li>set mock by property setter if possible\n     *       <li>else set mock by field injection\n     *       </ul>\n     *     <li>remove mock from mocks copy (mocks are just injected once)\n     *     <li>else don't fail, user will then provide dependencies\n     *     </ul>\n     *   </ul>\n     * </p>\n     *\n     * @param injectMocksFields Fields annotated by @InjectMocks\n     * @param mocks Mocks\n     * @param testClassInstance The test class instance\n     */\n    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n        for (Field field : injectMocksFields) {\n            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n            Object injectMocksFieldInstance = null;\n            try {\n                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n            } catch (MockitoException e) {\n                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n            }\n\n            // for each field in the class hierarchy\n            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n            while (fieldClass != Object.class) {\n                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n                fieldClass = fieldClass.getSuperclass();\n            }\n        }\n    }\n\n    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        }\n    }\n\n    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n        Arrays.sort(declaredFields, supertypesLast);\n        return declaredFields;\n    }\n\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\nimport org.mockito.internal.configuration.injection.MockCandidateFilter;\nimport org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\nimport org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\nimport org.mockito.internal.util.reflection.FieldInitializer;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n * <p/>\n * See {@link org.mockito.MockitoAnnotations}\n */\npublic class DefaultInjectionEngine {\n\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n        public int compare(Field field1, Field field2) {\n            Class<?> field1Type = field1.getType();\n            Class<?> field2Type = field2.getType();\n\n            if(field1Type.isAssignableFrom(field2Type)) {\n                return 1;\n            }\n            if(field2Type.isAssignableFrom(field1Type)) {\n                return -1;\n            }\n            return 0;\n        }\n    };\n\n    /**\n     * Inject mocks in injectMocksFields, and initialize them if needed.\n     *\n     * <p>\n     * <u>Algorithm :<br></u>\n     * for each field annotated by @InjectMocks\n     *   <ul>\n     *   <li>copy mocks set\n     *   <li>initialize field annotated by @InjectMocks\n     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n     *     <ul>\n     *     <li>find mock candidate by type\n     *     <li>if more than *one* candidate find mock candidate on name\n     *     <li>if one mock candidate then\n     *       <ul>\n     *       <li>set mock by property setter if possible\n     *       <li>else set mock by field injection\n     *       </ul>\n     *     <li>remove mock from mocks copy (mocks are just injected once)\n     *     <li>else don't fail, user will then provide dependencies\n     *     </ul>\n     *   </ul>\n     * </p>\n     *\n     * @param injectMocksFields Fields annotated by @InjectMocks\n     * @param mocks Mocks\n     * @param testClassInstance The test class instance\n     */\n    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n        for (Field field : injectMocksFields) {\n            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n            Object injectMocksFieldInstance = null;\n            try {\n                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n            } catch (MockitoException e) {\n                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n            }\n\n            // for each field in the class hierarchy\n            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n            while (fieldClass != Object.class) {\n                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n                fieldClass = fieldClass.getSuperclass();\n            }\n        }\n    }\n\n    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n            mocks.remove(injected);\n        }\n    }\n\n    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n        Arrays.sort(declaredFields, supertypesLast);\n        return declaredFields;\n    }\n\n}\n"}]}
{"project": "Mockito", "bug_id": 29, "classes_modified": [{"class_name": "org.mockito.internal.matchers.Same", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport org.hamcrest.Description;\nimport org.mockito.ArgumentMatcher;\n\nimport java.io.Serializable;\n\n\npublic class Same extends ArgumentMatcher<Object> implements Serializable {\n\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n\n    public Same(Object wanted) {\n        this.wanted = wanted;\n    }\n\n    public boolean matches(Object actual) {\n        return wanted == actual;\n    }\n\n    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n\n    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\n\nimport org.hamcrest.Description;\nimport org.mockito.ArgumentMatcher;\n\nimport java.io.Serializable;\n\n\npublic class Same extends ArgumentMatcher<Object> implements Serializable {\n\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n\n    public Same(Object wanted) {\n        this.wanted = wanted;\n    }\n\n    public boolean matches(Object actual) {\n        return wanted == actual;\n    }\n\n    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n\n    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 30, "classes_modified": [{"class_name": "org.mockito.exceptions.Reporter", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.exceptions;\n\nimport static org.mockito.exceptions.Pluralizer.pluralize;\nimport static org.mockito.internal.util.StringJoiner.join;\n\nimport java.util.List;\n\nimport org.mockito.exceptions.base.MockitoAssertionError;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\nimport org.mockito.exceptions.misusing.MissingMethodInvocationException;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.exceptions.misusing.NullInsteadOfMockException;\nimport org.mockito.exceptions.misusing.UnfinishedStubbingException;\nimport org.mockito.exceptions.misusing.UnfinishedVerificationException;\nimport org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\nimport org.mockito.exceptions.verification.ArgumentsAreDifferent;\nimport org.mockito.exceptions.verification.NeverWantedButInvoked;\nimport org.mockito.exceptions.verification.NoInteractionsWanted;\nimport org.mockito.exceptions.verification.SmartNullPointerException;\nimport org.mockito.exceptions.verification.TooLittleActualInvocations;\nimport org.mockito.exceptions.verification.TooManyActualInvocations;\nimport org.mockito.exceptions.verification.VerificationInOrderFailure;\nimport org.mockito.exceptions.verification.WantedButNotInvoked;\nimport org.mockito.exceptions.verification.junit.JUnitTool;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.exceptions.VerificationAwareInvocation;\nimport org.mockito.internal.exceptions.util.ScenarioPrinter;\nimport org.mockito.internal.invocation.Invocation;\n\n/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n\n    public void checkedExceptionInvalid(Throwable t) {\n        throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n                ));\n    }\n\n    public void cannotStubWithNullThrowable() {\n        throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n                ));\n\n    }\n\n    public void unfinishedStubbing(Location location) {\n        throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \"\"\n        ));\n    }\n\n    public void missingMethodInvocation() {\n        throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"2. inside when() you don't call method on mock but on some other object.\"\n        ));\n    }\n\n    public void unfinishedVerificationException(Location location) {\n        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                \"\"\n        ));\n\n        throw exception;\n    }\n\n    public void notAMockPassedToVerify(Class type) {\n        throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToVerify() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void notAMockPassedToWhenMethod() {\n        throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToWhenMethod() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void notAMockPassedToVerifyNoMoreInteractions() {\n        throw new NotAMockException(join(\n            \"Argument(s) passed is not a mock!\",\n            \"Examples of correct verifications:\",\n            \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n            \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void nullPassedToVerifyNoMoreInteractions() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void notAMockPassedWhenCreatingInOrder() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void nullPassedWhenCreatingInOrder() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void mocksHaveToBePassedWhenCreatingInOrder() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void inOrderRequiresFamiliarMock() {\n        throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n                ));\n    }\n\n    public void invalidUseOfMatchers(int expectedMatchersCount, int recordedMatchersCount) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchersCount + \" recorded.\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\"\n        ));\n    }\n\n    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new Location(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n                );\n\n        if (JUnitTool.hasJUnit()) {\n            throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n        } else {\n            throw new ArgumentsAreDifferent(message);\n        }\n    }\n\n    public void wantedButNotInvoked(PrintableInvocation wanted) {\n        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n    }\n\n    public void wantedButNotInvoked(PrintableInvocation wanted, List<? extends PrintableInvocation> invocations) {\n        String allInvocations;\n        if (invocations.isEmpty()) {\n            allInvocations = \"Actually, there were zero interactions with this mock.\\n\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n            for (PrintableInvocation i : invocations) {\n                 sb.append(i.getLocation());\n                 sb.append(\"\\n\");\n            }\n            allInvocations = sb.toString();\n        }\n\n        String message = createWantedButNotInvokedMessage(wanted);\n        throw new WantedButNotInvoked(message + allInvocations);\n    }\n\n    private String createWantedButNotInvokedMessage(PrintableInvocation wanted) {\n        return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new Location(),\n                \"\"\n        );\n    }\n\n    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n        throw new VerificationInOrderFailure(join(\n                    \"Verification in order failure\",\n                    \"Wanted but not invoked:\",\n                    wanted.toString(),\n                    new Location(),\n                    \"Wanted anywhere AFTER following interaction:\",\n                    previous.toString(),\n                    previous.getLocation(),\n                    \"\"\n        ));\n    }\n\n    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new TooManyActualInvocations(message);\n    }\n\n    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, PrintableInvocation wanted,\n            Location firstUndesired) {\n        return join(\n                wanted.toString(),\n                \"Wanted \" + Pluralizer.pluralize(wantedCount) + \":\",\n                new Location(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );\n    }\n\n    public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n        throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new Location(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));\n    }\n\n    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n                ));\n    }\n\n    private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n            Location lastActualInvocation) {\n        String ending =\n            (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n\n            String message = join(\n                    wanted.toString(),\n                    \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                    new Location(),\n                    \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                    ending\n            );\n            return message;\n    }\n\n    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new TooLittleActualInvocations(message);\n    }\n\n    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n                ));\n    }\n\n    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n        String scenario = scenarioPrinter.print(invocations);\n\n        throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new Location(),\n                \"But found this interaction:\",\n                undesired.getLocation(),\n                scenario,\n                \"\"\n        ));\n    }\n\n    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n        throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new Location(),\n                \"But found this interaction:\",\n                undesired.getLocation(),\n                \"\"\n                ));\n    }\n\n    public void cannotMockFinalClass(Class<?> clazz) {\n        throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));\n    }\n\n    public void cannotStubVoidMethodWithAReturnValue(String methodName) {\n        throw new MockitoException(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"If the method you are trying to stub is *overloaded* then make sure you are calling the right overloaded version.\",\n                \"This exception might also occur when somewhere in your test you are stubbing *final methods*.\"\n             ));\n    }\n\n    public void onlyVoidMethodsCanBeSetToDoNothing() {\n        throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n             ));\n    }\n\n    public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"\"\n                ));\n    }\n\n    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n    }\n\n    public void misplacedArgumentMatcher(Location location) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                location,\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                \"\"\n                ));\n    }\n\n    public void smartNullPointerException(Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n                \"Because this method was *not* stubbed correctly:\",\n                location,\n                \"\"\n                ));\n    }\n\n    public void noArgumentValueWasCaptured() {\n        throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n                ));\n    }\n\n    public void extraInterfacesDoesNotAcceptNullParameters() {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n                ));\n    }\n\n    public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));\n    }\n\n    public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));\n    }\n\n    public void extraInterfacesRequiresAtLeastOneInterface() {\n        throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));\n    }\n\n    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));\n    }\n\n    public void cannotCallRealMethodOnInterface() {\n        throw new MockitoException(join(\n                \"Cannot call real method on java interface. Interface does not have any implementation!\",\n                \"Calling real methods is only possible when mocking concrete classes.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.doStuff()).thenCallRealMethod();\"\n        ));\n    }\n\n    public void cannotVerifyToString() {\n        throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));\n    }\n\n    public void moreThanOneAnnotationNotAllowed(String fieldName) {\n        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n    }\n\n    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n    }\n\n    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instianate a @Spy for '\" + fieldName + \"' field.\",\n            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n            \"However, I failed because: \" + details.getMessage(),\n            \"Examples of correct usage of @Spy:\",\n            \"   @Spy List mock = new LinkedList();\",\n            \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);\n    }\n\n    public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instianate @InjectMocks field named '\" + fieldName + \"'.\",\n            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n            \"However, I failed because: \" + details.getMessage(),\n            \"Examples of correct usage of @InjectMocks:\",\n            \"   @InjectMocks Service service = new Service();\",\n            \"   @InjectMocks Service service; //only if Service has parameterless constructor\",\n            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n            \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.exceptions;\n\nimport static org.mockito.exceptions.Pluralizer.pluralize;\nimport static org.mockito.internal.util.StringJoiner.join;\n\nimport java.util.List;\n\nimport org.mockito.exceptions.base.MockitoAssertionError;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\nimport org.mockito.exceptions.misusing.MissingMethodInvocationException;\nimport org.mockito.exceptions.misusing.NotAMockException;\nimport org.mockito.exceptions.misusing.NullInsteadOfMockException;\nimport org.mockito.exceptions.misusing.UnfinishedStubbingException;\nimport org.mockito.exceptions.misusing.UnfinishedVerificationException;\nimport org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\nimport org.mockito.exceptions.verification.ArgumentsAreDifferent;\nimport org.mockito.exceptions.verification.NeverWantedButInvoked;\nimport org.mockito.exceptions.verification.NoInteractionsWanted;\nimport org.mockito.exceptions.verification.SmartNullPointerException;\nimport org.mockito.exceptions.verification.TooLittleActualInvocations;\nimport org.mockito.exceptions.verification.TooManyActualInvocations;\nimport org.mockito.exceptions.verification.VerificationInOrderFailure;\nimport org.mockito.exceptions.verification.WantedButNotInvoked;\nimport org.mockito.exceptions.verification.junit.JUnitTool;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.exceptions.VerificationAwareInvocation;\nimport org.mockito.internal.exceptions.util.ScenarioPrinter;\nimport org.mockito.internal.invocation.Invocation;\n\n/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n\n    public void checkedExceptionInvalid(Throwable t) {\n        throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n                ));\n    }\n\n    public void cannotStubWithNullThrowable() {\n        throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n                ));\n\n    }\n\n    public void unfinishedStubbing(Location location) {\n        throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \"\"\n        ));\n    }\n\n    public void missingMethodInvocation() {\n        throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"2. inside when() you don't call method on mock but on some other object.\"\n        ));\n    }\n\n    public void unfinishedVerificationException(Location location) {\n        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                \"\"\n        ));\n\n        throw exception;\n    }\n\n    public void notAMockPassedToVerify(Class type) {\n        throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToVerify() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void notAMockPassedToWhenMethod() {\n        throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));\n    }\n\n    public void nullPassedToWhenMethod() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }\n\n    public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void notAMockPassedToVerifyNoMoreInteractions() {\n        throw new NotAMockException(join(\n            \"Argument(s) passed is not a mock!\",\n            \"Examples of correct verifications:\",\n            \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n            \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void nullPassedToVerifyNoMoreInteractions() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }\n\n    public void notAMockPassedWhenCreatingInOrder() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void nullPassedWhenCreatingInOrder() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void mocksHaveToBePassedWhenCreatingInOrder() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                ));\n    }\n\n    public void inOrderRequiresFamiliarMock() {\n        throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n                ));\n    }\n\n    public void invalidUseOfMatchers(int expectedMatchersCount, int recordedMatchersCount) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchersCount + \" recorded.\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\"\n        ));\n    }\n\n    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new Location(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n                );\n\n        if (JUnitTool.hasJUnit()) {\n            throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n        } else {\n            throw new ArgumentsAreDifferent(message);\n        }\n    }\n\n    public void wantedButNotInvoked(PrintableInvocation wanted) {\n        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n    }\n\n    public void wantedButNotInvoked(PrintableInvocation wanted, List<? extends PrintableInvocation> invocations) {\n        String allInvocations;\n        if (invocations.isEmpty()) {\n            allInvocations = \"Actually, there were zero interactions with this mock.\\n\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n            for (PrintableInvocation i : invocations) {\n                 sb.append(i.getLocation());\n                 sb.append(\"\\n\");\n            }\n            allInvocations = sb.toString();\n        }\n\n        String message = createWantedButNotInvokedMessage(wanted);\n        throw new WantedButNotInvoked(message + allInvocations);\n    }\n\n    private String createWantedButNotInvokedMessage(PrintableInvocation wanted) {\n        return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new Location(),\n                \"\"\n        );\n    }\n\n    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n        throw new VerificationInOrderFailure(join(\n                    \"Verification in order failure\",\n                    \"Wanted but not invoked:\",\n                    wanted.toString(),\n                    new Location(),\n                    \"Wanted anywhere AFTER following interaction:\",\n                    previous.toString(),\n                    previous.getLocation(),\n                    \"\"\n        ));\n    }\n\n    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new TooManyActualInvocations(message);\n    }\n\n    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, PrintableInvocation wanted,\n            Location firstUndesired) {\n        return join(\n                wanted.toString(),\n                \"Wanted \" + Pluralizer.pluralize(wantedCount) + \":\",\n                new Location(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );\n    }\n\n    public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n        throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new Location(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));\n    }\n\n    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n                ));\n    }\n\n    private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n            Location lastActualInvocation) {\n        String ending =\n            (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n\n            String message = join(\n                    wanted.toString(),\n                    \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                    new Location(),\n                    \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                    ending\n            );\n            return message;\n    }\n\n    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new TooLittleActualInvocations(message);\n    }\n\n    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n                ));\n    }\n\n    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n        String scenario = scenarioPrinter.print(invocations);\n\n        throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new Location(),\n                \"But found this interaction:\",\n                undesired.getLocation(),\n                scenario,\n                \"\"\n        ));\n    }\n\n    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n        throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new Location(),\n                \"But found this interaction:\",\n                undesired.getLocation(),\n                \"\"\n                ));\n    }\n\n    public void cannotMockFinalClass(Class<?> clazz) {\n        throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));\n    }\n\n    public void cannotStubVoidMethodWithAReturnValue(String methodName) {\n        throw new MockitoException(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"If the method you are trying to stub is *overloaded* then make sure you are calling the right overloaded version.\",\n                \"This exception might also occur when somewhere in your test you are stubbing *final methods*.\"\n             ));\n    }\n\n    public void onlyVoidMethodsCanBeSetToDoNothing() {\n        throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n             ));\n    }\n\n    public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"\"\n                ));\n    }\n\n    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n    }\n\n    public void misplacedArgumentMatcher(Location location) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                location,\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                \"\"\n                ));\n    }\n\n    public void smartNullPointerException(Object obj, Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new Location(),\n                obj,\n                \"Because this method was *not* stubbed correctly:\",\n                location,\n                \"\"\n                ));\n    }\n\n    public void noArgumentValueWasCaptured() {\n        throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n                ));\n    }\n\n    public void extraInterfacesDoesNotAcceptNullParameters() {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n                ));\n    }\n\n    public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));\n    }\n\n    public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));\n    }\n\n    public void extraInterfacesRequiresAtLeastOneInterface() {\n        throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));\n    }\n\n    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));\n    }\n\n    public void cannotCallRealMethodOnInterface() {\n        throw new MockitoException(join(\n                \"Cannot call real method on java interface. Interface does not have any implementation!\",\n                \"Calling real methods is only possible when mocking concrete classes.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.doStuff()).thenCallRealMethod();\"\n        ));\n    }\n\n    public void cannotVerifyToString() {\n        throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));\n    }\n\n    public void moreThanOneAnnotationNotAllowed(String fieldName) {\n        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n    }\n\n    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n    }\n\n    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instianate a @Spy for '\" + fieldName + \"' field.\",\n            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n            \"However, I failed because: \" + details.getMessage(),\n            \"Examples of correct usage of @Spy:\",\n            \"   @Spy List mock = new LinkedList();\",\n            \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);\n    }\n\n    public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instianate @InjectMocks field named '\" + fieldName + \"'.\",\n            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n            \"However, I failed because: \" + details.getMessage(),\n            \"Examples of correct usage of @InjectMocks:\",\n            \"   @InjectMocks Service service = new Service();\",\n            \"   @InjectMocks Service service; //only if Service has parameterless constructor\",\n            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n            \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);\n    }\n}"}, {"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\nimport org.mockito.Mockito;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = 7618312406617949441L;\n\n    private final class ThrowingInterceptor implements MethodInterceptor {\n        private final InvocationOnMock invocation;\n        private final Location location = new Location();\n\n        private ThrowingInterceptor(InvocationOnMock invocation) {\n            this.invocation = invocation;\n        }\n\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(location);\n            return null;\n        }\n\n\t\tprivate String formatMethodCall() {\n\t\t\tString args = Arrays.toString(invocation.getArguments());\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\n\t\t}\n    }\n\n    private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n\n    public Object answer(final InvocationOnMock invocation) throws Throwable {\n        Object defaultReturnValue = delegate.answer(invocation);\n        if (defaultReturnValue != null) {\n            return defaultReturnValue;\n        }\n        Class<?> type = invocation.getMethod().getReturnType();\n        if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n            return ClassImposterizer.INSTANCE.imposterise(new ThrowingInterceptor(invocation), type);\n        }\n        return null;\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\nimport org.mockito.Mockito;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = 7618312406617949441L;\n\n    private final class ThrowingInterceptor implements MethodInterceptor {\n        private final InvocationOnMock invocation;\n        private final Location location = new Location();\n\n        private ThrowingInterceptor(InvocationOnMock invocation) {\n            this.invocation = invocation;\n        }\n\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(obj, location);\n            return null;\n        }\n\n\t\tprivate String formatMethodCall() {\n\t\t\tString args = Arrays.toString(invocation.getArguments());\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\n\t\t}\n    }\n\n    private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n\n    public Object answer(final InvocationOnMock invocation) throws Throwable {\n        Object defaultReturnValue = delegate.answer(invocation);\n        if (defaultReturnValue != null) {\n            return defaultReturnValue;\n        }\n        Class<?> type = invocation.getMethod().getReturnType();\n        if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n            return ClassImposterizer.INSTANCE.imposterise(new ThrowingInterceptor(invocation), type);\n        }\n        return null;\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 31, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\n\nimport org.mockito.Mockito;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = 7618312406617949441L;\n\n    private final class ThrowingInterceptor implements MethodInterceptor {\n        private final InvocationOnMock invocation;\n        private final Location location = new Location();\n\n        private ThrowingInterceptor(InvocationOnMock invocation) {\n            this.invocation = invocation;\n        }\n\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(location);\n            return null;\n        }\n\n\t\tprivate String formatMethodCall() {\n\t\t\treturn invocation.getMethod().getName() + \"()\";\n\t\t}\n    }\n\n    private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n\n    public Object answer(final InvocationOnMock invocation) throws Throwable {\n        Object defaultReturnValue = delegate.answer(invocation);\n        if (defaultReturnValue != null) {\n            return defaultReturnValue;\n        }\n        Class<?> type = invocation.getMethod().getReturnType();\n        if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n            return ClassImposterizer.INSTANCE.imposterise(new ThrowingInterceptor(invocation), type);\n        }\n        return null;\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\nimport org.mockito.Mockito;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.creation.jmock.ClassImposterizer;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = 7618312406617949441L;\n\n    private final class ThrowingInterceptor implements MethodInterceptor {\n        private final InvocationOnMock invocation;\n        private final Location location = new Location();\n\n        private ThrowingInterceptor(InvocationOnMock invocation) {\n            this.invocation = invocation;\n        }\n\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(method)) {\n                return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n            }\n\n            new Reporter().smartNullPointerException(location);\n            return null;\n        }\n\n\t\tprivate String formatMethodCall() {\n\t\t\tString args = Arrays.toString(invocation.getArguments());\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\n\t\t}\n    }\n\n    private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n\n    public Object answer(final InvocationOnMock invocation) throws Throwable {\n        Object defaultReturnValue = delegate.answer(invocation);\n        if (defaultReturnValue != null) {\n            return defaultReturnValue;\n        }\n        Class<?> type = invocation.getMethod().getReturnType();\n        if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n            return ClassImposterizer.INSTANCE.imposterise(new ThrowingInterceptor(invocation), type);\n        }\n        return null;\n    }\n}\n"}]}
{"project": "Mockito", "bug_id": 32, "classes_modified": [{"class_name": "org.mockito.internal.configuration.SpyAnnotationEngine", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\n\nimport org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.Spy;\nimport org.mockito.configuration.AnnotationEngine;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.MockUtil;\n\n\n@SuppressWarnings({\"unchecked\"})\npublic class SpyAnnotationEngine implements AnnotationEngine {\n\n    public Object createMockFor(Annotation annotation, Field field) {\n        return null;\n    }\n    \n    @SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class)) {\n                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                boolean wasAccessible = field.isAccessible();\n                field.setAccessible(true);\n                try {\n                    Object instance = field.get(testClass);\n                    if (instance == null) {\n                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n                        \t\t  \"The instance must be created *before* initMocks();\\n\" +\n                                  \"Example of correct usage of @Spy:\\n\" +\n                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n\n                    }\n                    if (new MockUtil().isMock(instance)) { \n                        // instance has been spied earlier\n                        Mockito.reset(instance);\n                    } else {\n                        field.set(testClass, Mockito.spy(instance));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                } finally {\n                    field.setAccessible(wasAccessible);\n                }\n            }\n        }\n    }\n    \n    //TODO duplicated elsewhere\n    void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n        for (Class u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n            }\n        }        \n    }    \n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\n\nimport org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.Spy;\nimport org.mockito.configuration.AnnotationEngine;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.util.MockUtil;\n\nimport static org.mockito.Mockito.withSettings;\n\n@SuppressWarnings({\"unchecked\"})\npublic class SpyAnnotationEngine implements AnnotationEngine {\n\n    public Object createMockFor(Annotation annotation, Field field) {\n        return null;\n    }\n    \n    @SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class)) {\n                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                boolean wasAccessible = field.isAccessible();\n                field.setAccessible(true);\n                try {\n                    Object instance = field.get(testClass);\n                    if (instance == null) {\n                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n                        \t\t  \"The instance must be created *before* initMocks();\\n\" +\n                                  \"Example of correct usage of @Spy:\\n\" +\n                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n\n                    }\n                    if (new MockUtil().isMock(instance)) { \n                        // instance has been spied earlier\n                        Mockito.reset(instance);\n                    } else {\n                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                } finally {\n                    field.setAccessible(wasAccessible);\n                }\n            }\n        }\n    }\n    \n    //TODO duplicated elsewhere\n    void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n        for (Class u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n            }\n        }        \n    }    \n}\n"}]}
{"project": "Mockito", "bug_id": 33, "classes_modified": [{"class_name": "org.mockito.internal.invocation.InvocationMatcher", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return invocation.toString(matchers, new PrintSettings());\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        \t/* Avoid unnecessary cloning */\n        return m1.equals(m2);\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return invocation.toString(matchers, new PrintSettings());\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }\n}"}]}
{"project": "Mockito", "bug_id": 34, "classes_modified": [{"class_name": "org.mockito.internal.invocation.InvocationMatcher", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return invocation.toString(matchers, new PrintSettings());\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        return invocation.getMethod().equals(candidate.getMethod());\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return invocation.toString(matchers, new PrintSettings());\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        return invocation.getMethod().equals(candidate.getMethod());\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n}"}]}
{"project": "Mockito", "bug_id": 35, "classes_modified": [{"class_name": "org.mockito.Matchers", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.matchers.apachecommons.ReflectionEquals;\nimport org.mockito.internal.progress.HandyReturnValues;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\n\n/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre>\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </pre>\n * \n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre>\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre>\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\n@SuppressWarnings(\"unchecked\")\npublic class Matchers {\n    \n    private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    /**\n     * any boolean, Boolean or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean() {\n        return reportMatcher(Any.ANY).returnFalse();\n    }\n\n    /**\n     * any byte, Byte or null\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static byte anyByte() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any char, Character or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static char anyChar() {\n        return reportMatcher(Any.ANY).returnChar();\n    }\n\n    /**\n     * any int, Integer or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static int anyInt() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any long, Long or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static long anyLong() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any float, Float or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static float anyFloat() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any double, Double or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static double anyDouble() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any short, Short or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static short anyShort() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any Object or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T anyObject() {\n        return (T) reportMatcher(Any.ANY).returnNull();\n    }\n    //TODO: after 1.8 check out Jay Fields' idea on any() matcher\n\n    /**\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre>\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     */\n    public static <T> T anyVararg() {\n        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();\n    }\n    \n    /**\n     * any kind object, not necessary of the given class.\n     * The class argument is provided only to avoid casting.\n     * <p>\n     * Sometimes looks better than anyObject() - especially when explicit casting is required\n     * <p>\n     * Alias to {@link Matchers#anyObject()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any(Class<T> clazz) {\n        return (T) anyObject();\n    }\n    \n    /**\n     * any object or null \n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any() {\n        return (T) anyObject();\n    }\n\n    /**\n     * any String or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     */\n    public static String anyString() {\n        return reportMatcher(Any.ANY).returnString();\n    }\n    \n    /**\n     * any List or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static List anyList() {\n        return reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * any List or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static <T> List<T> anyListOf(Class<T> clazz) {\n        return (List) reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * any Set or null\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static Set anySet() {\n        return reportMatcher(Any.ANY).returnSet();\n    }\n    \n    /**\n     * generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * any Set or null\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static <T> Set<T> anySetOf(Class<T> clazz) {\n        return (Set) reportMatcher(Any.ANY).returnSet();\n    }\n\n    /**\n     * any Map or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     */\n    public static Map anyMap() {\n        return reportMatcher(Any.ANY).returnMap();\n    }    \n    \n    /**\n     * any Collection or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static Collection anyCollection() {\n        return reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * generic friendly alias to {@link Matchers#anyCollection()}. \n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.     \n     * <p>\n     * any Collection or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n        return (Collection) reportMatcher(Any.ANY).returnList();\n    }    \n\n    /**\n     * Object argument that implements the given class. \n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the accepted type.\n     * @param clazz\n     *            the class of the accepted type.\n     * @return <code>null</code>.\n     */\n    public static <T> T isA(Class<T> clazz) {\n        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();\n    }\n\n    /**\n     * boolean argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static boolean eq(boolean value) {\n        return reportMatcher(new Equals(value)).returnFalse();\n    }\n\n    /**\n     * byte argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static byte eq(byte value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * char argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static char eq(char value) {\n        return reportMatcher(new Equals(value)).returnChar();\n    }\n\n    /**\n     * double argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static double eq(double value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * float argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static float eq(float value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n    \n    /**\n     * int argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static int eq(int value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * long argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static long eq(long value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * short argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static short eq(short value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * Object argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T eq(T value) {\n        return reportMatcher(new Equals(value)).<T>returnNull();\n    }  \n\n    /**\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     */\n    public static <T> T refEq(T value, String... excludeFields) {\n        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();\n    }\n    \n    /**\n     * Object argument that is the same as the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T same(T value) {\n        return reportMatcher(new Same(value)).<T>returnNull();\n    }\n\n    /**\n     * null argument.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNull() {\n        return reportMatcher(Null.NULL).returnNull();\n    }\n\n    /**\n     * not null argument.\n     * <p>\n     * alias to {@link Matchers#isNotNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object notNull() {\n        return reportMatcher(NotNull.NOT_NULL).returnNull();\n    }\n    \n    /**\n     * not null argument.\n     * <p>\n     * alias to {@link Matchers#notNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNotNull() {\n        return notNull();\n    }\n\n    /**\n     * String argument that contains the given substring.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param substring\n     *            the substring.\n     * @return empty String (\"\").\n     */\n    public static String contains(String substring) {\n        return reportMatcher(new Contains(substring)).returnString();\n    }\n\n    /**\n     * String argument that matches the given regular expression.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param regex\n     *            the regular expression.\n     * @return empty String (\"\").\n     */\n    public static String matches(String regex) {\n        return reportMatcher(new Matches(regex)).returnString();\n    }\n\n    /**\n     * String argument that ends with the given suffix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param suffix\n     *            the suffix.\n     * @return empty String (\"\").\n     */\n    public static String endsWith(String suffix) {\n        return reportMatcher(new EndsWith(suffix)).returnString();\n    }\n\n    /**\n     * String argument that starts with the given prefix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param prefix\n     *            the prefix.\n     * @return empty String (\"\").\n     */\n    public static String startsWith(String prefix) {\n        return reportMatcher(new StartsWith(prefix)).returnString();\n    }\n\n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link ArgumentMatcher} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>null</code>.\n     */\n    public static <T> T argThat(Matcher<T> matcher) {\n        return reportMatcher(matcher).<T>returnNull();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static char charThat(Matcher<Character> matcher) {\n        return reportMatcher(matcher).returnChar();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     */\n    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        return reportMatcher(matcher).returnFalse();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static byte byteThat(Matcher<Byte> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static short shortThat(Matcher<Short> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static int intThat(Matcher<Integer> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static long longThat(Matcher<Long> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static float floatThat(Matcher<Float> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static double doubleThat(Matcher<Double> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.matchers.apachecommons.ReflectionEquals;\nimport org.mockito.internal.progress.HandyReturnValues;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\n\n/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre>\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </pre>\n * \n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre>\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre>\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\n@SuppressWarnings(\"unchecked\")\npublic class Matchers {\n    \n    private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    /**\n     * any boolean, Boolean or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean() {\n        return reportMatcher(Any.ANY).returnFalse();\n    }\n\n    /**\n     * any byte, Byte or null\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static byte anyByte() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any char, Character or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static char anyChar() {\n        return reportMatcher(Any.ANY).returnChar();\n    }\n\n    /**\n     * any int, Integer or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static int anyInt() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any long, Long or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static long anyLong() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any float, Float or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static float anyFloat() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any double, Double or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static double anyDouble() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any short, Short or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static short anyShort() {\n        return reportMatcher(Any.ANY).returnZero();\n    }\n\n    /**\n     * any Object or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T anyObject() {\n        return (T) reportMatcher(Any.ANY).returnNull();\n    }\n    //TODO: after 1.8 check out Jay Fields' idea on any() matcher\n\n    /**\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre>\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     */\n    public static <T> T anyVararg() {\n        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();\n    }\n    \n    /**\n     * any kind object, not necessary of the given class.\n     * The class argument is provided only to avoid casting.\n     * <p>\n     * Sometimes looks better than anyObject() - especially when explicit casting is required\n     * <p>\n     * Alias to {@link Matchers#anyObject()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any(Class<T> clazz) {\n        return (T) anyObject();\n    }\n    \n    /**\n     * any object or null \n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any() {\n        return (T) anyObject();\n    }\n\n    /**\n     * any String or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     */\n    public static String anyString() {\n        return reportMatcher(Any.ANY).returnString();\n    }\n    \n    /**\n     * any List or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static List anyList() {\n        return reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * any List or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static <T> List<T> anyListOf(Class<T> clazz) {\n        return (List) reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * any Set or null\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static Set anySet() {\n        return reportMatcher(Any.ANY).returnSet();\n    }\n    \n    /**\n     * generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * any Set or null\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static <T> Set<T> anySetOf(Class<T> clazz) {\n        return (Set) reportMatcher(Any.ANY).returnSet();\n    }\n\n    /**\n     * any Map or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     */\n    public static Map anyMap() {\n        return reportMatcher(Any.ANY).returnMap();\n    }    \n    \n    /**\n     * any Collection or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static Collection anyCollection() {\n        return reportMatcher(Any.ANY).returnList();\n    }    \n    \n    /**\n     * generic friendly alias to {@link Matchers#anyCollection()}. \n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.     \n     * <p>\n     * any Collection or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n        return (Collection) reportMatcher(Any.ANY).returnList();\n    }    \n\n    /**\n     * Object argument that implements the given class. \n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the accepted type.\n     * @param clazz\n     *            the class of the accepted type.\n     * @return <code>null</code>.\n     */\n    public static <T> T isA(Class<T> clazz) {\n        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\n    }\n\n    /**\n     * boolean argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static boolean eq(boolean value) {\n        return reportMatcher(new Equals(value)).returnFalse();\n    }\n\n    /**\n     * byte argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static byte eq(byte value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * char argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static char eq(char value) {\n        return reportMatcher(new Equals(value)).returnChar();\n    }\n\n    /**\n     * double argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static double eq(double value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * float argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static float eq(float value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n    \n    /**\n     * int argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static int eq(int value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * long argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static long eq(long value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * short argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static short eq(short value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }\n\n    /**\n     * Object argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T eq(T value) {\n        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());\n    }  \n\n    /**\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     */\n    public static <T> T refEq(T value, String... excludeFields) {\n        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();\n    }\n    \n    /**\n     * Object argument that is the same as the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     */\n    public static <T> T same(T value) {\n        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());\n    }\n\n    /**\n     * null argument.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNull() {\n        return reportMatcher(Null.NULL).returnNull();\n    }\n\n    /**\n     * not null argument.\n     * <p>\n     * alias to {@link Matchers#isNotNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object notNull() {\n        return reportMatcher(NotNull.NOT_NULL).returnNull();\n    }\n    \n    /**\n     * not null argument.\n     * <p>\n     * alias to {@link Matchers#notNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static Object isNotNull() {\n        return notNull();\n    }\n\n    /**\n     * String argument that contains the given substring.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param substring\n     *            the substring.\n     * @return empty String (\"\").\n     */\n    public static String contains(String substring) {\n        return reportMatcher(new Contains(substring)).returnString();\n    }\n\n    /**\n     * String argument that matches the given regular expression.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param regex\n     *            the regular expression.\n     * @return empty String (\"\").\n     */\n    public static String matches(String regex) {\n        return reportMatcher(new Matches(regex)).returnString();\n    }\n\n    /**\n     * String argument that ends with the given suffix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param suffix\n     *            the suffix.\n     * @return empty String (\"\").\n     */\n    public static String endsWith(String suffix) {\n        return reportMatcher(new EndsWith(suffix)).returnString();\n    }\n\n    /**\n     * String argument that starts with the given prefix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param prefix\n     *            the prefix.\n     * @return empty String (\"\").\n     */\n    public static String startsWith(String prefix) {\n        return reportMatcher(new StartsWith(prefix)).returnString();\n    }\n\n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link ArgumentMatcher} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>null</code>.\n     */\n    public static <T> T argThat(Matcher<T> matcher) {\n        return reportMatcher(matcher).<T>returnNull();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static char charThat(Matcher<Character> matcher) {\n        return reportMatcher(matcher).returnChar();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     */\n    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        return reportMatcher(matcher).returnFalse();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static byte byteThat(Matcher<Byte> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static short shortThat(Matcher<Short> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static int intThat(Matcher<Integer> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static long longThat(Matcher<Long> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static float floatThat(Matcher<Float> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n    \n    /**\n     * Allows creating custom argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static double doubleThat(Matcher<Double> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }\n\n    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n    }\n}"}]}
{"project": "Mockito", "bug_id": 36, "classes_modified": [{"class_name": "org.mockito.internal.invocation.Invocation", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.util.*;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.invocation.realmethod.RealMethod;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\nimport org.mockito.internal.util.*;\nimport org.mockito.invocation.InvocationOnMock;\n\n/**\n * Method call on a mock object.\n * <p>\n * Contains sequence number which should be globally unique and is used for\n * verification in order.\n * <p>\n * Contains stack trace of invocation\n */\n@SuppressWarnings(\"unchecked\")\npublic class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {\n\n    private static final long serialVersionUID = 8240069639250980199L;\n    private static final int MAX_LINE_LENGTH = 45;\n    private final int sequenceNumber;\n    private final Object mock;\n    private final MockitoMethod method;\n    private final Object[] arguments;\n    private final Object[] rawArguments;\n\n    private final Location location;\n    private boolean verified;\n    private boolean verifiedInOrder;\n\n    final RealMethod realMethod;\n\n    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new Location();\n    }\n\n    // expands array varArgs that are given by runtime (1, [a, b]) into true\n    // varArgs (1, a, b);\n    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }\n\n    public Object getMock() {\n        return mock;\n    }\n\n    public MockitoMethod getMethod() {\n        return method;\n    }\n\n    public Object[] getArguments() {\n        return arguments;\n    }\n\n    public boolean isVerified() {\n        return verified;\n    }\n\n    public Integer getSequenceNumber() {\n        return sequenceNumber;\n    }\n\n    public boolean isVerifiedInOrder() {\n        return verifiedInOrder;\n    }\n\n    public boolean equals(Object o) {\n        if (o == null || !o.getClass().equals(this.getClass())) {\n            return false;\n        }\n\n        Invocation other = (Invocation) o;\n\n        return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);\n    }\n\n    private boolean equalArguments(Object[] arguments) {\n        return Arrays.equals(arguments, this.arguments);\n    }\n\n    public int hashCode() {\n        throw new RuntimeException(\"hashCode() is not implemented\");\n    }\n\n    public String toString() {\n        return toString(argumentsToMatchers(), new PrintSettings());\n    }\n\n    protected String toString(List<Matcher> matchers, PrintSettings printSettings) {\n        MatchersPrinter matchersPrinter = new MatchersPrinter();\n        String method = qualifiedMethodName();\n        String invocation = method + matchersPrinter.getArgumentsLine(matchers, printSettings);\n        if (printSettings.isMultiline() || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n            return method + matchersPrinter.getArgumentsBlock(matchers, printSettings);\n        } else {\n            return invocation;\n        }\n    }\n\n    private String qualifiedMethodName() {\n        return new MockUtil().getMockName(mock) + \".\" + method.getName();\n    }\n\n    protected List<Matcher> argumentsToMatchers() {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }\n\n    public static boolean isToString(InvocationOnMock invocation) {\n        return new ObjectMethodsGuru().isToString(invocation.getMethod());\n    }\n\n    public boolean isValidException(Throwable throwable) {\n        Class<?>[] exceptions = this.getMethod().getExceptionTypes();\n        Class<?> throwableClass = throwable.getClass();\n        for (Class<?> exception : exceptions) {\n            if (exception.isAssignableFrom(throwableClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean isValidReturnType(Class clazz) {\n        if (method.getReturnType().isPrimitive()) {\n            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n        } else {\n            return method.getReturnType().isAssignableFrom(clazz);\n        }\n    }\n\n    public boolean isVoid() {\n        return this.method.getReturnType() == Void.TYPE;\n    }\n\n    public String printMethodReturnType() {\n        return method.getReturnType().getSimpleName();\n    }\n\n    public String getMethodName() {\n        return method.getName();\n    }\n\n    public boolean returnsPrimitive() {\n        return method.getReturnType().isPrimitive();\n    }\n\n    public Location getLocation() {\n        return location;\n    }\n\n    public int getArgumentsCount() {\n        return arguments.length;\n    }\n\n    public Object[] getRawArguments() {\n        return this.rawArguments;\n    }\n\n    public Object callRealMethod() throws Throwable {\n        return realMethod.invoke(mock, rawArguments);\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return toString(argumentsToMatchers(), printSettings);\n    }\n\n    void markVerified() {\n        this.verified = true;\n    }\n\n    void markVerifiedInOrder() {\n        markVerified();\n        this.verifiedInOrder = true;\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.util.*;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.invocation.realmethod.RealMethod;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\nimport org.mockito.internal.util.*;\nimport org.mockito.invocation.InvocationOnMock;\n\n/**\n * Method call on a mock object.\n * <p>\n * Contains sequence number which should be globally unique and is used for\n * verification in order.\n * <p>\n * Contains stack trace of invocation\n */\n@SuppressWarnings(\"unchecked\")\npublic class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {\n\n    private static final long serialVersionUID = 8240069639250980199L;\n    private static final int MAX_LINE_LENGTH = 45;\n    private final int sequenceNumber;\n    private final Object mock;\n    private final MockitoMethod method;\n    private final Object[] arguments;\n    private final Object[] rawArguments;\n\n    private final Location location;\n    private boolean verified;\n    private boolean verifiedInOrder;\n\n    final RealMethod realMethod;\n\n    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new Location();\n    }\n\n    // expands array varArgs that are given by runtime (1, [a, b]) into true\n    // varArgs (1, a, b);\n    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }\n\n    public Object getMock() {\n        return mock;\n    }\n\n    public MockitoMethod getMethod() {\n        return method;\n    }\n\n    public Object[] getArguments() {\n        return arguments;\n    }\n\n    public boolean isVerified() {\n        return verified;\n    }\n\n    public Integer getSequenceNumber() {\n        return sequenceNumber;\n    }\n\n    public boolean isVerifiedInOrder() {\n        return verifiedInOrder;\n    }\n\n    public boolean equals(Object o) {\n        if (o == null || !o.getClass().equals(this.getClass())) {\n            return false;\n        }\n\n        Invocation other = (Invocation) o;\n\n        return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);\n    }\n\n    private boolean equalArguments(Object[] arguments) {\n        return Arrays.equals(arguments, this.arguments);\n    }\n\n    public int hashCode() {\n        throw new RuntimeException(\"hashCode() is not implemented\");\n    }\n\n    public String toString() {\n        return toString(argumentsToMatchers(), new PrintSettings());\n    }\n\n    protected String toString(List<Matcher> matchers, PrintSettings printSettings) {\n        MatchersPrinter matchersPrinter = new MatchersPrinter();\n        String method = qualifiedMethodName();\n        String invocation = method + matchersPrinter.getArgumentsLine(matchers, printSettings);\n        if (printSettings.isMultiline() || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n            return method + matchersPrinter.getArgumentsBlock(matchers, printSettings);\n        } else {\n            return invocation;\n        }\n    }\n\n    private String qualifiedMethodName() {\n        return new MockUtil().getMockName(mock) + \".\" + method.getName();\n    }\n\n    protected List<Matcher> argumentsToMatchers() {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }\n\n    public static boolean isToString(InvocationOnMock invocation) {\n        return new ObjectMethodsGuru().isToString(invocation.getMethod());\n    }\n\n    public boolean isValidException(Throwable throwable) {\n        Class<?>[] exceptions = this.getMethod().getExceptionTypes();\n        Class<?> throwableClass = throwable.getClass();\n        for (Class<?> exception : exceptions) {\n            if (exception.isAssignableFrom(throwableClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean isValidReturnType(Class clazz) {\n        if (method.getReturnType().isPrimitive()) {\n            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n        } else {\n            return method.getReturnType().isAssignableFrom(clazz);\n        }\n    }\n\n    public boolean isVoid() {\n        return this.method.getReturnType() == Void.TYPE;\n    }\n\n    public String printMethodReturnType() {\n        return method.getReturnType().getSimpleName();\n    }\n\n    public String getMethodName() {\n        return method.getName();\n    }\n\n    public boolean returnsPrimitive() {\n        return method.getReturnType().isPrimitive();\n    }\n\n    public Location getLocation() {\n        return location;\n    }\n\n    public int getArgumentsCount() {\n        return arguments.length;\n    }\n\n    public Object[] getRawArguments() {\n        return this.rawArguments;\n    }\n\n    public Object callRealMethod() throws Throwable {\n        if (this.getMethod().getDeclaringClass().isInterface()) {\n            new Reporter().cannotCallRealMethodOnInterface();\n        }\n        return realMethod.invoke(mock, rawArguments);\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return toString(argumentsToMatchers(), printSettings);\n    }\n\n    void markVerified() {\n        this.verified = true;\n    }\n\n    void markVerifiedInOrder() {\n        markVerified();\n        this.verifiedInOrder = true;\n    }\n}"}]}
{"project": "Mockito", "bug_id": 37, "classes_modified": [{"class_name": "org.mockito.internal.stubbing.answers.AnswersValidator", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.answers;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.stubbing.Answer;\n\npublic class AnswersValidator {\n\n    private Reporter reporter = new Reporter();\n    \n    public void validate(Answer<?> answer, Invocation invocation) {\n        if (answer instanceof ThrowsException) {\n            validateException((ThrowsException) answer, invocation);\n        }\n        \n        if (answer instanceof Returns) {\n            validateReturnValue((Returns) answer, invocation);\n        }\n        \n        if (answer instanceof DoesNothing) {\n            validateDoNothing((DoesNothing) answer, invocation);\n        }\n        \n    }\n\n\n    private void validateDoNothing(DoesNothing answer, Invocation invocation) {\n        if (!invocation.isVoid()) {\n            reporter.onlyVoidMethodsCanBeSetToDoNothing();\n        }\n    }\n\n    private void validateReturnValue(Returns answer, Invocation invocation) {\n        if (invocation.isVoid()) {\n            reporter.cannotStubVoidMethodWithAReturnValue();\n        }\n        \n        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n        } \n\n        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n        }\n    }\n\n    private void validateException(ThrowsException answer, Invocation invocation) {\n        Throwable throwable = answer.getThrowable();\n        if (throwable == null) {\n            reporter.cannotStubWithNullThrowable();\n        }\n        \n        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n            return;\n        }\n        \n        if (!invocation.isValidException(throwable)) {\n            reporter.checkedExceptionInvalid(throwable);\n        }\n    }\n}", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.answers;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.invocation.Invocation;\nimport org.mockito.stubbing.Answer;\n\npublic class AnswersValidator {\n\n    private Reporter reporter = new Reporter();\n    \n    public void validate(Answer<?> answer, Invocation invocation) {\n        if (answer instanceof ThrowsException) {\n            validateException((ThrowsException) answer, invocation);\n        }\n        \n        if (answer instanceof Returns) {\n            validateReturnValue((Returns) answer, invocation);\n        }\n        \n        if (answer instanceof DoesNothing) {\n            validateDoNothing((DoesNothing) answer, invocation);\n        }\n        \n        if (answer instanceof CallsRealMethods) {\n            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\n        }\n    }\n\n    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\n        if (invocation.getMethod().getDeclaringClass().isInterface()) {\n            reporter.cannotCallRealMethodOnInterface();\n        }\n    }\n\n    private void validateDoNothing(DoesNothing answer, Invocation invocation) {\n        if (!invocation.isVoid()) {\n            reporter.onlyVoidMethodsCanBeSetToDoNothing();\n        }\n    }\n\n    private void validateReturnValue(Returns answer, Invocation invocation) {\n        if (invocation.isVoid()) {\n            reporter.cannotStubVoidMethodWithAReturnValue();\n        }\n        \n        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n        } \n\n        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n        }\n    }\n\n    private void validateException(ThrowsException answer, Invocation invocation) {\n        Throwable throwable = answer.getThrowable();\n        if (throwable == null) {\n            reporter.cannotStubWithNullThrowable();\n        }\n        \n        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n            return;\n        }\n        \n        if (!invocation.isValidException(throwable)) {\n            reporter.checkedExceptionInvalid(throwable);\n        }\n    }\n}"}]}
{"project": "Mockito", "bug_id": 38, "classes_modified": [{"class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool", "buggy_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification.argumentmatching;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.mockito.internal.matchers.ContainsExtraTypeInformation;\n\n@SuppressWarnings(\"unchecked\")\npublic class ArgumentMatchingTool {\n\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }\n\n    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }\n}\n", "fixed_version": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.verification.argumentmatching;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.StringDescription;\nimport org.mockito.internal.matchers.ContainsExtraTypeInformation;\n\n@SuppressWarnings(\"unchecked\")\npublic class ArgumentMatchingTool {\n\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }\n\n    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }\n}\n"}]}
