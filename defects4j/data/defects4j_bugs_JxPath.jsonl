{"project": "JxPath", "bug_id": 1, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        else if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n        }\n        else if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        else if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null) {\n            return s2 == null || s2.trim().length() == 0;\n        }\n        \n        if (s2 == null) {\n            return s1 == null || s1.trim().length() == 0;\n        }\n\n        if (s1 != null && !s1.trim().equals(s2.trim())) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        if (current == null) {\n            return super.isLanguage(lang);\n        }\n        return current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        Node n = node;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(\"xml:lang\");\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (equalStrings(nsURI, \n                            getNamespaceResolver().getDefaultNamespaceURI())) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof DOMNodePointer)) {\n            return false;\n        }\n\n        DOMNodePointer other = (DOMNodePointer) object;\n        return node == other.node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        if (index == -1) {\n            return null;\n        }\n\n        return name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        if (index == -1) {\n            return name;\n        }\n\n        return name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String qname;\n        String prefix = getPrefix(node);\n        if (prefix == null) {\n            qname = \"xmlns\";\n        }\n        else {\n            qname = \"xmlns:\" + prefix;\n        }\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        else if (\n            nodeType == Node.TEXT_NODE\n                || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : text.trim();\n        }\n        else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        else {\n            NodeList list = node.getChildNodes();\n            StringBuffer buf = new StringBuffer(16);\n            for (int i = 0; i < list.getLength(); i++) {\n                Node child = list.item(i);\n                if (child.getNodeType() == Node.TEXT_NODE) {\n                    buf.append(child.getNodeValue());\n                }\n                else {\n                    buf.append(stringValue(child));\n                }\n            }\n            return buf.toString().trim();\n        }\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document;\n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            document = (Document) node;\n        }\n        else {\n            document = node.getOwnerDocument();\n        }\n        Element element = document.getElementById(id);\n        if (element != null) {\n            return new DOMNodePointer(element, getLocale(), id);\n        }\n        else {\n            return new NullPointer(getLocale(), id);\n        }\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            else if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n\n        return 0;\n    }\n}", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        else if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n        }\n        else if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        else if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null) {\n            return s2 == null || s2.trim().length() == 0;\n        }\n        \n        if (s2 == null) {\n            return s1 == null || s1.trim().length() == 0;\n        }\n\n        if (s1 != null && !s1.trim().equals(s2.trim())) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        if (current == null) {\n            return super.isLanguage(lang);\n        }\n        return current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        Node n = node;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(\"xml:lang\");\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (equalStrings(nsURI, \n                            getNamespaceResolver().getDefaultNamespaceURI())) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof DOMNodePointer)) {\n            return false;\n        }\n\n        DOMNodePointer other = (DOMNodePointer) object;\n        return node == other.node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        if (index == -1) {\n            return null;\n        }\n\n        return name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        if (index == -1) {\n            return name;\n        }\n\n        return name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String qname;\n        String prefix = getPrefix(node);\n        if (prefix == null) {\n            qname = \"xmlns\";\n        }\n        else {\n            qname = \"xmlns:\" + prefix;\n        }\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        else if (\n            nodeType == Node.TEXT_NODE\n                || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : text.trim();\n        }\n        else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        else {\n            NodeList list = node.getChildNodes();\n            StringBuffer buf = new StringBuffer(16);\n            for (int i = 0; i < list.getLength(); i++) {\n                Node child = list.item(i);\n                if (child.getNodeType() == Node.TEXT_NODE) {\n                    buf.append(child.getNodeValue());\n                }\n                else {\n                    buf.append(stringValue(child));\n                }\n            }\n            return buf.toString().trim();\n        }\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document;\n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            document = (Document) node;\n        }\n        else {\n            document = node.getOwnerDocument();\n        }\n        Element element = document.getElementById(id);\n        if (element != null) {\n            return new DOMNodePointer(element, getLocale(), id);\n        }\n        else {\n            return new NullPointer(getLocale(), id);\n        }\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            else if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n\n        return 0;\n    }\n}"}, {"class_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    \n    private Object node;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n    \n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (node instanceof Document) {\n            Element element = ((Document)node).getRootElement(); \n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }        \n        else if (node instanceof Element) {\n            Element element = (Element) node;\n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }\n        return null;\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) \n    {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        else if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        else if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            else if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n    \n    public int getLength() {\n        return 1;\n    }    \n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        else if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n     */\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            return ((Element) node).getTextTrim();\n        }\n        else if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        else if (node instanceof Text) {\n            return ((Text) node).getTextTrim();\n        }\n        else if (node instanceof CDATA) {\n            return ((CDATA) node).getTextTrim();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String text = ((ProcessingInstruction) node).getData();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        return null;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    } \n      \n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n    \n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test) \n    {\n        if (test == null) {\n            return true;\n        }\n        else if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n\n        }\n        else if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return node instanceof Element;\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        else if (test instanceof ProcessingInstructionTest) {\n            if (node instanceof ProcessingInstruction) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null && s2 != null) {\n            return false;\n        }\n        if (s1 != null && s2 == null) {\n            return false;\n        }\n\n        if (s1 != null && !s1.trim().equals(s2.trim())) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        else if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n    \n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        else if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        if (current == null) {\n            return super.isLanguage(lang);\n        }\n        return current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        Object n = node;\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr =\n                    e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n    \n    private Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (parent instanceof Element) {\n                return (Element) parent;\n            }\n        }\n        else if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        else if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        else if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            Namespace ns = element.getNamespace(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n                \n                if (equalStrings(nsURI, \n                        getNamespaceResolver().getDefaultNamespaceURI())) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String target = ((ProcessingInstruction) node).getTarget();\n            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n            \n            List children = ((Element)parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n    \n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n}", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    \n    private Object node;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n    \n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (node instanceof Document) {\n            Element element = ((Document)node).getRootElement(); \n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }        \n        else if (node instanceof Element) {\n            Element element = (Element) node;\n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }\n        return null;\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) \n    {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        else if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        else if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            else if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n    \n    public int getLength() {\n        return 1;\n    }    \n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        else if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n     */\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            return ((Element) node).getTextTrim();\n        }\n        else if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        else if (node instanceof Text) {\n            return ((Text) node).getTextTrim();\n        }\n        else if (node instanceof CDATA) {\n            return ((CDATA) node).getTextTrim();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String text = ((ProcessingInstruction) node).getData();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        return null;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    } \n      \n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n    \n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test) \n    {\n        if (test == null) {\n            return true;\n        }\n        else if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n\n        }\n        else if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return (node instanceof Element) || (node instanceof Document);\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        else if (test instanceof ProcessingInstructionTest) {\n            if (node instanceof ProcessingInstruction) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null && s2 != null) {\n            return false;\n        }\n        if (s1 != null && s2 == null) {\n            return false;\n        }\n\n        if (s1 != null && !s1.trim().equals(s2.trim())) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        else if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n    \n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        else if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        if (current == null) {\n            return super.isLanguage(lang);\n        }\n        return current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        Object n = node;\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr =\n                    e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n    \n    private Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (parent instanceof Element) {\n                return (Element) parent;\n            }\n        }\n        else if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        else if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        else if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            Namespace ns = element.getNamespace(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n                \n                if (equalStrings(nsURI, \n                        getNamespaceResolver().getDefaultNamespaceURI())) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String target = ((ProcessingInstruction) node).getTarget();\n            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n            \n            List children = ((Element)parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n    \n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n}"}]}
{"project": "JxPath", "bug_id": 2, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.Expression", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.util.ValueUtils;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Locale;\n\n/**\n * Common superclass for several types of nodes in the parse tree. Provides\n * APIs for optimization of evaluation of expressions.  Specifically, an\n * expression only needs to executed once during the evaluation of an xpath\n * if that expression is context-independent.  Expression.isContextDependent()\n * provides that hint.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class Expression {\n\n    protected static final Double ZERO = new Double(0);\n    protected static final Double ONE = new Double(1);\n    protected static final Double NOT_A_NUMBER = new Double(Double.NaN);\n\n    private boolean contextDependencyKnown = false;\n    private boolean contextDependent;\n\n    /**\n     * Returns true if this expression should be re-evaluated\n     * each time the current position in the context changes.\n     */\n    public boolean isContextDependent() {\n        if (!contextDependencyKnown) {\n            contextDependent = computeContextDependent();\n            contextDependencyKnown = true;\n        }\n        return contextDependent;\n    }\n\n    /**\n     * Implemented by subclasses and result is cached by isContextDependent()\n     */\n    public abstract boolean computeContextDependent();\n\n    /**\n     * Evaluates the expression. If the result is a node set, returns\n     * the first element of the node set.\n     */\n    public abstract Object computeValue(EvalContext context);\n    public abstract Object compute(EvalContext context);\n\n    public Iterator iterate(EvalContext context) {\n        Object result = compute(context);\n        if (result instanceof EvalContext) {\n            return new ValueIterator((EvalContext) result);\n        }\n        return ValueUtils.iterate(result);\n    }\n\n    public Iterator iteratePointers(EvalContext context) {\n        Object result = compute(context);\n        if (result == null) {\n            return Collections.EMPTY_LIST.iterator();\n        }\n        if (result instanceof EvalContext) {\n            return (EvalContext) result;\n        }\n        return new PointerIterator(ValueUtils.iterate(result),\n                new QName(null, \"value\"),\n                context.getRootContext().getCurrentNodePointer().getLocale());\n    }\n\n    public static class PointerIterator implements Iterator {\n        private Iterator iterator;\n        private QName qname;\n        private Locale locale;\n\n        //to what method does the following comment refer?\n        /**\n         * @deprecated Use the method that takes a NamespaceManager\n         */\n        public PointerIterator(Iterator it, QName qname, Locale locale) {\n            this.iterator = it;\n            this.qname = qname;\n            this.locale = locale;\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            Object o = iterator.next();\n            return o instanceof Pointer ? o : NodePointer.newNodePointer(qname, o, locale);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    public static class ValueIterator implements Iterator {\n        private Iterator iterator;\n\n        public ValueIterator(Iterator it) {\n            this.iterator = it;\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            Object o = iterator.next();\n            if (o instanceof Pointer) {\n                return ((Pointer) o).getValue();\n            }\n            return o;\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport org.apache.commons.jxpath.NodeSet;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.util.ValueUtils;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Locale;\n\n/**\n * Common superclass for several types of nodes in the parse tree. Provides\n * APIs for optimization of evaluation of expressions.  Specifically, an\n * expression only needs to executed once during the evaluation of an xpath\n * if that expression is context-independent.  Expression.isContextDependent()\n * provides that hint.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class Expression {\n\n    protected static final Double ZERO = new Double(0);\n    protected static final Double ONE = new Double(1);\n    protected static final Double NOT_A_NUMBER = new Double(Double.NaN);\n\n    private boolean contextDependencyKnown = false;\n    private boolean contextDependent;\n\n    /**\n     * Returns true if this expression should be re-evaluated\n     * each time the current position in the context changes.\n     */\n    public boolean isContextDependent() {\n        if (!contextDependencyKnown) {\n            contextDependent = computeContextDependent();\n            contextDependencyKnown = true;\n        }\n        return contextDependent;\n    }\n\n    /**\n     * Implemented by subclasses and result is cached by isContextDependent()\n     */\n    public abstract boolean computeContextDependent();\n\n    /**\n     * Evaluates the expression. If the result is a node set, returns\n     * the first element of the node set.\n     */\n    public abstract Object computeValue(EvalContext context);\n    public abstract Object compute(EvalContext context);\n\n    public Iterator iterate(EvalContext context) {\n        Object result = compute(context);\n        if (result instanceof EvalContext) {\n            return new ValueIterator((EvalContext) result);\n        }\n        if (result instanceof NodeSet) {\n            return new ValueIterator(((NodeSet) result).getPointers().iterator());\n        }\n        return ValueUtils.iterate(result);\n    }\n\n    public Iterator iteratePointers(EvalContext context) {\n        Object result = compute(context);\n        if (result == null) {\n            return Collections.EMPTY_LIST.iterator();\n        }\n        if (result instanceof EvalContext) {\n            return (EvalContext) result;\n        }\n        if (result instanceof NodeSet) {\n            return new PointerIterator(((NodeSet) result).getPointers().iterator(),\n                    new QName(null, \"value\"),\n                    context.getRootContext().getCurrentNodePointer().getLocale());\n        }\n        return new PointerIterator(ValueUtils.iterate(result),\n                new QName(null, \"value\"),\n                context.getRootContext().getCurrentNodePointer().getLocale());\n    }\n\n    public static class PointerIterator implements Iterator {\n        private Iterator iterator;\n        private QName qname;\n        private Locale locale;\n\n        //to what method does the following comment refer?\n        /**\n         * @deprecated Use the method that takes a NamespaceManager\n         */\n        public PointerIterator(Iterator it, QName qname, Locale locale) {\n            this.iterator = it;\n            this.qname = qname;\n            this.locale = locale;\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            Object o = iterator.next();\n            return o instanceof Pointer ? o : NodePointer.newNodePointer(qname, o, locale);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    public static class ValueIterator implements Iterator {\n        private Iterator iterator;\n\n        public ValueIterator(Iterator it) {\n            this.iterator = it;\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            Object o = iterator.next();\n            if (o instanceof Pointer) {\n                return ((Pointer) o).getValue();\n            }\n            return o;\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}"}]}
{"project": "JxPath", "bug_id": 3, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.beans;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathInvalidAccessException;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NullPropertyPointer extends PropertyPointer {\n\n    private String propertyName = \"*\";\n    private boolean byNameAttribute = false;\n\n    /**\n     */\n    public NullPropertyPointer(NodePointer parent) {\n        super(parent);\n    }\n\n    public QName getName() {\n        return new QName(propertyName);\n    }\n\n    public void setPropertyIndex(int index) {\n    }\n\n    public int getLength() {\n        return 0;\n    }\n\n    public Object getBaseValue() {\n        return null;\n    }\n\n    public Object getImmediateNode() {\n        return null;\n    }\n\n    public boolean isLeaf() {\n        return true;\n    }    \n\n    public NodePointer getValuePointer() {\n        return new NullPointer(this,  new QName(getPropertyName()));\n    }\n\n    protected boolean isActualProperty() {\n        return false;\n    }\n\n    public boolean isActual() {\n        return false;\n    }\n\n    public boolean isContainer() {\n        return true;\n    }\n\n    public void setValue(Object value) {\n        if (parent == null || parent.isContainer()) {\n            throw new JXPathInvalidAccessException(\n                \"Cannot set property \"\n                    + asPath()\n                    + \", the target object is null\");\n        }\n        else if (parent instanceof PropertyOwnerPointer &&\n                ((PropertyOwnerPointer) parent).\n                    isDynamicPropertyDeclarationSupported()){\n            // If the parent property owner can create\n            // a property automatically - let it do so\n            PropertyPointer propertyPointer =\n                ((PropertyOwnerPointer) parent).getPropertyPointer();\n            propertyPointer.setPropertyName(propertyName);\n            propertyPointer.setValue(value);\n        }\n        else {\n            throw new JXPathInvalidAccessException(\n                \"Cannot set property \"\n                    + asPath()\n                    + \", path does not match a changeable location\");\n        }\n    }\n\n    public NodePointer createPath(JXPathContext context) {\n        NodePointer newParent = parent.createPath(context);\n        if (isAttribute()) {\n            return newParent.createAttribute(context, getName());\n        }\n        else {\n            // Consider these two use cases:\n            // 1. The parent pointer of NullPropertyPointer is \n            //    a PropertyOwnerPointer other than NullPointer. When we call \n            //    createPath on it, it most likely returns itself. We then\n            //    take a PropertyPointer from it and get the PropertyPointer\n            //    to expand the collection for the corresponding property.\n            //\n            // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n            //    When we call createPath, it may return a PropertyOwnerPointer\n            //    or it may return anything else, like a DOMNodePointer.\n            //    In the former case we need to do exactly what we did in use \n            //    case 1.  In the latter case, we simply request that the \n            //    non-property pointer expand the collection by itself.\n            if (newParent instanceof PropertyOwnerPointer) {\n                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n                newParent = pop.getPropertyPointer();\n            }\n            return newParent.createChild(context, getName(), getIndex());\n        }\n    }\n\n    public NodePointer createPath(JXPathContext context, Object value) {\n        NodePointer newParent = parent.createPath(context);\n        if (isAttribute()) {\n            NodePointer pointer = newParent.createAttribute(context, getName());\n            pointer.setValue(value);\n            return pointer;\n        }\n        else {\n            if (newParent instanceof PropertyOwnerPointer) {\n                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n                newParent = pop.getPropertyPointer();\n            }\n            return newParent.createChild(context, getName(), index, value);\n        }\n    }\n    \n    public NodePointer createChild(\n            JXPathContext context,\n            QName name, \n            int index)\n    {\n        return createPath(context).createChild(context, name, index);\n    }\n        \n    public NodePointer createChild(\n            JXPathContext context,\n            QName name, \n            int index,\n            Object value) \n    {\n        return createPath(context).createChild(context, name, index, value);\n    }\n\n    public String getPropertyName() {\n        return propertyName;\n    }\n\n    public void setPropertyName(String propertyName) {\n        this.propertyName = propertyName;\n    }\n\n    public void setNameAttributeValue(String attributeValue) {\n        this.propertyName = attributeValue;\n        byNameAttribute = true;\n    }\n\n    public boolean isCollection() {\n        return getIndex() != WHOLE_COLLECTION;\n    }\n\n    public int getPropertyCount() {\n        return 0;\n    }\n\n    public String[] getPropertyNames() {\n        return new String[0];\n    }\n\n    public String asPath() {\n        if (!byNameAttribute) {\n            return super.asPath();\n        }\n        else {\n            StringBuffer buffer = new StringBuffer();\n            buffer.append(getImmediateParentPointer().asPath());\n            buffer.append(\"[@name='\");\n            buffer.append(escape(getPropertyName()));\n            buffer.append(\"']\");\n            if (index != WHOLE_COLLECTION) {\n                buffer.append('[').append(index + 1).append(']');\n            }\n            return buffer.toString();\n        }\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.beans;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathInvalidAccessException;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NullPropertyPointer extends PropertyPointer {\n\n    private String propertyName = \"*\";\n    private boolean byNameAttribute = false;\n\n    /**\n     */\n    public NullPropertyPointer(NodePointer parent) {\n        super(parent);\n    }\n\n    public QName getName() {\n        return new QName(propertyName);\n    }\n\n    public void setPropertyIndex(int index) {\n    }\n\n    public int getLength() {\n        return 0;\n    }\n\n    public Object getBaseValue() {\n        return null;\n    }\n\n    public Object getImmediateNode() {\n        return null;\n    }\n\n    public boolean isLeaf() {\n        return true;\n    }    \n\n    public NodePointer getValuePointer() {\n        return new NullPointer(this,  new QName(getPropertyName()));\n    }\n\n    protected boolean isActualProperty() {\n        return false;\n    }\n\n    public boolean isActual() {\n        return false;\n    }\n\n    public boolean isContainer() {\n        return true;\n    }\n\n    public void setValue(Object value) {\n        if (parent == null || parent.isContainer()) {\n            throw new JXPathInvalidAccessException(\n                \"Cannot set property \"\n                    + asPath()\n                    + \", the target object is null\");\n        }\n        else if (parent instanceof PropertyOwnerPointer &&\n                ((PropertyOwnerPointer) parent).\n                    isDynamicPropertyDeclarationSupported()){\n            // If the parent property owner can create\n            // a property automatically - let it do so\n            PropertyPointer propertyPointer =\n                ((PropertyOwnerPointer) parent).getPropertyPointer();\n            propertyPointer.setPropertyName(propertyName);\n            propertyPointer.setValue(value);\n        }\n        else {\n            throw new JXPathInvalidAccessException(\n                \"Cannot set property \"\n                    + asPath()\n                    + \", path does not match a changeable location\");\n        }\n    }\n\n    public NodePointer createPath(JXPathContext context) {\n        NodePointer newParent = parent.createPath(context);\n        if (isAttribute()) {\n            return newParent.createAttribute(context, getName());\n        }\n        else {\n            if (parent instanceof NullPointer && parent.equals(newParent)) {\n                throw createBadFactoryException(context.getFactory());\n            }\n            // Consider these two use cases:\n            // 1. The parent pointer of NullPropertyPointer is \n            //    a PropertyOwnerPointer other than NullPointer. When we call \n            //    createPath on it, it most likely returns itself. We then\n            //    take a PropertyPointer from it and get the PropertyPointer\n            //    to expand the collection for the corresponding property.\n            //\n            // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n            //    When we call createPath, it may return a PropertyOwnerPointer\n            //    or it may return anything else, like a DOMNodePointer.\n            //    In the former case we need to do exactly what we did in use \n            //    case 1.  In the latter case, we simply request that the \n            //    non-property pointer expand the collection by itself.\n            if (newParent instanceof PropertyOwnerPointer) {\n                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n                newParent = pop.getPropertyPointer();\n            }\n            return newParent.createChild(context, getName(), getIndex());\n        }\n    }\n\n    public NodePointer createPath(JXPathContext context, Object value) {\n        NodePointer newParent = parent.createPath(context);\n        if (isAttribute()) {\n            NodePointer pointer = newParent.createAttribute(context, getName());\n            pointer.setValue(value);\n            return pointer;\n        }\n        else {\n            if (parent instanceof NullPointer && parent.equals(newParent)) {\n                throw createBadFactoryException(context.getFactory());\n            }\n            if (newParent instanceof PropertyOwnerPointer) {\n                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n                newParent = pop.getPropertyPointer();\n            }\n            return newParent.createChild(context, getName(), index, value);\n        }\n    }\n    \n    public NodePointer createChild(\n            JXPathContext context,\n            QName name, \n            int index)\n    {\n        return createPath(context).createChild(context, name, index);\n    }\n        \n    public NodePointer createChild(\n            JXPathContext context,\n            QName name, \n            int index,\n            Object value) \n    {\n        return createPath(context).createChild(context, name, index, value);\n    }\n\n    public String getPropertyName() {\n        return propertyName;\n    }\n\n    public void setPropertyName(String propertyName) {\n        this.propertyName = propertyName;\n    }\n\n    public void setNameAttributeValue(String attributeValue) {\n        this.propertyName = attributeValue;\n        byNameAttribute = true;\n    }\n\n    public boolean isCollection() {\n        return getIndex() != WHOLE_COLLECTION;\n    }\n\n    public int getPropertyCount() {\n        return 0;\n    }\n\n    public String[] getPropertyNames() {\n        return new String[0];\n    }\n\n    public String asPath() {\n        if (!byNameAttribute) {\n            return super.asPath();\n        }\n        else {\n            StringBuffer buffer = new StringBuffer();\n            buffer.append(getImmediateParentPointer().asPath());\n            buffer.append(\"[@name='\");\n            buffer.append(escape(getPropertyName()));\n            buffer.append(\"']\");\n            if (index != WHOLE_COLLECTION) {\n                buffer.append('[').append(index + 1).append(']');\n            }\n            return buffer.toString();\n        }\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) {\n        return new JXPathAbstractFactoryException(\"Factory \" + factory\n                + \" reported success creating object for path: \" + asPath()\n                + \" but object was null.  Terminating to avoid stack recursion.\");\n    }\n}"}]}
{"project": "JxPath", "bug_id": 4, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        Node n = node;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(\"xml:lang\");\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (equalStrings(nsURI, \n                            getNamespaceResolver().getDefaultNamespaceURI())) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : text.trim();\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                buf.append(child.getNodeValue());\n            }\n            else {\n            buf.append(stringValue(child));\n            }\n        }\n        return buf.toString().trim();\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (equalStrings(nsURI, \n                            getNamespaceResolver().getDefaultNamespaceURI())) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n\n    private Object node;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n    \n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (node instanceof Document) {\n            Element element = ((Document)node).getRootElement(); \n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }        \n        else if (node instanceof Element) {\n            Element element = (Element) node;\n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }\n        return null;\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) \n    {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n    \n    public int getLength() {\n        return 1;\n    }    \n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n     */\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            return ((Element) node).getTextTrim();\n        }\n        if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        if (node instanceof Text) {\n            return ((Text) node).getTextTrim();\n        }\n        if (node instanceof CDATA) {\n            return ((CDATA) node).getTextTrim();\n        }\n        if (node instanceof ProcessingInstruction) {\n            String text = ((ProcessingInstruction) node).getData();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        return null;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    } \n      \n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n    \n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test) \n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return (node instanceof Element) || (node instanceof Document);\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n    \n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        Object n = node;\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr =\n                    e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n\n    private static Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            return parent instanceof Element ? (Element) parent : null;\n        }\n        if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            Namespace ns = element.getNamespace(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n                \n                if (equalStrings(nsURI, \n                        getNamespaceResolver().getDefaultNamespaceURI())) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String target = ((ProcessingInstruction) node).getTarget();\n            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n            \n            List children = ((Element)parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n    \n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n\n    private Object node;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n    \n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (node instanceof Document) {\n            Element element = ((Document)node).getRootElement(); \n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }        \n        else if (node instanceof Element) {\n            Element element = (Element) node;\n            Namespace ns = element.getNamespace(prefix);\n            if (ns != null) {\n                return ns.getURI();\n            }\n        }\n        return null;\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) \n    {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n    \n    public int getLength() {\n        return 1;\n    }    \n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n     */\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            StringBuffer buf = new StringBuffer();\n            for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) {\n                NodePointer ptr = children.getNodePointer();\n                if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {\n                    buf.append(ptr.getValue());\n                }\n            }\n            return buf.toString();\n        }\n        if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        String result = null;\n        if (node instanceof Text) {\n            result = ((Text) node).getText();\n        }\n        if (node instanceof ProcessingInstruction) {\n            result = ((ProcessingInstruction) node).getData();\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"space\", Namespace.XML_NAMESPACE));\n        return result != null && trim ? result.trim() : result;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    } \n      \n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n    \n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test) \n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return (node instanceof Element) || (node instanceof Document);\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n    \n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n    }\n\n    protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr = e.getAttributeValue(attrName, ns);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n\n    private static Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            return parent instanceof Element ? (Element) parent : null;\n        }\n        if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix != null \n                ? context.getNamespaceURI(prefix) \n                : context.getDefaultNamespaceURI();\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            Namespace ns = element.getNamespace(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n                \n                if (equalStrings(nsURI, \n                        getNamespaceResolver().getDefaultNamespaceURI())) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String target = ((ProcessingInstruction) node).getTarget();\n            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n            \n            List children = ((Element)parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n    \n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n}"}]}
{"project": "JxPath", "bug_id": 5, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.NodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model;\n\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\n\n/**\n * Common superclass for Pointers of all kinds.  A NodePointer maps to\n * a deterministic XPath that represents the location of a node in an \n * object graph. This XPath uses only simple axes: child, namespace and\n * attribute and only simple, context-independent predicates.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class NodePointer implements Pointer {\n\n    public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n    protected int index = WHOLE_COLLECTION;\n    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n    private boolean attribute = false;\n    private transient Object rootNode;\n    private NamespaceResolver namespaceResolver;\n    \n    /**\n     * Allocates an entirely new NodePointer by iterating through all installed\n     * NodePointerFactories until it finds one that can create a pointer.\n     */\n    public static NodePointer newNodePointer(\n        QName name,\n        Object bean,\n        Locale locale) \n    {\n        NodePointer pointer = null;\n        if (bean == null) {\n            pointer = new NullPointer(name, locale);\n            return pointer;\n        }\n        \n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            pointer = factories[i].createNodePointer(name, bean, locale);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    /**\n     * Allocates an new child NodePointer by iterating through all installed\n     * NodePointerFactories until it finds one that can create a pointer.\n     */\n    public static NodePointer newChildNodePointer(\n        NodePointer parent,\n        QName name,\n        Object bean) \n    {\n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            NodePointer pointer =\n                factories[i].createNodePointer(parent, name, bean);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    protected NodePointer parent;\n    protected Locale locale;\n//    private NamespaceManager namespaceManager;\n\n    protected NodePointer(NodePointer parent) {\n        this.parent = parent;\n    }\n\n    protected NodePointer(NodePointer parent, Locale locale) {\n        this.parent = parent;\n        this.locale = locale;\n    }\n\n    public NamespaceResolver getNamespaceResolver() {\n        if (namespaceResolver == null && parent != null) {\n            namespaceResolver = parent.getNamespaceResolver();\n        }\n        return namespaceResolver;\n    }\n    \n    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n        this.namespaceResolver = namespaceResolver;\n    }\n    \n    public NodePointer getParent() {\n        NodePointer pointer = parent;\n        while (pointer != null && pointer.isContainer()) {\n            pointer = pointer.getImmediateParentPointer();\n        }\n        return pointer;\n    }\n    \n    public NodePointer getImmediateParentPointer() {\n        return parent;\n    }\n\n    /**\n     * Set to true if the pointer represents the \"attribute::\" axis.\n     */\n    public void setAttribute(boolean attribute) {\n        this.attribute = attribute;\n    }\n\n    /**\n     * Returns true if the pointer represents the \"attribute::\" axis.\n     */\n    public boolean isAttribute() {\n        return attribute;\n    }\n\n    /**\n     * Returns true if this Pointer has no parent.\n     */\n    public boolean isRoot() {\n        return parent == null;\n    }\n\n    /**\n     * If true, this node does not have children\n     */\n    public abstract boolean isLeaf();\n\n    /**\n     * @deprecated Please use !isContainer()\n     */\n    public boolean isNode() {\n        return !isContainer();\n    }\n     \n    /**\n     * If true, this node is axiliary and can only be used as an intermediate in\n     * the chain of pointers.\n     */\n    public boolean isContainer() {\n        return false;\n    }\n\n    /**\n     * If the pointer represents a collection, the index identifies\n     * an element of that collection.  The default value of <code>index</code>\n     * is <code>WHOLE_COLLECTION</code>, which just means that the pointer\n     * is not indexed at all.\n     * Note: the index on NodePointer starts with 0, not 1.\n     */\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    /**\n     * Returns <code>true</code> if the value of the pointer is an array or\n     * a Collection.\n     */\n    public abstract boolean isCollection();\n\n    /**\n     * If the pointer represents a collection (or collection element),\n     * returns the length of the collection.\n     * Otherwise returns 1 (even if the value is null).\n     */\n    public abstract int getLength();\n\n    /**\n     * By default, returns <code>getNode()</code>, can be overridden to\n     * return a \"canonical\" value, like for instance a DOM element should\n     * return its string value.\n     */\n    public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        // Default behavior is to return the same as getNode() \n        return getNode();\n    }\n\n    /**\n     * If this pointer manages a transparent container, like a variable,\n     * this method returns the pointer to the contents.\n     * Only an auxiliary (non-node) pointer can (and should) return a\n     * value pointer other than itself.\n     * Note that you probably don't want to override \n     * <code>getValuePointer()</code> directly.  Override the\n     * <code>getImmediateValuePointer()</code> method instead.  The\n     * <code>getValuePointer()</code> method is calls\n     * <code>getImmediateValuePointer()</code> and, if the result is not\n     * <code>this</code>, invokes <code>getValuePointer()</code> recursively.\n     * The idea here is to open all nested containers. Let's say we have a\n     * container within a container within a container. The\n     * <code>getValuePointer()</code> method should then open all those\n     * containers and return the pointer to the ultimate contents. It does so\n     * with the above recursion.\n     */\n    public NodePointer getValuePointer() {\n        NodePointer ivp = getImmediateValuePointer();\n        return ivp == this ? this : ivp.getValuePointer();\n    }\n\n    /**\n     * @see #getValuePointer()\n     * \n     * @return NodePointer is either <code>this</code> or a pointer\n     *   for the immediately contained value.\n     */\n    public NodePointer getImmediateValuePointer() {\n        return this;\n    }\n    \n    /**\n     * An actual pointer points to an existing part of an object graph, even\n     * if it is null. A non-actual pointer represents a part that does not exist\n     * at all.\n     * For instance consider the pointer \"/address/street\".\n     * If both <em>address</em> and <em>street</em> are not null,\n     * the pointer is actual.\n     * If <em>address</em> is not null, but <em>street</em> is null,\n     * the pointer is still actual.\n     * If <em>address</em> is null, the pointer is not actual.\n     * (In JavaBeans) if <em>address</em> is not a property of the root bean,\n     * a Pointer for this path cannot be obtained at all - actual or otherwise.\n     */\n    public boolean isActual() {\n        return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n    }\n\n    /**\n     * Returns the name of this node. Can be null.\n     */\n    public abstract QName getName();\n\n    /**\n     * Returns the value represented by the pointer before indexing.\n     * So, if the node represents an element of a collection, this\n     * method returns the collection itself.\n     */\n    public abstract Object getBaseValue();\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     *\n     * @deprecated 1.1 Please use getNode()\n     */\n    public Object getNodeValue() {\n        return getNode();\n    }\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type. Opens containers, properties etc and returns\n     * the ultimate contents.\n     */\n    public Object getNode() {\n        return getValuePointer().getImmediateNode();\n    }\n    \n    public Object getRootNode() {\n        if (rootNode == null) {\n            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n        }\n        return rootNode;\n    }\n    \n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     */\n    public abstract Object getImmediateNode();\n\n    /**\n     * Converts the value to the required type and changes the corresponding\n     * object to that value.\n     */\n    public abstract void setValue(Object value);\n\n    /**\n     * Compares two child NodePointers and returns a positive number,\n     * zero or a positive number according to the order of the pointers.\n     */\n    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    /**\n     *  Called directly by JXPathContext. Must create path and\n     *  set value.\n     */\n    public NodePointer createPath(JXPathContext context, Object value) {\n        setValue(value);\n        return this;\n    }\n\n    /**\n     * Remove the node of the object graph this pointer points to.\n     */\n    public void remove() {\n        // It is a no-op\n\n//        System.err.println(\"REMOVING: \" + asPath() + \" \" + getClass());\n//        printPointerChain();\n    }\n\n    /**\n     * Called by a child pointer when it needs to create a parent object.\n     * Must create an object described by this pointer and return\n     * a new pointer that properly describes the new object.\n     */\n    public NodePointer createPath(JXPathContext context) {\n        return this;\n    }\n\n    /**\n     * Called by a child pointer if that child needs to assign the value\n     * supplied in the createPath(context, value) call to a non-existent\n     * node. This method may have to expand the collection in order to assign\n     * the element.\n     */\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index,\n        Object value) \n    {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n\n    /**\n     * Called by a child pointer when it needs to create a parent object for a\n     * non-existent collection element. It may have to expand the collection,\n     * then create an element object and return a new pointer describing the\n     * newly created element.\n     */\n    public NodePointer createChild(JXPathContext context, QName name, int index)\n    {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n    \n    /**\n     * Called to create a non-existing attribute\n     */\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        throw new JXPathException(\"Cannot create an attribute for path \"\n                + asPath() + \"/@\" + name\n                + \", operation is not allowed for this type of node\");\n    }\n\n    /**\n     * If the Pointer has a parent, returns the parent's locale; otherwise\n     * returns the locale specified when this Pointer was created.\n     */\n    public Locale getLocale() {\n        if (locale == null) {\n            if (parent != null) {\n                locale = parent.getLocale();\n            }\n        }\n        return locale;\n    }\n\n    /**\n     * Returns true if the selected locale name starts\n     * with the specified prefix <i>lang</i>, case-insensitive.\n     */\n    public boolean isLanguage(String lang) {\n        Locale loc = getLocale();\n        String name = loc.toString().replace('_', '-');\n        return name.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n//    /**\n//     * Installs the supplied manager as the namespace manager for this node\n//     * pointer. The {@link #getNamespaceURI(String) getNamespaceURI(prefix)}\n//     * uses this manager to resolve namespace prefixes.\n//     * \n//     * @param namespaceManager\n//     */\n//    public void setNamespaceManager(NamespaceManager namespaceManager) {\n//        this.namespaceManager = namespaceManager;\n//    }\n//    \n//    public NamespaceManager getNamespaceManager() {\n//        if (namespaceManager != null) {\n//            return namespaceManager;\n//        }\n//        if (parent != null) {\n//            return parent.getNamespaceManager();\n//        }        \n//        return null;\n//    }\n//    \n    /**\n     * Returns a NodeIterator that iterates over all children or all children\n     * that match the given NodeTest, starting with the specified one.\n     */\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.childIterator(test, reverse, startWith);\n    }\n\n    /**\n     * Returns a NodeIterator that iterates over all attributes of the current\n     * node matching the supplied node name (could have a wildcard).\n     * May return null if the object does not support the attributes.\n     */\n    public NodeIterator attributeIterator(QName qname) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.attributeIterator(qname);\n    }\n\n    /**\n     * Returns a NodeIterator that iterates over all namespaces of the value\n     * currently pointed at.\n     * May return null if the object does not support the namespaces.\n     */\n    public NodeIterator namespaceIterator() {\n        return null;\n    }\n\n    /**\n     * Returns a NodePointer for the specified namespace. Will return null\n     * if namespaces are not supported.\n     * Will return UNKNOWN_NAMESPACE if there is no such namespace.\n     */\n    public NodePointer namespacePointer(String namespace) {\n        return null;\n    }\n\n    /**\n     * Decodes a namespace prefix to the corresponding URI.\n     */\n    public String getNamespaceURI(String prefix) {\n        return null;\n    }\n\n    /**\n     * Returns the namespace URI associated with this Pointer.\n     */\n    public String getNamespaceURI() {\n        return null;\n    }\n\n    /**\n     * Returns true if the supplied prefix represents the\n     * default namespace in the context of the current node.\n     */\n    protected boolean isDefaultNamespace(String prefix) {\n        if (prefix == null) {\n            return true;\n        }\n\n        String namespace = getNamespaceURI(prefix);\n        return namespace != null && namespace.equals(getDefaultNamespaceURI());\n    }\n\n    protected String getDefaultNamespaceURI() {\n        return null;\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        return context.getPointerByID(id);\n    }\n\n    /**\n     * Locates a node by key and value.\n     */\n    public Pointer getPointerByKey(\n        JXPathContext context,\n        String key,\n        String value) \n    {\n        return context.getPointerByKey(key, value);\n    }\n\n    /**\n     * Returns an XPath that maps to this Pointer.\n     */\n    public String asPath() {\n        // If the parent of this node is a container, it is responsible\n        // for appended this node's part of the path.\n        if (parent != null && parent.isContainer()) {\n            return parent.asPath();\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n\n        if (buffer.length() == 0\n            || buffer.charAt(buffer.length() - 1) != '/') {\n            buffer.append('/');\n        }\n        if (attribute) {\n            buffer.append('@');\n        }\n        buffer.append(getName());\n\n        if (index != WHOLE_COLLECTION && isCollection()) {\n            buffer.append('[').append(index + 1).append(']');\n        }\n        return buffer.toString();\n    }\n\n    public Object clone() {\n        try {\n            NodePointer ptr = (NodePointer) super.clone();\n            if (parent != null) {\n                ptr.parent = (NodePointer) parent.clone();\n            }\n            return ptr;\n        }\n        catch (CloneNotSupportedException ex) {\n            // Of course it is supported\n            ex.printStackTrace();\n        }\n        return null;\n    }\n\n    public String toString() {\n        return asPath();\n    }\n\n    public int compareTo(Object object) {\n        // Let it throw a ClassCastException\n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        // Task 1: find the common parent\n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }\n\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n\n    /**\n     * Print internal structure of a pointer for debugging\n     */\n    public void printPointerChain() {\n        printDeep(this, \"\");\n    }\n\n    private static void printDeep(NodePointer pointer, String indent) {\n        if (indent.length() == 0) {\n            System.err.println(\n                \"POINTER: \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        else {\n            System.err.println(\n                indent\n                    + \" of \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        if (pointer.getImmediateParentPointer() != null) {\n            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n        }\n    }\n}", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model;\n\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\n\n/**\n * Common superclass for Pointers of all kinds.  A NodePointer maps to\n * a deterministic XPath that represents the location of a node in an \n * object graph. This XPath uses only simple axes: child, namespace and\n * attribute and only simple, context-independent predicates.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class NodePointer implements Pointer {\n\n    public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n    protected int index = WHOLE_COLLECTION;\n    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n    private boolean attribute = false;\n    private transient Object rootNode;\n    private NamespaceResolver namespaceResolver;\n    \n    /**\n     * Allocates an entirely new NodePointer by iterating through all installed\n     * NodePointerFactories until it finds one that can create a pointer.\n     */\n    public static NodePointer newNodePointer(\n        QName name,\n        Object bean,\n        Locale locale) \n    {\n        NodePointer pointer = null;\n        if (bean == null) {\n            pointer = new NullPointer(name, locale);\n            return pointer;\n        }\n        \n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            pointer = factories[i].createNodePointer(name, bean, locale);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    /**\n     * Allocates an new child NodePointer by iterating through all installed\n     * NodePointerFactories until it finds one that can create a pointer.\n     */\n    public static NodePointer newChildNodePointer(\n        NodePointer parent,\n        QName name,\n        Object bean) \n    {\n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            NodePointer pointer =\n                factories[i].createNodePointer(parent, name, bean);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }\n\n    protected NodePointer parent;\n    protected Locale locale;\n//    private NamespaceManager namespaceManager;\n\n    protected NodePointer(NodePointer parent) {\n        this.parent = parent;\n    }\n\n    protected NodePointer(NodePointer parent, Locale locale) {\n        this.parent = parent;\n        this.locale = locale;\n    }\n\n    public NamespaceResolver getNamespaceResolver() {\n        if (namespaceResolver == null && parent != null) {\n            namespaceResolver = parent.getNamespaceResolver();\n        }\n        return namespaceResolver;\n    }\n    \n    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n        this.namespaceResolver = namespaceResolver;\n    }\n    \n    public NodePointer getParent() {\n        NodePointer pointer = parent;\n        while (pointer != null && pointer.isContainer()) {\n            pointer = pointer.getImmediateParentPointer();\n        }\n        return pointer;\n    }\n    \n    public NodePointer getImmediateParentPointer() {\n        return parent;\n    }\n\n    /**\n     * Set to true if the pointer represents the \"attribute::\" axis.\n     */\n    public void setAttribute(boolean attribute) {\n        this.attribute = attribute;\n    }\n\n    /**\n     * Returns true if the pointer represents the \"attribute::\" axis.\n     */\n    public boolean isAttribute() {\n        return attribute;\n    }\n\n    /**\n     * Returns true if this Pointer has no parent.\n     */\n    public boolean isRoot() {\n        return parent == null;\n    }\n\n    /**\n     * If true, this node does not have children\n     */\n    public abstract boolean isLeaf();\n\n    /**\n     * @deprecated Please use !isContainer()\n     */\n    public boolean isNode() {\n        return !isContainer();\n    }\n     \n    /**\n     * If true, this node is axiliary and can only be used as an intermediate in\n     * the chain of pointers.\n     */\n    public boolean isContainer() {\n        return false;\n    }\n\n    /**\n     * If the pointer represents a collection, the index identifies\n     * an element of that collection.  The default value of <code>index</code>\n     * is <code>WHOLE_COLLECTION</code>, which just means that the pointer\n     * is not indexed at all.\n     * Note: the index on NodePointer starts with 0, not 1.\n     */\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    /**\n     * Returns <code>true</code> if the value of the pointer is an array or\n     * a Collection.\n     */\n    public abstract boolean isCollection();\n\n    /**\n     * If the pointer represents a collection (or collection element),\n     * returns the length of the collection.\n     * Otherwise returns 1 (even if the value is null).\n     */\n    public abstract int getLength();\n\n    /**\n     * By default, returns <code>getNode()</code>, can be overridden to\n     * return a \"canonical\" value, like for instance a DOM element should\n     * return its string value.\n     */\n    public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        // Default behavior is to return the same as getNode() \n        return getNode();\n    }\n\n    /**\n     * If this pointer manages a transparent container, like a variable,\n     * this method returns the pointer to the contents.\n     * Only an auxiliary (non-node) pointer can (and should) return a\n     * value pointer other than itself.\n     * Note that you probably don't want to override \n     * <code>getValuePointer()</code> directly.  Override the\n     * <code>getImmediateValuePointer()</code> method instead.  The\n     * <code>getValuePointer()</code> method is calls\n     * <code>getImmediateValuePointer()</code> and, if the result is not\n     * <code>this</code>, invokes <code>getValuePointer()</code> recursively.\n     * The idea here is to open all nested containers. Let's say we have a\n     * container within a container within a container. The\n     * <code>getValuePointer()</code> method should then open all those\n     * containers and return the pointer to the ultimate contents. It does so\n     * with the above recursion.\n     */\n    public NodePointer getValuePointer() {\n        NodePointer ivp = getImmediateValuePointer();\n        return ivp == this ? this : ivp.getValuePointer();\n    }\n\n    /**\n     * @see #getValuePointer()\n     * \n     * @return NodePointer is either <code>this</code> or a pointer\n     *   for the immediately contained value.\n     */\n    public NodePointer getImmediateValuePointer() {\n        return this;\n    }\n    \n    /**\n     * An actual pointer points to an existing part of an object graph, even\n     * if it is null. A non-actual pointer represents a part that does not exist\n     * at all.\n     * For instance consider the pointer \"/address/street\".\n     * If both <em>address</em> and <em>street</em> are not null,\n     * the pointer is actual.\n     * If <em>address</em> is not null, but <em>street</em> is null,\n     * the pointer is still actual.\n     * If <em>address</em> is null, the pointer is not actual.\n     * (In JavaBeans) if <em>address</em> is not a property of the root bean,\n     * a Pointer for this path cannot be obtained at all - actual or otherwise.\n     */\n    public boolean isActual() {\n        return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n    }\n\n    /**\n     * Returns the name of this node. Can be null.\n     */\n    public abstract QName getName();\n\n    /**\n     * Returns the value represented by the pointer before indexing.\n     * So, if the node represents an element of a collection, this\n     * method returns the collection itself.\n     */\n    public abstract Object getBaseValue();\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     *\n     * @deprecated 1.1 Please use getNode()\n     */\n    public Object getNodeValue() {\n        return getNode();\n    }\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type. Opens containers, properties etc and returns\n     * the ultimate contents.\n     */\n    public Object getNode() {\n        return getValuePointer().getImmediateNode();\n    }\n    \n    public Object getRootNode() {\n        if (rootNode == null) {\n            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n        }\n        return rootNode;\n    }\n    \n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     */\n    public abstract Object getImmediateNode();\n\n    /**\n     * Converts the value to the required type and changes the corresponding\n     * object to that value.\n     */\n    public abstract void setValue(Object value);\n\n    /**\n     * Compares two child NodePointers and returns a positive number,\n     * zero or a positive number according to the order of the pointers.\n     */\n    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    /**\n     *  Called directly by JXPathContext. Must create path and\n     *  set value.\n     */\n    public NodePointer createPath(JXPathContext context, Object value) {\n        setValue(value);\n        return this;\n    }\n\n    /**\n     * Remove the node of the object graph this pointer points to.\n     */\n    public void remove() {\n        // It is a no-op\n\n//        System.err.println(\"REMOVING: \" + asPath() + \" \" + getClass());\n//        printPointerChain();\n    }\n\n    /**\n     * Called by a child pointer when it needs to create a parent object.\n     * Must create an object described by this pointer and return\n     * a new pointer that properly describes the new object.\n     */\n    public NodePointer createPath(JXPathContext context) {\n        return this;\n    }\n\n    /**\n     * Called by a child pointer if that child needs to assign the value\n     * supplied in the createPath(context, value) call to a non-existent\n     * node. This method may have to expand the collection in order to assign\n     * the element.\n     */\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index,\n        Object value) \n    {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n\n    /**\n     * Called by a child pointer when it needs to create a parent object for a\n     * non-existent collection element. It may have to expand the collection,\n     * then create an element object and return a new pointer describing the\n     * newly created element.\n     */\n    public NodePointer createChild(JXPathContext context, QName name, int index)\n    {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }\n    \n    /**\n     * Called to create a non-existing attribute\n     */\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        throw new JXPathException(\"Cannot create an attribute for path \"\n                + asPath() + \"/@\" + name\n                + \", operation is not allowed for this type of node\");\n    }\n\n    /**\n     * If the Pointer has a parent, returns the parent's locale; otherwise\n     * returns the locale specified when this Pointer was created.\n     */\n    public Locale getLocale() {\n        if (locale == null) {\n            if (parent != null) {\n                locale = parent.getLocale();\n            }\n        }\n        return locale;\n    }\n\n    /**\n     * Returns true if the selected locale name starts\n     * with the specified prefix <i>lang</i>, case-insensitive.\n     */\n    public boolean isLanguage(String lang) {\n        Locale loc = getLocale();\n        String name = loc.toString().replace('_', '-');\n        return name.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n//    /**\n//     * Installs the supplied manager as the namespace manager for this node\n//     * pointer. The {@link #getNamespaceURI(String) getNamespaceURI(prefix)}\n//     * uses this manager to resolve namespace prefixes.\n//     * \n//     * @param namespaceManager\n//     */\n//    public void setNamespaceManager(NamespaceManager namespaceManager) {\n//        this.namespaceManager = namespaceManager;\n//    }\n//    \n//    public NamespaceManager getNamespaceManager() {\n//        if (namespaceManager != null) {\n//            return namespaceManager;\n//        }\n//        if (parent != null) {\n//            return parent.getNamespaceManager();\n//        }        \n//        return null;\n//    }\n//    \n    /**\n     * Returns a NodeIterator that iterates over all children or all children\n     * that match the given NodeTest, starting with the specified one.\n     */\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.childIterator(test, reverse, startWith);\n    }\n\n    /**\n     * Returns a NodeIterator that iterates over all attributes of the current\n     * node matching the supplied node name (could have a wildcard).\n     * May return null if the object does not support the attributes.\n     */\n    public NodeIterator attributeIterator(QName qname) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.attributeIterator(qname);\n    }\n\n    /**\n     * Returns a NodeIterator that iterates over all namespaces of the value\n     * currently pointed at.\n     * May return null if the object does not support the namespaces.\n     */\n    public NodeIterator namespaceIterator() {\n        return null;\n    }\n\n    /**\n     * Returns a NodePointer for the specified namespace. Will return null\n     * if namespaces are not supported.\n     * Will return UNKNOWN_NAMESPACE if there is no such namespace.\n     */\n    public NodePointer namespacePointer(String namespace) {\n        return null;\n    }\n\n    /**\n     * Decodes a namespace prefix to the corresponding URI.\n     */\n    public String getNamespaceURI(String prefix) {\n        return null;\n    }\n\n    /**\n     * Returns the namespace URI associated with this Pointer.\n     */\n    public String getNamespaceURI() {\n        return null;\n    }\n\n    /**\n     * Returns true if the supplied prefix represents the\n     * default namespace in the context of the current node.\n     */\n    protected boolean isDefaultNamespace(String prefix) {\n        if (prefix == null) {\n            return true;\n        }\n\n        String namespace = getNamespaceURI(prefix);\n        return namespace != null && namespace.equals(getDefaultNamespaceURI());\n    }\n\n    protected String getDefaultNamespaceURI() {\n        return null;\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        return context.getPointerByID(id);\n    }\n\n    /**\n     * Locates a node by key and value.\n     */\n    public Pointer getPointerByKey(\n        JXPathContext context,\n        String key,\n        String value) \n    {\n        return context.getPointerByKey(key, value);\n    }\n\n    /**\n     * Returns an XPath that maps to this Pointer.\n     */\n    public String asPath() {\n        // If the parent of this node is a container, it is responsible\n        // for appended this node's part of the path.\n        if (parent != null && parent.isContainer()) {\n            return parent.asPath();\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n\n        if (buffer.length() == 0\n            || buffer.charAt(buffer.length() - 1) != '/') {\n            buffer.append('/');\n        }\n        if (attribute) {\n            buffer.append('@');\n        }\n        buffer.append(getName());\n\n        if (index != WHOLE_COLLECTION && isCollection()) {\n            buffer.append('[').append(index + 1).append(']');\n        }\n        return buffer.toString();\n    }\n\n    public Object clone() {\n        try {\n            NodePointer ptr = (NodePointer) super.clone();\n            if (parent != null) {\n                ptr.parent = (NodePointer) parent.clone();\n            }\n            return ptr;\n        }\n        catch (CloneNotSupportedException ex) {\n            // Of course it is supported\n            ex.printStackTrace();\n        }\n        return null;\n    }\n\n    public String toString() {\n        return asPath();\n    }\n\n    public int compareTo(Object object) {\n        // Let it throw a ClassCastException\n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        // Task 1: find the common parent\n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }\n\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            return 0;\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n\n    /**\n     * Print internal structure of a pointer for debugging\n     */\n    public void printPointerChain() {\n        printDeep(this, \"\");\n    }\n\n    private static void printDeep(NodePointer pointer, String indent) {\n        if (indent.length() == 0) {\n            System.err.println(\n                \"POINTER: \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        else {\n            System.err.println(\n                indent\n                    + \" of \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        if (pointer.getImmediateParentPointer() != null) {\n            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n        }\n    }\n}"}]}
{"project": "JxPath", "bug_id": 6, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n\n    public CoreOperationCompare(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        return equal(l, r);\n    }\n\n    protected boolean contains(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (equal(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (contains(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean equal(Object l, Object r) {\n        if (l instanceof Pointer && r instanceof Pointer) {\n            if (l.equals(r)) {\n                return true;\n            }\n        }\n\n        if (l instanceof Pointer) {\n            l = ((Pointer) l).getValue();\n        }\n\n        if (r instanceof Pointer) {\n            r = ((Pointer) r).getValue();\n        }\n\n        if (l == r) {\n            return true;\n        }\n\n//        System.err.println(\"COMPARING VALUES: \" + l + \" \" + r);\n        if (l instanceof Boolean || r instanceof Boolean) {\n            return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n        }\n        if (l instanceof Number || r instanceof Number) {\n            return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n        }\n        if (l instanceof String || r instanceof String) {\n            return (\n                InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n        }\n        return l != null && l.equals(r);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n\n    public CoreOperationCompare(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext) {\n            ((EvalContext) l).reset();\n        }\n\n        if (l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext) {\n            ((EvalContext) r).reset();\n        }\n\n        if (r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        return equal(l, r);\n    }\n\n    protected boolean contains(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (equal(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (contains(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean equal(Object l, Object r) {\n        if (l instanceof Pointer && r instanceof Pointer) {\n            if (l.equals(r)) {\n                return true;\n            }\n        }\n\n        if (l instanceof Pointer) {\n            l = ((Pointer) l).getValue();\n        }\n\n        if (r instanceof Pointer) {\n            r = ((Pointer) r).getValue();\n        }\n\n        if (l == r) {\n            return true;\n        }\n\n//        System.err.println(\"COMPARING VALUES: \" + l + \" \" + r);\n        if (l instanceof Boolean || r instanceof Boolean) {\n            return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n        }\n        if (l instanceof Number || r instanceof Number) {\n            return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n        }\n        if (l instanceof String || r instanceof String) {\n            return (\n                InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n        }\n        return l != null && l.equals(r);\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 7, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&gt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThan extends CoreOperationRelationalExpression {\n\n    public CoreOperationGreaterThan(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n        return l > r ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    public String getSymbol() {\n        return \">\";\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&gt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThan extends CoreOperationRelationalExpression {\n\n    public CoreOperationGreaterThan(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    protected boolean evaluateCompare(int compare) {\n        return compare > 0;\n    }\n\n    public String getSymbol() {\n        return \">\";\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&gt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThanOrEqual extends\n        CoreOperationRelationalExpression {\n\n    public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    public String getSymbol() {\n        return \">=\";\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&gt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThanOrEqual extends\n        CoreOperationRelationalExpression {\n\n    public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    protected boolean evaluateCompare(int compare) {\n        return compare >= 0;\n    }\n\n    public String getSymbol() {\n        return \">=\";\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&lt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThan extends CoreOperationRelationalExpression {\n\n    public CoreOperationLessThan(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n        return l < r ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    public String getSymbol() {\n        return \"<\";\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&lt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThan extends CoreOperationRelationalExpression {\n\n    public CoreOperationLessThan(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    protected boolean evaluateCompare(int compare) {\n        return compare < 0;\n    }\n\n    public String getSymbol() {\n        return \"<\";\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&lt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThanOrEqual extends\n        CoreOperationRelationalExpression {\n\n    public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    public String getSymbol() {\n        return \"<=\";\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"&lt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThanOrEqual extends\n        CoreOperationRelationalExpression {\n\n    public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {\n        super(new Expression[] { arg1, arg2 });\n    }\n\n    protected boolean evaluateCompare(int compare) {\n        return compare <= 0;\n    }\n\n    public String getSymbol() {\n        return \"<=\";\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n *\n * @author Matt Benson\n * @version $Revision:$ $Date:$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n\n\n\n\n\n\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n *\n * @author Matt Benson\n * @version $Revision:$ $Date:$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1]\n                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        return evaluateCompare(compare(left, right));\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (evaluateCompare(compare(element, value))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private int compare(Object l, Object r) {\n        double ld = InfoSetUtil.doubleValue(l);\n        double rd = InfoSetUtil.doubleValue(r);\n        return ld == rd ? 0 : ld < rd ? -1 : 1;\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 8, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1]\n                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1]\n                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 9, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n\n    public CoreOperationCompare(Expression arg1, Expression arg2) {\n\n        super(new Expression[] { arg1, arg2 });\n    }\n\n\n    protected int getPrecedence() {\n        return 2;\n    }\n\n    protected boolean isSymmetric() {\n        return true;\n    }\n\n    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n        if (l instanceof InitialContext) {\n            ((EvalContext) l).reset();\n        }\n\n        if (l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext) {\n            ((EvalContext) r).reset();\n        }\n\n        if (r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        if (l instanceof Iterator) {\n            return contains((Iterator) l, r);\n        }\n        if (r instanceof Iterator) {\n            return contains((Iterator) r, l);\n        }\n        return equal(l, r);\n    }\n\n    protected boolean contains(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (equal(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (contains(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean equal(Object l, Object r) {\n        if (l instanceof Pointer && r instanceof Pointer) {\n            if (l.equals(r)) {\n                return true;\n            }\n        }\n        if (l instanceof Pointer) {\n            l = ((Pointer) l).getValue();\n        }\n\n        if (r instanceof Pointer) {\n            r = ((Pointer) r).getValue();\n        }\n\n        if (l == r) {\n            return true;\n        }\n        if (l instanceof Boolean || r instanceof Boolean) {\n            return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n            }\n            //if either side is NaN, no comparison returns true:\n        if (l instanceof Number || r instanceof Number) {\n            return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n            }\n            if (l instanceof String || r instanceof String) {\n            return (\n                InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n        }\n        return l != null && l.equals(r);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n    private boolean invert;\n\n    public CoreOperationCompare(Expression arg1, Expression arg2) {\n        this(arg1, arg2, false);\n    }\n\n    protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) {\n        super(new Expression[] { arg1, arg2 });\n        this.invert = invert;\n    }\n\n    public Object computeValue(EvalContext context) {\n        return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected int getPrecedence() {\n        return 2;\n    }\n\n    protected boolean isSymmetric() {\n        return true;\n    }\n\n    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n        if (l instanceof InitialContext) {\n            ((EvalContext) l).reset();\n        }\n\n        if (l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext) {\n            ((EvalContext) r).reset();\n        }\n\n        if (r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        if (l instanceof Iterator) {\n            return contains((Iterator) l, r);\n        }\n        if (r instanceof Iterator) {\n            return contains((Iterator) r, l);\n        }\n        return equal(l, r);\n    }\n\n    protected boolean contains(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (equal(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (contains(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean equal(Object l, Object r) {\n        if (l instanceof Pointer) {\n            l = ((Pointer) l).getValue();\n        }\n\n        if (r instanceof Pointer) {\n            r = ((Pointer) r).getValue();\n        }\n\n        boolean result;\n        if (l instanceof Boolean || r instanceof Boolean) {\n            result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r);\n        } else if (l instanceof Number || r instanceof Number) {\n            //if either side is NaN, no comparison returns true:\n            double ld = InfoSetUtil.doubleValue(l);\n            if (Double.isNaN(ld)) {\n                return false;\n            }\n            double rd = InfoSetUtil.doubleValue(r);\n            if (Double.isNaN(rd)) {\n                return false;\n            }\n            result = ld == rd;\n        } else {\n            if (l instanceof String || r instanceof String) {\n                l = InfoSetUtil.stringValue(l);\n                r = InfoSetUtil.stringValue(r);\n            }\n            result = l == r || l != null && l.equals(r);\n        }\n        return result ^ invert;\n    }\n\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationEqual", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationEqual extends CoreOperationCompare {\n\n    public CoreOperationEqual(Expression arg1, Expression arg2) {\n        super(arg1, arg2);\n    }\n\n    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n        return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\n    }\n    public String getSymbol() {\n        return \"=\";\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationEqual extends CoreOperationCompare {\n\n    public CoreOperationEqual(Expression arg1, Expression arg2) {\n        super(arg1, arg2);\n    }\n\n    public String getSymbol() {\n        return \"=\";\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationNotEqual extends CoreOperationCompare {\n\n    public CoreOperationNotEqual(Expression arg1, Expression arg2) {\n        super(arg1, arg2);\n    }\n\n    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n        return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    public String getSymbol() {\n        return \"!=\";\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\n/**\n * Implementation of Expression for the operation \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationNotEqual extends CoreOperationCompare {\n\n    public CoreOperationNotEqual(Expression arg1, Expression arg2) {\n        super(arg1, arg2, true);\n    }\n\n    public String getSymbol() {\n        return \"!=\";\n    }\n}\n"}]}
{"project": "JxPath", "bug_id": 10, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 11, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n\n    public DOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        this.name = name;\n        attributes = new ArrayList();\n        Node node = (Node) parent.getNode();\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                Attr attr = getAttribute((Element) node, name);\n                if (attr != null) {\n                    attributes.add(attr);\n                }\n            }\n            else {\n                NamedNodeMap map = node.getAttributes();\n                int count = map.getLength();\n                for (int i = 0; i < count; i++) {\n                    Attr attr = (Attr) map.item(i);\n                    if (testAttr(attr, name)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean testAttr(Attr attr, QName testName) {\n        String nodePrefix = DOMNodePointer.getPrefix(attr);\n        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n\n        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n            return false;\n        }\n\n        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n            return false;\n        }\n\n        String testLocalName = name.getName();\n        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n            String testPrefix = testName.getPrefix();\n\n            if (equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n\n            String testNS = null;\n            if (testPrefix != null) {\n                testNS = parent.getNamespaceURI(testPrefix);\n            }\n\n            String nodeNS = null;\n            if (nodePrefix != null) {\n                nodeNS = parent.getNamespaceURI(nodePrefix);\n            }\n            return equalStrings(testNS, nodeNS);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    private Attr getAttribute(Element element, QName name) {\n        String testPrefix = name.getPrefix();\n        String testNS = null;\n\n        if (testPrefix != null) {\n            testNS = parent.getNamespaceURI(testPrefix);\n        }\n\n        if (testNS != null) {\n            Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n            if (attr != null) {\n                return attr;\n            }\n\n            // This may mean that the parser does not support NS for\n            // attributes, example - the version of Crimson bundled\n            // with JDK 1.4.0\n            NamedNodeMap nnm = element.getAttributes();\n            for (int i = 0; i < nnm.getLength(); i++) {\n                attr = (Attr) nnm.item(i);\n                if (testAttr(attr, name)) {\n                    return attr;\n                }\n            }\n            return null;\n        }\n        return element.getAttributeNode(name.getName());\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n\n    public DOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        this.name = name;\n        attributes = new ArrayList();\n        Node node = (Node) parent.getNode();\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                Attr attr = getAttribute((Element) node, name);\n                if (attr != null) {\n                    attributes.add(attr);\n                }\n            }\n            else {\n                NamedNodeMap map = node.getAttributes();\n                int count = map.getLength();\n                for (int i = 0; i < count; i++) {\n                    Attr attr = (Attr) map.item(i);\n                    if (testAttr(attr, name)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean testAttr(Attr attr, QName testName) {\n        String nodePrefix = DOMNodePointer.getPrefix(attr);\n        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n\n        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n            return false;\n        }\n\n        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n            return false;\n        }\n\n        String testLocalName = name.getName();\n        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n            String testPrefix = testName.getPrefix();\n\n            if (equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n\n            String testNS = null;\n            if (testPrefix != null) {\n                testNS = parent.getNamespaceURI(testPrefix);\n            }\n\n            String nodeNS = null;\n            if (nodePrefix != null) {\n                nodeNS = parent.getNamespaceURI(nodePrefix);\n            }\n            return equalStrings(testNS, nodeNS);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    private Attr getAttribute(Element element, QName name) {\n        String testPrefix = name.getPrefix();\n        String testNS = null;\n\n        if (testPrefix != null) {\n            NamespaceResolver nsr = parent.getNamespaceResolver();\n            testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix);\n            testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS;\n        }\n\n        if (testNS != null) {\n            Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n            if (attr != null) {\n                return attr;\n            }\n\n            // This may mean that the parser does not support NS for\n            // attributes, example - the version of Crimson bundled\n            // with JDK 1.4.0\n            NamedNodeMap nnm = element.getAttributes();\n            for (int i = 0; i < nnm.getLength(); i++) {\n                attr = (Attr) nnm.item(i);\n                if (testAttr(attr, name)) {\n                    return attr;\n                }\n            }\n            return null;\n        }\n        return element.getAttributeNode(name.getName());\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}"}, {"class_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.jdom.Attribute;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n\n    public JDOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        if (parent.getNode() instanceof Element) {\n            Element element = (Element) parent.getNode();\n            String prefix = name.getPrefix();\n            Namespace ns = null;\n            if (prefix != null) {\n                if (prefix.equals(\"xml\")) {\n                    ns = Namespace.XML_NAMESPACE;\n                }\n                else {\n                        ns = element.getNamespace(prefix);\n                        if (ns == null) {\n                            // TBD: no attributes\n                            attributes = Collections.EMPTY_LIST;\n                            return;\n                        }\n                }\n            }\n            else {\n                ns = Namespace.NO_NAMESPACE;\n            }\n\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                attributes = new ArrayList();\n                if (ns != null) {\n                    Attribute attr = element.getAttribute(lname, ns);\n                    if (attr != null) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n            else {\n                attributes = new ArrayList();\n                List allAttributes = element.getAttributes();\n                for (int i = 0; i < allAttributes.size(); i++) {\n                    Attribute attr = (Attribute) allAttributes.get(i);\n                    if (attr.getNamespace().equals(ns)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new JDOMAttributePointer(\n            parent,\n            (Attribute) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        if (attributes == null) {\n            return false;\n        }\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.jdom.Attribute;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n\n    public JDOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        if (parent.getNode() instanceof Element) {\n            Element element = (Element) parent.getNode();\n            String prefix = name.getPrefix();\n            Namespace ns = null;\n            if (prefix != null) {\n                if (prefix.equals(\"xml\")) {\n                    ns = Namespace.XML_NAMESPACE;\n                }\n                else {\n                    NamespaceResolver nsr = parent.getNamespaceResolver();\n                    if (nsr != null) {\n                        String uri = nsr.getNamespaceURI(prefix);\n                        if (uri != null) {\n                            ns = Namespace.getNamespace(prefix, uri);\n                        }\n                    }\n                    if (ns == null) {\n                        ns = element.getNamespace(prefix);\n                        if (ns == null) {\n                            // TBD: no attributes\n                            attributes = Collections.EMPTY_LIST;\n                            return;\n                        }\n                    }\n                }\n            }\n            else {\n                ns = Namespace.NO_NAMESPACE;\n            }\n\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                attributes = new ArrayList();\n                if (ns != null) {\n                    Attribute attr = element.getAttribute(lname, ns);\n                    if (attr != null) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n            else {\n                attributes = new ArrayList();\n                List allAttributes = element.getAttributes();\n                for (int i = 0; i < allAttributes.size(); i++) {\n                    Attribute attr = (Attribute) allAttributes.get(i);\n                    if (attr.getNamespace().equals(ns)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new JDOMAttributePointer(\n            parent,\n            (Attribute) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        if (attributes == null) {\n            return false;\n        }\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}"}]}
{"project": "JxPath", "bug_id": 12, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n"}]}
{"project": "JxPath", "bug_id": 13, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.NamespaceResolver", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * Namespace resolver for JXPathContextReferenceImpl.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NamespaceResolver implements Cloneable {\n    final protected NamespaceResolver parent;\n    protected HashMap namespaceMap = new HashMap();\n    protected HashMap reverseMap;\n    protected NodePointer pointer;\n    private boolean sealed;\n\n    /**\n     * Find the namespace prefix for the specified namespace URI and NodePointer.\n     * @param pointer\n     * @param namespaceURI\n     * @return prefix if found\n     * @since JXPath 1.3\n     */\n\n    /**\n     * Create a new NamespaceResolver.\n     */\n    public NamespaceResolver() {\n        this(null);\n    }\n\n    /**\n     * Create a new NamespaceResolver.\n     * @param parent\n     */\n    public NamespaceResolver(NamespaceResolver parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Registers a namespace prefix.\n     * \n     * @param prefix A namespace prefix\n     * @param namespaceURI A URI for that prefix\n     */\n    public synchronized void registerNamespace(String prefix, String namespaceURI) {\n        if (isSealed()) {\n            throw new IllegalStateException(\n                    \"Cannot register namespaces on a sealed NamespaceResolver\");\n        }\n        namespaceMap.put(prefix, namespaceURI);\n        reverseMap = null;\n    }\n    \n    /**\n     * Register a namespace for the expression context.\n     * @param pointer the Pointer to set.\n     */\n    public void setNamespaceContextPointer(NodePointer pointer) {\n        this.pointer = pointer;\n    }\n\n    /**\n     * Get the namespace context pointer.\n     * @return Pointer\n     */\n    public Pointer getNamespaceContextPointer() {\n        if (pointer == null && parent != null) {\n            return parent.getNamespaceContextPointer();\n        }\n        return pointer;\n    }\n    \n    /**\n     * Given a prefix, returns a registered namespace URI. If the requested\n     * prefix was not defined explicitly using the registerNamespace method,\n     * JXPathContext will then check the context node to see if the prefix is\n     * defined there. See\n     * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\n     * \n     * @param prefix The namespace prefix to look up\n     * @return namespace URI or null if the prefix is undefined.\n     */\n    public synchronized String getNamespaceURI(String prefix) {\n\n    /**\n     * Given a prefix, returns an externally registered namespace URI.\n     * \n     * @param prefix The namespace prefix to look up\n     * @return namespace URI or null if the prefix is undefined.\n     * @since JXPath 1.3\n     */\n        String uri = (String) namespaceMap.get(prefix);\n        if (uri == null && pointer != null) {\n            uri = pointer.getNamespaceURI(prefix);\n        }\n        if (uri == null && parent != null) {\n            return parent.getNamespaceURI(prefix);\n        }\n        return uri;\n    }\n\n    /**\n     * Get the prefix associated with the specifed namespace URI.\n     * @param namespaceURI the ns URI to check.\n     * @return String prefix\n     */\n    public synchronized String getPrefix(String namespaceURI) {\n\n    /**\n     * Get the nearest prefix found that matches an externally-registered namespace. \n     * @param namespaceURI\n     * @return String prefix if found.\n     * @since JXPath 1.3\n     */\n        if (reverseMap == null) {\n            reverseMap = new HashMap();\n            NodeIterator ni = pointer.namespaceIterator();\n            if (ni != null) {\n                for (int position = 1; ni.setPosition(position); position++) {\n                    NodePointer nsPointer = ni.getNodePointer();\n                    String uri = nsPointer.getNamespaceURI();                    \n                    String prefix = nsPointer.getName().getName();\n                    if (!\"\".equals(prefix)) {\n                        reverseMap.put(uri, prefix);\n                    }\n                }\n            }\n            Iterator it = namespaceMap.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry entry = (Map.Entry) it.next();\n                reverseMap.put(entry.getValue(), entry.getKey());\n            }\n        }\n        String prefix = (String) reverseMap.get(namespaceURI);\n        if (prefix == null && parent != null) {\n            return parent.getPrefix(namespaceURI);\n        }\n        return prefix;\n    }\n\n    /**\n     * Learn whether this NamespaceResolver has been sealed.\n     * @return\n     */\n    public boolean isSealed() {\n        return sealed;\n    }\n\n    /**\n     * Seal this {@link NamespaceResolver}.\n     */\n    public void seal() {\n        sealed = true;\n        if (parent != null) {\n            parent.seal();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * @see java.lang.Object#clone()\n     */\n    public Object clone() {\n        try {\n            NamespaceResolver result = (NamespaceResolver) super.clone();\n            result.sealed = false;\n            return result;\n        }\n        catch (CloneNotSupportedException e) {\n            // Of course, it's supported.\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * Namespace resolver for JXPathContextReferenceImpl.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NamespaceResolver implements Cloneable {\n    final protected NamespaceResolver parent;\n    protected HashMap namespaceMap = new HashMap();\n    protected HashMap reverseMap;\n    protected NodePointer pointer;\n    private boolean sealed;\n\n    /**\n     * Find the namespace prefix for the specified namespace URI and NodePointer.\n     * @param pointer\n     * @param namespaceURI\n     * @return prefix if found\n     * @since JXPath 1.3\n     */\n    protected static String getPrefix(NodePointer pointer, String namespaceURI) {\n        NodePointer currentPointer = pointer;\n        while (currentPointer != null) {\n            NodeIterator ni = currentPointer.namespaceIterator();\n            for (int position = 1; ni != null && ni.setPosition(position); position++) {\n                NodePointer nsPointer = ni.getNodePointer();\n                String uri = nsPointer.getNamespaceURI();\n                if (uri.equals(namespaceURI)) {\n                    String prefix = nsPointer.getName().getName();\n                    if (!\"\".equals(prefix)) {\n                        return prefix;\n                    }\n                }\n            }\n            currentPointer = pointer.getParent();\n        }\n        return null;\n    }\n\n    /**\n     * Create a new NamespaceResolver.\n     */\n    public NamespaceResolver() {\n        this(null);\n    }\n\n    /**\n     * Create a new NamespaceResolver.\n     * @param parent\n     */\n    public NamespaceResolver(NamespaceResolver parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Registers a namespace prefix.\n     * \n     * @param prefix A namespace prefix\n     * @param namespaceURI A URI for that prefix\n     */\n    public synchronized void registerNamespace(String prefix, String namespaceURI) {\n        if (isSealed()) {\n            throw new IllegalStateException(\n                    \"Cannot register namespaces on a sealed NamespaceResolver\");\n        }\n        namespaceMap.put(prefix, namespaceURI);\n        reverseMap = null;\n    }\n    \n    /**\n     * Register a namespace for the expression context.\n     * @param pointer the Pointer to set.\n     */\n    public void setNamespaceContextPointer(NodePointer pointer) {\n        this.pointer = pointer;\n    }\n\n    /**\n     * Get the namespace context pointer.\n     * @return Pointer\n     */\n    public Pointer getNamespaceContextPointer() {\n        if (pointer == null && parent != null) {\n            return parent.getNamespaceContextPointer();\n        }\n        return pointer;\n    }\n    \n    /**\n     * Given a prefix, returns a registered namespace URI. If the requested\n     * prefix was not defined explicitly using the registerNamespace method,\n     * JXPathContext will then check the context node to see if the prefix is\n     * defined there. See\n     * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\n     * \n     * @param prefix The namespace prefix to look up\n     * @return namespace URI or null if the prefix is undefined.\n     */\n    public synchronized String getNamespaceURI(String prefix) {\n        String uri = getExternallyRegisteredNamespaceURI(prefix);\n        return uri == null && pointer != null ? pointer.getNamespaceURI(prefix)\n                : uri;\n    }\n\n    /**\n     * Given a prefix, returns an externally registered namespace URI.\n     * \n     * @param prefix The namespace prefix to look up\n     * @return namespace URI or null if the prefix is undefined.\n     * @since JXPath 1.3\n     */\n     protected synchronized String getExternallyRegisteredNamespaceURI(\n            String prefix) {\n        String uri = (String) namespaceMap.get(prefix);\n        return uri == null && parent != null ? parent\n                .getExternallyRegisteredNamespaceURI(prefix) : uri;\n    }\n\n    /**\n     * Get the prefix associated with the specifed namespace URI.\n     * @param namespaceURI the ns URI to check.\n     * @return String prefix\n     */\n    public synchronized String getPrefix(String namespaceURI) {\n        String prefix = getExternallyRegisteredPrefix(namespaceURI);\n        return prefix == null && pointer != null ? getPrefix(pointer,\n                namespaceURI) : prefix;\n    }\n\n    /**\n     * Get the nearest prefix found that matches an externally-registered namespace. \n     * @param namespaceURI\n     * @return String prefix if found.\n     * @since JXPath 1.3\n     */\n    protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {\n        if (reverseMap == null) {\n            reverseMap = new HashMap();\n            Iterator it = namespaceMap.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry entry = (Map.Entry) it.next();\n                reverseMap.put(entry.getValue(), entry.getKey());\n            }\n        }\n        String prefix = (String) reverseMap.get(namespaceURI);\n        return prefix == null && parent != null ? parent\n                .getExternallyRegisteredPrefix(namespaceURI) : prefix;\n    }\n\n    /**\n     * Learn whether this NamespaceResolver has been sealed.\n     * @return\n     */\n    public boolean isSealed() {\n        return sealed;\n    }\n\n    /**\n     * Seal this {@link NamespaceResolver}.\n     */\n    public void seal() {\n        sealed = true;\n        if (parent != null) {\n            parent.seal();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * @see java.lang.Object#clone()\n     */\n    public Object clone() {\n        try {\n            NamespaceResolver result = (NamespaceResolver) super.clone();\n            result.sealed = false;\n            return result;\n        }\n        catch (CloneNotSupportedException e) {\n            // Of course, it's supported.\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}"}, {"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n     */\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n    \n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    public static final String XML_NAMESPACE_URI = \n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI = \n            \"http://www.w3.org/2000/xmlns/\";\n\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n    \n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n     */\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n        \n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n    \n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, \n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n    \n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n    \n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n"}]}
{"project": "JxPath", "bug_id": 14, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreFunction", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.JXPathInvalidSyntaxException;\nimport org.apache.commons.jxpath.NodeSet;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.NodeSetContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * An element of the compile tree representing one of built-in functions\n * like \"position()\" or \"number()\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreFunction extends Operation {\n\n    private static final Double ZERO = new Double(0);\n    private int functionCode;\n\n    public CoreFunction(int functionCode, Expression args[]) {\n        super(args);\n        this.functionCode = functionCode;\n    }\n\n    public int getFunctionCode() {\n        return functionCode;\n    }\n    \n    protected String getFunctionName() {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return \"last\";\n            case Compiler.FUNCTION_POSITION :\n                return \"position\";\n            case Compiler.FUNCTION_COUNT :\n                return \"count\";\n            case Compiler.FUNCTION_ID :\n                return \"id\";\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return \"local-name\";\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return \"namespace-uri\";\n            case Compiler.FUNCTION_NAME :\n                return \"name\";\n            case Compiler.FUNCTION_STRING :\n                return \"string\";\n            case Compiler.FUNCTION_CONCAT :\n                return \"concat\";\n            case Compiler.FUNCTION_STARTS_WITH :\n                return \"starts-with\";\n            case Compiler.FUNCTION_CONTAINS :\n                return \"contains\";\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return \"substring-before\";\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return \"substring-after\";\n            case Compiler.FUNCTION_SUBSTRING :\n                return \"substring\";\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return \"string-length\";\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return \"normalize-space\";\n            case Compiler.FUNCTION_TRANSLATE :\n                return \"translate\";\n            case Compiler.FUNCTION_BOOLEAN :\n                return \"boolean\";\n            case Compiler.FUNCTION_NOT :\n                return \"not\";\n            case Compiler.FUNCTION_TRUE :\n                return \"true\";\n            case Compiler.FUNCTION_FALSE :\n                return \"false\";\n            case Compiler.FUNCTION_LANG :\n                return \"lang\";\n            case Compiler.FUNCTION_NUMBER :\n                return \"number\";\n            case Compiler.FUNCTION_SUM :\n                return \"sum\";\n            case Compiler.FUNCTION_FLOOR :\n                return \"floor\";\n            case Compiler.FUNCTION_CEILING :\n                return \"ceiling\";\n            case Compiler.FUNCTION_ROUND :\n                return \"round\";\n            case Compiler.FUNCTION_KEY :\n                return \"key\";\n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return \"format-number\";\n        }\n        return \"unknownFunction\" + functionCode + \"()\";\n    }\n\n    public Expression getArg1() {\n        return args[0];\n    }\n\n    public Expression getArg2() {\n        return args[1];\n    }\n\n    public Expression getArg3() {\n        return args[2];\n    }\n\n    public int getArgumentCount() {\n        if (args == null) {\n            return 0;\n        }\n        return args.length;\n    }\n\n    /**\n     * Returns true if any argument is context dependent or if\n     * the function is last(), position(), boolean(), local-name(),\n     * name(), string(), lang(), number().\n     */\n    public boolean computeContextDependent() {\n        if (super.computeContextDependent()) {\n            return true;\n        }\n\n        switch(functionCode) {\n            case Compiler.FUNCTION_LAST:\n            case Compiler.FUNCTION_POSITION:\n                return true;\n\n            case Compiler.FUNCTION_BOOLEAN:\n            case Compiler.FUNCTION_LOCAL_NAME:\n            case Compiler.FUNCTION_NAME:\n            case Compiler.FUNCTION_NAMESPACE_URI:\n            case Compiler.FUNCTION_STRING:\n            case Compiler.FUNCTION_LANG:\n            case Compiler.FUNCTION_NUMBER:\n                return args == null || args.length == 0;\n\n            case Compiler.FUNCTION_COUNT:\n            case Compiler.FUNCTION_ID:\n            case Compiler.FUNCTION_CONCAT:\n            case Compiler.FUNCTION_STARTS_WITH:\n            case Compiler.FUNCTION_CONTAINS:\n            case Compiler.FUNCTION_SUBSTRING_BEFORE:\n            case Compiler.FUNCTION_SUBSTRING_AFTER:\n            case Compiler.FUNCTION_SUBSTRING:\n            case Compiler.FUNCTION_STRING_LENGTH:\n            case Compiler.FUNCTION_NORMALIZE_SPACE:\n            case Compiler.FUNCTION_TRANSLATE:\n            case Compiler.FUNCTION_NOT:\n            case Compiler.FUNCTION_TRUE:\n            case Compiler.FUNCTION_FALSE:\n            case Compiler.FUNCTION_SUM:\n            case Compiler.FUNCTION_FLOOR:\n            case Compiler.FUNCTION_CEILING:\n            case Compiler.FUNCTION_ROUND:\n                return false;\n                \n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return args != null && args.length == 2;                             \n        }\n\n        return false;\n    }\n\n    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getFunctionName());\n        buffer.append('(');\n        Expression args[] = getArguments();\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                if (i > 0) {\n                    buffer.append(\", \");\n                }\n                buffer.append(args[i]);\n            }\n        }\n        buffer.append(')');\n        return buffer.toString();\n    }\n\n    public Object compute(EvalContext context) {\n        return computeValue(context);\n    }\n\n    /**\n     * Computes a built-in function\n     */\n    public Object computeValue(EvalContext context) {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return functionLast(context);\n            case Compiler.FUNCTION_POSITION :\n                return functionPosition(context);\n            case Compiler.FUNCTION_COUNT :\n                return functionCount(context);\n            case Compiler.FUNCTION_LANG :\n                return functionLang(context);\n            case Compiler.FUNCTION_ID :\n                return functionID(context);\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return functionLocalName(context);\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return functionNamespaceURI(context);\n            case Compiler.FUNCTION_NAME :\n                return functionName(context);\n            case Compiler.FUNCTION_STRING :\n                return functionString(context);\n            case Compiler.FUNCTION_CONCAT :\n                return functionConcat(context);\n            case Compiler.FUNCTION_STARTS_WITH :\n                return functionStartsWith(context);\n            case Compiler.FUNCTION_CONTAINS :\n                return functionContains(context);\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return functionSubstringBefore(context);\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return functionSubstringAfter(context);\n            case Compiler.FUNCTION_SUBSTRING :\n                return functionSubstring(context);\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return functionStringLength(context);\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return functionNormalizeSpace(context);\n            case Compiler.FUNCTION_TRANSLATE :\n                return functionTranslate(context);\n            case Compiler.FUNCTION_BOOLEAN :\n                return functionBoolean(context);\n            case Compiler.FUNCTION_NOT :\n                return functionNot(context);\n            case Compiler.FUNCTION_TRUE :\n                return functionTrue(context);\n            case Compiler.FUNCTION_FALSE :\n                return functionFalse(context);\n            case Compiler.FUNCTION_NULL :\n                return functionNull(context);\n            case Compiler.FUNCTION_NUMBER :\n                return functionNumber(context);\n            case Compiler.FUNCTION_SUM :\n                return functionSum(context);\n            case Compiler.FUNCTION_FLOOR :\n                return functionFloor(context);\n            case Compiler.FUNCTION_CEILING :\n                return functionCeiling(context);\n            case Compiler.FUNCTION_ROUND :\n                return functionRound(context);\n            case Compiler.FUNCTION_KEY :\n                return functionKey(context);\n            case Compiler.FUNCTION_FORMAT_NUMBER :\n                return functionFormatNumber(context);\n        }\n        return null;\n    }\n\n    protected Object functionLast(EvalContext context) {\n        assertArgCount(0);\n        // Move the position to the beginning and iterate through\n        // the context to count nodes.\n        int old = context.getCurrentPosition();\n        context.reset();\n        int count = 0;\n        while (context.nextNode()) {\n            count++;\n        }\n\n        // Restore the current position.\n        if (old != 0) {\n            context.setPosition(old);\n        }\n        return new Double(count);\n    }\n\n    protected Object functionPosition(EvalContext context) {\n        assertArgCount(0);\n        return new Integer(context.getCurrentPosition());\n    }\n\n    protected Object functionCount(EvalContext context) {\n        assertArgCount(1);\n        Expression arg1 = getArg1();\n        int count = 0;\n        Object value = arg1.compute(context);\n        if (value instanceof NodePointer) {\n            value = ((NodePointer) value).getValue();\n        }\n        if (value instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) value;\n            while (ctx.hasNext()) {\n                ctx.next();\n                count++;\n            }\n        }\n        else if (value instanceof Collection) {\n            count = ((Collection) value).size();\n        }\n        else if (value == null) {\n            count = 0;\n        }\n        else {\n            count = 1;\n        }\n        return new Double(count);\n    }\n\n    protected Object functionLang(EvalContext context) {\n        assertArgCount(1);\n        String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        NodePointer pointer = (NodePointer) context.getSingleNodePointer();\n        if (pointer == null) {\n            return Boolean.FALSE;\n        }\n        return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionID(EvalContext context) {\n        assertArgCount(1);\n        String id = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n        return pointer.getPointerByID(jxpathContext, id);\n    }\n\n    protected Object functionKey(EvalContext context) {\n        assertArgCount(2);\n        String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        Object value = getArg2().compute(context);\n        EvalContext ec = null;\n        if (value instanceof EvalContext) {\n            ec = (EvalContext) value;\n            if (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n            } else { // empty context -> empty results\n                return new BasicNodeSet();\n            }\n        }\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodeSet nodeSet = jxpathContext.getNodeSetByKey(key, value);\n        if (ec != null && ec.hasNext()) {\n            BasicNodeSet accum = new BasicNodeSet();\n            accum.add(nodeSet);\n            while (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n                accum.add(jxpathContext.getNodeSetByKey(key, value));\n            }\n            nodeSet = accum;\n        }\n        return new NodeSetContext(context, nodeSet);\n    }\n\n    protected Object functionNamespaceURI(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            String str = ptr.getNamespaceURI();\n            return str == null ? \"\" : str;\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                String str = ptr.getNamespaceURI();\n                return str == null ? \"\" : str;\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionLocalName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().getName();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().getName();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().toString();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().toString();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionString(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.stringValue(getArg1().computeValue(context));\n    }\n\n    protected Object functionConcat(EvalContext context) {\n        if (getArgumentCount() < 2) {\n            assertArgCount(2);\n        }\n        StringBuffer buffer = new StringBuffer();\n        Expression args[] = getArguments();\n        for (int i = 0; i < args.length; i++) {\n            buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n        }\n        return buffer.toString();\n    }\n\n    protected Object functionStartsWith(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionContains(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionSubstringBefore(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(0, index);\n    }\n\n    protected Object functionSubstringAfter(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(index + s2.length());\n    }\n\n    protected Object functionSubstring(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n        if (Double.isNaN(from)) {\n            return \"\";\n        }\n\n        from = Math.round(from);\n        if (from > s1.length() + 1) {\n            return \"\";\n        }\n        if (ac == 2) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n        double length =\n            InfoSetUtil.doubleValue(getArg3().computeValue(context));\n        length = Math.round(length);\n        if (length < 0) {\n            return \"\";\n        }\n\n        double to = from + length;\n        if (to < 1) {\n            return \"\";\n        }\n\n        if (to > s1.length() + 1) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n\n        if (from < 1) {\n            from = 1;\n        }\n        return s1.substring((int) from - 1, (int) (to - 1));\n    }\n\n    protected Object functionStringLength(EvalContext context) {\n        String s;\n        if (getArgumentCount() == 0) {\n            s = InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        else {\n            assertArgCount(1);\n            s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        }\n        return new Double(s.length());\n    }\n\n    protected Object functionNormalizeSpace(EvalContext context) {\n        assertArgCount(1);\n        String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        char chars[] = s.toCharArray();\n        int out = 0;\n        int phase = 0;\n        for (int in = 0; in < chars.length; in++) {\n            switch(chars[in]) {\n                case 0x20:\n                case 0x9:\n                case 0xD:\n                case 0xA:\n                    if (phase == 0) {      // beginning\n                        ;\n                    }\n                    else if (phase == 1) { // non-space\n                        phase = 2;\n                        chars[out++] = ' ';\n                    }\n                    break;\n                default:\n                    chars[out++] = chars[in];\n                    phase = 1;\n            }\n        }\n        if (phase == 2) { // trailing-space\n            out--;\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionTranslate(EvalContext context) {\n        assertArgCount(3);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n        char chars[] = s1.toCharArray();\n        int out = 0;\n        for (int in = 0; in < chars.length; in++) {\n            char c = chars[in];\n            int inx = s2.indexOf(c);\n            if (inx != -1) {\n                if (inx < s3.length()) {\n                    chars[out++] = s3.charAt(inx);\n                }\n            }\n            else {\n                chars[out++] = c;\n            }\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionBoolean(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.TRUE\n            : Boolean.FALSE;\n    }\n\n    protected Object functionNot(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.FALSE\n            : Boolean.TRUE;\n    }\n\n    protected Object functionTrue(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.TRUE;\n    }\n\n    protected Object functionFalse(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.FALSE;\n    }\n\n    protected Object functionNull(EvalContext context) {\n        assertArgCount(0);\n        return null;\n    }\n\n    protected Object functionNumber(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.number(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.number(getArg1().computeValue(context));\n    }\n\n    protected Object functionSum(EvalContext context) {\n        assertArgCount(1);\n        Object v = getArg1().compute(context);\n        if (v == null) {\n            return ZERO;\n        }\n        if (v instanceof EvalContext) {\n            double sum = 0.0;\n            EvalContext ctx = (EvalContext) v;\n            while (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                sum += InfoSetUtil.doubleValue(ptr);\n            }\n            return new Double(sum);\n        }\n        throw new JXPathException(\n            \"Invalid argument type for 'sum': \" + v.getClass().getName());\n    }\n\n    protected Object functionFloor(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.floor(v));\n    }\n\n    protected Object functionCeiling(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.ceil(v));\n    }\n\n    protected Object functionRound(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.round(v));\n    }\n\n    private Object functionFormatNumber(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        double number =\n            InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        String pattern =\n            InfoSetUtil.stringValue(getArg2().computeValue(context));\n\n        DecimalFormatSymbols symbols = null;\n        if (ac == 3) {\n            String symbolsName =\n                InfoSetUtil.stringValue(getArg3().computeValue(context));\n            symbols =\n                context.getJXPathContext().getDecimalFormatSymbols(symbolsName);\n        }\n        else {\n            NodePointer pointer = context.getCurrentNodePointer();\n            Locale locale;\n            if (pointer != null) {\n                locale = pointer.getLocale();\n            }\n            else {\n                locale = context.getJXPathContext().getLocale();\n            }\n            symbols = new DecimalFormatSymbols(locale);\n        }\n        \n        DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();\n        format.setDecimalFormatSymbols(symbols);\n        format.applyLocalizedPattern(pattern);\n        return format.format(number);\n    }\n\n    private void assertArgCount(int count) {\n        assertArgRange(count, count);\n    }\n\n    private void assertArgRange(int min, int max) {\n        int ct = getArgumentCount();\n        if (ct < min || ct > max) {\n            throw new JXPathInvalidSyntaxException(\n                    \"Incorrect number of arguments: \" + this);\n        }\n    }\n}", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.JXPathInvalidSyntaxException;\nimport org.apache.commons.jxpath.NodeSet;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.NodeSetContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * An element of the compile tree representing one of built-in functions\n * like \"position()\" or \"number()\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreFunction extends Operation {\n\n    private static final Double ZERO = new Double(0);\n    private int functionCode;\n\n    public CoreFunction(int functionCode, Expression args[]) {\n        super(args);\n        this.functionCode = functionCode;\n    }\n\n    public int getFunctionCode() {\n        return functionCode;\n    }\n    \n    protected String getFunctionName() {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return \"last\";\n            case Compiler.FUNCTION_POSITION :\n                return \"position\";\n            case Compiler.FUNCTION_COUNT :\n                return \"count\";\n            case Compiler.FUNCTION_ID :\n                return \"id\";\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return \"local-name\";\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return \"namespace-uri\";\n            case Compiler.FUNCTION_NAME :\n                return \"name\";\n            case Compiler.FUNCTION_STRING :\n                return \"string\";\n            case Compiler.FUNCTION_CONCAT :\n                return \"concat\";\n            case Compiler.FUNCTION_STARTS_WITH :\n                return \"starts-with\";\n            case Compiler.FUNCTION_CONTAINS :\n                return \"contains\";\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return \"substring-before\";\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return \"substring-after\";\n            case Compiler.FUNCTION_SUBSTRING :\n                return \"substring\";\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return \"string-length\";\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return \"normalize-space\";\n            case Compiler.FUNCTION_TRANSLATE :\n                return \"translate\";\n            case Compiler.FUNCTION_BOOLEAN :\n                return \"boolean\";\n            case Compiler.FUNCTION_NOT :\n                return \"not\";\n            case Compiler.FUNCTION_TRUE :\n                return \"true\";\n            case Compiler.FUNCTION_FALSE :\n                return \"false\";\n            case Compiler.FUNCTION_LANG :\n                return \"lang\";\n            case Compiler.FUNCTION_NUMBER :\n                return \"number\";\n            case Compiler.FUNCTION_SUM :\n                return \"sum\";\n            case Compiler.FUNCTION_FLOOR :\n                return \"floor\";\n            case Compiler.FUNCTION_CEILING :\n                return \"ceiling\";\n            case Compiler.FUNCTION_ROUND :\n                return \"round\";\n            case Compiler.FUNCTION_KEY :\n                return \"key\";\n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return \"format-number\";\n        }\n        return \"unknownFunction\" + functionCode + \"()\";\n    }\n\n    public Expression getArg1() {\n        return args[0];\n    }\n\n    public Expression getArg2() {\n        return args[1];\n    }\n\n    public Expression getArg3() {\n        return args[2];\n    }\n\n    public int getArgumentCount() {\n        if (args == null) {\n            return 0;\n        }\n        return args.length;\n    }\n\n    /**\n     * Returns true if any argument is context dependent or if\n     * the function is last(), position(), boolean(), local-name(),\n     * name(), string(), lang(), number().\n     */\n    public boolean computeContextDependent() {\n        if (super.computeContextDependent()) {\n            return true;\n        }\n\n        switch(functionCode) {\n            case Compiler.FUNCTION_LAST:\n            case Compiler.FUNCTION_POSITION:\n                return true;\n\n            case Compiler.FUNCTION_BOOLEAN:\n            case Compiler.FUNCTION_LOCAL_NAME:\n            case Compiler.FUNCTION_NAME:\n            case Compiler.FUNCTION_NAMESPACE_URI:\n            case Compiler.FUNCTION_STRING:\n            case Compiler.FUNCTION_LANG:\n            case Compiler.FUNCTION_NUMBER:\n                return args == null || args.length == 0;\n\n            case Compiler.FUNCTION_COUNT:\n            case Compiler.FUNCTION_ID:\n            case Compiler.FUNCTION_CONCAT:\n            case Compiler.FUNCTION_STARTS_WITH:\n            case Compiler.FUNCTION_CONTAINS:\n            case Compiler.FUNCTION_SUBSTRING_BEFORE:\n            case Compiler.FUNCTION_SUBSTRING_AFTER:\n            case Compiler.FUNCTION_SUBSTRING:\n            case Compiler.FUNCTION_STRING_LENGTH:\n            case Compiler.FUNCTION_NORMALIZE_SPACE:\n            case Compiler.FUNCTION_TRANSLATE:\n            case Compiler.FUNCTION_NOT:\n            case Compiler.FUNCTION_TRUE:\n            case Compiler.FUNCTION_FALSE:\n            case Compiler.FUNCTION_SUM:\n            case Compiler.FUNCTION_FLOOR:\n            case Compiler.FUNCTION_CEILING:\n            case Compiler.FUNCTION_ROUND:\n                return false;\n                \n            case Compiler.FUNCTION_FORMAT_NUMBER:\n                return args != null && args.length == 2;                             \n        }\n\n        return false;\n    }\n\n    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getFunctionName());\n        buffer.append('(');\n        Expression args[] = getArguments();\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                if (i > 0) {\n                    buffer.append(\", \");\n                }\n                buffer.append(args[i]);\n            }\n        }\n        buffer.append(')');\n        return buffer.toString();\n    }\n\n    public Object compute(EvalContext context) {\n        return computeValue(context);\n    }\n\n    /**\n     * Computes a built-in function\n     */\n    public Object computeValue(EvalContext context) {\n        switch (functionCode) {\n            case Compiler.FUNCTION_LAST :\n                return functionLast(context);\n            case Compiler.FUNCTION_POSITION :\n                return functionPosition(context);\n            case Compiler.FUNCTION_COUNT :\n                return functionCount(context);\n            case Compiler.FUNCTION_LANG :\n                return functionLang(context);\n            case Compiler.FUNCTION_ID :\n                return functionID(context);\n            case Compiler.FUNCTION_LOCAL_NAME :\n                return functionLocalName(context);\n            case Compiler.FUNCTION_NAMESPACE_URI :\n                return functionNamespaceURI(context);\n            case Compiler.FUNCTION_NAME :\n                return functionName(context);\n            case Compiler.FUNCTION_STRING :\n                return functionString(context);\n            case Compiler.FUNCTION_CONCAT :\n                return functionConcat(context);\n            case Compiler.FUNCTION_STARTS_WITH :\n                return functionStartsWith(context);\n            case Compiler.FUNCTION_CONTAINS :\n                return functionContains(context);\n            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n                return functionSubstringBefore(context);\n            case Compiler.FUNCTION_SUBSTRING_AFTER :\n                return functionSubstringAfter(context);\n            case Compiler.FUNCTION_SUBSTRING :\n                return functionSubstring(context);\n            case Compiler.FUNCTION_STRING_LENGTH :\n                return functionStringLength(context);\n            case Compiler.FUNCTION_NORMALIZE_SPACE :\n                return functionNormalizeSpace(context);\n            case Compiler.FUNCTION_TRANSLATE :\n                return functionTranslate(context);\n            case Compiler.FUNCTION_BOOLEAN :\n                return functionBoolean(context);\n            case Compiler.FUNCTION_NOT :\n                return functionNot(context);\n            case Compiler.FUNCTION_TRUE :\n                return functionTrue(context);\n            case Compiler.FUNCTION_FALSE :\n                return functionFalse(context);\n            case Compiler.FUNCTION_NULL :\n                return functionNull(context);\n            case Compiler.FUNCTION_NUMBER :\n                return functionNumber(context);\n            case Compiler.FUNCTION_SUM :\n                return functionSum(context);\n            case Compiler.FUNCTION_FLOOR :\n                return functionFloor(context);\n            case Compiler.FUNCTION_CEILING :\n                return functionCeiling(context);\n            case Compiler.FUNCTION_ROUND :\n                return functionRound(context);\n            case Compiler.FUNCTION_KEY :\n                return functionKey(context);\n            case Compiler.FUNCTION_FORMAT_NUMBER :\n                return functionFormatNumber(context);\n        }\n        return null;\n    }\n\n    protected Object functionLast(EvalContext context) {\n        assertArgCount(0);\n        // Move the position to the beginning and iterate through\n        // the context to count nodes.\n        int old = context.getCurrentPosition();\n        context.reset();\n        int count = 0;\n        while (context.nextNode()) {\n            count++;\n        }\n\n        // Restore the current position.\n        if (old != 0) {\n            context.setPosition(old);\n        }\n        return new Double(count);\n    }\n\n    protected Object functionPosition(EvalContext context) {\n        assertArgCount(0);\n        return new Integer(context.getCurrentPosition());\n    }\n\n    protected Object functionCount(EvalContext context) {\n        assertArgCount(1);\n        Expression arg1 = getArg1();\n        int count = 0;\n        Object value = arg1.compute(context);\n        if (value instanceof NodePointer) {\n            value = ((NodePointer) value).getValue();\n        }\n        if (value instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) value;\n            while (ctx.hasNext()) {\n                ctx.next();\n                count++;\n            }\n        }\n        else if (value instanceof Collection) {\n            count = ((Collection) value).size();\n        }\n        else if (value == null) {\n            count = 0;\n        }\n        else {\n            count = 1;\n        }\n        return new Double(count);\n    }\n\n    protected Object functionLang(EvalContext context) {\n        assertArgCount(1);\n        String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        NodePointer pointer = (NodePointer) context.getSingleNodePointer();\n        if (pointer == null) {\n            return Boolean.FALSE;\n        }\n        return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionID(EvalContext context) {\n        assertArgCount(1);\n        String id = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n        return pointer.getPointerByID(jxpathContext, id);\n    }\n\n    protected Object functionKey(EvalContext context) {\n        assertArgCount(2);\n        String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        Object value = getArg2().compute(context);\n        EvalContext ec = null;\n        if (value instanceof EvalContext) {\n            ec = (EvalContext) value;\n            if (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n            } else { // empty context -> empty results\n                return new BasicNodeSet();\n            }\n        }\n        JXPathContext jxpathContext = context.getJXPathContext();\n        NodeSet nodeSet = jxpathContext.getNodeSetByKey(key, value);\n        if (ec != null && ec.hasNext()) {\n            BasicNodeSet accum = new BasicNodeSet();\n            accum.add(nodeSet);\n            while (ec.hasNext()) {\n                value = ((NodePointer) ec.next()).getValue();\n                accum.add(jxpathContext.getNodeSetByKey(key, value));\n            }\n            nodeSet = accum;\n        }\n        return new NodeSetContext(context, nodeSet);\n    }\n\n    protected Object functionNamespaceURI(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            String str = ptr.getNamespaceURI();\n            return str == null ? \"\" : str;\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                String str = ptr.getNamespaceURI();\n                return str == null ? \"\" : str;\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionLocalName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().getName();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().getName();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionName(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            NodePointer ptr = context.getCurrentNodePointer();\n            return ptr.getName().toString();\n        }\n        assertArgCount(1);\n        Object set = getArg1().compute(context);\n        if (set instanceof EvalContext) {\n            EvalContext ctx = (EvalContext) set;\n            if (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                return ptr.getName().toString();\n            }\n        }\n        return \"\";\n    }\n\n    protected Object functionString(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.stringValue(getArg1().computeValue(context));\n    }\n\n    protected Object functionConcat(EvalContext context) {\n        if (getArgumentCount() < 2) {\n            assertArgCount(2);\n        }\n        StringBuffer buffer = new StringBuffer();\n        Expression args[] = getArguments();\n        for (int i = 0; i < args.length; i++) {\n            buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n        }\n        return buffer.toString();\n    }\n\n    protected Object functionStartsWith(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionContains(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected Object functionSubstringBefore(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(0, index);\n    }\n\n    protected Object functionSubstringAfter(EvalContext context) {\n        assertArgCount(2);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        int index = s1.indexOf(s2);\n        if (index == -1) {\n            return \"\";\n        }\n        return s1.substring(index + s2.length());\n    }\n\n    protected Object functionSubstring(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n        if (Double.isNaN(from)) {\n            return \"\";\n        }\n\n        from = Math.round(from);\n        if (from > s1.length() + 1) {\n            return \"\";\n        }\n        if (ac == 2) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n        double length =\n            InfoSetUtil.doubleValue(getArg3().computeValue(context));\n        length = Math.round(length);\n        if (length < 0) {\n            return \"\";\n        }\n\n        double to = from + length;\n        if (to < 1) {\n            return \"\";\n        }\n\n        if (to > s1.length() + 1) {\n            if (from < 1) {\n                from = 1;\n            }\n            return s1.substring((int) from - 1);\n        }\n\n        if (from < 1) {\n            from = 1;\n        }\n        return s1.substring((int) from - 1, (int) (to - 1));\n    }\n\n    protected Object functionStringLength(EvalContext context) {\n        String s;\n        if (getArgumentCount() == 0) {\n            s = InfoSetUtil.stringValue(context.getCurrentNodePointer());\n        }\n        else {\n            assertArgCount(1);\n            s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        }\n        return new Double(s.length());\n    }\n\n    protected Object functionNormalizeSpace(EvalContext context) {\n        assertArgCount(1);\n        String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        char chars[] = s.toCharArray();\n        int out = 0;\n        int phase = 0;\n        for (int in = 0; in < chars.length; in++) {\n            switch(chars[in]) {\n                case 0x20:\n                case 0x9:\n                case 0xD:\n                case 0xA:\n                    if (phase == 0) {      // beginning\n                        ;\n                    }\n                    else if (phase == 1) { // non-space\n                        phase = 2;\n                        chars[out++] = ' ';\n                    }\n                    break;\n                default:\n                    chars[out++] = chars[in];\n                    phase = 1;\n            }\n        }\n        if (phase == 2) { // trailing-space\n            out--;\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionTranslate(EvalContext context) {\n        assertArgCount(3);\n        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n        String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n        char chars[] = s1.toCharArray();\n        int out = 0;\n        for (int in = 0; in < chars.length; in++) {\n            char c = chars[in];\n            int inx = s2.indexOf(c);\n            if (inx != -1) {\n                if (inx < s3.length()) {\n                    chars[out++] = s3.charAt(inx);\n                }\n            }\n            else {\n                chars[out++] = c;\n            }\n        }\n        return new String(chars, 0, out);\n    }\n\n    protected Object functionBoolean(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.TRUE\n            : Boolean.FALSE;\n    }\n\n    protected Object functionNot(EvalContext context) {\n        assertArgCount(1);\n        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n            ? Boolean.FALSE\n            : Boolean.TRUE;\n    }\n\n    protected Object functionTrue(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.TRUE;\n    }\n\n    protected Object functionFalse(EvalContext context) {\n        assertArgCount(0);\n        return Boolean.FALSE;\n    }\n\n    protected Object functionNull(EvalContext context) {\n        assertArgCount(0);\n        return null;\n    }\n\n    protected Object functionNumber(EvalContext context) {\n        if (getArgumentCount() == 0) {\n            return InfoSetUtil.number(context.getCurrentNodePointer());\n        }\n        assertArgCount(1);\n        return InfoSetUtil.number(getArg1().computeValue(context));\n    }\n\n    protected Object functionSum(EvalContext context) {\n        assertArgCount(1);\n        Object v = getArg1().compute(context);\n        if (v == null) {\n            return ZERO;\n        }\n        if (v instanceof EvalContext) {\n            double sum = 0.0;\n            EvalContext ctx = (EvalContext) v;\n            while (ctx.hasNext()) {\n                NodePointer ptr = (NodePointer) ctx.next();\n                sum += InfoSetUtil.doubleValue(ptr);\n            }\n            return new Double(sum);\n        }\n        throw new JXPathException(\n            \"Invalid argument type for 'sum': \" + v.getClass().getName());\n    }\n\n    protected Object functionFloor(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        if (Double.isNaN(v) || Double.isInfinite(v)) {\n        \treturn new Double(v);\n        }\n        return new Double(Math.floor(v));\n    }\n\n    protected Object functionCeiling(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        if (Double.isNaN(v) || Double.isInfinite(v)) {\n        \treturn new Double(v);\n        }\n        return new Double(Math.ceil(v));\n    }\n\n    protected Object functionRound(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        if (Double.isNaN(v) || Double.isInfinite(v)) {\n        \treturn new Double(v);\n        }\n        return new Double(Math.round(v));\n    }\n\n    private Object functionFormatNumber(EvalContext context) {\n        int ac = getArgumentCount();\n        if (ac != 2 && ac != 3) {\n            assertArgCount(2);\n        }\n\n        double number =\n            InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        String pattern =\n            InfoSetUtil.stringValue(getArg2().computeValue(context));\n\n        DecimalFormatSymbols symbols = null;\n        if (ac == 3) {\n            String symbolsName =\n                InfoSetUtil.stringValue(getArg3().computeValue(context));\n            symbols =\n                context.getJXPathContext().getDecimalFormatSymbols(symbolsName);\n        }\n        else {\n            NodePointer pointer = context.getCurrentNodePointer();\n            Locale locale;\n            if (pointer != null) {\n                locale = pointer.getLocale();\n            }\n            else {\n                locale = context.getJXPathContext().getLocale();\n            }\n            symbols = new DecimalFormatSymbols(locale);\n        }\n        \n        DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();\n        format.setDecimalFormatSymbols(symbols);\n        format.applyLocalizedPattern(pattern);\n        return format.format(number);\n    }\n\n    private void assertArgCount(int count) {\n        assertArgRange(count, count);\n    }\n\n    private void assertArgRange(int min, int max) {\n        int ct = getArgumentCount();\n        if (ct < min || ct > max) {\n            throw new JXPathInvalidSyntaxException(\n                    \"Incorrect number of arguments: \" + this);\n        }\n    }\n}"}]}
{"project": "JxPath", "bug_id": 15, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.axes.UnionContext", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.axes;\n\nimport java.util.ArrayList;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * EvalContext that represents a union between other contexts - result\n * of a union operation like (a | b)\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class UnionContext extends NodeSetContext {\n    private EvalContext contexts[];\n    private boolean prepared;\n\n    public UnionContext(EvalContext parentContext, EvalContext contexts[]) {\n        super(parentContext, new BasicNodeSet());\n        this.contexts = contexts;\n    }\n\n    public int getDocumentOrder() {\n        return contexts.length > 1 ? 1 : super.getDocumentOrder();\n    }\n\n    public boolean setPosition(int position) {\n        if (!prepared) {\n            prepared = true;\n            BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n            ArrayList pointers = new ArrayList();\n            for (int i = 0; i < contexts.length; i++) {\n                EvalContext ctx = (EvalContext) contexts[i];\n                while (ctx.nextSet()) {\n                    while (ctx.nextNode()) {\n                        NodePointer ptr = ctx.getCurrentNodePointer();\n                        if (!pointers.contains(ptr)) {\n                            nodeSet.add(ptr);\n                            pointers.add(ptr);\n                        }\n                    }\n                }\n            }\n        }\n        return super.setPosition(position);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.axes;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.BasicNodeSet;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * EvalContext that represents a union between other contexts - result\n * of a union operation like (a | b)\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class UnionContext extends NodeSetContext {\n    private EvalContext contexts[];\n    private boolean prepared;\n\n    public UnionContext(EvalContext parentContext, EvalContext contexts[]) {\n        super(parentContext, new BasicNodeSet());\n        this.contexts = contexts;\n    }\n\n    public int getDocumentOrder() {\n        return contexts.length > 1 ? 1 : super.getDocumentOrder();\n    }\n\n    public boolean setPosition(int position) {\n        if (!prepared) {\n            prepared = true;\n            BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n            ArrayList pointers = new ArrayList();\n            for (int i = 0; i < contexts.length; i++) {\n                EvalContext ctx = (EvalContext) contexts[i];\n                while (ctx.nextSet()) {\n                    while (ctx.nextNode()) {\n                        NodePointer ptr = ctx.getCurrentNodePointer();\n                        if (!pointers.contains(ptr)) {\n                            pointers.add(ptr);\n                        }\n                    }\n                }\n            }\n            sortPointers(pointers);\n\n            for (Iterator it = pointers.iterator(); it.hasNext();) {\n                nodeSet.add((Pointer) it.next());\n            }\n        }\n        return super.setPosition(position);\n    }\n}"}]}
{"project": "JxPath", "bug_id": 16, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML namespace URI */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS namespace URI */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     */\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     * @param id string id\n     */\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param parent pointer\n     * @param node pointed\n     */\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Test string equality.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if == or .equals()\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith)\n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isActual() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isCollection() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getLength() {\n        return 1;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang ns to test\n     * @return boolean\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Get the language attribute for this node. \n     * @return String language name\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     * @param value to set\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index)\n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null :\n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer createChild(JXPathContext context,\n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Return a string escaping single and double quotes.\n     * @param string string to treat\n     * @return string with any necessary changes made.\n     */\n    private String escape(String string) {\n        final char[] c = new char[] { '\\'', '\"' };\n        final String[] esc = new String[] { \"&apos;\", \"&quot;\" };\n        StringBuffer sb = null;\n        for (int i = 0; sb == null && i < c.length; i++) {\n            if (string.indexOf(c[i]) >= 0) {\n                sb = new StringBuffer(string);\n            }\n        }\n        if (sb == null) {\n            return string;\n        }\n        for (int i = 0; i < c.length; i++) {\n            if (string.indexOf(c[i]) < 0) {\n                continue;\n            }\n            int pos = 0;\n            while (pos < sb.length()) {\n                if (sb.charAt(pos) == c[i]) {\n                    sb.replace(pos, pos + 1, esc[i]);\n                    pos += esc[i].length();\n                } else {\n                    pos++;\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        int count = 1;\n        String target = ((ProcessingInstruction) node).getTarget();\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    /**\n     * Get any prefix from the specified node.\n     * @param node the node to check\n     * @return String xml prefix\n     */\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node node to check\n     * @return String local name\n     */\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    /**\n     * Get the string value of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     * @param context starting context\n     * @param id to find\n     * @return Pointer\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    /**\n     * Get the AbstractFactory associated with the specified JXPathContext.\n     * @param context JXPathContext\n     * @return AbstractFactory\n     */\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML namespace URI */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS namespace URI */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     */\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     * @param id string id\n     */\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param parent pointer\n     * @param node pointed\n     */\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Test string equality.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if == or .equals()\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith)\n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document)aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isActual() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isCollection() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getLength() {\n        return 1;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang ns to test\n     * @return boolean\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Get the language attribute for this node. \n     * @return String language name\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     * @param value to set\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index)\n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null :\n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer createChild(JXPathContext context,\n                QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Return a string escaping single and double quotes.\n     * @param string string to treat\n     * @return string with any necessary changes made.\n     */\n    private String escape(String string) {\n        final char[] c = new char[] { '\\'', '\"' };\n        final String[] esc = new String[] { \"&apos;\", \"&quot;\" };\n        StringBuffer sb = null;\n        for (int i = 0; sb == null && i < c.length; i++) {\n            if (string.indexOf(c[i]) >= 0) {\n                sb = new StringBuffer(string);\n            }\n        }\n        if (sb == null) {\n            return string;\n        }\n        for (int i = 0; i < c.length; i++) {\n            if (string.indexOf(c[i]) < 0) {\n                continue;\n            }\n            int pos = 0;\n            while (pos < sb.length()) {\n                if (sb.charAt(pos) == c[i]) {\n                    sb.replace(pos, pos + 1, esc[i]);\n                    pos += esc[i].length();\n                } else {\n                    pos++;\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        int count = 1;\n        String target = ((ProcessingInstruction) node).getTarget();\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    /**\n     * Get any prefix from the specified node.\n     * @param node the node to check\n     * @return String xml prefix\n     */\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node node to check\n     * @return String local name\n     */\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    /**\n     * Get the string value of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     * @param context starting context\n     * @param id to find\n     * @return Pointer\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    /**\n     * Get the AbstractFactory associated with the specified JXPathContext.\n     * @param context JXPathContext\n     * @return AbstractFactory\n     */\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith)\n    {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n     */\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix.equals(\"xml\")) {\n            return Namespace.XML_NAMESPACE.getURI();\n        }\n        Element element = null;\n        if (node instanceof Document) {\n            element = ((Document) node).getRootElement();\n        }\n        if (node instanceof Element) {\n            element = (Element) node;\n        }\n        if (element == null) {\n            return null;\n        }\n        Namespace ns = element.getNamespace(prefix);\n        return ns == null ? null : ns.getURI();\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2)\n    {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n     */\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            StringBuffer buf = new StringBuffer();\n            for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) {\n                NodePointer ptr = children.getNodePointer();\n                if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {\n                    buf.append(ptr.getValue());\n                }\n            }\n            return buf.toString();\n        }\n        if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        String result = null;\n        if (node instanceof Text) {\n            result = ((Text) node).getText();\n        }\n        if (node instanceof ProcessingInstruction) {\n            result = ((ProcessingInstruction) node).getData();\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"space\", Namespace.XML_NAMESPACE));\n        return result != null && trim ? result.trim() : result;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    }\n\n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return (node instanceof Element) || (node instanceof Document);\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n\n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n    }\n\n    protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr = e.getAttributeValue(attrName, ns);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n\n    private static Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            return parent instanceof Element ? (Element) parent : null;\n        }\n        if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index)\n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String namespaceUri = getNamespaceResolver().getNamespaceURI(prefix);\n            if (namespaceUri == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Namespace ns = Namespace.getNamespace(prefix, namespaceUri);\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n\n                if (nsURI == null) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String target = ((ProcessingInstruction) node).getTarget();\n            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n\n            List children = ((Element)parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n\n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n}", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith)\n    {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n     */\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix.equals(\"xml\")) {\n            return Namespace.XML_NAMESPACE.getURI();\n        }\n        Element element = null;\n        if (node instanceof Document) {\n            element = ((Document) node).getRootElement();\n        }\n        if (node instanceof Element) {\n            element = (Element) node;\n        }\n        if (element == null) {\n            return null;\n        }\n        Namespace ns = element.getNamespace(prefix);\n        return ns == null ? null : ns.getURI();\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2)\n    {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n     */\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n     */\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            StringBuffer buf = new StringBuffer();\n            for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) {\n                NodePointer ptr = children.getNodePointer();\n                if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {\n                    buf.append(ptr.getValue());\n                }\n            }\n            return buf.toString();\n        }\n        if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        String result = null;\n        if (node instanceof Text) {\n            result = ((Text) node).getText();\n        }\n        if (node instanceof ProcessingInstruction) {\n            result = ((ProcessingInstruction) node).getData();\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"space\", Namespace.XML_NAMESPACE));\n        return result != null && trim ? result.trim() : result;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    }\n\n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n\n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n    }\n\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n    }\n\n    protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr = e.getAttributeValue(attrName, ns);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n\n    private static Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            return parent instanceof Element ? (Element) parent : null;\n        }\n        if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index)\n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value)\n    {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String namespaceUri = getNamespaceResolver().getNamespaceURI(prefix);\n            if (namespaceUri == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Namespace ns = Namespace.getNamespace(prefix, namespaceUri);\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n\n                if (nsURI == null) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            String target = ((ProcessingInstruction) node).getTarget();\n            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }\n\n    private int getRelativePositionByName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n\n            List children = ((Element)parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n\n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private int getRelativePositionOfPI(String target) {\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }\n\n}"}]}
{"project": "JxPath", "bug_id": 17, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n\n    public DOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        this.name = name;\n        attributes = new ArrayList();\n        Node node = (Node) parent.getNode();\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                Attr attr = getAttribute((Element) node, name);\n                if (attr != null) {\n                    attributes.add(attr);\n                }\n            }\n            else {\n                NamedNodeMap map = node.getAttributes();\n                int count = map.getLength();\n                for (int i = 0; i < count; i++) {\n                    Attr attr = (Attr) map.item(i);\n                    if (testAttr(attr)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean testAttr(Attr attr) {\n        String nodePrefix = DOMNodePointer.getPrefix(attr);\n        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n\n        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n            return false;\n        }\n\n        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n            return false;\n        }\n\n        String testLocalName = name.getName();\n        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n            String testPrefix = name.getPrefix();\n\n            if (equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n            String testNS = null;\n            if (testPrefix != null) {\n                testNS = parent.getNamespaceURI(testPrefix);\n            }\n            String nodeNS = null;\n            if (nodePrefix != null) {\n                nodeNS = parent.getNamespaceURI(nodePrefix);\n            }\n            return equalStrings(testNS, nodeNS);\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    private Attr getAttribute(Element element, QName name) {\n        String testPrefix = name.getPrefix();\n        String testNS = null;\n\n        if (testPrefix != null) {\n            testNS = parent.getNamespaceResolver().getNamespaceURI(testPrefix);\n        }\n\n        if (testNS != null) {\n            Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n            if (attr != null) {\n                return attr;\n            }\n\n            // This may mean that the parser does not support NS for\n            // attributes, example - the version of Crimson bundled\n            // with JDK 1.4.0\n            NamedNodeMap nnm = element.getAttributes();\n            for (int i = 0; i < nnm.getLength(); i++) {\n                attr = (Attr) nnm.item(i);\n                if (testAttr(attr)) {\n                    return attr;\n                }\n            }\n            return null;\n        }\n        return element.getAttributeNode(name.getName());\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n\n    public DOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        this.name = name;\n        attributes = new ArrayList();\n        Node node = (Node) parent.getNode();\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                Attr attr = getAttribute((Element) node, name);\n                if (attr != null) {\n                    attributes.add(attr);\n                }\n            }\n            else {\n                NamedNodeMap map = node.getAttributes();\n                int count = map.getLength();\n                for (int i = 0; i < count; i++) {\n                    Attr attr = (Attr) map.item(i);\n                    if (testAttr(attr)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean testAttr(Attr attr) {\n        String nodePrefix = DOMNodePointer.getPrefix(attr);\n        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n\n        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n            return false;\n        }\n\n        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n            return false;\n        }\n\n        String testLocalName = name.getName();\n        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n            String testPrefix = name.getPrefix();\n\n            if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n            if (nodePrefix == null) {\n                return false;\n            }\n            return equalStrings(parent.getNamespaceURI(testPrefix), parent\n                    .getNamespaceURI(nodePrefix));\n        }\n        return false;\n    }\n\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }\n\n    private Attr getAttribute(Element element, QName name) {\n        String testPrefix = name.getPrefix();\n        String testNS = null;\n\n        if (testPrefix != null) {\n            testNS = parent.getNamespaceResolver().getNamespaceURI(testPrefix);\n        }\n\n        if (testNS != null) {\n            Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n            if (attr != null) {\n                return attr;\n            }\n\n            // This may mean that the parser does not support NS for\n            // attributes, example - the version of Crimson bundled\n            // with JDK 1.4.0\n            NamedNodeMap nnm = element.getAttributes();\n            for (int i = 0; i < nnm.getLength(); i++) {\n                attr = (Attr) nnm.item(i);\n                if (testAttr(attr)) {\n                    return attr;\n                }\n            }\n            return null;\n        }\n        return element.getAttributeNode(name.getName());\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}"}, {"class_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.jdom.Attribute;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n\n    public JDOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        if (parent.getNode() instanceof Element) {\n            Element element = (Element) parent.getNode();\n            String prefix = name.getPrefix();\n            Namespace ns = null;\n            if (prefix != null) {\n                if (prefix.equals(\"xml\")) {\n                    ns = Namespace.XML_NAMESPACE;\n                }\n                else {\n                    String uri = parent.getNamespaceResolver().getNamespaceURI(prefix);\n                    if (uri != null) {\n                        ns = Namespace.getNamespace(prefix, uri);\n                    }\n                    if (ns == null) {\n                        // TBD: no attributes\n                        attributes = Collections.EMPTY_LIST;\n                        return;\n                    }\n                }\n            }\n            else {\n                ns = Namespace.NO_NAMESPACE;\n            }\n\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                attributes = new ArrayList();\n                if (ns != null) {\n                Attribute attr = element.getAttribute(lname, ns);\n                if (attr != null) {\n                    attributes.add(attr);\n                    }\n                }\n            }\n            else {\n                attributes = new ArrayList();\n                List allAttributes = element.getAttributes();\n                for (int i = 0; i < allAttributes.size(); i++) {\n                    Attribute attr = (Attribute) allAttributes.get(i);\n                    if (attr.getNamespace().equals(ns)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new JDOMAttributePointer(\n            parent,\n            (Attribute) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        if (attributes == null) {\n            return false;\n        }\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.jdom.Attribute;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\n\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n\n    public JDOMAttributeIterator(NodePointer parent, QName name) {\n        this.parent = parent;\n        if (parent.getNode() instanceof Element) {\n            Element element = (Element) parent.getNode();\n            String prefix = name.getPrefix();\n            Namespace ns = null;\n            if (prefix != null) {\n                if (prefix.equals(\"xml\")) {\n                    ns = Namespace.XML_NAMESPACE;\n                }\n                else {\n                    String uri = parent.getNamespaceResolver().getNamespaceURI(prefix);\n                    if (uri != null) {\n                        ns = Namespace.getNamespace(prefix, uri);\n                    }\n                    if (ns == null) {\n                        // TBD: no attributes\n                        attributes = Collections.EMPTY_LIST;\n                        return;\n                    }\n                }\n            }\n            else {\n                ns = Namespace.NO_NAMESPACE;\n            }\n\n            String lname = name.getName();\n            if (!lname.equals(\"*\")) {\n                attributes = new ArrayList();\n                Attribute attr = element.getAttribute(lname, ns);\n                if (attr != null) {\n                    attributes.add(attr);\n                }\n            }\n            else {\n                attributes = new ArrayList();\n                List allAttributes = element.getAttributes();\n                for (int i = 0; i < allAttributes.size(); i++) {\n                    Attribute attr = (Attribute) allAttributes.get(i);\n                    if (ns == Namespace.NO_NAMESPACE\n                            || attr.getNamespace().equals(ns)) {\n                        attributes.add(attr);\n                    }\n                }\n            }\n        }\n    }\n\n    public NodePointer getNodePointer() {\n        if (position == 0) {\n            if (!setPosition(1)) {\n                return null;\n            }\n            position = 0;\n        }\n        int index = position - 1;\n        if (index < 0) {\n            index = 0;\n        }\n        return new JDOMAttributePointer(\n            parent,\n            (Attribute) attributes.get(index));\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public boolean setPosition(int position) {\n        if (attributes == null) {\n            return false;\n        }\n        this.position = position;\n        return position >= 1 && position <= attributes.size();\n    }\n}"}]}
{"project": "JxPath", "bug_id": 18, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.axes.AttributeContext", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.axes;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * EvalContext that walks the \"attribute::\" axis.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class AttributeContext extends EvalContext {\n\n    private NodeTest nodeTest;\n    private boolean setStarted = false;\n    private NodeIterator iterator;\n    private NodePointer currentNodePointer;\n\n    /**\n     * @param parentContext represents the previous step on the path\n     * @param nodeTest is the name of the attribute we are looking for\n     */\n    public AttributeContext(EvalContext parentContext, NodeTest nodeTest) {\n        super(parentContext);\n        this.nodeTest = nodeTest;\n    }\n\n    public NodePointer getCurrentNodePointer() {\n        return currentNodePointer;\n    }\n\n    public void reset() {\n        setStarted = false;\n        iterator = null;\n        super.reset();\n    }\n\n    public boolean setPosition(int position) {\n        if (position < getCurrentPosition()) {\n            reset();\n        }\n\n        while (getCurrentPosition() < position) {\n            if (!nextNode()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean nextNode() {\n        super.setPosition(getCurrentPosition() + 1);\n        if (!setStarted) {\n            setStarted = true;\n            if (!(nodeTest instanceof NodeNameTest)) {\n                return false;\n            }\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            iterator =\n                parentContext.getCurrentNodePointer().attributeIterator(name);\n        }\n        if (iterator == null) {\n            return false;\n        }\n        if (!iterator.setPosition(iterator.getPosition() + 1)) {\n            return false;\n        }\n        currentNodePointer = iterator.getNodePointer();\n        return true;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.axes;\n\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n/**\n * EvalContext that walks the \"attribute::\" axis.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class AttributeContext extends EvalContext {\n    private static final NodeNameTest WILDCARD_TEST = new NodeNameTest(new QName(null, \"*\"));\n\n    private NodeTest nodeTest;\n    private boolean setStarted = false;\n    private NodeIterator iterator;\n    private NodePointer currentNodePointer;\n\n    /**\n     * @param parentContext represents the previous step on the path\n     * @param nodeTest is the name of the attribute we are looking for\n     */\n    public AttributeContext(EvalContext parentContext, NodeTest nodeTest) {\n        super(parentContext);\n        this.nodeTest = nodeTest;\n    }\n\n    public NodePointer getCurrentNodePointer() {\n        return currentNodePointer;\n    }\n\n    public void reset() {\n        setStarted = false;\n        iterator = null;\n        super.reset();\n    }\n\n    public boolean setPosition(int position) {\n        if (position < getCurrentPosition()) {\n            reset();\n        }\n\n        while (getCurrentPosition() < position) {\n            if (!nextNode()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean nextNode() {\n        super.setPosition(getCurrentPosition() + 1);\n        if (!setStarted) {\n            setStarted = true;\n            NodeNameTest nodeNameTest = null;\n            if (nodeTest instanceof NodeTypeTest) {\n                if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {\n                    nodeNameTest = WILDCARD_TEST;\n                }\n            }\n            else if (nodeTest instanceof NodeNameTest) {\n                nodeNameTest = (NodeNameTest) nodeTest;\n            }\n            if (nodeNameTest == null) {\n                return false;\n            }\n            iterator = parentContext.getCurrentNodePointer().attributeIterator(\n                    nodeNameTest.getNodeName());\n        }\n        if (iterator == null) {\n            return false;\n        }\n        if (!iterator.setPosition(iterator.getPosition() + 1)) {\n            return false;\n        }\n        currentNodePointer = iterator.getNodePointer();\n        return true;\n    }\n}"}]}
{"project": "JxPath", "bug_id": 19, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML namespace URI */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS namespace URI */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     */\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     * @param id string id\n     */\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param parent pointer\n     * @param node pointed\n     */\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                default:\n                    return false;\n            }\n        }\n        if (test instanceof ProcessingInstructionTest\n                && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    /**\n     * Test string equality.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if == or .equals()\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(NodeTest test, boolean reverse,\n            NodePointer startWith) {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang ns to test\n     * @return boolean\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Get the language attribute for this node.\n     * @return String language name\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     * @param value to set\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name, int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name,\n            int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByQName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n                break;\n            default:\n                break;\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        int count = 1;\n        String target = ((ProcessingInstruction) node).getTarget();\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return node.hashCode();\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    /**\n     * Get any prefix from the specified node.\n     * @param node the node to check\n     * @return String xml prefix\n     */\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node node to check\n     * @return String local name\n     */\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    /**\n     * Get the string value of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     * @param context starting context\n     * @param id to find\n     * @return Pointer\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    public int compareChildNodePointers(NodePointer pointer1,\n            NodePointer pointer2) {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML namespace URI */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS namespace URI */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     */\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     * @param id string id\n     */\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param parent pointer\n     * @param node pointed\n     */\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                default:\n                    return false;\n            }\n        }\n        if (test instanceof ProcessingInstructionTest\n                && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    /**\n     * Test string equality.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if == or .equals()\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(NodeTest test, boolean reverse,\n            NodePointer startWith) {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang ns to test\n     * @return boolean\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Get the language attribute for this node.\n     * @return String language name\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     * @param value to set\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name, int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name,\n            int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByQName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n                break;\n            default:\n                break;\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private boolean matchesQName(Node n) {\n        if (getNamespaceURI() != null) {\n            return equalStrings(getNamespaceURI(n), getNamespaceURI())\n                    && equalStrings(node.getLocalName(), n.getLocalName());\n        }\n        return equalStrings(node.getNodeName(), n.getNodeName());\n    }\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        int count = 1;\n        String target = ((ProcessingInstruction) node).getTarget();\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return node.hashCode();\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    /**\n     * Get any prefix from the specified node.\n     * @param node the node to check\n     * @return String xml prefix\n     */\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node node to check\n     * @return String local name\n     */\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri != null) {\n            return uri;\n        }\n\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    /**\n     * Get the string value of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     * @param context starting context\n     * @param id to find\n     * @return Pointer\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    public int compareChildNodePointers(NodePointer pointer1,\n            NodePointer pointer2) {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n"}, {"class_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML ns uri */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS ns uri */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new JDOMNodePointer.\n     * @param node pointed\n     * @param locale Locale\n     */\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new JDOMNodePointer.\n     * @param node pointed\n     * @param locale Locale\n     * @param id String id\n     */\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new JDOMNodePointer.\n     * @param parent NodePointer\n     * @param node pointed\n     */\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix.equals(\"xml\")) {\n            return Namespace.XML_NAMESPACE.getURI();\n        }\n        Element element = null;\n        if (node instanceof Document) {\n            element = ((Document) node).getRootElement();\n        }\n        if (node instanceof Element) {\n            element = (Element) node;\n        }\n        if (element == null) {\n            return null;\n        }\n        Namespace ns = element.getNamespace(prefix);\n        return ns == null ? null : ns.getURI();\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            StringBuffer buf = new StringBuffer();\n            for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) {\n                NodePointer ptr = children.getNodePointer();\n                if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {\n                    buf.append(ptr.getValue());\n                }\n            }\n            return buf.toString();\n        }\n        if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        String result = null;\n        if (node instanceof Text) {\n            result = ((Text) node).getText();\n        }\n        if (node instanceof ProcessingInstruction) {\n            result = ((ProcessingInstruction) node).getData();\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"space\", Namespace.XML_NAMESPACE));\n        return result != null && trim ? result.trim() : result;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    }\n\n    /**\n     * Add the specified content to this element.\n     * @param content List\n     */\n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n\n    /**\n     * Execute test against node on behalf of pointer.\n     * @param pointer Pointer\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n                default:\n                    return false;\n            }\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    /**\n     * Learn whether two strings are == or .equals()\n     * @param s1 string 1\n     * @param s2 string 2\n     * @return true if equal\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    /**\n     * Get the prefix from a given node.\n     * @param node to check\n     * @return String\n     */\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node to check\n     * @return String local name\n     */\n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang to compare\n     * @return true if this element uses the specified language.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang) : current.toUpperCase(\n                Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Get the language of this element.\n     * @return String language\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @param ns Namespace\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr = e.getAttributeValue(attrName, ns);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n\n    /**\n     * Get the parent of the specified node.\n     * @param node to check\n     * @return parent Element\n     */\n    private static Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            return parent instanceof Element ? (Element) parent : null;\n        }\n        if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String namespaceUri = getNamespaceResolver().getNamespaceURI(prefix);\n            if (namespaceUri == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Namespace ns = Namespace.getNamespace(prefix, namespaceUri);\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n\n                if (nsURI == null) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByQName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            buffer.append(\"/processing-instruction(\\'\").append(((ProcessingInstruction) node).getTarget()).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI()).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n\n            List children = ((Element) parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if ((child instanceof Element)\n                    && ((Element) child).getQualifiedName().equals(name)) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        String target = ((ProcessingInstruction) node).getTarget();\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return node.hashCode();\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.jdom;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.jdom.Attribute;\nimport org.jdom.CDATA;\nimport org.jdom.Comment;\nimport org.jdom.Document;\nimport org.jdom.Element;\nimport org.jdom.Namespace;\nimport org.jdom.ProcessingInstruction;\nimport org.jdom.Text;\n\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML ns uri */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS ns uri */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new JDOMNodePointer.\n     * @param node pointed\n     * @param locale Locale\n     */\n    public JDOMNodePointer(Object node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new JDOMNodePointer.\n     * @param node pointed\n     * @param locale Locale\n     * @param id String id\n     */\n    public JDOMNodePointer(Object node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new JDOMNodePointer.\n     * @param parent NodePointer\n     * @param node pointed\n     */\n    public JDOMNodePointer(NodePointer parent, Object node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) {\n        return new JDOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new JDOMAttributeIterator(this, name);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new JDOMNamespaceIterator(this);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new JDOMNamespacePointer(this, prefix);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private static String getNamespaceURI(Object node) {\n        if (node instanceof Element) {\n            Element element = (Element) node;\n            String ns = element.getNamespaceURI();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            return ns;\n        }\n        return null;\n    }\n\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix.equals(\"xml\")) {\n            return Namespace.XML_NAMESPACE.getURI();\n        }\n        Element element = null;\n        if (node instanceof Document) {\n            element = ((Document) node).getRootElement();\n        }\n        if (node instanceof Element) {\n            element = (Element) node;\n        }\n        if (element == null) {\n            return null;\n        }\n        Namespace ns = element.getNamespace(prefix);\n        return ns == null ? null : ns.getURI();\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) {\n        Object node1 = pointer1.getBaseValue();\n        Object node2 = pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n            return -1;\n        }\n        if (\n            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            return 1;\n        }\n        if (\n            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n            List list = ((Element) getNode()).getAttributes();\n            int length = list.size();\n            for (int i = 0; i < length; i++) {\n                Object n = list.get(i);\n                if (n == node1) {\n                    return -1;\n                }\n                else if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        if (!(node instanceof Element)) {\n            throw new RuntimeException(\n                \"JXPath internal error: \"\n                    + \"compareChildNodes called for \"\n                    + node);\n        }\n\n        List children = ((Element) node).getContent();\n        int length = children.size();\n        for (int i = 0; i < length; i++) {\n            Object n = children.get(i);\n            if (n == node1) {\n                return -1;\n            }\n            if (n == node2) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        if (node instanceof Element) {\n            return ((Element) node).getContent().size() == 0;\n        }\n        if (node instanceof Document) {\n            return ((Document) node).getContent().size() == 0;\n        }\n        return true;\n    }\n\n    public QName getName() {\n        String ns = null;\n        String ln = null;\n        if (node instanceof Element) {\n            ns = ((Element) node).getNamespacePrefix();\n            if (ns != null && ns.equals(\"\")) {\n                ns = null;\n            }\n            ln = ((Element) node).getName();\n        }\n        else if (node instanceof ProcessingInstruction) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public Object getValue() {\n        if (node instanceof Element) {\n            StringBuffer buf = new StringBuffer();\n            for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) {\n                NodePointer ptr = children.getNodePointer();\n                if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {\n                    buf.append(ptr.getValue());\n                }\n            }\n            return buf.toString();\n        }\n        if (node instanceof Comment) {\n            String text = ((Comment) node).getText();\n            if (text != null) {\n                text = text.trim();\n            }\n            return text;\n        }\n        String result = null;\n        if (node instanceof Text) {\n            result = ((Text) node).getText();\n        }\n        if (node instanceof ProcessingInstruction) {\n            result = ((ProcessingInstruction) node).getData();\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"space\", Namespace.XML_NAMESPACE));\n        return result != null && trim ? result.trim() : result;\n    }\n\n    public void setValue(Object value) {\n        if (node instanceof Text) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                ((Text) node).setText(string);\n            }\n            else {\n                nodeParent(node).removeContent((Text) node);\n            }\n        }\n        else {\n            Element element = (Element) node;\n            element.getContent().clear();\n\n            if (value instanceof Element) {\n                Element valueElement = (Element) value;\n                addContent(valueElement.getContent());\n            }\n            else if (value instanceof Document) {\n                Document valueDocument = (Document) value;\n                addContent(valueDocument.getContent());\n            }\n            else if (value instanceof Text || value instanceof CDATA) {\n                String string = ((Text) value).getText();\n                element.addContent(new Text(string));\n            }\n            else if (value instanceof ProcessingInstruction) {\n                ProcessingInstruction pi =\n                    (ProcessingInstruction) ((ProcessingInstruction) value)\n                        .clone();\n                element.addContent(pi);\n            }\n            else if (value instanceof Comment) {\n                Comment comment = (Comment) ((Comment) value).clone();\n                element.addContent(comment);\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    element.addContent(new Text(string));\n                }\n            }\n        }\n    }\n\n    /**\n     * Add the specified content to this element.\n     * @param content List\n     */\n    private void addContent(List content) {\n        Element element = (Element) node;\n        int count = content.size();\n\n        for (int i = 0; i < count; i++) {\n            Object child = content.get(i);\n            if (child instanceof Element) {\n                child = ((Element) child).clone();\n                element.addContent((Element) child);\n            }\n            else if (child instanceof Text) {\n                child = ((Text) child).clone();\n                element.addContent((Text) child);\n            }\n            else if (node instanceof CDATA) {\n                child = ((CDATA) child).clone();\n                element.addContent((CDATA) child);\n            }\n            else if (node instanceof ProcessingInstruction) {\n                child = ((ProcessingInstruction) child).clone();\n                element.addContent((ProcessingInstruction) child);\n            }\n            else if (node instanceof Comment) {\n                child = ((Comment) child).clone();\n                element.addContent((Comment) child);\n            }\n        }\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }\n\n    /**\n     * Execute test against node on behalf of pointer.\n     * @param pointer Pointer\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n                default:\n                    return false;\n            }\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    /**\n     * Learn whether two strings are == or .equals()\n     * @param s1 string 1\n     * @param s2 string 2\n     * @return true if equal\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    /**\n     * Get the prefix from a given node.\n     * @param node to check\n     * @return String\n     */\n    public static String getPrefix(Object node) {\n        if (node instanceof Element) {\n            String prefix = ((Element) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        if (node instanceof Attribute) {\n            String prefix = ((Attribute) node).getNamespacePrefix();\n            return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n        }\n        return null;\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node to check\n     * @return String local name\n     */\n    public static String getLocalName(Object node) {\n        if (node instanceof Element) {\n            return ((Element) node).getName();\n        }\n        if (node instanceof Attribute) {\n            return ((Attribute) node).getName();\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang to compare\n     * @return true if this element uses the specified language.\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang) : current.toUpperCase(\n                Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Get the language of this element.\n     * @return String language\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @param ns Namespace\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n        while (n != null) {\n            if (n instanceof Element) {\n                Element e = (Element) n;\n                String attr = e.getAttributeValue(attrName, ns);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = nodeParent(n);\n        }\n        return null;\n    }\n\n    /**\n     * Get the parent of the specified node.\n     * @param node to check\n     * @return parent Element\n     */\n    private static Element nodeParent(Object node) {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            return parent instanceof Element ? (Element) parent : null;\n        }\n        if (node instanceof Text) {\n            return (Element) ((Text) node).getParent();\n        }\n        if (node instanceof CDATA) {\n            return (Element) ((CDATA) node).getParent();\n        }\n        if (node instanceof ProcessingInstruction) {\n            return (Element) ((ProcessingInstruction) node).getParent();\n        }\n        if (node instanceof Comment) {\n            return (Element) ((Comment) node).getParent();\n        }\n        return null;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it =\n                childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n                + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(\n            JXPathContext context, QName name, int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String namespaceUri = getNamespaceResolver().getNamespaceURI(prefix);\n            if (namespaceUri == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            Namespace ns = Namespace.getNamespace(prefix, namespaceUri);\n            Attribute attr = element.getAttribute(name.getName(), ns);\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\", ns);\n            }\n        }\n        else {\n            Attribute attr = element.getAttribute(name.getName());\n            if (attr == null) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Element parent = nodeParent(node);\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root JDOM node\");\n        }\n        parent.getContent().remove(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        if (node instanceof Element) {\n            // If the parent pointer is not a JDOMNodePointer, it is\n            // the parent's responsibility to produce the node test part\n            // of the path\n            if (parent instanceof JDOMNodePointer) {\n                if (buffer.length() == 0\n                    || buffer.charAt(buffer.length() - 1) != '/') {\n                    buffer.append('/');\n                }\n                String nsURI = getNamespaceURI();\n                String ln = JDOMNodePointer.getLocalName(node);\n\n                if (nsURI == null) {\n                    buffer.append(ln);\n                    buffer.append('[');\n                    buffer.append(getRelativePositionByQName()).append(']');\n                }\n                else {\n                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n                    if (prefix != null) {\n                        buffer.append(prefix);\n                        buffer.append(':');\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName());\n                        buffer.append(']');\n                    }\n                    else {\n                        buffer.append(\"node()\");\n                        buffer.append('[');\n                        buffer.append(getRelativePositionOfElement());\n                        buffer.append(']');\n                    }\n                }\n\n            }\n        }\n        else if (node instanceof Text || node instanceof CDATA) {\n            buffer.append(\"/text()\");\n            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n                ']');\n        }\n        else if (node instanceof ProcessingInstruction) {\n            buffer.append(\"/processing-instruction(\\'\").append(((ProcessingInstruction) node).getTarget()).append(\n                \"')\");\n            buffer.append('[').append(getRelativePositionOfPI()).append(\n                ']');\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName() {\n        if (node instanceof Element) {\n            Object parent = ((Element) node).getParent();\n            if (!(parent instanceof Element)) {\n                return 1;\n            }\n\n            List children = ((Element) parent).getContent();\n            int count = 0;\n            String name = ((Element) node).getQualifiedName();\n            for (int i = 0; i < children.size(); i++) {\n                Object child = children.get(i);\n                if (child instanceof Element && matchesQName(((Element) child))) {\n                    count++;\n                }\n                if (child == node) {\n                    break;\n                }\n            }\n            return count;\n        }\n        return 1;\n    }\n\n    private boolean matchesQName(Element element) {\n        if (getNamespaceURI() != null) {\n            String ns = getNamespaceURI(element);\n            if (ns == null || !ns.equals(getNamespaceURI())) {\n                return false;\n            }\n        }\n        return element.getName().equals(((Element) node).getName());\n    }\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        Object parent = ((Element) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children;\n        if (parent instanceof Element) {\n            children = ((Element) parent).getContent();\n        }\n        else {\n            children = ((Document) parent).getContent();\n        }\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Element) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        Element parent;\n        if (node instanceof Text) {\n            parent = (Element) ((Text) node).getParent();\n        }\n        else {\n            parent = (Element) ((CDATA) node).getParent();\n        }\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof Text || child instanceof CDATA) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        String target = ((ProcessingInstruction) node).getTarget();\n        Element parent = (Element) ((ProcessingInstruction) node).getParent();\n        if (parent == null) {\n            return 1;\n        }\n        List children = parent.getContent();\n        int count = 0;\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if (child instanceof ProcessingInstruction\n                && (target == null\n                    || target.equals(\n                        ((ProcessingInstruction) child).getTarget()))) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return node.hashCode();\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof JDOMNodePointer)) {\n            return false;\n        }\n\n        JDOMNodePointer other = (JDOMNodePointer) object;\n        return node == other.node;\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 20, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    /**\n     * Create a new CoreOperationRelationalExpression.\n     * @param args arguments\n     */\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return RELATIONAL_EXPR_PRECEDENCE;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    /**\n     * Template method for subclasses to evaluate the result of a comparison.\n     * @param compare result of comparison to evaluate\n     * @return ultimate operation success/failure\n     */\n    protected abstract boolean evaluateCompare(int compare);\n\n    /**\n     * Compare left to right.\n     * @param left left operand\n     * @param right right operand\n     * @return operation success/failure\n     */\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    /**\n     * Reduce an operand for comparison.\n     * @param o Object to reduce\n     * @return reduced operand\n     */\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    /**\n     * Learn whether any element returned from an Iterator matches a given value.\n     * @param it Iterator\n     * @param value to look for\n     * @return whether a match was found\n     */\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Learn whether any element returned from an Iterator matches a given value.\n     * @param it Iterator\n     * @param value to look for\n     * @return whether a match was found\n     */\n\n    /**\n     * Learn whether there is an intersection between two Iterators.\n     * @param lit left Iterator\n     * @param rit right Iterator\n     * @return whether a match was found\n     */\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    /**\n     * Create a new CoreOperationRelationalExpression.\n     * @param args arguments\n     */\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return RELATIONAL_EXPR_PRECEDENCE;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    /**\n     * Template method for subclasses to evaluate the result of a comparison.\n     * @param compare result of comparison to evaluate\n     * @return ultimate operation success/failure\n     */\n    protected abstract boolean evaluateCompare(int compare);\n\n    /**\n     * Compare left to right.\n     * @param left left operand\n     * @param right right operand\n     * @return operation success/failure\n     */\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch(left, (Iterator) right);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n\n    /**\n     * Reduce an operand for comparison.\n     * @param o Object to reduce\n     * @return reduced operand\n     */\n    private Object reduce(Object o) {\n        if (o instanceof SelfContext) {\n            o = ((EvalContext) o).getSingleNodePointer();\n        }\n        if (o instanceof Collection) {\n            o = ((Collection) o).iterator();\n        }\n        return o;\n    }\n\n    /**\n     * Learn whether any element returned from an Iterator matches a given value.\n     * @param it Iterator\n     * @param value to look for\n     * @return whether a match was found\n     */\n    private boolean containsMatch(Iterator it, Object value) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(element, value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Learn whether any element returned from an Iterator matches a given value.\n     * @param it Iterator\n     * @param value to look for\n     * @return whether a match was found\n     */\n    private boolean containsMatch(Object value, Iterator it) {\n        while (it.hasNext()) {\n            Object element = it.next();\n            if (compute(value, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Learn whether there is an intersection between two Iterators.\n     * @param lit left Iterator\n     * @param rit right Iterator\n     * @return whether a match was found\n     */\n    private boolean findMatch(Iterator lit, Iterator rit) {\n        HashSet left = new HashSet();\n        while (lit.hasNext()) {\n            left.add(lit.next());\n        }\n        while (rit.hasNext()) {\n            if (containsMatch(left.iterator(), rit.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 21, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.beans.PropertyPointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.beans;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathIntrospector;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.ValueUtils;\n\n/**\n * A pointer allocated by a PropertyOwnerPointer to represent the value of\n * a property of the parent object.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class PropertyPointer extends NodePointer {\n    public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n\n    /** property index */\n    protected int propertyIndex = UNSPECIFIED_PROPERTY;\n\n    /** owning object */\n    protected Object bean;\n\n    /**\n     * Takes a javabean, a descriptor of a property of that object and\n     * an offset within that property (starting with 0).\n     * @param parent parent pointer\n     */\n    public PropertyPointer(NodePointer parent) {\n        super(parent);\n    }\n\n    /**\n     * Get the property index.\n     * @return int index\n     */\n    public int getPropertyIndex() {\n        return propertyIndex;\n    }\n\n    /**\n     * Set the property index.\n     * @param index property index\n     */\n    public void setPropertyIndex(int index) {\n        if (propertyIndex != index) {\n            propertyIndex = index;\n            setIndex(WHOLE_COLLECTION);\n        }\n    }\n\n    /**\n     * Get the parent bean.\n     * @return Object\n     */\n    public Object getBean() {\n        if (bean == null) {\n            bean = getImmediateParentPointer().getNode();\n        }\n        return bean;\n    }\n\n    public QName getName() {\n        return new QName(null, getPropertyName());\n    }\n\n    /**\n     * Get the property name.\n     * @return String property name.\n     */\n    public abstract String getPropertyName();\n\n    /**\n     * Set the property name.\n     * @param propertyName property name to set.\n     */\n    public abstract void setPropertyName(String propertyName);\n\n    /**\n     * Count the number of properties represented.\n     * @return int\n     */\n    public abstract int getPropertyCount();\n\n    /**\n     * Get the names of the included properties.\n     * @return String[]\n     */\n    public abstract String[] getPropertyNames();\n\n    /**\n     * Learn whether this pointer references an actual property.\n     * @return true if actual\n     */\n    protected abstract boolean isActualProperty();\n\n    public boolean isActual() {\n        if (!isActualProperty()) {\n            return false;\n        }\n\n        return super.isActual();\n    }\n\n    private static final Object UNINITIALIZED = new Object();\n\n    private Object value = UNINITIALIZED;\n\n    public Object getImmediateNode() {\n        if (value == UNINITIALIZED) {\n            value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n                    : ValueUtils.getValue(getBaseValue(), index);\n        }\n        return value;\n    }\n\n    public boolean isCollection() {\n        Object value = getBaseValue();\n        return value != null && ValueUtils.isCollection(value);\n    }\n\n    public boolean isLeaf() {\n        Object value = getNode();\n        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n    }\n\n    /**\n     * If the property contains a collection, then the length of that\n     * collection, otherwise - 1.\n     * @return int length\n     */\n    public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    /**\n     * Returns a NodePointer that can be used to access the currently\n     * selected property value.\n     * @return NodePointer\n     */\n    public NodePointer getImmediateValuePointer() {\n        return NodePointer.newChildNodePointer(\n            (NodePointer) this.clone(),\n            getName(),\n            getImmediateNode());\n    }\n\n    public NodePointer createPath(JXPathContext context) {\n        if (getImmediateNode() == null) {\n            AbstractFactory factory = getAbstractFactory(context);\n            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n            boolean success =\n                factory.createObject(\n                    context,\n                    this,\n                    getBean(),\n                    getPropertyName(),\n                    inx);\n            if (!success) {\n                throw new JXPathAbstractFactoryException(\"Factory \" + factory\n                        + \" could not create an object for path: \" + asPath());\n            }\n        }\n        return this;\n    }\n\n    public NodePointer createPath(JXPathContext context, Object value) {\n        // If neccessary, expand collection\n        if (index != WHOLE_COLLECTION && index >= getLength()) {\n            createPath(context);\n        }\n        setValue(value);\n        return this;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index,\n        Object value) {\n        PropertyPointer prop = (PropertyPointer) clone();\n        if (name != null) {\n            prop.setPropertyName(name.toString());\n        }\n        prop.setIndex(index);\n        return prop.createPath(context, value);\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) {\n        PropertyPointer prop = (PropertyPointer) clone();\n        if (name != null) {\n            prop.setPropertyName(name.toString());\n        }\n        prop.setIndex(index);\n        return prop.createPath(context);\n    }\n\n    public int hashCode() {\n        return getImmediateParentPointer().hashCode() + propertyIndex + index;\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof PropertyPointer)) {\n            return false;\n        }\n\n        PropertyPointer other = (PropertyPointer) object;\n        if (parent != other.parent && (parent == null || !parent.equals(other.parent))) {\n            return false;\n        }\n\n        if (getPropertyIndex() != other.getPropertyIndex()\n            || !getPropertyName().equals(other.getPropertyName())) {\n            return false;\n        }\n\n        int iThis = (index == WHOLE_COLLECTION ? 0 : index);\n        int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n        return iThis == iOther;\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) {\n        return getValuePointer().compareChildNodePointers(pointer1, pointer2);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.beans;\n\nimport org.apache.commons.jxpath.AbstractFactory;\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathIntrospector;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.ValueUtils;\n\n/**\n * A pointer allocated by a PropertyOwnerPointer to represent the value of\n * a property of the parent object.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class PropertyPointer extends NodePointer {\n    public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n\n    /** property index */\n    protected int propertyIndex = UNSPECIFIED_PROPERTY;\n\n    /** owning object */\n    protected Object bean;\n\n    /**\n     * Takes a javabean, a descriptor of a property of that object and\n     * an offset within that property (starting with 0).\n     * @param parent parent pointer\n     */\n    public PropertyPointer(NodePointer parent) {\n        super(parent);\n    }\n\n    /**\n     * Get the property index.\n     * @return int index\n     */\n    public int getPropertyIndex() {\n        return propertyIndex;\n    }\n\n    /**\n     * Set the property index.\n     * @param index property index\n     */\n    public void setPropertyIndex(int index) {\n        if (propertyIndex != index) {\n            propertyIndex = index;\n            setIndex(WHOLE_COLLECTION);\n        }\n    }\n\n    /**\n     * Get the parent bean.\n     * @return Object\n     */\n    public Object getBean() {\n        if (bean == null) {\n            bean = getImmediateParentPointer().getNode();\n        }\n        return bean;\n    }\n\n    public QName getName() {\n        return new QName(null, getPropertyName());\n    }\n\n    /**\n     * Get the property name.\n     * @return String property name.\n     */\n    public abstract String getPropertyName();\n\n    /**\n     * Set the property name.\n     * @param propertyName property name to set.\n     */\n    public abstract void setPropertyName(String propertyName);\n\n    /**\n     * Count the number of properties represented.\n     * @return int\n     */\n    public abstract int getPropertyCount();\n\n    /**\n     * Get the names of the included properties.\n     * @return String[]\n     */\n    public abstract String[] getPropertyNames();\n\n    /**\n     * Learn whether this pointer references an actual property.\n     * @return true if actual\n     */\n    protected abstract boolean isActualProperty();\n\n    public boolean isActual() {\n        if (!isActualProperty()) {\n            return false;\n        }\n\n        return super.isActual();\n    }\n\n    private static final Object UNINITIALIZED = new Object();\n\n    private Object value = UNINITIALIZED;\n\n    public Object getImmediateNode() {\n        if (value == UNINITIALIZED) {\n            value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n                    : ValueUtils.getValue(getBaseValue(), index);\n        }\n        return value;\n    }\n\n    public boolean isCollection() {\n        Object value = getBaseValue();\n        return value != null && ValueUtils.isCollection(value);\n    }\n\n    public boolean isLeaf() {\n        Object value = getNode();\n        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n    }\n\n    /**\n     * If the property contains a collection, then the length of that\n     * collection, otherwise - 1.\n     * @return int length\n     */\n    public int getLength() {\n        Object baseValue = getBaseValue();\n        return baseValue == null ? 1 : ValueUtils.getLength(baseValue);\n    }\n\n    /**\n     * Returns a NodePointer that can be used to access the currently\n     * selected property value.\n     * @return NodePointer\n     */\n    public NodePointer getImmediateValuePointer() {\n        return NodePointer.newChildNodePointer(\n            (NodePointer) this.clone(),\n            getName(),\n            getImmediateNode());\n    }\n\n    public NodePointer createPath(JXPathContext context) {\n        if (getImmediateNode() == null) {\n            AbstractFactory factory = getAbstractFactory(context);\n            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n            boolean success =\n                factory.createObject(\n                    context,\n                    this,\n                    getBean(),\n                    getPropertyName(),\n                    inx);\n            if (!success) {\n                throw new JXPathAbstractFactoryException(\"Factory \" + factory\n                        + \" could not create an object for path: \" + asPath());\n            }\n        }\n        return this;\n    }\n\n    public NodePointer createPath(JXPathContext context, Object value) {\n        // If neccessary, expand collection\n        if (index != WHOLE_COLLECTION && index >= getLength()) {\n            createPath(context);\n        }\n        setValue(value);\n        return this;\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index,\n        Object value) {\n        PropertyPointer prop = (PropertyPointer) clone();\n        if (name != null) {\n            prop.setPropertyName(name.toString());\n        }\n        prop.setIndex(index);\n        return prop.createPath(context, value);\n    }\n\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) {\n        PropertyPointer prop = (PropertyPointer) clone();\n        if (name != null) {\n            prop.setPropertyName(name.toString());\n        }\n        prop.setIndex(index);\n        return prop.createPath(context);\n    }\n\n    public int hashCode() {\n        return getImmediateParentPointer().hashCode() + propertyIndex + index;\n    }\n\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n\n        if (!(object instanceof PropertyPointer)) {\n            return false;\n        }\n\n        PropertyPointer other = (PropertyPointer) object;\n        if (parent != other.parent && (parent == null || !parent.equals(other.parent))) {\n            return false;\n        }\n\n        if (getPropertyIndex() != other.getPropertyIndex()\n            || !getPropertyName().equals(other.getPropertyName())) {\n            return false;\n        }\n\n        int iThis = (index == WHOLE_COLLECTION ? 0 : index);\n        int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n        return iThis == iOther;\n    }\n\n    public int compareChildNodePointers(\n        NodePointer pointer1,\n        NodePointer pointer2) {\n        return getValuePointer().compareChildNodePointers(pointer1, pointer2);\n    }\n\n}\n"}]}
{"project": "JxPath", "bug_id": 22, "classes_modified": [{"class_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML namespace URI */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS namespace URI */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     */\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     * @param id string id\n     */\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param parent pointer\n     * @param node pointed\n     */\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                default:\n                    return false;\n            }\n        }\n        if (test instanceof ProcessingInstructionTest\n                && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    /**\n     * Test string equality.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if == or .equals()\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(NodeTest test, boolean reverse,\n            NodePointer startWith) {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang ns to test\n     * @return boolean\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Get the language attribute for this node.\n     * @return String language name\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     * @param value to set\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name, int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name,\n            int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByQName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n                break;\n            default:\n                break;\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private boolean matchesQName(Node n) {\n        if (getNamespaceURI() != null) {\n            return equalStrings(getNamespaceURI(n), getNamespaceURI())\n                    && equalStrings(node.getLocalName(), n.getLocalName());\n        }\n        return equalStrings(node.getNodeName(), n.getNodeName());\n    }\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        int count = 1;\n        String target = ((ProcessingInstruction) node).getTarget();\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return node.hashCode();\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    /**\n     * Get any prefix from the specified node.\n     * @param node the node to check\n     * @return String xml prefix\n     */\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node node to check\n     * @return String local name\n     */\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri == null) {\n            String prefix = getPrefix(node);\n            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n    \n            Node aNode = node;\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        return attr.getValue();\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            return null;\n        }\n        return uri;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    /**\n     * Get the string value of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     * @param context starting context\n     * @param id to find\n     * @return Pointer\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    public int compareChildNodePointers(NodePointer pointer1,\n            NodePointer pointer2) {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.model.dom;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.apache.commons.jxpath.JXPathAbstractFactoryException;\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.JXPathException;\nimport org.apache.commons.jxpath.Pointer;\nimport org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.NamespaceResolver;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.NodeIterator;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.ri.model.beans.NullPointer;\nimport org.apache.commons.jxpath.util.TypeUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n\n    private static final long serialVersionUID = -8751046933894857319L;\n\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n\n    /** XML namespace URI */\n    public static final String XML_NAMESPACE_URI =\n            \"http://www.w3.org/XML/1998/namespace\";\n\n    /** XMLNS namespace URI */\n    public static final String XMLNS_NAMESPACE_URI =\n            \"http://www.w3.org/2000/xmlns/\";\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     */\n    public DOMNodePointer(Node node, Locale locale) {\n        super(null, locale);\n        this.node = node;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param node pointed at\n     * @param locale Locale\n     * @param id string id\n     */\n    public DOMNodePointer(Node node, Locale locale, String id) {\n        super(null, locale);\n        this.node = node;\n        this.id = id;\n    }\n\n    /**\n     * Create a new DOMNodePointer.\n     * @param parent pointer\n     * @param node pointed\n     */\n    public DOMNodePointer(NodePointer parent, Node node) {\n        super(parent);\n        this.node = node;\n    }\n\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }\n\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                default:\n                    return false;\n            }\n        }\n        if (test instanceof ProcessingInstructionTest\n                && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n    /**\n     * Test string equality.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if == or .equals()\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }\n\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }\n\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }\n\n    public NodeIterator childIterator(NodeTest test, boolean reverse,\n            NodePointer startWith) {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }\n\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }\n\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }\n\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }\n\n    public synchronized NamespaceResolver getNamespaceResolver() {\n        if (localNamespaceResolver == null) {\n            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n            localNamespaceResolver.setNamespaceContextPointer(this);\n        }\n        return localNamespaceResolver;\n    }\n\n    public String getNamespaceURI(String prefix) {\n        if (prefix == null || prefix.equals(\"\")) {\n            return getDefaultNamespaceURI();\n        }\n\n        if (prefix.equals(\"xml\")) {\n            return XML_NAMESPACE_URI;\n        }\n\n        if (prefix.equals(\"xmlns\")) {\n            return XMLNS_NAMESPACE_URI;\n        }\n\n        String namespace = null;\n        if (namespaces == null) {\n            namespaces = new HashMap();\n        }\n        else {\n            namespace = (String) namespaces.get(prefix);\n        }\n\n        if (namespace == null) {\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        namespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            if (namespace == null || namespace.equals(\"\")) {\n                namespace = NodePointer.UNKNOWN_NAMESPACE;\n            }\n        }\n\n        namespaces.put(prefix, namespace);\n        if (namespace == UNKNOWN_NAMESPACE) {\n            return null;\n        }\n\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return namespace;\n    }\n\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }\n\n    public Object getBaseValue() {\n        return node;\n    }\n\n    public Object getImmediateNode() {\n        return node;\n    }\n\n    public boolean isActual() {\n        return true;\n    }\n\n    public boolean isCollection() {\n        return false;\n    }\n\n    public int getLength() {\n        return 1;\n    }\n\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }\n\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     * @param lang ns to test\n     * @return boolean\n     */\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Find the nearest occurrence of the specified attribute\n     * on the specified and enclosing elements.\n     * @param n current node\n     * @param attrName attribute name\n     * @return attribute value\n     */\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }\n\n    /**\n     * Get the language attribute for this node.\n     * @return String language name\n     */\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }\n\n    /**\n     * Sets contents of the node to the specified value. If the value is\n     * a String, the contents of the node are replaced with this text.\n     * If the value is an Element or Document, the children of the\n     * node are replaced with the children of the passed node.\n     * @param value to set\n     */\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name, int index) {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : context\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }\n\n    public NodePointer createChild(JXPathContext context, QName name,\n            int index, Object value) {\n        NodePointer ptr = createChild(context, name, index);\n        ptr.setValue(value);\n        return ptr;\n    }\n\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = null;\n            NamespaceResolver nsr = getNamespaceResolver();\n            if (nsr != null) {\n                ns = nsr.getNamespaceURI(prefix);\n            }\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }\n\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }\n\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByQName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n                break;\n            default:\n                break;\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    private boolean matchesQName(Node n) {\n        if (getNamespaceURI() != null) {\n            return equalStrings(getNamespaceURI(n), getNamespaceURI())\n                    && equalStrings(node.getLocalName(), n.getLocalName());\n        }\n        return equalStrings(node.getNodeName(), n.getNodeName());\n    }\n\n    /**\n     * Get relative position of this among all siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among sibling text nodes.\n     * @return 1..n\n     */\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    /**\n     * Get the relative position of this among same-target processing instruction siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionOfPI() {\n        int count = 1;\n        String target = ((ProcessingInstruction) node).getTarget();\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }\n\n    public int hashCode() {\n        return node.hashCode();\n    }\n\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }\n\n    /**\n     * Get any prefix from the specified node.\n     * @param node the node to check\n     * @return String xml prefix\n     */\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }\n\n    /**\n     * Get the local name of the specified node.\n     * @param node node to check\n     * @return String local name\n     */\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }\n\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri == null) {\n            String prefix = getPrefix(node);\n            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n    \n            Node aNode = node;\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        uri = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        return \"\".equals(uri) ? null : uri;\n    }\n\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }\n\n    /**\n     * Get the string value of the specified node.\n     * @param node Node to check\n     * @return String\n     */\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Locates a node by ID.\n     * @param context starting context\n     * @param id to find\n     * @return Pointer\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }\n\n    public int compareChildNodePointers(NodePointer pointer1,\n            NodePointer pointer2) {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }\n}\n"}]}
